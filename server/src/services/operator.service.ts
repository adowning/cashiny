// apps/server/src/services/operator.service.ts
// Ensure these types align with your Zod schemas
// import { OperatorCreatePayload, OperatorInvitePayload, OperatorUpdatePayload } from '@/routes/schema';
import { Profile } from '@cashflow/database'
import { db } from '@cashflow/database'
// import { randomUUID } from 'crypto';

// Assuming Role is generated by Prisma

// For generating tokens if not handled by DB default

// A utility for creating a Prisma-style error for 'not found'
class RecordNotFoundError extends Error {
  public code: string
  constructor(message: string) {
    super(message)
    this.name = 'RecordNotFoundError'
    this.code = 'P2025' // Mimic Prisma's record not found error code
  }
}

export class OperatorService {
  private prisma = db
  constructor() {
    // this.prisma = db
  }

  /**
   * Creates a new operator and assigns the creator as the owner.
   * The creatorUserId is typically the ID of the authenticated user performing the action.
   */
  // async createOperator(data: OperatorCreatePayload, creatorUserId: string) {
  //   const { name, ...restOfData } = data; // Assuming 'name' is mandatory

  //   if (!name) {
  //     throw new Error('Operator name is required.');
  //   }
  //   if (!creatorUserId) {
  //     throw new Error('Creator user ID is required.');
  //   }

  //   return this.prisma.operatorAccess.create({
  //     data: {
  //       name,
  //       ...restOfData, // include other fields from OperatorCreatePayload if they exist on Operator model
  //       owner: {
  //         connect: {
  //           id: creatorUserId,
  //         },
  //       },
  //       operator_secret: 'asdf',
  //       callback_url: 'http://localhost:3000',
  //       operator_access: '',
  //       profiles: {
  //         create: [
  //           {
  //             userId: creatorUserId,
  //           },
  //         ],
  //       },
  //     },
  //     include: {
  //       profiles: {
  //         include: {
  //           user: { select: { id: true, email: true, name: true } },
  //         },
  //       }, // Optionally include members or other relations
  //     },
  //   });
  // }

  /**
   * Invites users to an operator by their email addresses.
   * invitingUserId is the ID of the user sending the invitations.
   */
  // async inviteUsersToOperator(payload: OperatorInvitePayload, invitingUserId: string) {
  //   const { operatorId, userEmails, role = Role.MEMBER } = payload;

  //   // Check if invitingUser has permission to invite to this operatorId
  //   const inviterMembership = await this.prisma.operatorAccess.findUnique({
  //     where: { id: operatorId },
  //     select: {
  //       ownerId: true,
  //       members: {
  //         where: { userId: invitingUserId, isActive: true },
  //         select: { role: true },
  //       },
  //     },
  //   });
  //   if (
  //     !inviterMembership ||
  //     (inviterMembership.ownerId !== invitingUserId &&
  //       !inviterMembership.members.some((m) => [Role.ADMIN, Role.OWNER].includes(m.role)))
  //   ) {
  //     throw new Error('Unauthorized: You do not have permission to invite users to this operator.');
  //   }

  //   const invitations = userEmails.map((email) => ({
  //     operatorId,
  //     email,
  //     role,
  //     invitedById: invitingUserId,
  //     expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // Invitation expires in 7 days
  //     token: randomUUID(), // Generate a unique token
  //   }));

  //   // Using a transaction to create multiple invitations
  //   // Prisma's createMany does not return the created records for some databases or with relations.
  //   // So, we loop or use transaction for returning data or handling complex logic.
  //   const createdInvitations = [];
  //   for (const invData of invitations) {
  //     // Optional: Check if user is already a member or has a pending invitation
  //     const existingMember = await this.prisma.operatorAccess.findFirst({
  //       where: {
  //         id: operatorId,
  //         members: {
  //           some: {
  //             user: { email: invData.email },
  //             isActive: true,
  //           },
  //         },
  //       },
  //     });
  //     if (existingMember) {
  //       console.warn(
  //         `User ${invData.email} is already a member of operator ${operatorId}. Skipping invitation.`,
  //       );
  //       continue; // Or throw an error / return a specific status
  //     }
  //     const existingInvitation = await this.prisma.operatorInvitation.findFirst({
  //       where: {
  //         operatorId,
  //         email: invData.email,
  //         acceptedAt: null,
  //         expiresAt: { gt: new Date() },
  //       },
  //     });
  //     if (existingInvitation) {
  //       console.warn(
  //         `User ${invData.email} already has a pending invitation for operator ${operatorId}. Skipping.`,
  //       );
  //       continue; // Or refresh token / resend email
  //     }

  //     const newInvitation = await this.prisma.operatorInvitation.create({
  //       data: invData,
  //     });
  //     createdInvitations.push(newInvitation);
  //     // TODO: Trigger email sending for newInvitation.token and newInvitation.email
  //   }

  //   return {
  //     message: `${createdInvitations.length} invitation(s) sent successfully. ${invitations.length - createdInvitations.length} skipped.`,
  //     createdInvitations,
  //   };
  // }

  /**
   * Accepts an invitation to join an operator.
   * acceptingUserId is the ID of the user who is accepting the invitation.
   */
  // async acceptInvitation(invitationToken: string, acceptingUserId: string) {
  //   const invitation = await this.prisma.operatorInvitation.findUnique({
  //     where: { token: invitationToken },
  //   });

  //   if (!invitation) {
  //     throw new RecordNotFoundError('Invitation not found or invalid token.');
  //   }
  //   if (invitation.acceptedAt) {
  //     throw new Error('Invitation already accepted.');
  //   }
  //   if (new Date() > invitation.expiresAt) {
  //     throw new Error('Invitation has expired.');
  //   }
  //   // Optionally, verify if acceptingUserId's email matches invitation.email
  //   const user = await this.prisma.user.findUnique({ where: { id: acceptingUserId } });
  //   if (!user || user.email !== invitation.email) {
  //     throw new Error('User email does not match invitation.');
  //   }

  //   return this.prisma.$transaction(async (tx) => {
  //     const updatedInvitation = await tx.operatorInvitation.update({
  //       where: { id: invitation.id },
  //       data: { acceptedAt: new Date() },
  //     });

  //     const updatedOperator = await tx.operatorAccess.update({
  //       where: { id: invitation.operatorId },
  //       data: {
  //         members: {
  //           create: {
  //             userId: acceptingUserId,
  //             role: invitation.role,
  //             isActive: true,
  //           },
  //         },
  //       },
  //       include: {
  //         members: {
  //           where: { userId: acceptingUserId },
  //           include: {
  //             user: { select: { id: true, email: true, name: true } },
  //           },
  //         },
  //       },
  //     });
  //     return {
  //       message: 'Invitation accepted successfully.',
  //       membership: updatedOperator.members[0],
  //     };
  //   });
  // }

  /**
   * Gets all operators a specific user is a member of.
   */
  async getAllOperators(userId: string) {
    return this.prisma.operatorAccess.findMany({
      where: {
        profiles: {
          some: {
            userId: userId,
            // isActive: true, // Only include if membership is active
          },
        },
      },
      include: {
        // Optionally include owner details, member counts, etc.
        owner: { select: { id: true, name: true, email: true } },
        _count: { select: { profiles: true } },
      },
    })
  }

  /**
   * Deactivates a user's membership in an operator (soft delete).
   * performingUserId is the ID of the admin/owner performing the action.
   */
  // async deactivateUser(operatorId: string, userIdToDeactivate: string, performingUserId: string) {
  //   // Check if performingUserId has permission (is OWNER or ADMIN of the operator)
  //   const operator = await this.prisma.operatorAccess.findUnique({
  //     where: { id: operatorId },
  //     select: {
  //       ownerId: true,
  //       members: {
  //         where: { userId: performingUserId, isActive: true },
  //         select: { role: true },
  //       },
  //     },
  //   });

  //   if (
  //     !operator ||
  //     (operator.ownerId !== performingUserId &&
  //       !operator.members.some((m) => [Role.ADMIN, Role.OWNER].includes(m.role)))
  //   ) {
  //     throw new Error(
  //       'Unauthorized: You do not have permission to deactivate users in this operator.',
  //     );
  //   }

  //   // Prevent deactivating self if owner, or add specific logic
  //   if (performingUserId === userIdToDeactivate && performingUserMembership.role === Role.OWNER) {
  //     const otherOwners = await this.prisma.userOperator.count({
  //       where: { operatorId, role: Role.OWNER, NOT: { userId: userIdToDeactivate } },
  //     });
  //     if (otherOwners === 0) {
  //       throw new Error(
  //         'Cannot deactivate the sole owner of the operator. Transfer ownership or delete the operator.',
  //       );
  //     }
  //   }

  //   const membershipToDeactivate = await this.prisma.operatorAccess.findFirst({
  //     where: {
  //       id: operatorId,
  //       members: {
  //         some: {
  //           userId: userIdToDeactivate,
  //           isActive: true,
  //         },
  //       },
  //     },
  //     select: {
  //       members: {
  //         where: { userId: userIdToDeactivate },
  //         select: { role: true, isActive: true },
  //       },
  //     },
  //   });

  //   if (!membershipToDeactivate) {
  //     throw new RecordNotFoundError('User is not a member of this operator.');
  //   }
  //   if (!membershipToDeactivate.isActive) {
  //     return {
  //       message: 'User is already inactive in this operator.',
  //       membership: membershipToDeactivate,
  //     };
  //   }

  //   const updatedMembership = await this.prisma.userOperator.update({
  //     where: { userId_operatorId: { userId: userIdToDeactivate, operatorId } },
  //     data: { isActive: false },
  //   });
  //   return {
  //     message: 'User deactivated successfully from operator.',
  //     membership: updatedMembership,
  //   };
  // }

  /**
   * Gets a single operator by its ID.
   * Optionally, add userId to check if the user is a member for scoped access.
   */
  async getOperator(operatorId: string, requestingUserId?: string) {
    const operator = await this.prisma.operatorAccess.findUnique({
      where: { id: operatorId },
      include: {
        profiles: {
          // where: { isActive: true }, // Only active members
          include: { user: { select: { id: true, name: true, email: true } } },
        },
        owner: { select: { id: true, name: true, email: true } },
      },
    })

    if (!operator) {
      throw new RecordNotFoundError('Operator not found.')
    }
    // If requestingUserId is provided, ensure they are a member (or implement other access rules)
    if (requestingUserId) {
      const isMember = operator.profiles.some(
        (profile: Profile) => profile.userId === requestingUserId
      )
      if (!isMember && operator.ownerId !== requestingUserId) {
        // Also check if they are the direct owner if not in members list explicitly
        throw new Error('Access Denied: You are not a member of this operator.')
      }
    }
    return operator
  }

  /**
   * Updates an operator's details.
   * performingUserId is the ID of the user performing the update (must be owner/admin).
   */
  // async updateOperator(operatorId: string, data: OperatorUpdatePayload, performingUserId: string) {
  //   const operator = await this.prisma.operatorAccess.findUnique({
  //     where: { id: operatorId },
  //     select: {
  //       ownerId: true,
  //       members: {
  //         where: { userId: performingUserId, isActive: true },
  //         select: { role: true },
  //       },
  //     },
  //   });

  //   if (
  //     !operator ||
  //     (operator.ownerId !== performingUserId &&
  //       !operator.members.some((m) => [Role.ADMIN, Role.OWNER].includes(m.role)))
  //   ) {
  //     throw new Error('Unauthorized: You do not have permission to update this operator.');
  //   }

  //   return this.prisma.operatorAccess.update({
  //     where: { id: operatorId },
  //     data: data, // Prisma will only update fields present in 'data'
  //   });
  // }

  /**
   * Deletes an operator.
   * performingUserId is the ID of the user performing the deletion (must be owner).
   */
  // async deleteOperator(operatorId: string, performingUserId: string): Promise<void> {
  //   const operator = await this.prisma.operatorAccess.findUnique({
  //     where: { id: operatorId },
  //     select: { ownerId: true },
  //   });

  //   if (!operator) {
  //     throw new RecordNotFoundError('Operator not found.');
  //   }

  //   if (operator.ownerId !== performingUserId) {
  //     throw new Error('Unauthorized: Only the operator owner can delete the operator.');
  //   }
  //   // Prisma will cascade delete related UserOperator and OperatorInvitation records
  //   // if `onDelete: Cascade` is set in the schema. Otherwise, handle manually.
  //   await this.prisma.operatorAccess.delete({
  //     where: { id: operatorId },
  //   });
  // }

  /**
   * Gets all active users (members) of a specific operator.
   */
  async getProfilesByOperator(operatorId: string, requestingUserId: string) {
    // Verify requestingUserId is a member of operatorId
    const operator = await this.prisma.operatorAccess.findFirst({
      where: {
        id: operatorId,
        OR: [{ ownerId: requestingUserId }, { profiles: { some: { userId: requestingUserId } } }],
      },
    })
    if (!operator) {
      throw new Error('Access Denied: You are not an active member of this operator.')
    }

    return this.prisma.profile.findMany({
      where: {
        operatorAccessId: operatorId,
        // isActive: true,
      },
      include: {
        user: {
          select: {
            id: true,
            email: true,
            name: true,
            // other safe user fields
          },
        },
        // role is already on UserOperator
      },
    })
  }

  /**
   * Gets the role of a specific user within a specific operator.
   */
  async getProfilesRole(userId: string) {
    // Verify requestingUserId is a member of operatorId
    // const operator = await this.prisma.operatorAccess.findFirst({
    //   where: {
    //     id: operatorId,
    //     OR: [
    //       { ownerId: requestingUserId },
    //       { profiles: { some: { userId: requestingUserId, } } },
    //     ],
    //   },
    // });
    // if (!operator) {
    //   throw new Error('Access Denied: You are not an active member of this operator.');
    // }

    const membership = await this.prisma.profile.findUnique({
      where: {
        operatorAccessId: userId,
        // isActive: true,
      },
      select: { role: true, user: { select: { id: true, email: true, name: true } } },
    })

    if (!membership) {
      throw new RecordNotFoundError(
        'User is not an active member of this operator or does not exist.'
      )
    }
    return membership
  }

  /**
   * Assigns or updates a role for a user within an operator.
   * performingUserId is the ID of the user making the change (must be owner/admin).
   */
  // async assignRole(
  //   userIdToAssign: string,
  //   operatorId: string,
  //   role: Role,
  //   performingUserId: string,
  // ) {
  //   // Check if performingUserId has permission
  //   const operator = await this.prisma.operatorAccess.findUnique({
  //     where: { id: operatorId },
  //     select: {
  //       ownerId: true,
  //       members: {
  //         where: { userId: performingUserId, isActive: true },
  //         select: { role: true },
  //       },
  //     },
  //   });

  //   if (
  //     !operator ||
  //     (operator.ownerId !== performingUserId &&
  //       !operator.members.some((m) => [Role.ADMIN, Role.OWNER].includes(m.role)))
  //   ) {
  //     throw new Error('Unauthorized: You do not have permission to assign roles in this operator.');
  //   }

  //   // Ensure the target user is actually a member of the operator
  //   const targetUserMembership = await this.prisma.operatorAccess.findFirst({
  //     where: {
  //       id: operatorId,
  //       members: {
  //         some: {
  //           userId: userIdToAssign,
  //           isActive: true,
  //         },
  //       },
  //     },
  //     select: {
  //       members: {
  //         where: { userId: userIdToAssign },
  //         select: { role: true },
  //       },
  //     },
  //   });

  //   if (!targetUserMembership) {
  //     throw new RecordNotFoundError(
  //       "Target user is not a member of this operator. Invite them first or ensure they've accepted.",
  //     );
  //   }

  //   // Prevent changing owner's role unless by another owner (more complex logic might be needed for single owner scenarios)
  //   if (targetUserMembership.role === Role.OWNER && performingUserMembership.role !== Role.OWNER) {
  //     throw new Error("Admins cannot change an Owner's role.");
  //   }
  //   // Prevent assigning OWNER role if not an owner themselves, or ensure only one owner if that's a rule
  //   if (role === Role.OWNER && performingUserMembership.role !== Role.OWNER) {
  //     throw new Error('Only an Owner can assign the Owner role.');
  //   }

  //   return this.prisma.userOperator.update({
  //     where: { userId_operatorId: { userId: userIdToAssign, operatorId } },
  //     data: { role: role, isActive: true }, // Ensure user is active when role is assigned/updated
  //     include: {
  //       user: { select: { id: true, email: true, name: true } },
  //       operator: { select: { id: true, name: true } },
  //     },
  //   });
  // }
}
