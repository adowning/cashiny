/*! For license information please see game.js.LICENSE.txt */
(() => {
	var t = {
			31763: t => {
				function e(t, e) {
					const i = new Promise(((i, n) => {
						const s = function(t, e) {
							const i = new XMLHttpRequest,
								n = e.method || "GET";
							return i.open(n, t),
								function(t, e) {
									const i = e.headers || {};
									for (let e in i) t.setRequestHeader(e, i[e])
								}(i, e), i
						}(t, e);
						! function(t, e, i) {
							t.onload = function() {
								if (t.status >= 200 && t.status < 400) e(t.responseText);
								else {
									const e = Error(t.statusText || "Unknown failure; possibly CORS");
									e.status = t.status, i(e)
								}
							}, t.onerror = function(t) {
								i(t)
							}
						}(s, i, n), s.send(e.data)
					}));
					return i.json = function(t) {
						return t ? i.then(JSON.parse).then(t) : i.then(JSON.parse)
					}, i
				}
				const i = {
					get: (t, i = {}) => (i.method = "GET", i.data = null, e(t, i)),
					post: (t, i, n = {}) => (n.method = "POST", n.headers = n.headers || {}, n.headers["Content-Type"] = "application/x-www-form-urlencoded; charset=UTF-8", n.data = function(t) {
						const e = [];
						for (let i in t) {
							const n = t[i];
							e.push(encodeURIComponent(i) + "=" + encodeURIComponent(n))
						}
						return e.join("&")
					}(i), e(t, n)),
					postJson: (t, i, n = {}) => (n.method = "POST", n.headers = n.headers || {}, n.headers["Content-Type"] = "application/json; charset=UTF-8", n.data = JSON.stringify(i), e(t, n))
				};
				t.exports = i
			},
			26786: t => {
				const e = document.getElementsByTagName("script"),
					i = e[e.length - 1],
					n = i.src,
					s = n.substring(0, n.lastIndexOf("/")),
					o = s.replace(/^(https?:\/\/)?[^/]+/, ""),
					r = s.replace(o, ""),
					a = {
						tag: i,
						src: n,
						path: o,
						root: s,
						host: r
					};
				t.exports = a
			},
			82935: (t, e, i) => {
				const n = i(87128),
					s = {
						create: function() {
							let t = {},
								e = [],
								i = {},
								s = !1;
							return {
								on(e, n) {
									if ("function" != typeof n) throw new Error("Callback " + n + " is not a function");
									if (t[e] = t[e] || [], t[e].push(n), i[e])
										for (; i[e].length > 0;) this.trigger(e, i[e].pop())
								},
								any(t) {
									e.push(t)
								},
								once(t, e) {
									e.once = !0, this.on(t, e)
								},
								trigger(o, r) {
									function a(t) {
										return Array.isArray(t) ? t.slice(0) : n(t) ? Object.assign({}, t) : t
									}
									s || (e.forEach((t => {
										t(o, a(r))
									})), t[o] ? (t[o].forEach((t => {
										!0 === t.once && !0 === t.called || (t.called = !0, t(a(r)))
									})), t[o] = t[o].filter((t => !0 !== t.once))) : function(t, e) {
										i[t] = i[t] || [], i[t].push(e)
									}(o, r))
								},
								pause() {
									s = !0
								},
								resume() {
									s = !1
								},
								shutdown() {
									this.trigger = function() {}
								},
								destroy() {
									t = null, e = null, i = null
								}
							}
						}
					};
				t.exports = s
			},
			71019: (t, e, i) => {
				const n = i(98149),
					s = i(78768),
					o = i(82935).create(),
					r = function() {
						return n.nolimit.development || !1
					};

				function a() {
					n.nolimit.development = JSON.parse(s.sessionStorage.getItem("nolimit.development")) || !1, o.trigger("development", n.nolimit.development)
				}
				r.on = o.on, "boolean" == typeof n.nolimit.development && null === s.sessionStorage.getItem("nolimit.development") && s.sessionStorage.setItem("nolimit.development", n.nolimit.development), n.addEventListener("message", (t => {
					if ("string" == typeof t.data) {
						const e = "nolimit.development:";
						if (0 === t.data.indexOf(e)) {
							const i = t.data.substr(e.length);
							s.sessionStorage.setItem("nolimit.development", i), a()
						}
					} else console.log("nolimit-development.js got unexpected event", t)
				})), n.addEventListener("storage", a), a(), t.exports = r
			},
			31208: (t, e, i) => {
				const n = i(82935).create();
				n.listen = t => {
					t.resizeSensor = document.createElement("div");
					const e = "position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;",
						i = "position: absolute; left: 0; top: 0; transition: 0s;",
						s = i + " width: 200%; height: 200%;";
					t.resizeSensor.style.cssText = e, t.resizeSensor.innerHTML = '<div style="' + e + '"><div style="' + i + '"></div></div><div style="' + e + '"><div style="' + s + '"></div></div>', t.appendChild(t.resizeSensor), t.resizeSensor.offsetParent !== t && (t.style.position = "relative");
					const o = t.resizeSensor.childNodes[0],
						r = o.childNodes[0],
						a = t.resizeSensor.childNodes[1];
					let l, h = t.offsetWidth,
						u = t.offsetHeight;

					function c() {
						n.trigger("resize", t), p()
					}

					function d() {
						(t.offsetWidth !== h || t.offsetHeight !== u) && (h = t.offsetWidth, u = t.offsetHeight, cancelAnimationFrame(l), l = requestAnimationFrame(c))
					}

					function p() {
						r.style.width = "100000px", r.style.height = "100000px", o.scrollLeft = 1e5, o.scrollTop = 1e5, a.scrollLeft = 1e5, a.scrollTop = 1e5
					}
					p(), a.addEventListener("scroll", d), o.addEventListener("scroll", d)
				}, t.exports = n
			},
			93295: (t, e, i) => {
				const n = i(82935),
					s = {
						create(t, e = {}) {
							const i = n.create();

							function s() {
								return [].slice.call(t.children).map((t => new o(t)))
							}
							return e.defaultHead = e.defaultHead || "", e.attributes = e.attributes || {}, e.attributes.frameBorder = e.attributes.frameBorder || "0", e.attributes.scrolling = e.attributes.scrolling || "no", e.styles = e.styles || {}, e.styles.width = e.styles.width || "100%", e.styles.height = e.styles.height || "100%", e.styles.display = e.styles.display || "none", e.styles.position = e.styles.position || "absolute", s().forEach((t => {
								for (let i in e.styles) t.setStyle(e.styles[i])
							})), {
								add(i, n) {
									if (!i) throw "Screen must have a name";
									if (this.get(i)) throw `Screen ${i} already exists`;
									const s = document.createElement("div");
									s.setAttribute("data-name", i);
									for (let t in e.attributes) s.setAttribute(t, e.attributes[t]);
									for (let t in e.styles) s.style[t] = e.styles[t];
									return new Promise((e => {
										s.innerHTML = n, t.appendChild(s), e(s)
									}))
								},
								get: t => s().find((e => e.name === t)),
								find(t, e) {
									const i = this.get(t);
									return i ? i.find(e) : []
								},
								show(t = 0) {
									s().forEach(((e, n) => {
										e.name === t || n === t ? (e.show(), i.trigger("show", e)) : e.hide()
									}))
								},
								hide() {
									s().forEach((t => {
										t.isVisible() && (i.trigger("hide", t), t.hide())
									}))
								},
								remove(t = 0) {
									const e = this.get(name);
									e && (i.trigger("remove", t), e.remove())
								},
								current: () => s().find((t => t.isVisible())),
								previous(t = !1) {
									const e = this.current();
									e && (e.index() > 0 ? this.show(e.index() - 1) : t && this.show(this.size() - 1))
								},
								next(t = !1) {
									const e = this.current();
									e && (e.index() < this.size() - 1 ? this.show(e.index() + 1) : t && this.show(0))
								},
								size: () => s().length,
								siblings: () => Array.prototype.slice.call(t.parentNode.children).filter((e => t !== e)),
								on: i.on,
								trigger: i.trigger,
								destroy: i.destroy
							}
						}
					};
				class o {
					constructor(t) {
						this.element = t, this.name = t.name || t.getAttribute("data-name")
					}
					show() {
						this.element.style.display = "block"
					}
					hide() {
						this.element.style.display = "none"
					}
					remove() {
						this.element.parentNode.removeChild(this.element)
					}
					setStyle(t, e) {
						this.element.style[t] = e
					}
					find(t) {
						let e = [];
						return e = "iframe" === this.element.tagName.toLowerCase() ? this.element.contentDocument.querySelectorAll(t) : this.element.querySelectorAll(t), [].slice.call(e)
					}
					isVisible() {
						return "block" === this.element.style.display
					}
					index() {
						let t = 0,
							e = this.element.previousElementSibling;
						for (; e;) t++, e = e.previousElementSibling;
						return t
					}
				}
				t.exports = s
			},
			900: (t, e, i) => {
				const n = i(78768).localStorage,
					s = i(82935),
					o = {
						create(t) {
							if (!t) throw "Settings must have a namespace";
							t += ".";
							const e = s.create(),
								i = {};

							function o(e) {
								const s = t + e;
								if (i[s]) return i[s].value;
								const o = n.getItem(s);
								return i[s] = {
									value: o
								}, o
							}

							function r(e, s) {
								const o = t + e;
								i[o] = {
									value: s
								}, n.setItem(o, s)
							}
							return {
								default (t, e) {
									null === o(t) && r(t, JSON.stringify(e))
								},
								get(t, e) {
									const i = o(t);
									return null !== i ? JSON.parse(i) : e
								},
								set(t, e) {
									r(t, void 0 === e ? null : JSON.stringify(e)), this.trigger(t)
								},
								remove(e) {
									! function(e) {
										const s = t + e;
										delete i[s], n.removeItem(s)
									}(e)
								},
								on: e.on,
								any: e.any,
								trigger(t) {
									e.trigger(t, this.get(t))
								},
								destroy: e.destroy
							}
						}
					};
				t.exports = o
			},
			78768: (t, e, i) => {
				const n = i(98149),
					s = i(12215),
					o = "nolimit.storageTest",
					r = {};

				function a(t) {
					return {
						cache: {},
						getItem: function(t) {
							return this.cache[t] || null
						},
						setItem: function(e, i) {
							const s = String(i);
							this.cache[e] = s, n.dispatchEvent(new n.Event("storage", {
								key: e,
								oldValue: this.cache[e] || null,
								newValue: s,
								storageArea: r[t]
							}))
						},
						removeItem: function(t) {
							delete this.cache[t]
						}
					}
				}! function() {
					try {
						if (n.localStorage.setItem(o, o), n.localStorage.getItem(o) !== o) throw "Did not store test value";
						n.localStorage.removeItem(o), r.localStorage = n.localStorage, r.sessionStorage = n.sessionStorage
					} catch (t) {
						r.localStorage = a("localStorage"), r.sessionStorage = a("sessionStorage")
					}
					r.tempStorage = a("tempStorage"), r.cookieStorage = {
						getItem: t => s.getJSON(t),
						setItem(t, e) {
							s.set(t, e)
						},
						removeItem(t) {
							s.remove(t)
						}
					}
				}(), t.exports = r
			},
			98149: (t, e, i) => {
				const n = i(82935);
				t.exports = "object" == typeof window ? window : function() {
					const t = n.create();
					return {
						addEventListener(e, i) {
							t.on(e, i)
						},
						dispatchEvent(e) {
							t.trigger(e.type, e)
						},
						Event: class {
							constructor(t, e) {
								this.type = t, this.data = e
							}
						},
						nolimit: {}
					}
				}()
			},
			312: t => {
				const e = Date.now(),
					i = {
						init(t) {
							t.events.on("loaded", (() => {
								if (t.options.loadStart) {
									const i = e - t.options.loadStart;
									t.analytics.timing(t.options.game, "loaded", i)
								}
							})), t.events.on("init", (() => {
								t.analytics.event("init", t.options.operator)
							})), t.events.on("bet", (e => {
								t.analytics.event("bet", e.type, 100 * e.bet)
							})), t.events.on("actionSpinsBet", (e => {
								t.analytics.event("bet", e.type, 100 * e.bet)
							})), t.events.on("balance", (e => {
								t.analytics.event("balance", 100 * parseFloat(e))
							}))
						}
					};
				t.exports = i
			},
			72775: (t, e, i) => {
				const n = i(78620),
					s = i(8834);
				let o = "0.00";
				const r = {
					init(t) {
						t.events.on("bet", (function(e) {
							if ("normalBet" === e.type) try {
								e.replayAndFeatureBuy || r.subtract(e.bet)
							} catch (e) {
								if (!t.options.replay) throw e
							}
							if (!("featureBet" !== e.type || e.data && e.data.isPromotional)) try {
								r.subtract(s.getActualPrice(e))
							} catch (e) {
								if (!t.options.replay) throw e
							}
						})), t.events.on("actionSpinsBet", (function(e) {
							if ("normalBet" === e.type) try {
								e.replayAndFeatureBuy || r.subtract(e.bet)
							} catch (e) {
								if (!t.options.replay) throw e
							}
							if (!("featureBet" !== e.type || e.data && e.data.isPromotional)) try {
								r.subtract(s.getActualPrice(e))
							} catch (e) {
								if (!t.options.replay) throw e
							}
						})), t.events.on("balance", this.update)
					},
					update(t) {
						o = t
					},
					getAmount: () => parseFloat(o),
					toString: () => o,
					getFormattedBalance: (t = 2) => n.format(o, {
						minimumPrecision: t
					}),
					subtract(t) {
						function e(t) {
							"string" != typeof t && (t = t.toString());
							const e = t.split(/\./);
							if (1 === e.length) return 0;
							if (2 === e.length) return e[1].length;
							throw new Error("Value not a number " + t)
						}
						const i = Math.max(2, Math.max(e(n.formatValue(o, {
								minimumPrecision: 2
							})), e(t))),
							s = parseFloat(o) - parseFloat(t);
						if (s < 0) throw new Error("Subtraction too big: balance = " + o + ", bet = " + t);
						o = s.toFixed(i)
					}
				};
				t.exports = r
			},
			73253: (t, e, i) => {
				const n = i(79633),
					s = {
						bet(t = "normalBet", e = this.betLevel.getLevel(), i = {}, s = !1) {
							const o = this.balance.getAmount();
							if ("normalBet" === t && parseFloat(e) > o && !this.options.replay) n.show(this);
							else {
								const n = "pickAndClickBet" === t,
									o = i.blockBetSend && n;
								delete i.blockBetSend;
								const r = {
									type: n ? "zeroBet" : t,
									bet: e,
									playerInteraction: i,
									replayAndFeatureBuy: s
								};
								o || this.events.trigger("bet", r), this.communication.send("normal", r)
							}
						},
						zeroBet(t = {}) {
							this.bet("zeroBet", 0, t)
						},
						pickAndClickBet(t, e = !0) {
							const i = t.toString();
							this.bet("pickAndClickBet", 0, {
								selectedIndex: i,
								blockBetSend: e
							})
						},
						buyFeatureBet(t) {
							const e = {
								type: "featureBet",
								bet: this.betLevel.getLevel(),
								featureName: t
							};
							this.events.trigger("bet", e), this.communication.send("normal", e)
						}
					};
				t.exports = s
			},
			38028: (t, e, i) => {
				const n = i(34613),
					s = {
						availableBetLevels: [],
						unavailableBetLevels: []
					},
					o = {
						init(t) {
							this.api = t
						},
						onBetLevels(t, e) {
							if (n.load() && void 0 === t.options.replay) {
								const t = n.load();
								e.availableBetLevels.includes(t) && (e.bet = t)
							}
							Object.assign(s, e), t.events.trigger("currentBet", s.bet)
						},
						onBet(t, e) {
							"normalBet" === e.type && (n.save(e.bet), t.events.trigger("currentBet", s.bet))
						},
						setFreeBetAmount(t, e) {
							(e.previous || e.previous ? e.previous.used <= 0 : e.used <= 0) || (e.amount ? t.events.trigger("currentBet", e.amount) : t.events.trigger("currentBet", e.previous.amount))
						},
						finishFreeBets(t) {
							t.events.trigger("currentBet", s.bet)
						},
						increase() {
							if (this.isLast()) return;
							const t = s.availableBetLevels.indexOf(s.bet) + 1;
							this.setLevel(s.availableBetLevels[t])
						},
						decrease() {
							if (this.isFirst()) return;
							const t = s.availableBetLevels.indexOf(s.bet) - 1;
							this.setLevel(s.availableBetLevels[t])
						},
						getLevel: () => s.bet,
						setLevel(t) {
							if (-1 !== s.availableBetLevels.indexOf(t)) s.bet = t, this.api.events.trigger("currentBet", s.bet), n.save(s.bet);
							else {
								this.api.warn("level", t, "not found in", s.availableBetLevels);
								let e = null,
									i = null;
								s.availableBetLevels.forEach((n => {
									const s = Math.abs(parseFloat(n) - parseFloat(t));
									(null === i || s < i) && (i = s, e = n)
								})), null !== e && (this.api.warn("level", e, "was selected as the nearest available one"), s.bet = e, n.save(e))
							}
						},
						getAvailableLevels: () => s.availableBetLevels,
						getUnavailableLevels: () => s.unavailableBetLevels,
						isFirst: () => 0 === s.availableBetLevels.indexOf(s.bet) || -1 === s.availableBetLevels.indexOf(s.bet),
						isLast: () => s.availableBetLevels.indexOf(s.bet) === s.availableBetLevels.length - 1,
						getMessage: () => s.message,
						setMessage(t) {
							s.message = t
						},
						clearMessage() {
							delete s.message
						},
						isBroke: () => 0 === s.availableBetLevels.length
					};
				t.exports = o
			},
			86767: (t, e, i) => {
				const n = i(99499),
					s = i(61304),
					o = i(34613),
					r = i(90509),
					a = {
						replayMode: !1,
						init(t) {
							this.api = t;
							const e = t.startupPromise("communication.init");
							if (t.events.once("init", (function() {
									e.fulfill()
								})), n.any(((i, n) => {
									if ("error" === i || n.error) {
										const i = {
											code: n.code || r.CODES.COMMUNICATION,
											message: n.error || n.message || n,
											reinitGame: n.reinitGame || !1,
											dialog: n.dialog || {}
										};
										t.events.trigger("error", i), e.break(i.message)
									} else if ("debug" === i)
										for (let e in n) t.log(e, n);
									else "id" === i ? t.log("Communication id:", n) : t.events.trigger(i, n)
								})), t.options.replay) this.replayMode = !0, s.init(t, t.options.replay);
							else {
								n.on("connected", (t => {
									a.url = t.url, a.key = t.key
								}));
								const e = Object.assign({}, t.options);
								let i;
								e.lastBet = o.load(), n.connect(e), t.events.on("hidden", (t => {
									t || (clearTimeout(i), i = setTimeout((() => {
										a.refreshBalance()
									}), 1e3))
								}))
							}
						},
						refreshBalance() {
							if (!this.replayMode) {
								let t;
								const e = this.api.settings.get("balanceId", void 0);
								e && (t = {
									balanceId: e
								}), n.balance(o.load(), t)
							}
						},
						send(t, e) {
							this.replayMode ? "normal" === t && this.api.events.trigger("replayBet", e) : n.send(t, e)
						},
						getParameters() {
							return {
								url: this.url,
								key: this.key
							}
						},
						history: n.history,
						outcome: n.outcome
					};
				t.exports = a
			},
			69256: (t, e, i) => {
				const n = i(3950),
					s = i(96825),
					o = i(93361),
					r = i(97409),
					a = {
						init(t) {
							this.addCss([n, s, o, r].join("\n\n"), "game-api"), t.events.on("config", (e => {
								Array.isArray(e.css) && e.css.map(t.resources.getPath).forEach((t => a.addLink(t)))
							}))
						},
						addLink(t, e, i) {
							const n = document.createElement("link");
							n.setAttribute("rel", "stylesheet"), n.setAttribute("href", t), n.onload = e, n.onerror = i, document.head.appendChild(n)
						},
						addCss(t, e) {
							const i = document.createElement("style");
							i.setAttribute("data-source", e), i.textContent = t, document.head.appendChild(i)
						}
					};
				t.exports = a
			},
			78620: t => {
				let e = {};
				const i = {
					init(t) {
						e.hideCurrency = t.options.hideCurrency, t.events.on("currency", (function(t) {
							Object.assign(e, t)
						}))
					},
					playerCurrency: e,
					format(t, i) {
						const n = this.formatValue(t, i);
						return e.hideCurrency ? n : e.before ? (e.symbol + " " + n).replace(/\s{2,}/g, " ") : (n + " " + e.symbol).replace(/\s{2,}/g, " ")
					},
					formatValue(t, e) {
						function i(t) {
							const e = t.split(/\./);
							if (2 === e.length) return e[1].length;
							if (1 === e.length) return 0;
							throw new Error("Trying to get precision from " + t + " which isn't recognizable as a number")
						}

						function n(t, e) {
							return t > e ? e : t
						}
						let s;
						if (void 0 === (e = e || {}).precision)
							if (void 0 !== e.minimumPrecision) {
								"number" == typeof t && (t = t.toString());
								const o = i(t),
									r = i(t.replace(/[0]*$/, ""));
								s = o !== r ? Math.max(n(r, 2), e.minimumPrecision) : Math.max(n(o, 2), e.minimumPrecision)
							} else s = 2;
						return e.thousandSeparator = void 0 !== e.thousandSeparator ? e.thousandSeparator : "", parseFloat(t).toFixed(s).replace(/\B(?=(\d{3})+(?!\d))/g, e.thousandSeparator)
					},
					getCode: () => e.code ? e.code : "",
					getHideCurrency: () => !0 === e.hideCurrency,
					getSymbol: () => e.symbol ? e.symbol : ""
				};
				t.exports = i
			},
			56827: (t, e, i) => {
				const n = i(31208),
					s = i(9353),
					o = i(87295),
					r = [],
					a = {
						init: function(t) {
							this.api = t, this.showDialogs = t.options.showDialogs;
							const e = E();
							e.addEventListener("click", I), window.addEventListener("keyup", P), t.events.on("halt", (() => {
								e.removeEventListener("click", I), window.removeEventListener("keyup", P)
							})), t.events.on("showDialogs", (t => {
								this.showDialogs = t
							})), t.events.on("error", d), t.events.on("orientation", h), n.on("resize", u), t.events.on("ready", (() => {
								n.listen(A())
							}))
						},
						open(t, e = {}) {
							e.closeable = !1 !== e.closeable;
							const i = document.createElement("div");
							i.classList.add("dialog"), i.innerHTML = t, e.replace && i.setAttribute("data-replace", e.replace), (this.showDialogs || e.alwaysShow) && r.push(i), i.options = e;
							const n = b();
							return n && e.replace && e.replace === n.getAttribute("data-replace") || n && e.ignoreLocks ? a.close() : 1 === r.length && p() && (a.api.events.trigger("dialog", "open"), _()), i
						},
						close() {
							const t = E();
							t.classList.remove("blackout"), t.classList.remove("blocking");
							const e = b();
							e && ("function" == typeof e.options.onClose && e.options.onClose(), r.length > 0 ? l() : (a.api.events.trigger("dialog", "close"), function() {
								T().classList.remove("overlay");
								const t = b();
								t && t.parentNode.removeChild(t)
							}()))
						},
						lock: function(t) {
							c[t] = !0
						},
						unlock: function(t) {
							delete c[t], r.length > 0 && p() && (a.api.events.trigger("dialog", "open"), _())
						},
						unlockAll: d,
						hasOpenDialog: () => b() && b().clientHeight > 0
					};

				function l() {
					const t = A(),
						e = r.shift();
					t.appendChild(e), "function" == typeof e.options.onShowCB && e.options.onShowCB()
				}

				function h() {}

				function u(t) {
					const e = t.querySelector(".dialog");
					if (e && e.clientHeight > 0) {
						const t = E(),
							i = b();
						i && t.removeChild(i), t.appendChild(e), e.addEventListener("click", (t => {
								t.stopPropagation()
							})), y(e),
							function(t) {
								const e = t.querySelectorAll(".reload");
								for (let t = 0; t < e.length; t++) e[t].addEventListener("click", m)
							}(e),
							function(t) {
								const e = t.querySelectorAll(".support"),
									i = s.isRegistered("support");
								for (let t = 0; t < e.length; t++) {
									const n = e[t];
									i ? n.addEventListener("click", g) : n.parentNode.removeChild(n)
								}
							}(e),
							function(t) {
								const e = t.querySelectorAll(".halt");
								for (let t = 0; t < e.length; t++) e[t].addEventListener("click", f)
							}(e),
							function(t) {
								const e = t.querySelectorAll(".exit");
								for (let t = 0; t < e.length; t++) e[t].addEventListener("click", S)
							}(e), e.options.blackout && t.classList.add("blackout"), !1 === e.options.closeable && t.classList.add("blocking")
					}
				}
				let c = {};

				function d() {
					c = {}, r.length > 0 && (a.api.events.trigger("dialog", "open"), _())
				}

				function p() {
					return 0 === Object.keys(c).length
				}

				function _() {
					T().classList.add("overlay"), l()
				}

				function m() {
					s.trigger("reload").or((() => location.reload()))
				}

				function g() {
					s.trigger("support")
				}

				function f() {
					o.trigger("halt")
				}

				function S() {
					s.trigger("exit").or((() => history.back()))
				}

				function y(t) {
					const e = t.querySelectorAll(".close");
					for (let t = 0; t < e.length; t++) {
						const i = e[t];
						i.addEventListener("click", a.close), i.hasAttribute("data-timeout") && v(i)
					}
				}

				function v(t) {
					let e = parseInt(t.getAttribute("data-timeout")) || 10;
					t.setAttribute("data-text", t.textContent);
					const i = setInterval(n, 1e3);

					function n() {
						t.textContent = t.getAttribute("data-text") + " (" + e + ")", p() && e--, e < 0 && (clearInterval(i), t.click())
					}
					n()
				}

				function T() {
					return document.querySelector(".nolimit.container")
				}

				function E() {
					return document.querySelector(".nolimit .overlay")
				}

				function b() {
					return E().querySelector(".nolimit .dialog")
				}

				function A() {
					return document.querySelector(".nolimit .hidden")
				}

				function P(t) {
					27 === t.keyCode && w() && a.close()
				}

				function I(t) {
					t.stopPropagation(), w() && a.close()
				}

				function w() {
					const t = b();
					return t && t.options.closeable
				}
				t.exports = a
			},
			90509: (t, e, i) => {
				const n = i(63659),
					s = i(6396),
					o = i(58833),
					r = {
						UNKNOWN: 0,
						JAVASCRIPT: -1001,
						PROMISE: -1002,
						COMMUNICATION: -1003,
						REPLAY: -1004,
						GRAPHICS: -1005,
						FORBIDDEN: 403,
						BAD_GATEWAY: 502,
						SESSION_TIMEOUT: 1007,
						INSUFFICIENT_FUNDS: 1025,
						RESPONSIBLE_GAMING_EXCEEDED: 1026,
						RESPONSIBLE_GAMING_BLOCK: 1030,
						OPERATOR_ERROR: 1050,
						OPERATOR_ERROR_NON_FATAL: 1051,
						FRONT_CLIENT_NOT_VALID: 13004,
						FRONT_CLIENT_NOT_ACTIVE: 13005,
						COUNTRY_BLOCKED: 13043
					},
					a = {
						CODES: r,
						init(t) {
							const e = t.dialog;
							this.apiEvents = t.events, t.events.on("error", (i => {
								const a = i.message,
									l = i.code,
									h = i.dialog,
									u = a && a.includes("hasCustomMessage"),
									c = {
										closeable: !1
									};
								if (l === r.INSUFFICIENT_FUNDS) s.show(t, h, "recoverable-insufficient-funds", !0);
								else if (l === r.RESPONSIBLE_GAMING_EXCEEDED || l === r.RESPONSIBLE_GAMING_BLOCK) e.open(n.render("responsible-gaming-error", {
									message: "string" == typeof a ? a : null
								}), c), t.events.trigger("halt"), e.unlockAll();
								else if (l === r.SESSION_TIMEOUT) e.open(n.render("session-timeout"), c), t.externalApi.trigger("timeout"), t.events.trigger("halt");
								else if (l === r.BAD_GATEWAY) e.open(n.render("session-timeout"), c), t.externalApi.trigger("timeout"), t.events.trigger("halt");
								else if (l === r.FORBIDDEN) e.open(n.render("forbidden", {
									message: n.translate(a)
								}), c), t.externalApi.trigger("error", a), t.events.trigger("halt");
								else if (l === r.COUNTRY_BLOCKED) o.sendMessage({
									error: a,
									message: n.render("country-blocked")
								}), t.externalApi.trigger("error", a), t.events.trigger("halt");
								else if (l === r.FRONT_CLIENT_NOT_ACTIVE || l === r.FRONT_CLIENT_NOT_VALID) o.sendMessage({
									error: a,
									message: n.translate("The game you are trying to play is not enabled!")
								}), t.externalApi.trigger("error", a), t.events.trigger("halt");
								else if (l === r.GRAPHICS) e.open(n.render("generic-error", {
									message: a
								}), c), console.error("Error:", l, a), t.externalApi.trigger("error", a), t.events.trigger("halt");
								else if (l === r.OPERATOR_ERROR) {
									let i = u ? JSON.parse(a) : {},
										o = e.open(n.render(i.dialog_template || "error-message", u ? i : {
											message: a
										}), {
											closeable: !1
										});
									s.addEvent(t, o), console.error("Error:", l, a), u || (t.externalApi.trigger("error", a + " (" + l + ")"), t.events.trigger("halt"))
								} else if (l === r.OPERATOR_ERROR_NON_FATAL) {
									let e = u ? JSON.parse(a) : {};
									s.show(t, u ? e : h, e.dialog_template, !0), console.error("Error:", l, a)
								} else e.open(n.render("generic-error"), c), console.error("Error:", l, a), t.externalApi.trigger("error", a + " (" + l + ")"), t.events.trigger("halt")
							}))
						},
						trigger(t, e = r.UNKNOWN) {
							this.apiEvents.trigger("error", {
								message: t,
								code: e
							})
						}
					};
				t.exports = a
			},
			85488: t => {
				function e(t) {
					const e = [];
					for (let i in t)(Array.isArray(t[i]) ? t[i] : [t[i]]).forEach((t => {
						e.push(encodeURIComponent(i) + "=" + encodeURIComponent(t))
					}));
					return e.join("&")
				}

				function i(t, e) {
					const i = function(t, e) {
							const i = new XMLHttpRequest,
								n = e.method || "GET";
							return i.open(n, t), i.withCredentials = e.withCredentials || !1,
								function(t, e) {
									const i = e.headers || {};
									for (let e in i) t.setRequestHeader(e, i[e])
								}(i, e), i
						}(t, e),
						n = new Promise(((t, n) => {
							! function(t, e, i) {
								t.onload = function() {
									if (t.status >= 200 && t.status < 400) e(t.responseText);
									else {
										const e = Error(t.statusText || "Unknown failure; possibly CORS");
										e.status = t.status, e.request = t, i(e)
									}
								}, t.onerror = function(e) {
									e.request = t, i(e)
								}
							}(i, t, n), i.send(e.data)
						}));
					return n.json = function(t) {
						return new Promise(((e, i) => {
							n.then(JSON.parse).then(t || e).catch(i)
						}))
					}, n.headers = function(t) {
						return new Promise(((e, s) => {
							t = t || e, i.onreadystatechange = function() {
								this.readyState === this.HEADERS_RECEIVED && t(i.getAllResponseHeaders())
							}, n.then(e), n.catch(s)
						}))
					}, n
				}
				const n = {
					version: "__VERSION__",
					encodeQuery: e,
					get: (t, e = {}) => (e.method = "GET", e.data = null, i(t, e)),
					post: (t, n, s = {}) => (s.method = "POST", s.headers = s.headers || {}, s.headers["Content-Type"] = "application/x-www-form-urlencoded; charset=UTF-8", s.data = e(n), i(t, s)),
					postJson: (t, e, n = {}) => (n.method = "POST", n.headers = n.headers || {}, n.headers["Content-Type"] = "application/json; charset=UTF-8", n.data = JSON.stringify(e), i(t, n)),
					head: (t, e = {}) => (e.method = "HEAD", e.data = null, i(t, e).headers())
				};
				t.exports = n
			},
			9353: (t, e, i) => {
				const n = i(86767),
					s = new MessageChannel,
					o = {};
				let r = !1,
					a = !1,
					l = !1,
					h = !1;
				const u = {
					init(t) {
						function e() {
							l = !1, a = !0, t.events.trigger("pause"), t.events.pause()
						}
						s.port1.onmessage = i => {
							const s = i.data;
							if ("register" === s.method) {
								t.log("external-api register", s);
								for (let t = 0; t < s.params.length; t++) {
									const e = s.params[t];
									o[e] = !0
								}
							} else h && (t.log("external-api", s.method), "refresh" === s.method && n.refreshBalance(), "reload" === s.method && location.reload(), "send" === s.method && n.send(s.params[0], s.params[1]), "hold" === s.method && (a = !0, t.events.trigger("hold"), t.events.pause()), "pause" === s.method && (l = !0, r || e()), "resume" === s.method && (a ? (a = !1, t.events.resume(), t.events.trigger("resume"), u.trigger("idle")) : l = !1), "fastspin" === s.method && t.settings.set("fastspin", s.data), "mute" === s.method && (t.settings.set("music", !1), t.settings.set("sfx", !1)), "unmute" === s.method && (t.settings.set("music", !0), t.settings.set("sfx", !0)));
							"events.trigger" === s.method && (Array.isArray(s.params) && t.events.trigger(...s.params), "string" == typeof s.params && t.events.trigger(s.params)), "events.on" === s.method && t.events.on(s.params[0], s.params[1])
						}, t.events.on("ready", (() => {
							u.trigger("intro")
						})), t.events.on("start", (() => {
							u.trigger("ready"), h = !0, r || u.trigger("idle"), t.events.on("pause", (() => {
								u.trigger("pause")
							})), t.events.on("resume", (() => {
								u.trigger("resume")
							}))
						})), t.events.on("busy", (() => {
							r || (r = !0, u.trigger("busy"))
						})), t.events.on("idle", (() => {
							r && (r = !1, l && e(), u.trigger("idle"))
						})), t.events.any(((t, e) => {
							"tick" !== t && u.trigger("external", {
								name: t,
								data: e
							})
						})), t.settings.on("sfx", (e => {
							if (!0 === t.settings.get("masterSoundEnabled", !1)) {
								const i = t.settings.get("music", !1);
								!1 === e && !1 === i && t.settings.set("masterSoundEnabled", !1)
							} else !0 === e && t.settings.set("masterSoundEnabled", !0)
						})), t.settings.on("music", (e => {
							if (!0 === t.settings.get("masterSoundEnabled", !1)) {
								const i = t.settings.get("sfx", !1);
								!1 === e && !1 === i && t.settings.set("masterSoundEnabled", !1)
							} else !0 === e && t.settings.set("masterSoundEnabled", !0)
						})), t.settings.set("masterSoundEnabled", !1), window.postMessage(JSON.stringify({
							method: "connect"
						}), "*", [s.port2])
					},
					isRegistered: t => void 0 !== o[t],
					trigger(t, e) {
						const i = {};
						o[t] ? i.or = () => {} : i.or = t => t();
						const n = {
							method: t
						};
						e && (n.params = e);
						try {
							s.port1.postMessage(n)
						} catch (t) {
							console.warn("External API communications problem:", t)
						}
						return i
					}
				};
				t.exports = u
			},
			8834: t => {
				let e = {},
					i = {};
				const n = {
					init(t) {
						t.events.on("init", (function(t) {
							if (t.featureBuyTimesBetValue && t.featureBuyTimesBetValue.forEach((t => {
									e[t.name] = t.price
								})), t.featureBuyTimesBetValueAll)
								for (let e in t.featureBuyTimesBetValueAll) {
									const n = t.featureBuyTimesBetValueAll[e];
									i[e] = {}, n.forEach((t => {
										i[e][t.name] = t.price
									}))
								}
						}))
					},
					getActualPrice(t) {
						let n = 1;
						if (t.playerInteraction && t.playerInteraction.gameMode) {
							const e = i[t.playerInteraction.gameMode];
							n = e[t.featureName] ? e[t.featureName] : 1
						} else n = e[t.featureName] ? e[t.featureName] : 1;
						return +(parseFloat(t.bet) * n).toFixed(2)
					},
					getLockedReelPrice: t => t.playerInteraction && t.playerInteraction.price ? t.playerInteraction.price : 0
				};
				t.exports = n
			},
			59839: t => {
				const e = [],
					i = {
						getGameElement: (t = window.document) => t.querySelector(".nolimit.container .game"),
						getGameSize(t = window.document) {
							const i = this.getGameElement(t),
								n = i.offsetWidth,
								s = i.offsetHeight,
								o = {
									top: 0,
									left: 0,
									right: n,
									bottom: s,
									width: n,
									height: s
								};
							return e.forEach((t => t(o))), o.orientation = o.orientation || function(t, e) {
								return t >= e ? "landscape" : "portrait"
							}(o.width, o.height), o
						},
						addFilter(t) {
							e.push(t)
						}
					};
				t.exports = i
			},
			72937: t => {
				let e, i;
				const n = {
					init(t, e = "main") {
						this.api = t, i = e, this.clear()
					},
					is: (...t) => t.includes(e),
					isNot(...t) {
						return !this.is(...t)
					},
					get: () => e,
					set(t) {
						e = t, this.api.events.trigger("gameMode", t)
					},
					clear() {
						this.set(i)
					},
					clearIf(t) {
						this.is(t) && this.clear()
					},
					isDefault: () => e === i
				};
				t.exports = n
			},
			79633: t => {
				t.exports = {
					show: function(t) {
						const e = t.externalApi.isRegistered("deposit"),
							i = t.dialog.open(t.translations.render("insufficient-funds", {
								deposit: e
							}));
						t.communication.refreshBalance();
						const n = i.querySelector(".deposit");
						n && n.addEventListener("click", (function() {
							t.externalApi.trigger("deposit")
						}))
					}
				}
			},
			21906: t => {
				const e = {
					jurisdiction: {},
					init(t) {
						this.jurisdiction = t.options.jurisdiction || {}, t.events.on("jurisdiction", (t => {
							if ("[object Object]" === t) return void console.error("Broken jurisdiction data: [object Object]");
							const e = "string" == typeof t && t.trim().startsWith("{");
							(t = e ? JSON.parse(t) : t).name ? this.jurisdiction = t : console.error("jurisdiction event had missing name:", t)
						}))
					},
					get() {
						return "string" == typeof this.jurisdiction ? {
							name: this.jurisdiction
						} : this.jurisdiction || {}
					},
					name() {
						return "string" == typeof this.jurisdiction ? this.jurisdiction : this.jurisdiction.name
					}
				};
				t.exports = e
			},
			34613: t => {
				const e = "lastBet",
					i = {
						init(t) {
							this.api = t, this.api.settings.default(e, {})
						},
						load() {
							const t = this.api.currency.getCode();
							return this.api.settings.get(e)[t]
						},
						save(t) {
							const i = this.api.currency.getCode(),
								n = this.api.settings.get(e);
							n[i] = t, this.api.settings.set(e, n)
						}
					};
				t.exports = i
			},
			58833: t => {
				function e() {
					return document.querySelector("body > iframe.loader")
				}
				const i = {
					init(t) {
						t.events.on("ready", (() => {
							const t = e();
							t && t.contentWindow.postMessage(JSON.stringify({
								game: "ready"
							}), "*"), this.removeLoader()
						})), window.addEventListener("message", (function(e) {
							try {
								const i = JSON.parse(e.data);
								t.log("game-api - message received:", i)
							} catch (i) {
								t.log("Not JSON, ignoring:", e.data)
							}
						}))
					},
					sendMessage(t) {
						const i = e();
						i && i.contentWindow.postMessage(JSON.stringify(t), "*")
					},
					removeLoader() {
						setTimeout((function() {
							const t = e();
							t && t.parentNode && t.parentNode.removeChild(t)
						}), 1e3);
						const t = e();
						t && (t.style.transition = "opacity 1s ease-out", t.style.opacity = 0)
					}
				};
				t.exports = i
			},
			28779: (t, e, i) => {
				const n = i(63659),
					s = i(78620),
					o = {
						init(t) {
							t.events.on("maxWinCap", (function(e) {
								const i = s.format(e);
								t.dialog.open(n.render("max-win-cap", {
									amount: i
								}), {
									closeable: !1,
									blackout: !0
								}), t.events.trigger("halt"), t.dialog.unlockAll()
							}))
						}
					};
				t.exports = o
			},
			4591: (t, e, i) => {
				const n = i(31763),
					s = i(63659),
					o = [],
					r = new Set,
					a = ["operator", "environment", "game"],
					l = {
						init: t => {
							if (t.options.replay) return;
							if (!1 === t.options.readMessagesJson) return;
							const e = t.startupPromise("messages");
							t.settings.default("shownMessages", []), t.events.on("messages", (e => {
								for (let i = 0; i < e.length; i++) {
									const n = e[i],
										o = n.id;
									if (o) {
										if (r.has(o)) return;
										r.add(o)
									}
									const a = n.template || "generic-message",
										l = s.render(a, n.data);
									t.dialog.open(l)
								}
							})), n.get("https://www.nolimitcdn.com/messages/messages.json").json((i => {
								i = Array.isArray(i) ? i : [], t.log("messages", i), i.forEach((e => {
									if (void 0 === e.id) return void t.warn("Missing 'id' field in message:", e);
									if (void 0 === e.filter) return void t.warn("Missing 'filter' field in message:", e);
									for (let i = 0; i < a.length; i++) {
										const n = a[i];
										if (void 0 === e.filter[n]) return void t.warn(`Missing filter.'${n}' in message:`, e)
									}
									const i = e.id,
										n = t.settings.get("shownMessages");
									if (n.includes(i)) t.log("Already seen message with id:", i);
									else {
										if (e.filter) {
											for (const i in e.filter)
												if (!e.filter[i].includes(t.options[i])) return;
											const i = t.options.language,
												n = {
													title: e.title[i] || e.title.en,
													message: e.message[i] || e.message.en
												};
											o.push({
												data: n
											})
										}
										n.push(i), t.settings.set("shownMessages", n)
									}
								})), e.fulfill()
							})).catch((i => {
								t.warn("Message json failed", i), e.fulfill()
							})), t.events.once("start", (() => {
								o.length > 0 && t.events.trigger("messages", o), t.options.messages && t.options.messages.length > 0 && t.events.trigger("messages", t.options.messages)
							}))
						}
					};
				t.exports = l
			},
			87295: (t, e, i) => {
				const n = i(82935).create();
				n.init = function(t) {
					n.any(((e, i) => {
						"tick" !== e && (void 0 !== i ? t.log("Event:", e, i) : t.log("Event:", e)), "halt" === e && n.shutdown()
					}))
				}, t.exports = n
			},
			28731: (t, e, i) => {
				const n = i(900),
					s = i(9353);
				t.exports = {
					init(t, e) {
						const i = n.create(t);
						return i.any(((t, i) => {
							e.log("Settings:", t, i), s.trigger("settings", {
								name: t,
								value: i
							})
						})), i
					}
				}
			},
			35273: (t, e, i) => {
				window.nolimit = window.nolimit || {}, window.nolimit.api = window.nolimit.api || {};
				const n = i(37657).rE,
					s = i(54599),
					o = i(312),
					r = i(72775),
					a = i(73253),
					l = i(38028),
					h = i(86767),
					u = i(69256),
					c = i(78620),
					d = i(71019),
					p = i(56827),
					_ = i(87295),
					m = i(90509),
					g = i(9353),
					f = i(59839),
					S = i(21906),
					y = i(34613),
					v = i(58833),
					T = i(28779),
					E = i(4591),
					b = i(24485),
					A = i(25435),
					P = i(47270),
					I = i(39491),
					w = i(13730),
					L = i(72937),
					C = i(28731),
					x = i(84006),
					B = i(3694),
					O = i(63659),
					N = i(96958),
					M = i(8834);
				window.nolimit.api.events = _, window.nolimit.api.error = m, window.nolimit.api.transltions = O;
				const R = [],
					D = {},
					k = {
						init() {
							this.options = window.nolimit.options = b.get(window.nolimit.options), this.settings = C.init(this.options.operator + "." + this.options.game, this), window.nolimit.api.settings = this.settings, _.init(this), _.trigger("loading"), window.focus(), window.addEventListener("beforeunload", (function() {
								_.trigger("halt")
							})), s.init(this.options), o.init(this), console.log(this.options.game, this.options.version), this.log("User-Agent:", navigator.userAgent), this.log("@nolimitcity/game-api", n), document.documentElement.setAttribute("data-agent", navigator.userAgent), document.documentElement.setAttribute("data-device", this.options.device), O.init(this, x);
							const t = O.render("container", {
								game: this.options.game.replace(/DX[0-9]$/, "").replace(/([A-Z][a-z])/g, " $1").replace("Kitchen Drama", "Kitchen Drama:").replace("Mayan Magic", "Mayan Magic Wildfire").replace("Ture", "Turstugan").replace("Harlequin", "Harlequin Carnival").replace("Deadwood", "Deadwood xNudge").replace("Monkeys Gold", "Monkey's Gold").replace("Warrior Graveyard", "Warrior Graveyard xNudge").replace("East Vs West", "East Coast Vs West Coast").replace("San Quentin", "San Quentin xWays").replace("Fire In The Hole", "Fire In The Hole xBomb").replace("Infectious5", "Infectious5 xWays")
							});
							var e;
							document.body.firstElementChild.insertAdjacentHTML("beforebegin", t), _.on("loaded", (() => {
								document.querySelector(".nolimit.container").classList.remove("loading")
							})), _.on("start", (() => {
								if (this.options.replay) document.querySelector(".nolimit > .replay").style.display = "block";
								else if (this.options.funMode) {
									const t = document.querySelector(".fun");
									t.innerHTML = O.translate(t.innerHTML), t.style.display = "block"
								}
								if (this.options.version && this.options.version.startsWith("0.")) {
									const t = document.createElement("div");
									t.classList.add("beta"), t.textContent = "BETA", document.querySelector(".nolimit").appendChild(t)
								}
								s.screenView("main")
							})), e = this, m.init(e), S.init(e), c.init(e), M.init(e), r.init(e), y.init(e), l.init(e), u.init(e), w.init(e), A.init(e), I.init(e), E.init(e), p.init(e), g.init(e), v.init(e), B.init(e), N.init(e), P.init(e), T.init(e), L.init(e), D.ready = this.startupPromise("ready"), h.init(this)
						},
						loaded() {
							_.trigger("resize", f.getGameSize()), _.trigger("loaded")
						},
						ready() {
							D.ready.fulfill()
						},
						start() {
							_.trigger("start")
						},
						bet: a.bet,
						zeroBet: a.zeroBet,
						pickAndClickBet: a.pickAndClickBet,
						buyFeatureBet: a.buyFeatureBet,
						balance: r,
						realityCheck: P,
						currency: c,
						betLevel: l,
						events: _,
						css: u,
						dialog: p,
						translations: O,
						resources: w,
						development: d,
						resize: I,
						getGameElement: f.getGameElement,
						getGameSize: f.getGameSize,
						startupPromise(t) {
							if (!t) throw "What is thy promise?";
							return R.push(t), k.log("startupPromise given", t), {
								fulfill() {
									const e = R.indexOf(t); - 1 !== e ? (R.splice(e, 1), k.log("startupPromise fulfilled:", t, "- remaining:", R), 0 === R.length && (I.trigger(), k.events.trigger("ready"))) : k.warn("Unknown promise", t, "trying to fulfill"), this.fulfill = this.break = function() {}
								},
								break (e) {
									console.error("Promise", t, "failed:", e), console.error("Remaining promises:", R), k.error.trigger("Promise failure", m.CODES.PROMISE), k.events.trigger("halt")
								}
							}
						},
						log() {
							d() && console.log.apply(console, arguments)
						},
						warn() {
							d() && console.warn.apply(console, arguments)
						},
						externalApi: g,
						error: m,
						gameArea: f,
						analytics: s,
						communication: h,
						jurisdiction: S,
						gameMode: L
					};
				t.exports = k
			},
			24485: t => {
				t.exports = {
					get: function(t) {
						return function(t) {
							if (!t || !t.game) throw new Error("Missing nolimit.options.game: " + JSON.stringify(t))
						}(t), t.device = t.device || "desktop", "verbose" !== t.language && "succinct" !== t.language && "zh-Hant" !== t.language && "zh-hant" !== t.language && "pt-BR" !== t.language && "pt-br" !== t.language && "us-sweepstakes" !== t.language && (t.language = (t.language || "en").substring(0, 2).toLowerCase()), t.serverHost = function(t) {
							if (t.serverHost) return t.serverHost.replace(/\/$/, "");
							const e = t.environment;
							return -1 === e.indexOf(".") ? "https://" + e + ".nolimitcity.com" : "https://" + e.replace("nolimitcdn", "nolimitcity").replace("-us.nlccdn.com", ".nlcus.com").replace("nlccdn", "nlcgames").replace("nlcasiacdn", "nlcasia")
						}(t), !0 !== t.hideCurrency && "true" !== t.hideCurrency || (t.hideCurrency = !0), t.quality && (t.quality = t.quality.toLowerCase()), t.smartLoading = t.smartLoading && !1 !== t.smartLoading, t.showDialogs = !1 !== t.showDialogs, t.funMode = !t.token, t.realityCheck = t.realityCheck || {}, t
					}
				}
			},
			25435: t => {
				const e = {
					init(t) {
						"desktop" === t.options.device && t.events.on("resize", (t => {
							const e = document.querySelector(".nolimit .overlay");
							e.classList.contains("blackout") || e.classList.contains("blocking") ? e.style.height = "100%" : e.style.height = t.bottom + "px"
						})), t.events.on("pause", (() => {
							const t = i();
							t.classList.add("overlay"), t.classList.add("paused")
						})), t.events.on("resume", (() => {
							const t = i();
							t.classList.contains("paused") && (t.classList.remove("overlay"), t.classList.remove("paused"))
						}))
					}
				};

				function i() {
					return document.querySelector(".nolimit.container")
				}
				t.exports = e
			},
			47270: (t, e, i) => {
				const n = i(8834),
					s = i(78620),
					o = {
						interval: 60,
						enabled: !0
					},
					r = {
						bet: 0,
						bets: 0,
						winnings: 0
					},
					a = {
						init(t) {
							if (t.options.replay) return;

							function e(t) {
								"boolean" == typeof t.enabled && (o.enabled = t.enabled), t.bets && (r.bets += parseFloat(t.bets)), t.winnings && (r.winnings += parseFloat(t.winnings)), t.interval && t.interval !== o.interval && (o.interval = t.interval, o.nextTime = Date.now() + l(o.interval)), t.sessionStart && (o.sessionStart = t.sessionStart, o.nextTime = o.sessionStart + l(o.interval)), t.nextTime && (o.nextTime = t.nextTime), t.message && (o.message = t.message)
							}
							let i;
							t.options.funMode && (o.enabled = !1), o.message = t.translations.translate("We want to remind you that you have played for an even time interval, see below for details about your game session"), e(t.options.realityCheck), t.events.on("realityCheck", e), t.events.once("start", (() => {
								o.message = t.translations.translate(o.message)
							})), t.events.on("bet", (t => {
								if ("normalBet" === t.type && (r.bets += parseFloat(t.bet), r.bet = parseFloat(t.bet)), "featureBet" === t.type) {
									let e = t.data && t.data.isPromotional ? 0 : n.getActualPrice(t);
									n.getLockedReelPrice(t) > 0 && (e = n.getLockedReelPrice(t)), r.bets += parseFloat(e), r.bet = parseFloat(e)
								}
							})), t.events.on("actionSpinsBet", (t => {
								"normalBet" === t.type && (r.bets += parseFloat(t.bet)), "featureBet" === t.type && (r.bets += parseFloat(n.getActualPrice(t)))
							})), t.events.once("tick", (() => {
								o.sessionStart = o.sessionStart || Date.now(), o.nextTime = o.nextTime || o.sessionStart + l(o.interval)
							})), t.events.on("url", (t => {
								t.accountHistory && (i = t.accountHistory)
							})), t.events.on("tick", (e => {
								const n = {
									bets: s.formatValue(r.bets),
									winnings: s.formatValue(r.winnings),
									profit: s.formatValue(r.winnings - r.bets),
									hours: e.hours + ":" + e.minutes.toString().padStart(2, "0"),
									message: o.message
								};
								if (o.enabled && Date.now() > o.nextTime + 5e3) {
									o.nextTime = o.nextTime + l(o.interval), n.message = t.translations.translate(n.message);
									const e = t.translations.render("responsible-gaming", n),
										s = {
											closeable: !1,
											replace: "responsible-gaming",
											ignoreLocks: !0
										},
										r = t.dialog.open(e, s);
									r.querySelector("div.end-session a").addEventListener("click", (() => {
										"desktop" === t.options.device ? (t.dialog.open(t.translations.render("responsible-end-session")), t.events.trigger("halt")) : t.externalApi.trigger("exit").or(history.back.bind(history))
									}));
									const a = r.querySelector("div.account-history a");
									t.externalApi.isRegistered("accountHistory") ? (a.addEventListener("click", (() => {
										t.externalApi.trigger("accountHistory")
									})), a.style.display = "") : i ? (a.addEventListener("click", (() => {
										window.top.location.href = i
									})), a.style.display = "") : a.style.display = "none"
								}
								const a = document.getElementById("rc-hours"),
									h = document.getElementById("rc-winnings"),
									u = document.getElementById("rc-profit"),
									c = document.getElementById("rc-message");
								a && (a.textContent = n.hours), h && (h.textContent = n.winnings), u && (u.textContent = n.profit), c && (c.textContent = o.message)
							}))
						},
						getBet: () => r.bet,
						getTotalBets: () => r.bets,
						getTotalWins: () => r.winnings
					};

				function l(t) {
					return 60 * t * 1e3
				}
				t.exports = a
			},
			6396: t => {
				const e = {
					show: function(t, e, i, n) {
						const s = t.externalApi.isRegistered("recoverableErrorChoice") || !0 === n;
						e.title = e.title || "Recoverable error", e.text = e.text || "An error occurred", e.continue = s;
						let o = "recoverable-error";
						i && (o = i);
						const r = t.dialog.open(t.translations.render(o, e), {
							closeable: !1
						});
						this.addEvent(t, r)
					},
					addEvent: function(t, e) {
						const i = t.externalApi.isRegistered("recoverableErrorChoice"),
							n = e.querySelector(".stop");
						n && n.addEventListener("click", (function() {
							i ? t.externalApi.trigger("recoverableErrorChoice", {
								action: "stop"
							}) : t.externalApi.trigger("exit").or((() => history.back()))
						}));
						const s = e.querySelector(".close");
						s && (s.disabled = !0, s.classList.add("disabled"), s.classList.add("waiting"), t.events.once("finish", (() => {
							s.disabled = !1, s.classList.remove("disabled"), s.classList.remove("waiting")
						}))), i ? s && s.addEventListener("click", (function() {
							t.externalApi.trigger("recoverableErrorChoice", {
								action: "continue"
							})
						})) : s && s.addEventListener("click", (function() {
							t.externalApi.trigger("ready")
						}));
						let o = e.querySelectorAll("[data-event]");
						for (let e of o) {
							let i = e.dataset.event;
							i && e.addEventListener("click", (function() {
								t.externalApi.trigger(i)
							}))
						}
						t.communication.refreshBalance(), t.events.trigger("softReset")
					}
				};
				t.exports = e
			},
			61304: (t, e, i) => {
				const n = i(99499),
					s = i(90509);

				function o(t, e) {
					function i() {
						if (e.length > 0) {
							const i = e[0];
							i.freeBets ? t.bet("freeBet", i.freeBets.amount) : i.game.actualBetThisSpin ? t.bet(void 0, i.game.actualBetThisSpin, void 0, i.game.wasFeatureBuy) : i.game && i.game.wasFeatureBuy ? t.bet(void 0, void 0, void 0, i.game.wasFeatureBuy) : t.bet()
						} else {
							if (!t.options.replay.disableEndingPopup) {
								const e = t.translations.render("generic-message", {
									title: t.translations.translate("Replay completed"),
									message: t.translations.translate("Replay of a previously played game round is complete.")
								});
								setTimeout((() => {
									t.dialog.open(e)
								}), 1e3)
							}
							t.events.trigger("replayEnd")
						}
					}

					function s() {
						e.length > 0 && n.replay(e.shift())
					}
					t.events.on("replayBet", (() => {
						setTimeout(s, 300)
					})), t.events.on("start", (() => {
						t.events.on("state", (t => "ready" === t && i())), i()
					})), setTimeout((function() {
						s()
					}), 300)
				}
				const r = {
					init(t, e) {
						document.querySelector(".nolimit.container").classList.add("replay"), e.responses ? o(t, e.responses) : (t.communication.history.init(e.url.replace(/\/gs$/, "/history"), e.key), t.communication.history.replay(e.id, t.development()).then((e => {
							o(t, e)
						})).catch((e => {
							t.events.trigger("error", {
								code: s.CODES.REPLAY,
								error: e
							})
						})))
					}
				};
				t.exports = r
			},
			39491: (t, e, i) => {
				const n = i(31208);
				let s = {
					width: -1,
					height: -1
				};

				function o() {
					if (document.hidden) return void setTimeout(o, 500);
					const t = r.api.getGameSize();
					let e = !1;
					for (const i in s)
						if (s[i] !== t[i]) {
							e = !0;
							break
						} e && (r.api.events.trigger("resize", t), s.orientation !== t.orientation && r.api.events.trigger("orientation", t.orientation), s = t)
				}
				const r = {
					init(t) {
						this.api = t, n.on("resize", ((t, e = 300) => {
							let i;
							return (...n) => {
								i || t.apply(this, n), clearTimeout(i), i = setTimeout((() => {
									i = void 0
								}), e)
							}
						})(o, 250)), n.listen(t.getGameElement()), t.events.on("loaded", o)
					},
					trigger() {
						o()
					}
				};
				t.exports = r
			},
			13730: (t, e, i) => {
				const n = "/nolimit/",
					s = i(85488),
					o = i(26786).root;

				function r(t, e) {
					return o + e + t
				}

				function a(t, e) {
					return r(t, e)
				}

				function l(t) {
					const e = t.startupPromise("config.json");
					h.loadJson("config.json").then((i => function(i) {
						! function(i) {
							const n = t.options.device;
							i.device = n, i[n] = !0, i.staticRoot = o, h.config = i, t.events.trigger("config", i), e.fulfill()
						}(i)
					}(i))).catch((t => e.break(t)))
				}
				const h = {
					init(t) {
						l(t)
					},
					load(t) {
						const e = a(t, n);
						return s.get(e)
					},
					loadJson(t, e) {
						void 0 === e && (e = n);
						const i = a(t, e);
						return s.get(i).json()
					},
					getPath: t => r(t || "", n),
					getStaticRoot: () => o,
					getConfig() {
						return this.config
					}
				};
				t.exports = h
			},
			3694: t => {
				let e;

				function i(t) {
					return ("0" + t).slice(-2)
				}

				function n() {
					const t = Date.now() - e,
						n = Math.floor(t / 1e3),
						o = Math.floor(n / 60),
						r = Math.floor(o / 60),
						a = {
							deltaSeconds: n,
							deltaMinutes: o,
							deltaHours: r,
							seconds: i(n % 60),
							minutes: i(o % 60),
							hours: i(r)
						};
					s.api.events.trigger("tick", a)
				}
				const s = {
					init(t) {
						this.api = t, t.events.on("init", (() => {
							e = t.options.realityCheck.sessionStart || Date.now(), setInterval(n, 1e3), n()
						}))
					}
				};
				t.exports = s
			},
			63659: (t, e, i) => {
				const n = i(34714),
					s = {},
					o = ["bg", "bp", "cs", "da", "de", "el", "en", "es", "et", "fi", "fr", "hi", "hu", "id", "is", "it", "ja", "ka", "ko", "lt", "lv", "ms", "nl", "no", "pl", "pt", "ro", "ru", "sr", "succinct", "sv", "zh-hant", "th", "tr", "verbose", "vi", "zh", "sk", "uk", "mk", "us-sweepstakes"],
					r = i(78620),
					a = {
						init: function(t, e) {
							a.gamePath = t.resources.getPath(), a.device = t.options.device, a.templates = e, a.warn = t.warn, a.jurisdictionName = t.jurisdiction.name();
							let i = t.options.language.toLowerCase();
							"pt-br" === i ? i = "bp" : "hr" === i && (i = "sr"), a.language = i, -1 === o.indexOf(i) && (a.warn(`${i} language is not available`), a.language = "en")
						},
						add: function(t) {
							const e = a.language;
							if (t[e])
								for (let i in t[e]) s[i] = t[e][i];
							else a.warn("Something wrong in translations.")
						},
						render: function(t, e) {
							"string" == typeof(t = a.templates[t] || t) && (t = n.compile(t)), (e = e || {}).tr = function() {
								return function(t) {
									return t = e[t] || t, a.translate(t)
								}
							}, e.formatCurrency = function() {
								return function(t) {
									return t = e[t] || t, r.format(t)
								}
							}, e.language = e.language || a.language, e.gamePath = e.gamePath || a.gamePath, -1 === o.indexOf(e.language) && (a.warn(`${e.language} language is not available`), e.language = "en");
							const i = a.jurisdictionName;
							return i && (e.jurisdiction = e.jurisdiction || "jurisdiction:" + i, e["jurisdiction:" + i] = !0), "desktop" === a.device ? e.desktop = !0 : e.mobile = !0, t.render(e)
						},
						translate: function(t) {
							const e = a.language;
							return s[t] ? s[t] : ("en" !== e && a.warn(`No translation available for: "${t}" in "${e}"`), t)
						}
					};
				t.exports = a
			},
			96958: t => {
				const e = {
					init(t) {
						document.addEventListener("visibilitychange", (() => {
							t.events.trigger("hidden", document.hidden)
						}))
					}
				};
				t.exports = e
			},
			84006: (t, e, i) => {
				t.exports = {
					container: i(17862),
					flash: i(16379),
					forbidden: i(80820),
					"generic-error": i(82331),
					"generic-message": i(40858),
					"insufficient-funds": i(90381),
					"max-win-cap": i(72421),
					"responsible-gaming": i(43729),
					"responsible-gaming-error": i(35814),
					"responsible-gaming-server-dialog": i(47466),
					"recoverable-error": i(84066),
					"recoverable-insufficient-funds": i(64462),
					"responsible-end-session": i(41840),
					"session-timeout": i(49315),
					"country-blocked": i(69950),
					"server-dialog": i(69315),
					"error-message": i(157)
				}
			},
			99499: (t, e, i) => {
				let n = 0;
				const s = i(71533),
					o = i(8778),
					r = i(85881),
					a = i(82935),
					l = i(89007),
					h = i(72147),
					u = a.create(),
					c = s.name + "@" + s.version,
					d = {},
					p = {
						type: "init",
						content: {
							type: "init"
						},
						protocol: c
					},
					_ = ["currency", "betLevels", "operatorFreeBetMessages", "freeBets", "balance", "balances"];

				function m(t) {
					const e = t.game;
					delete t.game;
					const i = "ok" === t.init;
					delete t.init, t.extPlayerKey && (d.extPlayerKey = t.extPlayerKey), t.id && (u.trigger("id", t.id), delete t.id), t.error ? u.trigger("error", t.error) : (function(t) {
						_.forEach((e => {
							t[e] && (u.trigger(e, t[e]), delete t[e])
						}))
					}(t), function(t) {
						for (let e in t) u.trigger(e, t[e])
					}(t), e && (i ? u.trigger("init", e) : u.trigger("game", e)))
				}
				u.connect = function(t) {
					t.uuid = t.uuid || Math.random().toString(36).substr(2, 10), this.options = t;
					const e = function(t) {
							const e = new XMLHttpRequest;
							return e.open("POST", t, !0), e.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8"), e.setRequestHeader("Accept", "application/json"), e.onerror = t => u.trigger("error", t), e
						}(t.serverHost + "/EjsFrontWeb/fs"),
						i = function(t) {
							const e = (t.gameServer || t.game) + "@" + t.device,
								i = {
									action: "open_game",
									clientString: t.operator,
									language: t.language,
									gameCodeString: e
								};
							if (t.extra || t.jsonData) {
								const e = t.extra || t.jsonData;
								i.jsonData = "object" == typeof e ? JSON.stringify(e) : e
							}
							return t.token && (i.tokenString = t.token), t.jurisdiction && (i.jurisdiction = "object" == typeof t.jurisdiction ? JSON.stringify(t.jurisdiction) : t.jurisdiction), t.playForFunCurrency && (i.playForFunCurrency = t.playForFunCurrency), i
						}(t);
					e.onload = () => {
						const i = JSON.parse(e.responseText);
						if (i.error) u.trigger("error", i);
						else if (i.url && i.key) {
							this.trigger("connected", i), this.serverUrl = i.url + "?data=" + i.key, this.serverKey = i.key;
							const e = this.serverUrl.replace(/^http/, "ws").replace("/gs?data=", "/ws/game?data=");
							l.init(i.url.replace(/\/gs$/, "/history"), i.key), this.websocket = r(e), this.websocket.on("message", (t => this.trigger("debug", {
								"communication.game": t
							}))), this.websocket.on("message", (t => m(t))), this.websocket.on("error", (t => this.trigger("error", t)));
							const s = Object.assign({}, p);
							s.id = t.uuid + "-" + n, s.content.bet = t.lastBet, s.gameClientVersion = t.version, s.data = d, this.trigger("id", s.id), this.websocket.send(o.encrypt(this.serverKey, JSON.stringify(s)))
						} else u.trigger("error", "No url and/or key from server: " + e.responseText)
					}, this.trigger("debug", {
						"communication.open": i
					}), e.send(function(t) {
						const e = [];
						for (let i in t) {
							const n = t[i];
							e.push(encodeURIComponent(i) + "=" + encodeURIComponent(n))
						}
						return e.join("&")
					}(i))
				}, u.send = function(t, e) {
					n++;
					const i = {
						type: t,
						content: e,
						protocol: c,
						data: d,
						id: this.options.uuid + "-" + n
					};
					this.trigger("debug", {
						"communication.send": i
					}), this.websocket.send(o.encrypt(this.serverKey, JSON.stringify(i)))
				}, u.balance = function(t, e) {
					const i = {
						type: "balance",
						bet: t
					};
					e && (i.data = e), this.send("balance", i)
				}, u.history = l, u.outcome = h, u.replay = m, t.exports = u
			},
			85881: (t, e, i) => {
				const n = i(82935);
				t.exports = t => {
					let e = null,
						i = !1,
						s = 0;
					const o = [],
						r = n.create();

					function a() {
						try {
							for (; o.length > 0;) e.send(o[0]), o.shift()
						} catch (t) {
							l(), h()
						}
					}

					function l() {
						null !== e && (e.onopen = () => {}, e.onerror = () => {}, e.onclose = () => {}, e.close(), e = null)
					}

					function h() {
						i = !1, e = new WebSocket(t), e.onopen = () => {
							s = 0, a()
						}, e.onerror = t => {
							if (l(), i) o.length > 0 && h();
							else if (s < 10) s++, setTimeout(h, 500);
							else {
								let e;
								e = "error" === t.type && t.target.url ? "Websocket error at: " + t.target.url : t.message ? t.message : "Websocket error", r.trigger("error", {
									message: e
								})
							}
						}, e.onclose = t => {
							l(), 1e3 === t.code ? r.trigger("close", t.reason) : i || r.trigger("error", t)
						}, e.onmessage = t => {
							let e = t.data;
							e.startsWith("lzw:") && (e = function(t) {
								if (!t.startsWith("lzw:")) return t;
								const e = {};
								let i = (t = t.substr(4)).substr(0, 1),
									n = i,
									s = 256;
								const o = [i];
								for (let r = 1; r < t.length; r++) {
									const a = t.charCodeAt(r);
									let l;
									l = a < 256 ? t.substr(r, 1) : e[a] ? e[a] : n + i, o.push(l), i = l.substr(0, 1), e[s] = n + i, s++, n = l
								}
								return o.join("")
							}(e));
							try {
								r.trigger("message", JSON.parse(e))
							} catch (t) {
								r.trigger("error", {
									message: "" + t
								})
							}
							i = !0
						}
					}
					return r.send = t => {
						o.push(t), null !== e && e.readyState === WebSocket.OPEN ? a() : null === e || e.readyState !== WebSocket.CONNECTING ? (l(), h(), setTimeout((() => {
							o.length > 0 && (r.trigger("debug", "Timeout after reconnecting at 10000ms, clearing and trying again"), l(), h())
						}), 1e4)) : setTimeout((() => {
							e.readyState === WebSocket.CONNECTING && -1 !== o.indexOf(t) && (r.trigger("debug", "Timeout while connecting at 10000ms, clearing and trying again"), l(), h())
						}), 1e4)
					}, r
				}
			},
			89007: t => {
				function e(t) {
					return new Promise(((e, i) => {
						const n = new XMLHttpRequest;
						n.open("GET", t, !0), n.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8"), n.setRequestHeader("Accept", "application/json"), n.onload = () => {
							try {
								const t = JSON.parse(n.responseText);
								n.status >= 200 && n.status < 400 ? e(t) : t.error ? i(t.error) : i(`${n.status} ${n.statusText}`)
							} catch (t) {
								i(t.message)
							}
						}, n.onerror = () => {
							i(`${n.status} ${n.statusText}`)
						}, n.send()
					}))
				}
				const i = {
					init(t, e) {
						this.url = t, this.key = e, this.offset = (new Date).getTimezoneOffset()
					},
					roundsPaginated(t, i, n, s) {
						return e(`${this.url}/rounds_paginated?data=${this.key}&date=${t}&header=${i}&sortType=${n}&pageNo=${s}&offset=${this.offset}`)
					},
					daysNoHour(t, i) {
						return i = i.toString().padStart(2, "0"), e(`${this.url}/days_nohour?data=${this.key}&month=${t}-${i}&offset=${this.offset}`)
					},
					days(t, i) {
						return i = i.toString().padStart(2, "0"), e(`${this.url}/days?data=${this.key}&month=${t}-${i}&offset=${this.offset}`)
					},
					rounds(t, i) {
						return i = i.toString().padStart(2, "0"), e(`${this.url}/rounds?data=${this.key}&date=${t}&hour=${i}&offset=${this.offset}`)
					},
					round(t) {
						return e(`${this.url}/round?data=${this.key}&id=${t}`)
					},
					replay(t, i = !1) {
						let n = `${this.url}/replay?data=${this.key}&id=${t}`;
						return i && (n += "&debug=true"), e(n)
					},
					replayUrl(t) {
						return e(`${this.url}/replay-url?data=${this.key}&id=${t}`)
					},
					topListCurrentGame(t = "multiplier") {
						return e(`${this.url}/top-list-current-game?data=${this.key}&type=${t}`)
					},
					topListAnyGame(t = "multiplier") {
						return e(`${this.url}/top-list-any-game?data=${this.key}&type=${t}`)
					}
				};
				t.exports = i
			},
			72147: (t, e, i) => {
				const n = i(85881),
					s = {
						connect(t) {
							const e = t.demo,
								i = n(e);

							function s(t) {
								i.send(JSON.stringify(t))
							}
							return i.addFlag = t => {
								s({
									action: "add-flag",
									flag: t
								})
							}, i.addReels = t => {
								s({
									action: "add-reels",
									reels: t
								})
							}, i.clear = () => {
								s({
									action: "clear"
								})
							}, i
						}
					};
				t.exports = s
			},
			8778: t => {
				const e = "0123456789abcdef";

				function i(t, e) {
					let i, n, s, o = [],
						r = [];
					for (i = 0; i < 256; i++) o[i] = i;
					for (i = 0, n = 0; i < 256; i++) n = (n + o[i] + t[i % t.length]) % 256, s = o[i], o[i] = o[n], o[n] = s;
					for (let t = 0, i = 0, n = 0; t < e.length; t++) i = (i + 1) % 256, n = (n + o[i]) % 256, s = o[i], o[i] = o[n], o[n] = s, r.push(e[t] ^ o[(o[i] + o[n]) % 256]);
					return r
				}

				function n(t) {
					const i = encodeURIComponent(t).split(""),
						n = [];
					for (let t = 0; t < i.length; t++) "%" === i[t] ? (n.push(e.indexOf(i[t + 1].toLowerCase()) << 4 | e.indexOf(i[t + 2].toLowerCase())), t += 2) : n.push(i[t].charCodeAt(0));
					return n
				}
				const s = {
					encrypt: function(t, s) {
						return function(t) {
							const i = [];
							return t.forEach((function(t) {
								i.push(e.charAt(t >> 4 & 15)), i.push(e.charAt(15 & t))
							})), i.join("")
						}(i(n(t), n(s)))
					},
					decrypt: function(t, s) {
						return function(t) {
							let i = "";
							for (let n = 0; n < t.length; n++) i += "%" + e.charAt(t[n] >> 4 & 15) + e.charAt(15 & t[n]);
							return decodeURIComponent(i)
						}(i(n(t), function(t) {
							if ("string" != typeof t) return [];
							const i = [],
								n = t.split("");
							for (let t = 0; t < n.length; t += 2) i.push(e.indexOf(n[t]) << 4 | e.indexOf(n[t + 1]));
							return i
						}(s)))
					}
				};
				t.exports = s
			},
			54599: t => {
				const e = ["game", "version", "cdn", "device", "operator", "currency", "language", "environment"];
				let i, n, s = !1;

				function o(t, e) {
					s && i.port1.postMessage({
						hitType: t,
						eventData: e
					})
				}
				const r = {
					init: function(t) {
						return void 0 === n && (!1 === t.googleAnalytics ? n = Promise.resolve() : (r.options = function(t) {
							const i = {};
							return e.forEach((e => {
								t[e] && (i[e] = t[e])
							})), i
						}(t), n = new Promise(((t, e) => {
							i = new MessageChannel;
							const n = document.createElement("iframe");
							n.setAttribute("frameBorder", "0"), n.style.width = "0", n.style.height = "0", n.id = "nolimit-analytics", n.onload = function() {
								n.contentWindow.postMessage(JSON.stringify(r.options), r.options.cdn, [i.port2]), s = !0, t(n)
							}, n.onerror = function(t) {
								e(t.message)
							}, n.src = "{CDN}/analytics/analytics.html".replace("{CDN}", r.options.cdn).replace("{GAME}", r.options.game), document.body.appendChild(n)
						})))), n
					},
					screenView(t) {
						s && o("screenview", {
							screenName: t
						})
					},
					event(t, e, i) {
						if (s) {
							const n = {
								eventCategory: r.options.game + "@" + r.options.device,
								eventAction: t
							};
							e && ("number" == typeof e ? n.eventValue = e : n.eventLabel = String(e)), i && (n.eventValue = i), o("event", n)
						}
					},
					exception(t, e) {
						s && o("exception", {
							exDescription: t,
							exFatal: e
						})
					},
					timing(t, e, i, n) {
						if (s) {
							const s = {
								timingCategory: t,
								timingVar: e,
								timingValue: i
							};
							n && (s.timingLabel = n), o("timing", s)
						}
					}
				};
				t.exports = r
			},
			2425: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NolimitPromotionPlugin = void 0;
				const n = i(72468),
					s = i(91980),
					o = i(64118),
					r = i(64763),
					a = i(94183),
					l = i(50799),
					h = i(49490),
					u = i(97182),
					c = i(77549),
					d = i(39055),
					p = i(19803),
					_ = i(11877),
					m = i(41284),
					g = i(50108),
					f = i(81029),
					S = i(5117),
					y = i(46334),
					v = i(82748),
					T = i(61e3),
					E = i(12355),
					b = i(3933),
					A = i(5217),
					P = i(91275),
					I = i(88458),
					w = i(60767);
				class L {
					constructor(t) {
						this.name = "PromoPanel", this.GAME_FEATURE_ASSETS_FORMAT = ".png", this._featureControllerMap = new Map, this._isActionSpinRound = !1, t && (L.promoPanelGameConfiguration = t, L.ASOptionsData = t.getActionSpinOptions && t.getActionSpinOptions())
					}
					static fetchPlugins() {
						for (let t of s.NolimitLauncher.plugins)(0, f.isSoundPlugin)(t) ? L.sound = t : (0, u.isKeypadPlugin)(t) ? L.keypadPlugin = t : (0, o.isApiPlugin)(t) && (L.apiPlugIn = t);
						return null == L.sound ? Promise.reject(new Error("NolimitPromotionPlugin is missing SoundPlugin")) : null == L.apiPlugIn ? Promise.reject(new Error("NolimitPromotionPlugin is missing ApiPlugin")) : null == L.keypadPlugin ? Promise.reject(new Error("NolimitPromotionPlugin is missing KeypadPlugin")) : Promise.resolve()
					}
					static onBet(t) {
						t.type === v.APIBetType.ZERO_BET ? L.isZeroBet = !0 : t.type === v.APIBetType.FREE_BET ? L.isFreeBet = !0 : (L.isFreeBet = !1, L.isZeroBet = !1, !L.getButtonConfigByBtnId(d.PromoPanelButtonIDs.NOLIMIT_BONUS).isDisabled && n.NolimitApplication.events.trigger(c.PromoPanelEvents.ENABLE_NAV_BUTTON, d.PromoPanelButtonIDs.NOLIMIT_BONUS))
					}
					static getDefaultButtonConfig() {
						let t = p.PromoPanelConfig.FEATURE_BTN_CONFIG[0];
						for (let e = 0; e < p.PromoPanelConfig.FEATURE_BTN_CONFIG.length; e++) {
							const i = p.PromoPanelConfig.FEATURE_BTN_CONFIG[e];
							if (!i.isDisabled && i.isDefault) {
								t = i;
								break
							}
						}
						return t
					}
					static getButtonConfigByBtnId(t) {
						let e = p.PromoPanelConfig.FEATURE_BTN_CONFIG[0];
						for (let i = 0; i < p.PromoPanelConfig.FEATURE_BTN_CONFIG.length; i++) {
							const n = p.PromoPanelConfig.FEATURE_BTN_CONFIG[i];
							if (n.id == t) {
								e = n;
								break
							}
						}
						return e
					}
					static deleteButtonConfigByBtnId(t) {
						for (let e = 0; e < p.PromoPanelConfig.FEATURE_BTN_CONFIG.length; e++)
							if (p.PromoPanelConfig.FEATURE_BTN_CONFIG[e].id == t) {
								p.PromoPanelConfig.FEATURE_BTN_CONFIG.splice(e, 1);
								break
							}
					}
					static customizeFeature(t, e, i, n = !1, s = !1) {
						if (n && s) this.deleteButtonConfigByBtnId(t);
						else {
							let o = L.getButtonConfigByBtnId(t);
							o.isDefault = e, o.isDisabled = i, o.shouldHide = n, o.shouldReAligned = s
						}
					}
					static saveToLocalStorage(t, e) {
						L.apiPlugIn.settings.set(t, e)
					}
					static getFromLocalStorage(t, e) {
						return L.apiPlugIn.settings.get(t, e)
					}
					init() {
						return new Promise((t => {
							L.fetchPlugins().catch((t => Promise.reject(t))), this.loadResourcePromise = this.loadGameResources(), this._bonusBuyFeatureTypes = L.apiPlugIn.bonusFeatures.allTypesByCategory[A.GameFeatureCategory.BONUS_BUY], t(this)
						}))
					}
					addAssetsToLoader(t, e) {
						for (let i of e) t.add(i.name, i.url)
					}
					getReady() {
						if (!this.hasPromotions()) return Promise.resolve(this);
						const t = new g.FontLoader(n.NolimitApplication.resourcePath);
						return t.add(S.OpenSans.NORMAL_300), t.add(S.OpenSans.NORMAL_400), t.add(S.OpenSans.ITALIC_600), t.add(S.OpenSans.NORMAL_600), t.add(S.OpenSans.NORMAL_700), t.add(S.OpenSans.NORMAL_800), t.add(S.OpenSans.ITALIC_800), L.imgLoader = new T.ImgLoader(n.NolimitApplication.resourcePath), this.addAssetsToLoader(L.imgLoader, l.PromoPanelAssetConfig.getNavigationAssets()), this.hasActionSpin() && (this.addAssetsToLoader(L.imgLoader, l.PromoPanelAssetConfig.getNolimitBonusAssets()), this.addAssetsToLoader(L.imgLoader, l.PromoPanelAssetConfig.getActionSpinsAssets()), this.addAssetsToLoader(L.imgLoader, l.PromoPanelAssetConfig.getActionSpinsGameFeedAssets())), this.hasNolimitWinners() && this.addAssetsToLoader(L.imgLoader, l.PromoPanelAssetConfig.getNolimitWinnersAssets()), Promise.all([L.imgLoader.load(), t.load()]).then((() => this.loadComplete()))
					}
					getReadyToStart() {
						return this.hasPromotions() ? this.loadResourcePromise.then((() => (this.hasNolimitWinners() || L.customizeFeature(d.PromoPanelButtonIDs.NOLIMIT_WINNERS, !1, !0, !1), this.hasActionSpin() || L.customizeFeature(d.PromoPanelButtonIDs.ACTION_SPINS, !1, !0, !0, !0), this.initializeFeatureController(), Promise.resolve(this)))) : Promise.resolve(this)
					}
					start() {
						return Promise.resolve(this)
					}
					getKeypadGuide() {
						const t = new E.TemplateLoader(L.apiPlugIn.resources.getStaticRoot());
						t.add({
							name: "gui-guide",
							url: "node_modules/@nolimitcity/promo-panel/resources/default/templates/gui-guide.mustache"
						});
						const e = {
							hasNolimitBonus: !1,
							hasNolimitWinners: this.hasNolimitWinners(),
							hasActionSpin: this.hasActionSpin(),
							hasNolimitTournaments: this.hasNolimitTournaments(),
							hasNolimitVoucher: this.hasNolimitVoucher(),
							location: ".." + l.PromoPanelAssetConfig.getGameResourcePath()
						};
						return t.load().then((t => {
							for (let i of t)
								if ("gui-guide" == i.name && i.loadedData) return L.apiPlugIn.translations.render(i.loadedData, e);
							throw new Error("NolimitPromotionPlugin could not load gui-guide")
						}))
					}
					getIntroPages() {
						if (L.apiPlugIn.isReplay) return Promise.resolve([]);
						const t = new b.IntroPageCreator;
						return this.loadResourcePromise.then((() => t.getIntroPages(this)))
					}
					open() {
						this.setSavedSettings(), L.isFreeBet = L.apiPlugIn.freeBets.hasFreeBets(), w.ResponseParser.setBoostAndGetCost(void 0, !0), this._view.open(), this.buttonClick(new a.GuiButton(L.getDefaultButtonConfig().id), !0), L.apiPlugIn.events.trigger(c.PromoPanelEvents.PROMO_PANEL_OPENED)
					}
					minimize() {
						L.IS_MINIMIZED = !0, n.NolimitApplication.minimizeDialog(this.view), this.view.visible = !1, n.NolimitApplication.apiPlugin.events.trigger(h.APIEvent.ACTION_SPINS_IS_ACTIVE, !1), n.NolimitApplication.apiPlugin.events.trigger(c.PromoPanelEvents.PROMO_PANEL_MINIMIZED)
					}
					maximize() {
						this.view.visible = !0, n.NolimitApplication.addDialog(this.view, !0), L.IS_MINIMIZED = !1, n.NolimitApplication.apiPlugin.events.trigger(h.APIEvent.ACTION_SPINS_IS_ACTIVE, !0), n.NolimitApplication.apiPlugin.events.trigger(c.PromoPanelEvents.PROMO_PANEL_MAXIMIZED)
					}
					close(t = !1, e = !1) {
						this._view.close(e)
					}
					hasPromotions() {
						const t = this.hasNolimitWinners(),
							e = this.hasNolimitTournaments(),
							i = this.hasNolimitVoucher(),
							n = this.hasActionSpin(),
							s = L.apiPlugIn.options.replay;
						return (t || e || i || n) && !s
					}
					hasNolimitBonus() {
						return !1
					}
					hasActionSpinsBonus() {
						const t = L.apiPlugIn.bonusFeatures.hasAnyType(this._bonusBuyFeatureTypes),
							e = L.apiPlugIn.gameClientConfiguration.featureBuyEnabled;
						return t && e
					}
					hasNolimitWinners() {
						return L.apiPlugIn.gameClientConfiguration.nolimitWinnersEnabled
					}
					hasActionSpin() {
						var t;
						return 1 == (!L.apiPlugIn.options.funMode && L.apiPlugIn.gameClientConfiguration.actionSpin && (null === (t = L.ASOptionsData) || void 0 === t ? void 0 : t.hasActionSpin))
					}
					hasNolimitTournaments() {
						return !1
					}
					hasNolimitVoucher() {
						return !1
					}
					onRefresh() {
						n.NolimitApplication.events.trigger(c.PromoPanelEvents.BALANCE_UPDATE_EVENT, L.apiPlugIn.balance.getAmount())
					}
					buttonClick(t, e = !1) {
						switch (!e && L.sound.playKeypadEffect("click"), t.name) {
							case d.PromoPanelButtonIDs.NOLIMIT_BONUS:
							case d.PromoPanelButtonIDs.NOLIMIT_WINNERS:
							case d.PromoPanelButtonIDs.ACTION_SPINS:
							case d.PromoPanelButtonIDs.VOUCHER:
								const e = this._featureControllerMap.get(t.name);
								e && this.initializeFeatureView(e, t.name), n.NolimitApplication.events.trigger(c.PromoPanelEvents.DISABLE_ALL_NAV_BUTTON), n.NolimitApplication.events.trigger(c.PromoPanelEvents.NAV_BUTTON_PRESSED, t.name), this._view.backgroundColor = L.getButtonConfigByBtnId(t.name).viewBackgroundColor;
								break;
							case d.PromoPanelButtonIDs.CLOSE:
								this.close();
								break;
							default:
								y.Logger.warn("button click :: no match case : ", t)
						}
					}
					setSavedSettings() {
						L.savedSettings = {
							asStopOnBonus: !!L.apiPlugIn.settings.get(I.LocalStorageSettingsKey.AS_STOP_ON_BONUS),
							asBonusTabSelected: !!L.apiPlugIn.settings.get(I.LocalStorageSettingsKey.AS_BONUS_TAB_SELECTED)
						}
					}
					closeAllView() {
						var t, e;
						null === (e = null === (t = this._featureControllerMap.get(d.PromoPanelButtonIDs.ACTION_SPINS)) || void 0 === t ? void 0 : t.view) || void 0 === e || e.close(), this.close()
					}
					loadGameResources() {
						var t, e;
						const i = new T.ImgLoader(n.NolimitApplication.resourcePath);
						if (this.addAssetsToLoader(i, l.PromoPanelAssetConfig.getCommonAssets()), L.ASOptionsData) {
							let n = [];
							null === (t = L.ASOptionsData.mainGame) || void 0 === t || t.options.forEach((t => {
								n.indexOf(t.image) < 0 && (i.add(t.image, l.PromoPanelAssetConfig.getGameResourcePathForActionSpins() + t.image), n.push(t.image))
							})), null === (e = L.ASOptionsData.bonusGame) || void 0 === e || e.options.forEach((t => {
								n.indexOf(t.image) < 0 && (i.add(t.image, l.PromoPanelAssetConfig.getGameResourcePathForActionSpins() + t.image), n.push(t.image))
							}))
						}
						return L.apiPlugIn.getInitData().then((() => {
							var t, e;
							return this.hasActionSpin() && ((null === (e = null === (t = L.ASOptionsData) || void 0 === t ? void 0 : t.graphics) || void 0 === e ? void 0 : e.backgroundTextureName) || i.add("AS_REPLAY_BG", l.PromoPanelAssetConfig.getGameResourcePathForActionSpins() + "REPLAY_BG" + p.PromoPanelConfig.JPG_FORMAT), i.add("AS_GAME_LOGO", l.PromoPanelAssetConfig.getGameResourcePathForActionSpins() + "GAME_LOGO" + this.GAME_FEATURE_ASSETS_FORMAT), i.add("ActionSpinAnimation0", "/node_modules/@nolimitcity/promo-panel/resources/default/animation/Actionspin0.json")), i.load()
						}))
					}
					initializeFeatureController() {
						p.PromoPanelConfig.FEATURE_BTN_CONFIG.forEach((t => {
							switch (t.id) {
								case d.PromoPanelButtonIDs.NOLIMIT_WINNERS:
									t.isDisabled || this._featureControllerMap.set(t.id, new m.ReplayController(this));
									break;
								case d.PromoPanelButtonIDs.ACTION_SPINS:
									t.isDisabled || this._featureControllerMap.set(t.id, new P.ActionSpinsController(this));
								case d.PromoPanelButtonIDs.VOUCHER:
							}
						}))
					}
					loadComplete() {
						return this._view = new r.PromoPanelView(this), this.hide(), this.addEventListeners(), Promise.resolve(this)
					}
					initializeFeatureView(t, e) {
						if (!t.view) {
							const i = {
									color: 16777215,
									thickness: 3
								},
								n = new _.GUIScrollContainer(0, 0, !1, !0, !0, i);
							n.name = e.toUpperCase() + "_GUIScrollContainer", t.createView(n), n.addContent(t.view), this._view.featureContainer.addChild(n)
						}
					}
					addEventListeners() {
						L.apiPlugIn.events.on(h.APIEvent.REFRESH, (() => this.onRefresh())), L.apiPlugIn.events.on(h.APIEvent.BET, (t => L.onBet(t))), n.NolimitApplication.apiPlugin.events.on(h.APIEvent.BROKE, (() => this.closeAllView()))
					}
					hide() {
						this._view.hide()
					}
					get isActionSpinRound() {
						return this._isActionSpinRound
					}
					set isActionSpinRound(t) {
						this._isActionSpinRound = t
					}
					get view() {
						return this._view
					}
				}
				L.isZeroBet = !1, L.isFreeBet = !1, L.IS_MINIMIZED = !1, e.NolimitPromotionPlugin = L
			},
			64763: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PromoPanelView = void 0;
				const n = i(37950),
					s = i(72468),
					o = i(68714),
					r = i(66515),
					a = i(2425),
					l = i(46980),
					h = i(85136),
					u = i(56254),
					c = i(13006),
					d = i(59361),
					p = i(50799),
					_ = i(77549),
					m = i(56401),
					g = i(63288),
					f = i(39055),
					S = i(19803),
					y = i(61e3),
					v = i(2996);
				class T extends PIXI.Container {
					get popUpView() {
						return this._popUpView
					}
					constructor(t) {
						super(), this._backgroundColor = PIXI.utils.string2hex("#ee2552"), this._isBlurred = !1, this._isLandscape = s.NolimitApplication.isLandscape, this.name = "PromoPanelView", this._controller = t, this.addEventListener()
					}
					drawBackground() {
						this._background.tint = this.backgroundColor, this._background.width = s.NolimitApplication.screenBounds.width, this._background.height = s.NolimitApplication.screenBounds.height - a.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight()
					}
					close(t = !1) {
						this._isOpen && (s.NolimitApplication.removeDialog(this, !t), this._isOpen = !1, this.interactive = !1, this.interactiveChildren = !1, s.NolimitApplication.events.trigger(_.PromoPanelEvents.TOGGLE_BUTTONS_ON_LIGHTING_SPINS, !0), s.NolimitApplication.apiPlugin.events.trigger(_.PromoPanelEvents.PROMO_PANEL_CLOSED))
					}
					open() {
						this._init || (this.init(), this._init = !0), this._isOpen = !0, this.interactive = !0, this.interactiveChildren = !0, this.onResize(), this.show(), s.NolimitApplication.addDialog(this, !0)
					}
					shouldResize() {
						return this._init && this._isOpen
					}
					onResize() {
						if (this.shouldResize()) {
							this.popUpView.isOpen && this.popUpView.resize();
							const t = (0, n.cloneScreenBounds)(s.NolimitApplication.screenBounds);
							this.position.set(t.left, t.top), t.height -= a.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight(), this.drawBackground();
							const e = 59;
							this._closeButton.position.set(t.width - this._closeButton.width - 5, e - this._closeButton.height / 2), this._closeBtnXmark.position.set(this._closeButton.x + .5 * this._closeButton.width, this._closeButton.y + .5 * this._closeButton.height - 4), this._logo.position.set(t.width / 2 - 230, e), this._label.position.set(t.width / 2 - 10, e), this._promoLabel.position.set(t.width / 2 - 8, e);
							let i = .5 * t.width;
							const o = this._label.width + this._promoLabel.width + this._logo.width + 14;
							if (this._logo.position.set(i - .5 * o, e + 3), this._label.position.set(this._logo.x + this._logo.width + 14, e), this._promoLabel.position.set(this._label.x + this._label.width, e), this._topBar.position.set(t.width / 2, -5), this._navigationPanel.onResize(), this._closeButton.alpha = 1, s.NolimitApplication.isLandscape) {
								this._topBar.visible = !1, this._logo.visible = !1, this._label.visible = !1, this._content.visible = !1, this._closeBtnXmark.visible = !0;
								const e = 45 + .5 * this._closeBtnXmark.height - 6;
								this._closeBtnXmark.position.set(t.width - e - 28, e + 21), this._closeButton.position.set(this._closeBtnXmark.x - .5 * this._closeButton.width, this._closeBtnXmark.y - .5 * this._closeButton.height + 5), this._hBottomLine.visible = !0, this._hBottomLine.position.set(0, t.height - 1)
							} else this._hBottomLine.visible = !1, this._closeButton.alpha = 0, this._topBar.visible = !0, this._logo.visible = !0, this._label.visible = !0, this._content.visible = !0;
							this._popupDarkOverlay.visible && this.drawPopupDarkOverlay()
						}
						s.NolimitApplication.events.trigger(_.PromoPanelEvents.ON_RESIZE), this._isLandscape != s.NolimitApplication.isLandscape && (this.onOrientationChanged(), this._isLandscape = s.NolimitApplication.isLandscape)
					}
					addBlur() {
						this._isBlurred = !0, null == this._featureContainer.filters && (this._featureContainer.filters = []), this._featureContainer.filters.push(this._blur1, this._blur2);
						const t = new c.TimelineLite;
						return t.add([new c.TweenLite(this._blur1, .2, {
							blurX: 16,
							blurY: 16
						}), new c.TweenLite(this._blur2, .2, {
							blurX: 10,
							blurY: 10
						})]), t
					}
					removeBlur() {
						if (this._isBlurred) {
							const t = new c.TimelineLite({
								onComplete: () => {
									for (let t = this._featureContainer.filters.length - 1; t >= 0; t--) {
										const e = this._featureContainer.filters[t];
										e != this._blur1 && e != this._blur2 || this._featureContainer.filters.splice(t, 1)
									}
									this._isBlurred = !1
								}
							});
							return t.add([new c.TweenLite(this._blur1, .2, {
								blurX: 0,
								blurY: 0
							}), new c.TweenLite(this._blur2, .2, {
								blurX: 0,
								blurY: 0
							})]), t
						}
					}
					onOrientationChanged() {
						s.NolimitApplication.events.trigger(_.PromoPanelEvents.ON_ORIENTATION_CHANGED)
					}
					show(t) {
						const e = new c.TimelineLite;
						return t ? (this.visible = !0, e.add(new c.TweenLite(this, t, {
							alpha: 1,
							ease: c.Linear.easeNone
						})), e.add((() => {
							this.alpha = 1
						}))) : e.add((() => {
							this.alpha = 1, this.visible = !0
						})), e
					}
					hide(t) {
						const e = new c.TimelineLite;
						return t ? (e.add(new c.TweenLite(this, t, {
							alpha: 0,
							ease: c.Linear.easeNone
						})), e.add((() => {
							this.visible = !1
						}))) : e.add((() => {
							this.alpha = 0, this.visible = !1
						})), e
					}
					createFeatureBtnPanel() {
						this._navigationPanel = new d.NavigationPanelView(this._controller), this._promoContainer.addChild(this._navigationPanel)
					}
					createPopUpView() {
						this._popUpView = new v.ConfirmBetPopUpView, this.addChild(this._popUpView)
					}
					createBottomWhiteLine() {
						const t = s.NolimitApplication.screenBounds;
						this._hBottomLine = new PIXI.Graphics, this._hBottomLine.name = "H_BOTTOM_LINE", this._hBottomLine.lineStyle(2, 16777215).moveTo(0, 0).lineTo(Math.max(t.width, t.height), 0), this._promoContainer.addChild(this._hBottomLine)
					}
					addEventListener() {
						s.NolimitApplication.events.on(_.PromoPanelEvents.SHOW_HIDE_CLOSE_BUTTON, (t => this.showHideCloseBtn(t))), s.NolimitApplication.events.on(_.PromoPanelEvents.ON_POPUP_OPEN, (() => this.onPopUpOpen())), s.NolimitApplication.events.on(_.PromoPanelEvents.ON_POPUP_CLOSE, (() => this.onPopUpClose())), s.NolimitApplication.events.on(_.PromoPanelEvents.TOGGLE_BUTTONS_ON_LIGHTING_SPINS, (t => this._closeButton.enable(t)))
					}
					showHideCloseBtn(t) {
						this._closeBtnXmark.visible = t, this._closeButton.visible = t
					}
					onPopUpOpen() {
						this.drawPopupDarkOverlay(), this.addBlur(), this._featureContainer.interactive = !1, this._featureContainer.interactiveChildren = !1, this._navigationPanel.interactive = !1, this._navigationPanel.interactiveChildren = !1
					}
					removePopupDarkOverlay() {
						this._popupDarkOverlay.clear(), this._popupDarkOverlay.visible = !1, this._featureContainer.interactive = !0, this._featureContainer.interactiveChildren = !0, this._navigationPanel.interactive = !0, this._navigationPanel.interactiveChildren = !0
					}
					onPopUpClose() {
						this.removeBlur(), this._popupDarkOverlay.visible && this.removePopupDarkOverlay()
					}
					init() {
						this._promoContainer = new PIXI.Container, this._promoContainer.name = "PROMO_CONTAINER", this.addChild(this._promoContainer), this.createBlurFilters(), this._background = new PIXI.Sprite(PIXI.Texture.WHITE), this._background.name = "PROMO_BACKGROUND", this._content = new PIXI.Container, this._content.name = "PROMO_PANEL_VIEW_HEADING", this._featureContainer = new PIXI.Container, this._featureContainer.name = "MASTER_FEATURE_CONTAINER", this._label = new o.Label(a.NolimitPromotionPlugin.apiPlugIn.translations.translate(m.PromoPanelLabelIDs.PROMO_PANEL_HEADING + S.PromoPanelConfig.SINGLE_BLANK_SPACE), g.PromoPanelTextStyles.PROMO_PANEL_HEADING), this._label.anchor.set(0, .5), this._promoLabel = new o.Label(a.NolimitPromotionPlugin.apiPlugIn.translations.translate(m.PromoPanelLabelIDs.PROMO_PANEL_PROMOTIONS_HEADING), g.PromoPanelTextStyles.PROMO_PANEL_PROMOTIONS_HEADING), this._promoLabel.anchor.set(0, .5);
						const t = new l.PointerStateIconSet(new h.Icon(y.ImgLoader.getImgTexture(p.PromoPanelAssetConfig.CLOSE_BG_ICON))),
							e = new u.PointerStateColorSet(4294967295);
						this._closeButton = new r.IconToggleButton(f.PromoPanelButtonIDs.CLOSE, t, e), this._closeButton.addClickCallback((() => this._controller.buttonClick(this._closeButton))), this._closeButton.toggled = !1, this._closeButton.enable(!0), this._closeBtnXmark = new PIXI.Sprite(y.ImgLoader.getImgTexture(p.PromoPanelAssetConfig.CLOSE)), this._closeBtnXmark.tint = 0, this._closeBtnXmark.anchor.set(.5, .5), this._closeBtnXmark.pivot.y = -3, this._logo = new PIXI.Sprite(y.ImgLoader.getImgTexture(p.PromoPanelAssetConfig.NOLIMIT_PROMOTIONS_LOGO)), this._logo.anchor.set(0, .5), this._logo.pivot.y = 4, this._topBar = new PIXI.Sprite(y.ImgLoader.getImgTexture(p.PromoPanelAssetConfig.TOP_BAR)), this._topBar.width = 720, this._topBar.anchor.set(.5, 0), this._content.addChild(this._topBar, this._logo, this._promoLabel, this._label), this._promoContainer.addChild(this._background), this._popupDarkOverlay = new PIXI.Graphics, this._popupDarkOverlay.visible = !1, this._popupDarkOverlay.alpha = .4, this._promoContainer.addChild(this._featureContainer), this._promoContainer.addChild(this._popupDarkOverlay), this._promoContainer.addChild(this._content), this._promoContainer.addChild(this._closeButton, this._closeBtnXmark), this.createBottomWhiteLine(), this.createFeatureBtnPanel(), this.createPopUpView()
					}
					drawPopupDarkOverlay() {
						const t = s.NolimitApplication.screenBounds;
						this._popupDarkOverlay.clear(), this._popupDarkOverlay.beginFill(0), s.NolimitApplication.isLandscape ? this._popupDarkOverlay.drawRect(0, 0, t.width, t.height) : this._popupDarkOverlay.drawRect(0, 0, t.width, t.height - a.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight()), this._popupDarkOverlay.endFill(), this._popupDarkOverlay.visible = !0
					}
					createBlurFilters() {
						this._blur1 = new PIXI.filters.BlurFilter(0, 6), this._blur1.autoFit = !0, this._blur1.repeatEdgePixels = !1, this._blur2 = new PIXI.filters.BlurFilter(0, 6), this._blur2.autoFit = !0, this._blur2.repeatEdgePixels = !1
					}
					get backgroundColor() {
						return this._backgroundColor
					}
					set backgroundColor(t) {
						this._backgroundColor = t, this.drawBackground()
					}
					get featureContainer() {
						return this._featureContainer
					}
					set featureContainer(t) {
						this._featureContainer = t
					}
					get isOpen() {
						return this._isOpen
					}
				}
				e.PromoPanelView = T
			},
			59361: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NavigationPanelView = void 0;
				const n = i(2425),
					s = i(72468),
					o = i(34818),
					r = i(19803),
					a = i(50799),
					l = i(61e3);
				class h extends PIXI.Container {
					constructor(t) {
						super(), this._buttons = [], this._panelButton = [], this._controller = t, this._buttons = r.PromoPanelConfig.FEATURE_BTN_CONFIG, this.initAnimations()
					}
					initAnimations() {
						this._bgLandscape = new PIXI.Sprite(l.ImgLoader.getImgTexture(a.PromoPanelAssetConfig.NAV_BG_LANDSCAPE)), this._bgLandscape.height = 684, this._bgPortrait = new PIXI.Sprite(l.ImgLoader.getImgTexture(a.PromoPanelAssetConfig.NAV_BG_PORTRAIT)), this._bgPortrait.width = 720, this._bgLandscape.anchor.set(.5), this._bgPortrait.anchor.set(.5), this.addChild(this._bgLandscape), this.addChild(this._bgPortrait), this._buttons.forEach(((t, e) => {
							const i = new o.PanelButton(t, this._controller, e);
							this.addChild(i), this._panelButton.push(i)
						}))
					}
					onResize() {
						const t = s.NolimitApplication.screenBounds;
						this.getLocalBounds(), this._bgLandscape.visible = !1, this._bgPortrait.visible = !1, s.NolimitApplication.isLandscape ? (this._bgLandscape.visible = !0, this._bgLandscape.position.set(Math.floor(.5 * this._bgLandscape.width), Math.floor(.5 * this._bgLandscape.height)), this._panelButton.forEach((t => t.onResize(this._bgLandscape.position)))) : (this._bgPortrait.position.set(.5 * t.width, t.height - .5 * this._bgPortrait.height - n.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight()), this._bgPortrait.visible = !0, this.rotation = 0, this._panelButton.forEach((t => t.onResize(this._bgPortrait.position))))
					}
					show() {
						this.visible = !0
					}
					hide() {
						this.visible = !1
					}
				}
				e.NavigationPanelView = h
			},
			34818: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PanelButton = void 0;
				const n = i(66515),
					s = i(2425),
					o = i(56254),
					r = i(46980),
					a = i(85136),
					l = i(50799),
					h = i(72468),
					u = i(77549),
					c = i(39055),
					d = i(19803),
					p = i(46334),
					_ = i(61e3);
				class m extends PIXI.Container {
					constructor(t, e, i) {
						super(), this._active = !1, this.INACTIVE_COLOUR = 16777215, this._controller = e, this._index = i, this._buttonConfig = t, this._btnId = t.id, this.name = this._btnId + "_CONTAINER", this.init(), this.addEventListener()
					}
					addEventListener() {
						h.NolimitApplication.events.on(u.PromoPanelEvents.DISABLE_ALL_NAV_BUTTON, (() => this.setInActive())), h.NolimitApplication.events.on(u.PromoPanelEvents.NAV_BUTTON_PRESSED, (t => this.setActive(t))), h.NolimitApplication.events.on(u.PromoPanelEvents.DISABLE_NAV_BUTTON, (t => this.disable(t))), h.NolimitApplication.events.on(u.PromoPanelEvents.ENABLE_NAV_BUTTON, (t => this.enable(t))), h.NolimitApplication.events.on(u.PromoPanelEvents.HIDE_NAV_BUTTON, (t => this.hide(t))), h.NolimitApplication.events.on(u.PromoPanelEvents.SHOW_NAV_BUTTON, (t => this.show(t))), h.NolimitApplication.events.on(u.PromoPanelEvents.TOGGLE_BUTTONS_ON_LIGHTING_SPINS, (t => this.toggleButton(t)))
					}
					toggleButton(t) {
						this._btn.enable(!this._buttonConfig.isDisabled && t)
					}
					hide(t) {
						t == this._btnId && (this.alpha = 0)
					}
					show(t) {
						t == this._btnId && (this.alpha = 1)
					}
					setInActive() {
						this.active = !1
					}
					setActive(t) {
						this.active = this._btnId == t
					}
					disable(t) {
						t ? t == this._btnId && this.disable() : (this._btn.enable(!1), this._btn.alpha = d.PromoPanelConfig.DISABLE_BTN_ALPHA)
					}
					enable(t) {
						t ? t == this._btnId && this.enable() : (this._btn.enable(!0), this._btn.alpha = d.PromoPanelConfig.ENABLE_BTN_ALPHA)
					}
					enableButton(t) {
						this.active = this._btnId == t
					}
					createButton() {
						const t = new o.PointerStateColorSet(4294967295);
						let e;
						switch (this._btnId) {
							case c.PromoPanelButtonIDs.NOLIMIT_BONUS:
								e = new r.PointerStateIconSet(new a.Icon(_.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.NAV_NOLIMIT_BONUS)));
								break;
							case c.PromoPanelButtonIDs.NOLIMIT_WINNERS:
								e = new r.PointerStateIconSet(new a.Icon(_.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.NAV_NOLIMIT_WINNERS)), void 0, void 0, new a.Icon(_.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.NAV_NOLIMIT_WINNERS_DISABLED)));
								break;
							case c.PromoPanelButtonIDs.ACTION_SPINS:
								e = new r.PointerStateIconSet(new a.Icon(_.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.NAV_ACTION_SPINS)));
								break;
							case c.PromoPanelButtonIDs.VOUCHER:
								e = new r.PointerStateIconSet(new a.Icon(_.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.NAV_VOUCHER_DISABLED)));
								break;
							default:
								e = new r.PointerStateIconSet, p.Logger.warn("Btn id not available")
						}
						this._btn = new n.IconToggleButton(this._btnId, e, t), this._btn.addClickCallback((() => this._controller.buttonClick(this._btn))), this._buttonConfig.isDisabled ? this.disable() : this.enable(), this._buttonConfig.shouldHide && this.hide(this._btnId), this.addChild(this._btn), this.position.set(this.width / 2, this.height / 2), this.pivot.set(this.width / 2, this.height / 2)
					}
					createHighlightLine() {
						this._activeHighlightLine = new PIXI.Sprite(s.NolimitPromotionPlugin.imgLoader.getImgTexture(l.PromoPanelAssetConfig.NAV_ACTIVE)), this._activeHighlightLine.tint = this.INACTIVE_COLOUR, this._activeHighlightLine.anchor.set(.5, .5), this.addChild(this._activeHighlightLine), this._activeHighlightLine.position.set(this.x, this.y)
					}
					init() {
						this.createButton(), this.createHighlightLine(), this.pivot.set(this.width / 2, this.height / 2)
					}
					onResize(t) {
						const e = h.NolimitApplication.screenBounds,
							i = _.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.NAV_NOLIMIT_BONUS).width;
						let n = .2 * (e.width - 4 * i);
						h.NolimitApplication.isLandscape ? (n = .2 * (e.height - s.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - 4 * i), this.position.set(t.x, (n + i / 2) * (this._index + 1) + i / 2 * this._index)) : (this.rotation = 0, this.position.set((n + i / 2) * (this._index + 1) + i / 2 * this._index, t.y + 20))
					}
					get active() {
						return this._active
					}
					set active(t) {
						this._activeHighlightLine.tint = t ? this._buttonConfig.viewBackgroundColor : this.INACTIVE_COLOUR, this._activeHighlightLine.visible = t, this._active = t
					}
				}
				e.PanelButton = m
			},
			10386: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Communication = void 0;
				const n = i(64294),
					s = i(70660),
					o = i(2425),
					r = i(19803),
					a = i(49490);
				e.Communication = class {
					constructor(t) {
						this._replayBaseUrl = n.ReplayURLConfig.BASE_URL_DEFAULT, t.events.once(a.APIEvent.REPLAY_BASE_URL, (t => {
							this._replayBaseUrl = t
						}))
					}
					getTopXBetData(t) {
						return this.connect(this.getBaseURL() + n.ReplayURLConfig.TOP_X_BET_URL + this.getOperatorURL(t))
					}
					getTopMonetaryData(t) {
						return this.connect(this.getBaseURL() + n.ReplayURLConfig.TOP_MONETARY_URL + this.getOperatorURL(t))
					}
					getXBetGameSpecificData(t, e) {
						return this.connect(this.getBaseURL() + n.ReplayURLConfig.TOP_X_BET_URL + this.getOperatorURL(e) + n.ReplayURLConfig.GAME_SPECIFIC_URL + t)
					}
					getMonetaryGameSpecificData(t, e) {
						return this.connect(this.getBaseURL() + n.ReplayURLConfig.TOP_MONETARY_URL + this.getOperatorURL(e) + n.ReplayURLConfig.GAME_SPECIFIC_URL + t)
					}
					getTopListAnyGame(t) {
						return o.NolimitPromotionPlugin.apiPlugIn.communication.history.topListAnyGame(t)
					}
					getTopListCurrentGame(t) {
						return o.NolimitPromotionPlugin.apiPlugIn.communication.history.topListCurrentGame(t)
					}
					createXMLHttpRequest(t) {
						const e = new XMLHttpRequest;
						return e.open(s.RequestMethod.GET, t, !0), e.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8"), e.setRequestHeader("Accept", "application/json"), e
					}
					connect(t) {
						return new Promise(((e, i) => {
							const n = this.createXMLHttpRequest(t);
							n.onload = () => {
								const t = JSON.parse(n.responseText);
								t.error ? i(t.error) : Object.keys(t).length ? e(t) : i(n.responseText)
							}, n.send()
						}))
					}
					getOperatorURL(t) {
						return t ? n.ReplayURLConfig.OPERATOR_SPECIFIC_URL + t : r.PromoPanelConfig.EMPTY_STRING
					}
					getBaseURL() {
						return this._replayBaseUrl + n.ReplayURLConfig.BASE_PATH
					}
				}
			},
			83167: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BetDisplay = void 0;
				const n = i(68714),
					s = i(63288),
					o = i(91746);
				class r extends PIXI.Container {
					constructor(t, e, i = "") {
						super();
						const r = new PIXI.Container,
							a = new n.Label(t, s.PromoPanelTextStyles.BET_PANEL_BET_LABEL);
						if (r.addChild(a), e && "" != e) {
							const t = new n.Label(e, s.PromoPanelTextStyles.BET_PANEL_CURRENCY_LABEL);
							t.position.set(a.width, 0), r.addChild(t)
						}
						r.pivot.set(.5 * r.width, 0), this._valueLabel = new o.PromoPanelTextLabel(i, s.PromoPanelTextStyles.BET_PANEL_BET_STYLE, {
							landscapeMaxWidth: 268,
							portraitMaxWidth: 268
						}), this._valueLabel.anchor.set(.5, 0), this._valueLabel.position.set(0, a.height), this.addChild(r), this.addChild(this._valueLabel)
					}
					setValue(t) {
						this._valueLabel.value = t
					}
					resize() {
						this._valueLabel.onResize()
					}
				}
				e.BetDisplay = r
			},
			73010: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BetPanelView = void 0;
				const n = i(72468),
					s = i(2425),
					o = i(50799),
					r = i(56401),
					a = i(61e3),
					l = i(83167),
					h = i(91838),
					u = i(11499);
				class c extends PIXI.Container {
					constructor(t, e, i, s) {
						super(), this._formatValueAsCurrency = !0, this._betBackground = new PIXI.NineSlicePlane(a.ImgLoader.getImgTexture(o.PromoPanelAssetConfig.BET_PANEL_BG), 16, 16, 16, 16), this._betBackground.tint = s, this._betBackground.alpha = .8, this._betDisplay = this.createBetDisplay(), this._betSelector = this.createBetSelector(t, e, i), this.addChild(this._betBackground), this.addChild(this._betDisplay, this._betSelector), this.resize(n.NolimitApplication.isLandscape)
					}
					get betDisplay() {
						return this._betDisplay
					}
					get betSelector() {
						return this._betSelector
					}
					setBackgroundAlpha(t) {
						this._betBackground.alpha = t
					}
					resize(t) {
						t ? (this.setBackgroundSize(280, 264), this._betDisplay.position.set(.5 * this._betBackground.width, 34), this._betSelector.position.set(.5 * this._betBackground.width, 188)) : (this.setBackgroundSize(633, 153), this._betDisplay.position.set(.5 * this._betBackground.width - 170, 31), this._betSelector.position.set(.5 * this._betBackground.width + 170, 77)), this._betDisplay.resize()
					}
					setValue(t) {
						this._value = t, this._formatValueAsCurrency ? this._betDisplay.setValue(u.CurrencyUtils.formatWithDecimalCutOff(this._value)) : this._betDisplay.setValue("" + t)
					}
					getValue() {
						return this._value
					}
					setBackgroundSize(t, e) {
						this._betBackground.width = t, this._betBackground.height = e
					}
					createBetDisplay() {
						return new l.BetDisplay(s.NolimitPromotionPlugin.apiPlugIn.translations.translate(r.PromoPanelLabelIDs.BET))
					}
					createBetSelector(t, e, i) {
						return new h.PlusMinusWidget(t, e, i)
					}
				}
				e.BetPanelView = c
			},
			91838: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PlusMinusWidget = void 0;
				const n = i(56254),
					s = i(46980),
					o = i(85136),
					r = i(50799),
					a = i(66515),
					l = i(61e3),
					h = i(19803);
				class u extends PIXI.Container {
					constructor(t, e, i) {
						super();
						const h = new n.PointerStateColorSet(4294967295),
							u = new s.PointerStateIconSet(new o.Icon(l.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.BET_UP)));
						this._upButton = new a.IconToggleButton(t, u, h), this._upButton.addClickCallback((() => i(this._upButton))), this._upButton.toggled = !1, this._upButton.pivot.set(38, 35), this._upButton.position.set(62, 0);
						const c = new PIXI.Sprite(PIXI.Texture.WHITE);
						c.width = 2, c.height = 66, c.anchor.set(.5, .5), c.alpha = .5, c.roundPixels = !0;
						const d = new s.PointerStateIconSet(new o.Icon(l.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.BET_DOWN)));
						this._downButton = new a.IconToggleButton(e, d, h), this._downButton.addClickCallback((() => i(this._downButton))), this._downButton.toggled = !1, this._downButton.pivot.set(38, 35), this._downButton.position.set(-62, 0), this.addChild(this._upButton, c, this._downButton)
					}
					enableUpButton(t) {
						this._upButton.enable(t), this._upButton.alpha = t ? h.PromoPanelConfig.ENABLE_BTN_ALPHA : h.PromoPanelConfig.DISABLE_BTN_ALPHA
					}
					enableDownButton(t) {
						this._downButton.enable(t), this._downButton.alpha = t ? h.PromoPanelConfig.ENABLE_BTN_ALPHA : h.PromoPanelConfig.DISABLE_BTN_ALPHA
					}
				}
				e.PlusMinusWidget = u
			},
			50799: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PromoPanelAssetConfig = e.PromoAsset = e.PromoPanelAsset = void 0, e.PromoPanelAsset = class {
					constructor(t, e, i, s) {
						this.name = t, this.url = s || n.makeAssetPath(t), this.height = e, this.width = i
					}
				};
				class i {
					constructor(t, e) {
						this.name = t, this.url = e || n.makeAssetPath(t)
					}
				}
				e.PromoAsset = i;
				class n {
					static getIntroAssets() {
						return [new i(n.INTRO_NOLIMIT_WINNERS), new i(n.INTRO_NOLIMIT_BONUS_PRICE_TAG), new i(n.INTRO_NOLIMIT_BONUS_TICKET), new i(n.INTRO_NO_LIMIT_PROMOTIONS_TAB), new i(n.INTRO_ACTION_SPINS)]
					}
					static getNolimitBonusAssets() {
						return [new i(n.BET_DOWN), new i(n.BET_UP), new i(n.BET_PANEL_BG), new i(n.BUY_BTN), new i(n.TICKET)]
					}
					static getNavigationAssets() {
						return [new i(n.NAV_ACTIVE), new i(n.NAV_NOLIMIT_BONUS), new i(n.NAV_NOLIMIT_WINNERS), new i(n.NAV_NOLIMIT_WINNERS_DISABLED), new i(n.NAV_ACTION_SPINS), new i(n.NAV_VOUCHER_DISABLED), new i(n.CLOSE), new i(n.CLOSE_BG_ICON), new i(n.NAV_BG_LANDSCAPE), new i(n.NAV_BG_PORTRAIT), new i(n.NOLIMIT_PROMOTIONS_LOGO), new i(n.TOP_BAR)]
					}
					static getActionSpinsAssets() {
						return [new i(n.ACTION_SPINS_OPTIONS_BUTTON_MASK), new i(n.ACTION_SPINS_OPTIONS_BUTTON_ACTIVE), new i(n.ACTION_SPINS_OPTIONS_BUTTON_INACTIVE), new i(n.ACTION_SPINS_OPTIONS_BUTTON_OUTLINE), new i(n.ACTION_SPINS_OPTIONS_BUTTON_PLATE), new i(n.ACTION_SPINS_BUY_BTN), new i(n.ACTION_SPINS_GAME_CHECK_BOX_INACTIVE), new i(n.ACTION_SPINS_GAME_CHECK_BOX_ACTIVE), new i(n.ACTION_SPINS_SETTING_BTN), new i(n.ACTION_SPINS_PICK_POPUP_OPTION_ACTIVE), new i(n.ACTION_SPINS_PICK_POPUP_OPTION_IN_ACTIVE), new i(n.ACTION_SPINS_PICK_POPUP_MASK), new i(n.ACTION_SPINS_MENU_BET), new i(n.ACTION_SPINS_REPLAY_MENU_TOTAL_BET), new i(n.ACTION_SPINS_REPLAY_MENU_WIN), new i(n.ACTION_SPINS_REPLAY_MENU_PROFIT), new i(n.ACTION_SPINS_BTN_PLAY), new i(n.ACTION_SPINS_BTN_PAUSE), new i(n.ACTION_SPINS_REPLAY_FEED_BG), new i(n.ACTION_SPINS_REPLAY_BG_LANDSCAPE), new i(n.ACTION_SPINS_REPLAY_GAME_REPLAY_BTN), new i(n.ACTION_SPINS_REPLAY_GAME_REPLAY_DISABLED_BTN), new i(n.ACTION_SPINS_GAME_PLAY_BTN), new i(n.GAME_FEED_OK), new i(n.GAME_FEED_CANCEL), new i(n.ACTION_SPINS_GAME_CONTINUE), new i(n.ACTION_SPINS_GAME_CONTINUE_SMALL), new i(n.ACTION_SPINS_REPLAY_GAME_EXPAND), new i(n.ACTION_SPINS_REPLAY_INFO_BG_LANDSCAPE), new i(n.ACTION_SPINS_REPLAY_INFO_BG), new i(n.ACTION_SPINS_REPLAY_INFO_BG_SMALL), new i(n.ACTION_SPINS_SORT_ARROW_RIGHT), new i(n.ACTION_SPINS_SORT_ARROW_DOWN)]
					}
					static getActionSpinsGameFeedAssets() {
						return [new i(n.BONUS_ROUND_OUTLINE), new i(n.ACTION_SPINS_ROUNDS_NUMBER_BG), new i(n.ACTION_SPINS_PLAYED_ROUNDS_BG), new i(n.GAME_FEED_BONUS_INFO_BG), new i(n.BONUS_ROUND_BONUS_SUMMARY)]
					}
					static getCommonAssets() {
						return [new i(n.GAME_TYPE_INACTIVE), new i(n.GAME_TYPE_ACTIVE), new i(n.NOLIMIT_BONUS_ICON), new i(n.ACTION_SPINS_ICON), new i(n.BUTTON_PLATE_20), new i(n.BUTTON_STROKE_20), new i(n.NOLIMIT_WINNERS_ICON), new i(n.LOADING_CIRCLE), new i(n.POP_UP_BG)]
					}
					static getNolimitWinnersAssets() {
						return [new i(n.ALL_PLAYER_INACTIVE), new i(n.ALL_PLAYER_ACTIVE), new i(n.PLAYER_ACTIVE), new i(n.PLAYER_INACTIVE), new i(n.ROUND_INFO_BONUS_BUY_ICON), new i(n.ROUND_INFO_ACTION_SPINS_ICON), new i(n.REPLAY_BUTTON), new i(n.TROPHY_BRONZE), new i(n.TROPHY_GOLD), new i(n.TROPHY_SILVER), new i(n.INFO_BG), new i(n.REPLAY_WIN_BUTTON), new i(n.REPLAY_WIN_BUTTON_ACTIVE)]
					}
					static getIconResourcePath() {
						return "/node_modules/@nolimitcity/promo-panel/resources/default/"
					}
					static getGameResourcePath() {
						return "/nolimit/promo-panel/"
					}
					static getGameResourcePathForActionSpins() {
						return "/nolimit/promo-panel/action-spins/"
					}
					static makeAssetPath(t) {
						return n.getIconResourcePath() + "icons/" + t
					}
					static getConfigs() {
						return []
					}
				}
				n.NOLIMIT_BONUS_ICON = "nolimitBonus/nolimitBonusIcon@2x.png", n.ACTION_SPINS_ICON = "nolimitActionSpins/actionSpinsIcon@2x.png", n.NOLIMIT_WINNERS_ICON = "nolimitWinners/nolimitWinnersIcon@2x.png", n.GAME_TYPE_INACTIVE = "common/gameTypeInactive@2x.png", n.GAME_TYPE_ACTIVE = "common/gameTypeActive@2x.png", n.BUTTON_PLATE_20 = "buttonPlate20@2x.png", n.BUTTON_STROKE_20 = "buttonStroke20@2x.png", n.LOADING_CIRCLE = "loadingCircle@2x.png", n.ALL_PLAYER_INACTIVE = "nolimitWinners/allPlayerInactive@2x.png", n.POP_UP_BG = "nolimitBonus/popUpBackground@2x.png", n.INTRO_NOLIMIT_WINNERS = "introSplash/introSplashPrize@2x.png", n.INTRO_NOLIMIT_BONUS_PRICE_TAG = "introSplash/introSplashxBet@2x.png", n.INTRO_NOLIMIT_BONUS_TICKET = "introSplash/introSplashTicket@2x.png", n.INTRO_NO_LIMIT_PROMOTIONS_TAB = "introSplash/nolimitPromotionsTab@2x.png", n.INTRO_ACTION_SPINS = "introSplash/introSplashActionSpins@2x.png", n.BET_DOWN = "nolimitBonus/betDown@2x.png", n.BET_UP = "nolimitBonus/betUp@2x.png", n.BET_PANEL_BG = "nolimitBonus/betPanelBackground@2x.png", n.BUY_BTN = "nolimitBonus/buyBtn@2x.png", n.TICKET = "nolimitBonus/ticket@2x.png", n.NAV_ACTIVE = "navigation/navActive@2x.png", n.NAV_NOLIMIT_BONUS = "navigation/featureIcons/navNolimitBonus@2x.png", n.NAV_NOLIMIT_WINNERS = "navigation/featureIcons/navNolimitWinners@2x.png", n.NAV_NOLIMIT_WINNERS_DISABLED = "navigation/featureIcons/navNolimitWinnersDisabled@2x.png", n.NAV_ACTION_SPINS = "navigation/featureIcons/navActionSpins@2x.png", n.NAV_VOUCHER_DISABLED = "navigation/featureIcons/navVoucherDisabled@2x.png", n.CLOSE = "navigation/close@2x.png", n.CLOSE_BG_ICON = "navigation/closeBg@2x.png", n.NOLIMIT_PROMOTIONS_LOGO = "navigation/nolimitPromotion@2x.png", n.NAV_BG_LANDSCAPE = "navigation/navBarLandscape@2x.png", n.NAV_BG_PORTRAIT = "navigation/navBarPortrait@2x.png", n.TOP_BAR = "navigation/topBar@2x.png", n.ACTION_SPINS_BUY_BTN = "nolimitActionSpins/buyBtn@2x.png", n.ACTION_SPINS_GAME_CHECK_BOX_INACTIVE = "nolimitActionSpins/checkBoxInactive@2x.png", n.ACTION_SPINS_GAME_CHECK_BOX_ACTIVE = "nolimitActionSpins/checkBoxActive@2x.png", n.ACTION_SPINS_SETTING_BTN = "nolimitActionSpins/settings@2x.png", n.ACTION_SPINS_PICK_POPUP_OPTION_ACTIVE = "nolimitActionSpins/optionActive@2x.png", n.ACTION_SPINS_PICK_POPUP_OPTION_IN_ACTIVE = "nolimitActionSpins/optionInactive@2x.png", n.ACTION_SPINS_PICK_POPUP_MASK = "nolimitActionSpins/popUpChoice@2x.png", n.ACTION_SPINS_MENU_BET = "nolimitActionSpins/gameFeed/menuBet@2x.png", n.ACTION_SPINS_REPLAY_MENU_TOTAL_BET = "nolimitActionSpins/gameFeed/menuTotalBet@2x.png", n.ACTION_SPINS_REPLAY_MENU_WIN = "nolimitActionSpins/gameFeed/menuWin@2x.png", n.ACTION_SPINS_REPLAY_MENU_PROFIT = "nolimitActionSpins/gameFeed/menuProfit@2x.png", n.ACTION_SPINS_BTN_PLAY = "nolimitActionSpins/gameFeed/play@2x.png", n.ACTION_SPINS_BTN_PAUSE = "nolimitActionSpins/gameFeed/pause@2x.png", n.ACTION_SPINS_REPLAY_FEED_BG = "nolimitActionSpins/gameFeed/gameFeedBg@2x.png", n.ACTION_SPINS_REPLAY_BG_LANDSCAPE = "nolimitActionSpins/gameFeed/gameFeedBgLandscape@2x.png", n.ACTION_SPINS_REPLAY_GAME_REPLAY_BTN = "nolimitActionSpins/gameFeed/gameReplay@2x.png", n.ACTION_SPINS_REPLAY_GAME_REPLAY_DISABLED_BTN = "nolimitActionSpins/gameFeed/gameReplayDisabled@2x.png", n.ACTION_SPINS_GAME_PLAY_BTN = "nolimitActionSpins/gameFeed/gamePlay@2x.png", n.GAME_FEED_OK = "nolimitActionSpins/gameFeed/ok@2x.png", n.GAME_FEED_CANCEL = "nolimitActionSpins/gameFeed/cancel@2x.png", n.ACTION_SPINS_GAME_CONTINUE = "nolimitActionSpins/gameFeed/gameContinue@2x.png", n.ACTION_SPINS_GAME_CONTINUE_SMALL = "nolimitActionSpins/gameFeed/gameContinueSmall@2x.png", n.ACTION_SPINS_REPLAY_GAME_EXPAND = "nolimitActionSpins/gameFeed/gameExpand@2x.png", n.ACTION_SPINS_REPLAY_INFO_BG_LANDSCAPE = "nolimitActionSpins/gameFeed/infoBarLandscape@2x.png", n.ACTION_SPINS_REPLAY_INFO_BG = "nolimitActionSpins/gameFeed/infoBarBg@2x.png", n.ACTION_SPINS_REPLAY_INFO_BG_SMALL = "nolimitActionSpins/gameFeed/infoBarBgSmall@2x.png", n.ACTION_SPINS_OPTIONS_BUTTON_MASK = "nolimitActionSpins/gameOptionMask@2x.png", n.ACTION_SPINS_OPTIONS_BUTTON_ACTIVE = "nolimitActionSpins/gameOptionActive@2x.png", n.ACTION_SPINS_OPTIONS_BUTTON_INACTIVE = "nolimitActionSpins/gameOptionInactive@2x.png", n.ACTION_SPINS_OPTIONS_BUTTON_OUTLINE = "nolimitActionSpins/gameOptionOutline@2x.png", n.ACTION_SPINS_OPTIONS_BUTTON_PLATE = "nolimitActionSpins/gameOptionPlate@2x.png", n.ACTION_SPINS_SORT_ARROW_RIGHT = "nolimitActionSpins/gameFeed/sortArrowRight@2x.png", n.ACTION_SPINS_SORT_ARROW_DOWN = "nolimitActionSpins/gameFeed/sortArrowDown@2x.png", n.BONUS_ROUND_OUTLINE = "nolimitActionSpins/gameFeed/bonusOutline@2x.png", n.ACTION_SPINS_ROUNDS_NUMBER_BG = "nolimitActionSpins/gameFeed/spinNumberBg@2x.png", n.ACTION_SPINS_PLAYED_ROUNDS_BG = "nolimitActionSpins/gameFeed/playedRoundsBg@2x.png", n.GAME_FEED_BONUS_INFO_BG = "nolimitActionSpins/gameFeed/bonusInfoBg@2x.png", n.BONUS_ROUND_BONUS_SUMMARY = "nolimitActionSpins/gameFeed/lineBonusSummary@2x.png", n.ALL_PLAYER_ACTIVE = "nolimitWinners/allPlayersActive@2x.png", n.PLAYER_ACTIVE = "nolimitWinners/playerActive@2x.png", n.PLAYER_INACTIVE = "nolimitWinners/playerInactive@2x.png", n.ROUND_INFO_BONUS_BUY_ICON = "nolimitWinners/nolimitWinners_bonusIcon@2x.png", n.ROUND_INFO_ACTION_SPINS_ICON = "nolimitWinners/nolimitWinners_actionSpinsIcon@2x.png", n.REPLAY_BUTTON = "nolimitWinners/replayButton@2x.png", n.TROPHY_BRONZE = "nolimitWinners/trophyBronze@2x.png", n.TROPHY_GOLD = "nolimitWinners/trophyGold@2x.png", n.TROPHY_SILVER = "nolimitWinners/trophySilver@2x.png", n.INFO_BG = "nolimitWinners/infoBg@2x.png", n.REPLAY_WIN_BUTTON = "nolimitWinners/winBetBtn@2x.png", n.REPLAY_WIN_BUTTON_ACTIVE = "nolimitWinners/winBetBtnActive@2x.png", n.BET_PANEL_HEIGHT = 165, n.NO_LIMIT_PROMOTIONS_HEIGHT = 60, n.BET_BG_WIDTH = 632, n.GAME_FEATURE_MASK_WIDTH = 342, e.PromoPanelAssetConfig = n
			},
			19803: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Mode = e.PromoPanelConfig = void 0;
				const n = i(39055);
				class s {}
				var o;
				s.DISABLE_BTN_ALPHA = .4, s.ENABLE_BTN_ALPHA = 1, s.PROMO_PANEL_BTN_PANEL_HEIGHT = 150, s.FEATURE_BTN_CONFIG = [{
					id: n.PromoPanelButtonIDs.ACTION_SPINS,
					isDefault: !0,
					isDisabled: !1,
					shouldHide: !1,
					shouldReAligned: !1,
					viewBackgroundColor: 16695822
				}, {
					id: n.PromoPanelButtonIDs.NOLIMIT_WINNERS,
					isDefault: !0,
					isDisabled: !1,
					shouldHide: !1,
					shouldReAligned: !1,
					viewBackgroundColor: 6857945
				}, {
					id: n.PromoPanelButtonIDs.VOUCHER,
					isDefault: !1,
					isDisabled: !0,
					shouldHide: !1,
					shouldReAligned: !1,
					viewBackgroundColor: 16711680
				}], s.FEATURE_SCROLL_MASK_HEIGHT_PORTRAIT = 978, s.GAME_NAME_FILTER_REG_EXP = /\s/g, s.DEFAULT_SCREEN_RATIO = 1280 / 720, s.SINGLE_BLANK_SPACE = " ", s.NO_DECIMALS_CUTOFF_POINT = 10, s.DEFAULT_SCREEN_MIN_RATIO = 1.61, s.TEXT_LABEL_DRAW_BORDER = !1, s.DEFAULT_LARGE_BUTTON_SIZE = new PIXI.Rectangle(0, 0, 144, 76), s.DEFAULT_SMALL_BUTTON_SIZE = new PIXI.Rectangle(0, 0, 216, 72), s.AS_SETTING_POPUP_OK_BUTTON_SIZE = new PIXI.Rectangle(0, 0, 216, 98), s.FEATURE_FILTER_LIST = ["FREESPIN", "FEATURE_BUY"], s.DATE_SEPARATOR = "-", s.NOT_AVAILABLE = "n/a", s.NO_TEXT = "No", s.YES_TEXT = "Yes", s.EMPTY_STRING = "", s.DECIMAL_CUTOFF = 2, s.JPG_FORMAT = ".jpg", e.PromoPanelConfig = s, (o = e.Mode || (e.Mode = {})).NORMAL = "NORMAL", o.RESPIN = "RESPIN", o.FREESPIN = "FREESPIN", o.SUPER_FREESPIN = "SUPERFREESPIN"
			},
			63288: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PromoPanelTextStyles = void 0;
				const n = i(77616),
					s = i(5117),
					o = i(9886);
				class r {}
				r.FEATURE_BASE_PANEL_TITLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 50,
					fontStyle: n.FontStyle.ITALIC,
					fontWeight: n.FontWeight.SEMI_BOLD,
					padding: 50
				}), r.FEATURE_BASE_BUY_FEATURE_TITLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 50,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.SEMI_BOLD,
					dropShadow: !0,
					dropShadowAngle: -1,
					dropShadowDistance: -3,
					dropShadowColor: "#b62449",
					padding: 50
				}), r.FEATURE_BASE_REPLAY_TITLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 50,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.SEMI_BOLD,
					dropShadow: !0,
					dropShadowAngle: -1,
					dropShadowDistance: -3,
					dropShadowColor: "#4588c8",
					padding: 59
				}), r.FEATURE_ACTION_SPIN_REPLAY_TITLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 50,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.SEMI_BOLD,
					dropShadow: !0,
					dropShadowAngle: -1,
					dropShadowDistance: -3,
					dropShadowColor: "#f57f20",
					padding: 59
				}), r.BET_PANEL_BET_LABEL = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 24,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.LIGHT
				}), r.BET_PANEL_CURRENCY_LABEL = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 24,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.EXTRA_BOLD
				}), r.BET_PANEL_BET_STYLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 55,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.LIGHT
				}), r.BET_PANEL_SEPARATOR_STYLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 65,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.LIGHT
				}), r.POP_UP_FEATURE_TEXT = new PIXI.TextStyle({
					fill: "#367fff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 42,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.BOLD
				}), r.AS_BONUS_SELECTION_POP_UP_GAME_NAME_TEXT = new PIXI.TextStyle({
					fill: "#000000",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 35,
					fontStyle: n.FontStyle.ITALIC,
					fontWeight: n.FontWeight.SEMI_BOLD,
					padding: 10
				}), r.AS_POP_UP_HEADER_TEXT = new PIXI.TextStyle({
					fill: "#00b786",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 28,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.SEMI_BOLD,
					align: "center"
				}), r.AS_POP_UP_CONTENT_TEXT = new PIXI.TextStyle({
					fill: "#B7B7B7",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 20,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.SEMI_BOLD,
					wordWrap: !0,
					align: "center"
				}), r.AS_POPUP_OK_TEXT = new PIXI.TextStyle({
					fill: "#FFFFFF",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 32,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.EXTRA_BOLD,
					padding: 59
				}), r.AS_BONUS_SELECTION_POP_UP_MAIN_GAME_TEXT = new PIXI.TextStyle({
					fill: "#000000",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 30,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.REGULAR
				}), r.AS_BONUS_SELECTION_PICK_LABEL = new PIXI.TextStyle({
					fill: "#000000",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 30,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.REGULAR
				}), r.POP_UP_HLINE = new PIXI.TextStyle({
					fill: "#367fff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 42,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.NORMAL
				}), r.POP_UP_FORMATTED_PRICE = new PIXI.TextStyle({
					fill: "#000000",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 30,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.BOLD
				}), r.POP_UP_CHARGE_FROM_WALLET_TEXT = new PIXI.TextStyle({
					fill: "#686868",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 30,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.LIGHT
				}), r.ACTION_SPINS_SETTINGS_HEADER = new PIXI.TextStyle({
					fill: "#000",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 35,
					fontStyle: n.FontStyle.ITALIC,
					fontWeight: n.FontWeight.SEMI_BOLD,
					padding: 10
				}), r.ACTION_SPINS_SETTINGS_MAIN_GAME_HEADER = new PIXI.TextStyle({
					fill: "#000",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 30,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.REGULAR,
					padding: 10
				}), r.ACTION_SPINS_MAIN_GAME_LABEL = new PIXI.TextStyle({
					fill: "#f78d1d",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 30,
					fontStyle: n.FontStyle.NORMAL
				}), r.ACTION_SPINS_STOP_ON_BONUS_LABEL = new PIXI.TextStyle({
					fill: "#f78d1d",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 26,
					fontStyle: n.FontStyle.NORMAL
				}), r.ACTION_SPINS_OPTIONS_DISCLAIMER = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 20,
					fontStyle: n.FontStyle.NORMAL,
					wordWrap: !0,
					wordWrapWidth: 633,
					dropShadow: !0,
					dropShadowAngle: -1,
					dropShadowColor: "#f78d1d",
					dropShadowDistance: -2,
					padding: 5
				}), r.ACTION_SPINS_OPTIONS_TITLE = new PIXI.TextStyle({
					fill: "#f78d1d",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 26,
					fontStyle: n.FontStyle.NORMAL
				}), r.ACTION_SPINS_OPTIONS_VALUE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 26,
					fontStyle: n.FontStyle.NORMAL,
					dropShadow: !0,
					dropShadowAngle: -1,
					dropShadowColor: "#f78d1d",
					dropShadowDistance: -2,
					padding: 5
				}), r.AS_REPLAY_NUMBER_TEXT_STYLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 26,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.SEMI_BOLD
				}), r.GAME_FEATURE_CURRANCY_STYLE = new PIXI.TextStyle({
					fill: "#a76f00",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 24,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.EXTRA_BOLD
				}), r.GAME_FEATURE_PRICE_STYLE = new PIXI.TextStyle({
					fill: "#a76f00",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 35,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.LIGHT
				}), r.GAME_FEATURE_COST_TEXT = new PIXI.TextStyle({
					fill: "#a76f00",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 24,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.LIGHT
				}), r.GAME_FEATURE_BUY_TEXT = new PIXI.TextStyle({
					fill: "#fff500",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 36,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.EXTRA_BOLD,
					padding: 10
				}), r.GAME_FEATURE_BUY_TEXT_DISABLED = new PIXI.TextStyle({
					fill: "#f8f49f",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 36,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.EXTRA_BOLD,
					padding: 10
				}), r.PROMO_PANEL_HEADING = new PIXI.TextStyle({
					fill: "#000000",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 28,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.LIGHT
				}), r.PROMO_PANEL_PROMOTIONS_HEADING = new PIXI.TextStyle({
					fill: "#000000",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 28,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.EXTRA_BOLD
				}), r.GAME_FEATURE_OK_TEXT = new PIXI.TextStyle({
					fill: "#000000",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 38,
					fontStyle: n.FontStyle.ITALIC,
					fontWeight: n.FontWeight.EXTRA_BOLD,
					padding: 59
				}), r.AS_SETTING_POPUP_OK_TEXT = new PIXI.TextStyle({
					fill: "#000000",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 42,
					fontStyle: n.FontStyle.ITALIC,
					fontWeight: n.FontWeight.EXTRA_BOLD,
					padding: 59
				}), r.REPLAY_MIDDLE_BAR_TEXT = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 24,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.BOLD
				}), r.REPLAY_GAME_BTN_ACTIVE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 30,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.SEMI_BOLD,
					padding: 10
				}), r.REPLAY_GAME_BTN_INACTIVE = new PIXI.TextStyle({
					fill: "#284382",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 30,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.SEMI_BOLD,
					padding: 10
				}), r.ROUND_INFO_BET_TEXT_ACTIVE = new PIXI.TextStyle({
					fill: "#f3e550",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 25,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.BOLD
				}), r.ROUND_INFO_BET_TEXT_INACTIVE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 25,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.BOLD
				}), r.REPLAY_FILTER_STYLE_INACTIVE_FILL_COLOR = o.GuiUtils.getARGB(PIXI.utils.string2hex("#284382")), r.REPLAY_FILTER_STYLE_INACTIVE = new PIXI.TextStyle({
					fill: "#284382",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 20,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.BOLD,
					padding: 50
				}), r.REPLAY_FILTER_STYLE_ACTIVE_FILL_COLOR = o.GuiUtils.getARGB(PIXI.utils.string2hex("#f3e550")), r.REPLAY_FILTER_STYLE_ACTIVE = new PIXI.TextStyle({
					fill: "#f3e550",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 20,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.BOLD
				}), r.ROUND_INFO_DATE_TEXT = new PIXI.TextStyle({
					fill: "#000000",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 16,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.REGULAR
				}), r.SORT_BUTTON = new PIXI.TextStyle({
					fill: "#000000",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 20,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.SEMI_BOLD
				}), r.ROUND_INFO_GAME_NAME_TEXT = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 18,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.BOLD
				}), r.ROUND_INFO_CURRENCY_TEXT = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 25,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.LIGHT
				}), r.ROUND_INFO_WIN_TEXT = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 25,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.BOLD
				}), r.ROUND_INFO_TROPHY_TEXT = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 35,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.EXTRA_BOLD
				}), r.DEFAULT_BUTTON_LABEL_STYLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 40,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.LIGHT
				}), r.SETTINGS_BUTTON_LABEL_STYLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 24,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.LIGHT
				}), r.AS_ROUND_INFO_X_BET_STYLE = new PIXI.TextStyle({
					fill: "#000000",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 24,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.REGULAR
				}), r.AS_ROUND_INFO_SLASH_STYLE = new PIXI.TextStyle({
					fill: "#000000",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 24,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.LIGHT
				}), r.AS_ROUND_INFO_RE_SPIN_STYLE = new PIXI.TextStyle({
					fill: "#000000",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 24,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.SEMI_BOLD
				}), r.AS_ROUND_INFO_SPINS_LEFT_STYLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 28,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.SEMI_BOLD
				}), r.AS_ROUND_INFO_WIN_STYLE = new PIXI.TextStyle({
					fill: "#fbc217",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 24,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.EXTRA_BOLD,
					dropShadow: !1,
					dropShadowAngle: 1.57,
					dropShadowColor: "#000000",
					dropShadowDistance: 2,
					dropShadowAlpha: .7
				}), r.AS_ROUND_INFO_PLAY_BONUS_IN_GAME_STYLE = new PIXI.TextStyle({
					fill: "#000000",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 18,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.REGULAR,
					padding: 10
				}), r.AS_ROUND_INFO_CONTINUE_STYLE = new PIXI.TextStyle({
					fill: "#000000",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 15,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.SEMI_BOLD
				}), r.AS_POPUP_TOTAL_COST_STYLE = new PIXI.TextStyle({
					fill: "#000000",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 20,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.REGULAR
				}), r.AS_ROUND_INFO_SPIN_NUMBER_TEXT_STYLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: s.OpenSans.FAMILY,
					fontSize: 11,
					fontStyle: n.FontStyle.NORMAL,
					fontWeight: n.FontWeight.BOLD
				}), e.PromoPanelTextStyles = r
			},
			64294: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ReplayURLConfig = void 0;
				class i {}
				i.BASE_PATH = "api/top10/", i.BASE_URL_DEFAULT = "https://replay.nolimitcity.com/", i.TOP_X_BET_URL = "multiplier", i.TOP_MONETARY_URL = "monetary", i.GAME_SPECIFIC_URL = "/game/", i.OPERATOR_SPECIFIC_URL = "/operator/", e.ReplayURLConfig = i
			},
			88458: (t, e) => {
				"use strict";
				var i, n, s, o, r;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.OptionType = e.LocalStorageSettingsKey = e.ASBonusPickOptions = e.WINTYPE = e.ASMainGamePickOptions = void 0, (r = e.ASMainGamePickOptions || (e.ASMainGamePickOptions = {})).VOLATILITY = "VOLATILITY", r.BOOSTED_BET = "BOOSTED_BET", (o = e.WINTYPE || (e.WINTYPE = {})).NORMAL = "NORMAL", o.MULTIPLIER = "MULTIPLIER", (s = e.ASBonusPickOptions || (e.ASBonusPickOptions = {})).PICK_MODE = "pickMode", s.ROW_OPTIONS = "rowOptions", (n = e.LocalStorageSettingsKey || (e.LocalStorageSettingsKey = {})).AS_STOP_ON_BONUS = "AS_STOP_ON_BONUS", n.AS_BONUS_TAB_SELECTED = "AS_BONUS_TAB_SELECTED", (i = e.OptionType || (e.OptionType = {})).MAIN_GAME = "mainGame", i.BONUS_GAME = "bonusGame"
			},
			39055: (t, e) => {
				"use strict";
				var i;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PromoPanelButtonIDs = void 0, (i = e.PromoPanelButtonIDs || (e.PromoPanelButtonIDs = {})).CLOSE = "CLOSE", i.NOLIMIT_WINNERS = "NOLIMIT_WINNERS", i.TOURNAMENTS = "TOURNAMENTS", i.VOUCHER = "VOUCHER", i.NOLIMIT_BONUS = "NOLIMIT_BONUS", i.BET_DOWN = "BET_DOWN", i.BET_UP = "BET_UP", i.BUY = "BUY_BTN", i.OK_BTN = "OK_BTN", i.POP_UP_CLOSE = "POP_UP_CLOSE", i.CURRENT_GAME_BTN = "CURRENT_GAME_BTN", i.ALL_GAME_BTN = "ALL_GAME_BTN", i.SINGLE_PLAYER_BTN = "SINGLE_PLAYER_BTN", i.ALL_PLAYER_BTN = "ALL_PLAYER_BTN", i.X_BET_FILTER_BTN = "X_BET_FILTER_BTN", i.X_WIN_FILTER_BTN = "X_WIN_FILTER_BTN", i.PLAY_BTN = "PLAY_BTN", i.CAP_WIN_TOGGLE = "capWinToggleButton", i.ACTION_SPINS = "ACTION_SPINS", i.ACTION_SPINS_BET_UP = "ACTION_SPINS_BET_UP", i.ACTION_SPINS_BET_DOWN = "ACTION_SPINS_BET_DOWN", i.ACTION_SPINS_COUNT_DOWN = "ACTION_SPINS_COUNT_DOWN", i.ACTION_SPINS_COUNT_UP = "ACTION_SPINS_COUNT_UP", i.ACTION_SPINS_SPIN_BUTTON = "ACTION_SPINS_SPIN_BUTTON", i.ACTION_SPINS_SPIN_STOP_BUTTON = "ACTION_SPINS_SPIN_STOP_BUTTON", i.ACTION_SPIN_STOP_ON_BONUS_TRIGGERED = "ACTION_SPIN_STOP_ON_BONUS_TRIGGERED", i.ACTION_SPINS_SETTINGS = "ACTION_SPINS_SETTINGS", i.ACTION_SPINS_BONUS_BUY = "ACTION_SPINS_BONUS_BUY", i.ACTION_SPINS_MAIN_GAME = "ACTION_SPINS_MAIN_GAME", i.ACTION_SPINS_BONUS_BUY_LABEL = "Nolimit Bonus", i.ACTION_SPINS_MAIN_GAME_LABEL = "Main Game", i.ACTION_SPINS_BONUS_PICK_POP_UP_CLOSE = "BONUS_PICK_POP_UP_CLOSE", i.ACTION_SPINS_REPLAY_EXPAND_BUTTON = "ACTION_SPINS_REPLAY_EXPAND_BUTTON", i.ACTION_SPINS_REPLAY_REPLAY_BUTTON = "ACTION_SPINS_REPLAY_REPLAY_BUTTON", i.ACTION_SPINS_REPLAY_PAUSE_BUTTON = "ACTION_SPINS_REPLAY_PAUSE_BUTTON", i.ACTION_SPINS_REPLAY_PLAY_BUTTON = "ACTION_SPINS_REPLAY_PLAY_BUTTON", i.ACTION_SPINS_GAME_PLAY_BUTTON = "ACTION_SPINS_GAME_PLAY", i.ACTION_SPINS_GAME_CONTINUE_BUTTON = "ACTION_SPINS_GAME_CONTINUE", i.AS_BONUS_SELECTION_OK_BTN = "AS_BONUS_SELECTION_OK_BTN", i.AS_BONUS_SELECTION_CANCEL_BTN = "AS_BONUS_SELECTION_CANCEL_BTN"
			},
			56401: (t, e) => {
				"use strict";
				var i;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PromoPanelLabelIDs = void 0, (i = e.PromoPanelLabelIDs || (e.PromoPanelLabelIDs = {})).PROMO_PANEL_HEADING = "NOLIMIT", i.PROMO_PANEL_PROMOTIONS_HEADING = "PROMOTIONS", i.BET = "Bet", i.BUY = "BUY", i.BUY_FEATURE_TITLE = "Nolimit Shortcut", i.BUY_FEATURE_COST = "COST", i.POPUP_CANCEL = "CANCEL", i.POPUP_OK = "OK", i.CHARGE_FROM_WALLET = "will be charged from your wallet", i.REPLAY_FEATURE_TITLE = "Nolimit Winners", i.REPLAY_CURRENT_GAME = "Current game", i.REPLAY_ALL_GAMES = "All games", i.REPLAY_X_BET = "Bet", i.REPLAY_X_WIN = "Win", i.REPLAY_TOP_WINS_HEADING = "OVERALL TOP WINS", i.REPLAY_MY_TOP_WINS_HEADING = "MY TOP WINS", i.ACTION_SPINS = "Nolimit Action Spins", i.ACTION_SPINS_COST = "Action Spins Cost", i.ROUNDS = "Rounds", i.PRESS_S_TO_STOP = "Press S to stop", i.SPINS_LEFT = "Spins Left :", i.FREE_SPINS_LEFT = "FS Left :", i.SETTING = "Settings", i.BONUS_BUY = "Bonus Buy", i.ACTION_SPINS_BONUS_BUY = "Action Spins Bonus Buy", i.ACTION_SPINS_BONUS_BUY_LABEL = "Nolimit Bonus", i.ACTION_SPINS_MAIN_GAME_LABEL = "Main Game", i.YES = "YES", i.STOP_ON_BONUS = "Stop on bonus", i.PLAY_BONUS_IN_GAME = "Play bonus in game", i.NUMBER_OF_ROUNDS = "Number of Rounds", i.TOTAL_WIN = "Total Win", i.TOTAL_BET_PLACED = "Total bet Placed", i.TOTAL_FS_TRIGGERED = "Total Fs Triggered", i.START = "START", i.TOTAL_COST = "TOTAL COST", i.CONTINUE = "Continue", i.AS_SETTING_MAX_WIN_TEXT = "Max Win"
			},
			12342: (t, e) => {
				"use strict";
				var i;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ReplayFilterTypes = void 0, (i = e.ReplayFilterTypes || (e.ReplayFilterTypes = {})).MONETARY = "monetary", i.MULTIPLIER = "multiplier"
			},
			70660: (t, e) => {
				"use strict";
				var i;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.RequestMethod = void 0, (i = e.RequestMethod || (e.RequestMethod = {})).POST = "POST", i.GET = "GET", i.PUT = "PUT", i.HEAD = "HEAD"
			},
			1235: (t, e) => {
				"use strict";
				var i;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.TrophyTypes = void 0, (i = e.TrophyTypes || (e.TrophyTypes = {}))[i.TROPHY_GOLD = 0] = "TROPHY_GOLD", i[i.TROPHY_SILVER = 1] = "TROPHY_SILVER", i[i.TROPHY_BRONZE = 2] = "TROPHY_BRONZE"
			},
			77549: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PromoPanelEvents = void 0;
				class i {}
				i.BALANCE_UPDATE_EVENT = "onBalanceUpdate", i.ON_RESIZE = "promoPanelOnResize", i.ON_ORIENTATION_CHANGED = "promoPanelOnOrientationChanged", i.NAV_BUTTON_PRESSED = "onNavButtonPressed", i.DISABLE_ALL_NAV_BUTTON = "disableAllNavButtons", i.DISABLE_NAV_BUTTON = "disableNavButtons", i.ENABLE_NAV_BUTTON = "enableNavButtons", i.HIDE_NAV_BUTTON = "hideNavButtons", i.SHOW_NAV_BUTTON = "showNavButtons", i.ON_BET_CHANGE = "onBetChange", i.DISABLE_BET_BUTTONS = "disableBetButtons", i.ENABLE_BET_BUTTONS = "enableBetButtons", i.ON_POPUP_OPEN = "onPopUpOpen", i.ON_POPUP_CLOSE = "onPopUpClose", i.TOGGLE_BUTTONS_ON_LIGHTING_SPINS = "toggleButtonOnLightningSpins", i.AS_REPLAY_ADD_BLUR = "actionSpinReplayAddBlur", i.AS_REPLAY_REMOVE_BLUR = "actionSpinReplayRemoveBlur", i.ACTION_SPIN_DATA = "actionSpinData", i.SHOW_HIDE_CLOSE_BUTTON = "showHideCloseBtn", i.BLUR_BACKGROUND = "blurBackground", i.PROMO_PANEL_OPENED = "promoPanelOpened", i.PROMO_PANEL_CLOSED = "promoPanelClosed", i.PROMO_PANEL_MINIMIZED = "promoPanelMinimized", i.PROMO_PANEL_MAXIMIZED = "promoPanelMaximized", i.DIALOG_SHOWN = "dialogShown", i.FREE_BETS_START = "freeBetsStart", i.FREE_BETS_END = "freeBetsEnd", e.PromoPanelEvents = i
			},
			51797: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.FeatureBasePanel = void 0;
				const n = i(72468),
					s = i(68714),
					o = i(63288),
					r = i(77549),
					a = i(19803),
					l = i(61e3);
				class h extends PIXI.Container {
					constructor(t, e, i) {
						super(), this._init = !1, this._isOpen = !1, this._logoName = t, this._titleStr = e, this._titleTextStyle = i || o.PromoPanelTextStyles.FEATURE_BASE_PANEL_TITLE
					}
					init() {
						this.createLogo(), this.createTitle(), this.addEventListeners(), this._init = !0
					}
					addEventListeners() {
						n.NolimitApplication.events.on(r.PromoPanelEvents.ON_RESIZE, (() => this.onResize())), n.NolimitApplication.events.on(r.PromoPanelEvents.ON_ORIENTATION_CHANGED, (() => this.onOrientationChanged()))
					}
					createLogo() {
						this._logo = new PIXI.Sprite(l.ImgLoader.getImgTexture(this._logoName)), this._logo.anchor.set(0, .5), this._logo.pivot.y = -2, this.addChild(this._logo)
					}
					createTitle() {
						this._title = new s.Label(this._titleStr, this._titleTextStyle), this._title.anchor.set(0, .5), this.addChild(this._title)
					}
					onOrientationChanged() {}
					open() {
						this._init || this.init(), this._isOpen = !0, this.interactive = !0, this.interactiveChildren = !0, this.onResize(), this.show()
					}
					close() {
						this.hide(), this._isOpen = !1
					}
					show() {
						this.visible = !0
					}
					hide() {
						this.visible = !1
					}
					onResize() {
						const t = n.NolimitApplication.screenBounds;
						let e = .5 * t.width,
							i = 40;
						const s = this._title.width + this._logo.width + 24;
						n.NolimitApplication.isLandscape && (i = 45, e = .5 * (t.width - a.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT)), this._logo.position.set(e - .5 * s - 3, 32.5 + i), this._title.position.set(this._logo.x + this._logo.width + 24, 32.5 + i)
					}
					get logo() {
						return this._logo
					}
				}
				e.FeatureBasePanel = h
			},
			66619: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PromoPanelLabelButton = e.createDefaultButtonStroke = e.createDefaultButtonBackPlate = void 0;
				const n = i(68714),
					s = i(35235),
					o = i(5158),
					r = i(9886),
					a = i(50799),
					l = i(63288),
					h = i(61e3);

				function u() {
					const t = new PIXI.NineSlicePlane(h.ImgLoader.getImgTexture(a.PromoPanelAssetConfig.BUTTON_PLATE_20), 20, 20, 20, 20);
					return t.tint = 0, t.alpha = .15, t
				}
				e.createDefaultButtonBackPlate = u, e.createDefaultButtonStroke = function() {
					const t = new PIXI.NineSlicePlane(h.ImgLoader.getImgTexture(a.PromoPanelAssetConfig.BUTTON_STROKE_20), 20, 20, 20, 20);
					return t.tint = 16777215, t.alpha = .6, t
				};
				class c extends s.GuiToggleButton {
					constructor(t, e = "", i, s, r, a, h, c, d = !1) {
						super(t, (() => this.toggleCallback())), this._isToggledBtn = !1, this._colorSets = i && s && new o.ToggleStateSet(i, s), this.value = void 0, this._isToggledBtn = d, this._label = new n.Label(e, r || l.PromoPanelTextStyles.SETTINGS_BUTTON_LABEL_STYLE), this._backPlate = a || u(), this._stroke = h, this._backPlateOff = c, this.addChild(this._backPlate), this._backPlateOff && this.addChild(this._backPlateOff), this._stroke && this.addChild(this._stroke), this.addChild(this._label)
					}
					setSize(t, e) {
						this._backPlate.width = t, this._backPlate.height = e, this._backPlateOff && (this._backPlateOff.width = t), this._backPlateOff && (this._backPlateOff.height = e), this._stroke && (this._stroke.width = t, this._stroke.height = e), this._label.anchor.set(.5, .5), this._label.position.set(.5 * t, .5 * e), this.pivot.set(.5 * t, .5 * e)
					}
					resize(t = 0) {
						this._label.width + 5 >= this._backPlate.width && this.setSize(this._label.width + t, this._backPlate.height)
					}
					onPointerStateUpdate(t) {
						this.setColors()
					}
					setColors() {
						if (this._colorSets) {
							const t = this._colorSets.getItem(this.toggleState).getItem(this.pointerState);
							this._label.setColor(t), this._backPlate.alpha = .15 * (1 - this.toggleState), this._stroke && (this._stroke.tint = r.GuiUtils.getColorFromARGB(t), this._stroke.alpha = r.GuiUtils.getAlphaFromARGB(t), this._stroke.alpha *= this.toggled ? 1 : .6)
						}
					}
					toggleCallback() {
						this.setColors(), this._backPlateOff && (this._backPlate.alpha = this.toggled ? 1 : 0, this._backPlateOff.alpha = this.toggled ? 0 : 1)
					}
					get label() {
						return this._label
					}
					get backPlate() {
						return this._backPlate
					}
				}
				e.PromoPanelLabelButton = c
			},
			91746: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.TextLabelAdvanced = e.PromoPanelTextLabel = void 0;
				const n = i(71855),
					s = i(72468),
					o = i(19803),
					r = i(68714);
				class a extends r.Label {
					constructor(t, e, i) {
						super(t, e.clone()), this._textStyle = e.clone(), this._options = i, this._fontSize = "string" == typeof this._textStyle.fontSize ? parseInt(this._textStyle.fontSize) : this._textStyle.fontSize, this.defaultSize = this._fontSize, this.anchor.set(.5)
					}
					onResize() {
						const t = s.NolimitApplication.screenBounds,
							e = s.NolimitApplication.isLandscape && n.Helper.isDefaultScreenRatio(t) ? this._options.landscapeMaxWidth : this._options.portraitMaxWidth,
							i = this.getStyleClone(),
							r = ("string" == typeof i.fontSize ? parseInt(i.fontSize) : i.fontSize) / this.defaultSize,
							a = e / (this.width / r),
							l = Math.min(Math.floor(this.defaultSize * a), this.defaultSize);
						l != this._fontSize && (this._fontSize = l, this.setStyle(i)), o.PromoPanelConfig.TEXT_LABEL_DRAW_BORDER && this.drawBorder()
					}
					setStyle(t) {
						t.fontSize = this._fontSize, super.setStyle(t)
					}
					drawBorder() {
						this._border || (this._border = new PIXI.Graphics, this._border.name = this.text + "_BORDER", this.parent && this.parent.addChild(this._border));
						const t = s.NolimitApplication.screenBounds,
							e = s.NolimitApplication.isLandscape && n.Helper.isDefaultScreenRatio(t);
						this._border.clear(), this._border.beginFill(0), this._border.alpha = .2, e ? this._border.drawRect(0, 0, this._options.landscapeMaxWidth, this.height) : this._border.drawRect(0, 0, this._options.portraitMaxWidth, this.height), this._border.pivot.set(this._border.width * this.anchor.x, this._border.height * this.anchor.y), this._border.position.set(this.x, this.y)
					}
					get value() {
						return this._value
					}
					set value(t) {
						this._value = t, this.text = t, this.onResize()
					}
					get textStyle() {
						return this._textStyle
					}
				}
				e.PromoPanelTextLabel = a, e.TextLabelAdvanced = class extends a {
					get latestValue() {
						return this._latestValue
					}
					set latestValue(t) {
						this._latestValue = t
					}
				}
			},
			54004: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ASBetPanelView = void 0;
				const n = i(73010),
					s = i(83167),
					o = i(2425),
					r = i(56401);
				class a extends n.BetPanelView {
					constructor(t, e, i, n, s = !1) {
						a._isRoundsView = s, super(t, e, i, n), this.setBackgroundAlpha(1)
					}
					resize(t) {
						this.setBackgroundSize(633, 120), this._betDisplay.position.set(.5 * this._betBackground.width - 177, 13), this._betSelector.position.set(.5 * this._betBackground.width + 177, 60), this._betDisplay.resize()
					}
					createBetDisplay() {
						let t;
						return a._isRoundsView ? (this._formatValueAsCurrency = !1, t = o.NolimitPromotionPlugin.apiPlugIn.translations.translate(r.PromoPanelLabelIDs.ROUNDS)) : t = o.NolimitPromotionPlugin.apiPlugIn.translations.translate(r.PromoPanelLabelIDs.BET), new s.BetDisplay(t)
					}
				}
				e.ASBetPanelView = a
			},
			59934: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ActionSpinMainGameView = void 0;
				const n = i(14643),
					s = i(72468),
					o = i(71855);
				class r extends PIXI.Container {
					get actionButtonView() {
						return this._actionButtonView
					}
					constructor(t) {
						super(), this._controller = t, this.init()
					}
					resize(t) {
						this._actionButtonView.resize(t), this._actionButtonView.position.set(0, Math.floor(.5 * this._actionButtonView.height))
					}
					init() {
						this._actionButtonView = new n.ASMainGameActionButtonView(this._controller), this.addChild(this._actionButtonView), this.resize(s.NolimitApplication.isLandscape && o.Helper.isDefaultScreenRatio(s.NolimitApplication.screenBounds))
					}
					setStopOnBonusEnableState(t) {
						this._actionButtonView.stopSpinOnBonusBtn.enable(t)
					}
				}
				e.ActionSpinMainGameView = r
			},
			91275: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ActionSpinsController = void 0;
				const n = i(61982),
					s = i(2425),
					o = i(77549),
					r = i(39055),
					a = i(46334),
					l = i(82748),
					h = i(72468),
					u = i(49490),
					c = i(13006),
					d = i(1769),
					p = i(19803),
					_ = i(60767),
					m = i(58850),
					g = i(11395),
					f = i(9026),
					S = i(88458),
					y = i(11499),
					v = i(13553),
					T = i(41122),
					E = i(79633);
				class b {
					get spinCountList() {
						return this._spinCountList
					}
					get spinsLeft() {
						return this._spinsLeft
					}
					set spinsLeft(t) {
						this._spinsLeft = t
					}
					get nextMode() {
						return this._nextMode
					}
					set nextMode(t) {
						this._nextMode = t
					}
					get view() {
						return this._view
					}
					set view(t) {
						this._view = t
					}
					get replayController() {
						return this._replayController
					}
					get promotionPlugin() {
						return this._promotionPlugin
					}
					get selectedFeatureBet() {
						return this._selectedFeatureBet
					}
					get isPaused() {
						return this._isPaused
					}
					constructor(t) {
						this._normalMode = "NORMAL", this._spinsLeft = -1, this._isResponseReceived = !1, this._isPaused = !1, this._isOpen = !1, this._isFreeBetsAwarded = !1, this._freeFeatureBetsAwarded = !1, this._spinCountList = new v.StepList([5, 10, 20, 50, 100, 200, 500, 1e3]), this._wantsPause = !1, this._isPlayingBonusInGame = !1, this._returnedFromGame = !1, this.actionSpinsBetDataInjector = t => (this._isPlayingBonusInGame && (t.playerInteraction ? t.playerInteraction.actionSpin = !0 : t.playerInteraction = {
							actionSpin: !0
						}), t), this.onGameOptionUpdate = () => {
							var t;
							console.log(this.view.gameOptionsView.selectedOptions), this.updateStartButtonState(), (null === (t = s.NolimitPromotionPlugin.promoPanelGameConfiguration) || void 0 === t ? void 0 : t.onActionSpinGameOptionSelection) && s.NolimitPromotionPlugin.promoPanelGameConfiguration.onActionSpinGameOptionSelection(this.view.gameOptionsView.selectedOptions)
						}, this._promotionPlugin = t, this.init(), b.settings = new f.ASSettingsModel, this._betLevels = s.NolimitPromotionPlugin.apiPlugIn.betLevel.getAvailableLevels(), s.NolimitPromotionPlugin.apiPlugIn.betHandler.addBetDataInjectCallback(this.actionSpinsBetDataInjector), b.pickModes = [], s.NolimitPromotionPlugin.ASOptionsData && (s.NolimitPromotionPlugin.ASOptionsData.automaticPickGame && (b.pickModes = b.pickModes.concat(s.NolimitPromotionPlugin.ASOptionsData.automaticPickGame.pickNeededForModes)), s.NolimitPromotionPlugin.ASOptionsData.bonusGame && (b.pickModes = b.pickModes.concat(s.NolimitPromotionPlugin.ASOptionsData.bonusGame.pickNeededForModes))), s.NolimitPromotionPlugin.apiPlugIn.betLevel.hasCapWinLimitToggle() && s.NolimitPromotionPlugin.apiPlugIn.events.on(u.APIEvent.BET_GAME_MODE_CHANGED, (() => {
							var t;
							this.onRefresh(), (null === (t = this.view) || void 0 === t ? void 0 : t.capToggle) && (this.view.capToggle.toggled = s.NolimitPromotionPlugin.apiPlugIn.betLevel.isCapWinLimitToggled())
						}))
					}
					setFeatureBet(t) {
						this._selectedFeatureBet = t, this._view.onUpdateSelectedFeatureBet()
					}
					reset() {
						this.setBetLevels(), this.updateSpinsCountButtons(), _.ResponseParser.setBoostAndGetCost("", !0), b.bonusBuyData = void 0, this._isFreeBetsAwarded = !1, this._isPaused = !1
					}
					init() {
						this.addEventListeners()
					}
					addEventListeners() {
						h.NolimitApplication.events.on(o.PromoPanelEvents.NAV_BUTTON_PRESSED, (t => this.onNavButtonPressed(t))), s.NolimitPromotionPlugin.apiPlugIn.events.on(o.PromoPanelEvents.PROMO_PANEL_CLOSED, (() => this.close())), s.NolimitPromotionPlugin.apiPlugIn.events.on(u.APIEvent.BALANCE, (() => this.updateBalance())), s.NolimitPromotionPlugin.apiPlugIn.events.on(u.APIEvent.BALANCE, (t => this.onBalanceUpdate(t))), s.NolimitPromotionPlugin.apiPlugIn.events.on(u.APIEvent.DIALOG, (t => this.onDialog(t))), s.NolimitPromotionPlugin.apiPlugIn.events.on(u.APIEvent.PAUSE, (() => this.onExternalPause(!0))), s.NolimitPromotionPlugin.apiPlugIn.events.on(u.APIEvent.RESUME, (() => this.onExternalPause(!1))), s.NolimitPromotionPlugin.apiPlugIn.events.on(u.APIEvent.HALT, (() => this.onHalt())), s.NolimitPromotionPlugin.apiPlugIn.events.on(u.APIEvent.FREE_BETS, (t => this.onFreeBets(t))), s.NolimitPromotionPlugin.apiPlugIn.events.on(u.APIEvent.FREE_FEATURE_BETS, (t => this.onFreeFeatureBets(t))), s.NolimitPromotionPlugin.apiPlugIn.events.on(u.APIEvent.REFRESH, (() => this.onRefresh()))
					}
					createView(t) {
						null == this._view && (this._view = new n.ActionSpinsView(this, t), this._replayController = new d.ASReplayController(this), this._popUpView = this._promotionPlugin.view.popUpView)
					}
					open() {
						this.view && (this._isOpen || (this._view.open(), this._isOpen = !0), this.reset())
					}
					onReplayCloseButtonClick() {
						h.NolimitApplication.events.trigger(o.PromoPanelEvents.SHOW_HIDE_CLOSE_BUTTON, !0), this._promotionPlugin.isActionSpinRound = !1, this.reset(), this.view.showWrapper(), this.replayController.close()
					}
					close() {
						this._view && (this._isOpen = !1, this._view.close())
					}
					buttonClick(t, e, i = !1) {
						switch (a.Logger.logDev("Action Spin controller :: onButtonClick", t), !i && s.NolimitPromotionPlugin.sound.playKeypadEffect("click"), t.name) {
							case r.PromoPanelButtonIDs.ACTION_SPINS_BET_DOWN:
								this.onBetDownBtnPressed();
								break;
							case r.PromoPanelButtonIDs.CAP_WIN_TOGGLE:
								s.NolimitPromotionPlugin.apiPlugIn.betLevel.toggleCapWinLimit();
								break;
							case r.PromoPanelButtonIDs.ACTION_SPINS_BET_UP:
								this.onBetUpBtnPressed();
								break;
							case r.PromoPanelButtonIDs.ACTION_SPINS_COUNT_UP:
								this.stepSpinCount(!0);
								break;
							case r.PromoPanelButtonIDs.ACTION_SPINS_COUNT_DOWN:
								this.stepSpinCount(!1);
								break;
							case r.PromoPanelButtonIDs.ACTION_SPINS_BONUS_PICK_POP_UP_CLOSE:
								break;
							case r.PromoPanelButtonIDs.ACTION_SPINS_SPIN_BUTTON:
								this.showConfirmationView();
								break;
							case r.PromoPanelButtonIDs.ACTION_SPINS_SETTINGS:
							case r.PromoPanelButtonIDs.OK_BTN:
								break;
							case r.PromoPanelButtonIDs.AS_BONUS_SELECTION_OK_BTN:
							case r.PromoPanelButtonIDs.AS_BONUS_SELECTION_CANCEL_BTN:
								this.view.showWrapper();
								break;
							default:
								a.Logger.warn("Button click : default case : ", t)
						}
					}
					onBuyButtonClicked(t, e) {
						e && e(t)
					}
					updateStartButtonState() {
						let t = +s.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel();
						const e = this.view.gameOptionsView.selectedOptions.get(S.ASMainGamePickOptions.BOOSTED_BET);
						e && e.id > 0 && (t = _.ResponseParser.getBetCost(e.name));
						const i = t <= s.NolimitPromotionPlugin.apiPlugIn.balance.getAmount(),
							n = this.view.gameOptionsView.isAllMandatorySelected(),
							o = i && n;
						this._view.mainGameView.actionButtonView.startButton.enableStartBtn(o)
					}
					getSelectedBonusOption(t, e) {
						var i, n, o;
						let r = -1;
						const a = this._view.gameOptionsView.selectedOptions.get(S.ASBonusPickOptions.PICK_MODE);
						return null != a && a.id > -1 && (r = a.id), -1 == r && e && null != (null === (i = s.NolimitPromotionPlugin.ASOptionsData) || void 0 === i ? void 0 : i.automaticPickGame) && (null === (n = s.NolimitPromotionPlugin.ASOptionsData) || void 0 === n ? void 0 : n.automaticPickGame.pickNeededForModes.indexOf(t)) > -1 && (r = null === (o = s.NolimitPromotionPlugin.ASOptionsData) || void 0 === o ? void 0 : o.automaticPickGame.optionSelection(e)), r
					}
					showConfirmationView() {
						let t;
						t = null != this.selectedFeatureBet ? this.makeFeatureBetPopUpData(this.selectedFeatureBet) : this.makeNormalPopUpData(), this._popUpView.openActionSpins(((t, e) => {
							t.name == r.PromoPanelButtonIDs.OK_BTN ? (s.NolimitPromotionPlugin.apiPlugIn.betFeatureController.setActiveBetFeature(null == e ? void 0 : e.name), this._popUpView.close(), this.view.hideWrapper(), this.startActionSpins()) : (this._popUpView.close(), this.enableASMainScreen())
						}), t)
					}
					makeNormalPopUpData() {
						const t = {
							isBonusBuy: !1,
							bet: y.CurrencyUtils.formatWithDecimalCutOff(this.view.getBet()),
							rounds: this.spinsLeft,
							image: "AS_GAME_LOGO"
						};
						t.stopOnBonus = b.settings.stopOnBonus, t.options = [];
						const e = this.view.gameOptionsView.selectedOptions.get(S.ASMainGamePickOptions.BOOSTED_BET);
						e && e.id > 0 && t.options.push(e);
						const i = this.view.gameOptionsView.selectedOptions.get(S.ASMainGamePickOptions.VOLATILITY);
						if (i && t.options.push(i), !b.settings.stopOnBonus) {
							const e = this.view.gameOptionsView.selectedOptions.get(S.ASBonusPickOptions.ROW_OPTIONS);
							e && t.options.push(e);
							const i = this.view.gameOptionsView.selectedOptions.get(S.ASBonusPickOptions.PICK_MODE);
							i && t.options.push(i)
						}
						return t
					}
					makeFeatureBetPopUpData(t) {
						var e, i;
						const n = "FREESPIN" === t.type,
							o = {
								isBonusBuy: n,
								bet: y.CurrencyUtils.formatWithDecimalCutOff(t.getTotalCost()),
								featureData: t,
								image: t.name,
								rounds: this.spinsLeft
							};
						o.stopOnBonus = b.settings.stopOnBonus && !n, o.options = [];
						const r = this.view.gameOptionsView.selectedOptions.get(S.ASBonusPickOptions.ROW_OPTIONS);
						r && o.options.push(r);
						let a = !0;
						(null === (i = null === (e = s.NolimitPromotionPlugin.ASOptionsData) || void 0 === e ? void 0 : e.bonusGame) || void 0 === i ? void 0 : i.pickNeededForBuyFeatures) && (a = s.NolimitPromotionPlugin.ASOptionsData.bonusGame.pickNeededForBuyFeatures.indexOf(t.name) > -1);
						const l = this.view.gameOptionsView.selectedOptions.get(S.ASBonusPickOptions.PICK_MODE);
						return l && a && o.options.push(l), o
					}
					onBetDownBtnPressed(t = !1) {
						const e = s.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel();
						let i = this._betLevels.indexOf(e); - 1 != i ? (!t && --i, s.NolimitPromotionPlugin.apiPlugIn.betLevel.setLevel(this._betLevels[i]), this.updateBetButtons(i)) : a.Logger.warn("Error invalid bet index : ", i)
					}
					onBetUpBtnPressed() {
						const t = s.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel();
						let e = this._betLevels.indexOf(t); - 1 != e ? (++e, s.NolimitPromotionPlugin.apiPlugIn.betLevel.setLevel(this._betLevels[e]), this.updateBetButtons(e)) : a.Logger.warn("Error invalid bet index : ", e)
					}
					stepSpinCount(t) {
						if (this._spinCountList.current() != this._spinsLeft) {
							let e = this._spinCountList.getListClone(!1),
								i = 0;
							for (let n = 0; n < e.length; n++)
								if (e[n] > this._spinsLeft) {
									i = t ? n : --n;
									break
								} this._spinCountList.setIndex(i)
						} else t ? this._spinCountList.next() : this._spinCountList.prev();
						this.updateSpinsCountButtons()
					}
					updateSpinsCountButtons() {
						this.spinsLeft = this._spinCountList.current(), this.view.spinsPanel.setValue(this.spinsLeft), this.replayController.view.setSpinsLeft(this.spinsLeft), this.replayController.view.enablePlayPauseBtn(this.eligibleForNextSpin()), this._spinCountList.isFirst() ? this._view.spinsPanel.betSelector.enableDownButton(!1) : this._view.spinsPanel.betSelector.enableDownButton(!0), this._spinCountList.isLast() ? this._view.spinsPanel.betSelector.enableUpButton(!1) : this._view.spinsPanel.betSelector.enableUpButton(!0);
						const t = s.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel();
						this.view.onUpdateBuyFeaturePrice(t)
					}
					updateBetButtons(t) {
						const e = s.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel();
						this._view.onBetChange(e), this._view.disableBetButtons();
						const i = s.NolimitPromotionPlugin.apiPlugIn.balance.getAmount();
						t < this._betLevels.length - 1 && +this._betLevels[t] < i && this._view.betPanel.betSelector.enableUpButton(!0), t > 0 && this._view.betPanel.betSelector.enableDownButton(!0), this.view.onUpdateBuyFeaturePrice(e), this.updateStartButtonState()
					}
					onBalanceUpdate(t) {
						this._isOpen && !this._replayController.view.isOpen && this.setBetLevels()
					}
					setBetLevels() {
						this._betLevels = s.NolimitPromotionPlugin.apiPlugIn.betLevel.getAvailableLevels();
						const t = s.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel(),
							e = this._betLevels.indexOf(t);
						g.ASStopSettings.update(!0), this.updateBetButtons(e), this.updateStartButtonState()
					}
					isOpen() {
						return this._promotionPlugin.view.isOpen && this.replayController.view.isOpen && !s.NolimitPromotionPlugin.IS_MINIMIZED
					}
					startActionSpins(t) {
						t && (b.bonusBuyData = {
							featureData: t
						}, _.ResponseParser.setBoostAndGetCost("", !0), this.view.hideWrapper()), this.replayController.open(), this._promotionPlugin.isActionSpinRound = !0, this._wantsPause = !1, this.nextMode = this._normalMode, this.startSpin()
					}
					updateBalance() {
						this.isOpen() && setTimeout((() => {
							s.NolimitPromotionPlugin.apiPlugIn.events.trigger(u.APIEvent.ACTION_SPINS_ROUND_COMPLETE)
						}), 0)
					}
					enableASMainScreen() {
						this.onBetDownBtnPressed(!0), this.view.enableASMainTab()
					}
					onNavButtonPressed(t) {
						t == r.PromoPanelButtonIDs.ACTION_SPINS ? this.open() : this.close()
					}
					pauseGame(t, e = !1) {
						this._wantsPause = t, t || (this._isPaused = !1, e && this.startWhenReady())
					}
					isLowBalance() {
						const t = s.NolimitPromotionPlugin.apiPlugIn.balance.getAmount();
						let e = this.view.getBet();
						return b.bonusBuyData ? e = b.bonusBuyData.featureData.price * e : s.NolimitPromotionPlugin.apiPlugIn.betHandler.betBoost && (e = s.NolimitPromotionPlugin.apiPlugIn.betHandler.betBoost.calculatedPrice), a.Logger.logDev("Action Spin : isLowBalance check ", e, t), e > t
					}
					stopSpin() {
						var t;
						(null === (t = this._roundInfoTl) || void 0 === t ? void 0 : t.isActive()) ? this._roundInfoTl.add((() => {
							h.NolimitApplication.apiPlugin.slotStates.stateIsReady().then((() => {
								this.onGameStopped()
							}))
						})): s.NolimitPromotionPlugin.apiPlugIn.slotStates.checkState(T.SlotState.SCREEN) && 1 == this._returnedFromGame ? this.onGameStopped() : h.NolimitApplication.apiPlugin.slotStates.stateIsReady().then((() => {
							this.onGameStopped()
						}))
					}
					onHalt() {
						this.isOpen() && this.onExternalPause(!0)
					}
					onExternalPause(t) {
						this.isOpen() && (t ? (this.pauseGame(!0), this.replayController.view.addBlur()) : this.replayController.view.removeBlur())
					}
					onFreeBets(t) {
						this.isOpen() && (this._isFreeBetsAwarded = !0, this.onExternalPause(!0))
					}
					onFreeFeatureBets(t) {
						this.isOpen() && (this._freeFeatureBetsAwarded = !0, this.pauseGame(!0))
					}
					onDialog(t) {
						this.isOpen() && (this.onExternalPause("open" == t), this._isFreeBetsAwarded && "close" == t && (this._isFreeBetsAwarded = !1, this.closeDownActionSpins()))
					}
					closeDownActionSpins() {
						this.onReplayCloseButtonClick(), this._promotionPlugin.close()
					}
					onRefresh() {
						this._isOpen && (this.setBetLevels(), this._replayController.view.isOpen && this._isPaused && this.replayController.onGameStopped(this.eligibleForNextSpin()))
					}
					onGameStopped() {
						if (this._isPaused = !0, this._wantsPause = !1, 1 == this._freeFeatureBetsAwarded) return this._freeFeatureBetsAwarded = !1, void this.closeDownActionSpins();
						this.replayController.onGameStopped(this.eligibleForNextSpin())
					}
					startWhenReady() {
						this._wantsPause ? this.stopSpin() : s.NolimitPromotionPlugin.apiPlugIn.slotStates.checkState(T.SlotState.SCREEN) && 1 == this._returnedFromGame ? (this.startSpin(), this._isPaused || (this._returnedFromGame = !1)) : s.NolimitPromotionPlugin.apiPlugIn.slotStates.stateIsReady().then((() => {
							this._returnedFromGame = !1, this.startSpin()
						}))
					}
					startSpin() {
						if (this.nextMode === this._normalMode) {
							if (this.isLowBalance()) return void this.showInsufficientFunds();
							this.spinsLeft--
						}
						this.spinsLeft > -1 ? (this.makeBet(), this._isResponseReceived = !1) : this.onGameStopped()
					}
					makeBet() {
						s.NolimitPromotionPlugin.apiPlugIn.dialog.lock("PIXIDialog");
						let t = l.APIBetType.NORMAL_BET;
						if (b.isGambleMode(this.nextMode)) t = l.APIBetType.GAMBLE_BET;
						else if (this.nextMode === this._normalMode || b.isPickMode(this.nextMode)) {
							if (b.isPickMode(this.nextMode)) {
								const t = this.actionSpinDataPromise();
								_.ResponseParser.gameDataPromise().then((e => {
									this.onGameDataPromiseResolved(e, t)
								}));
								const e = this.getSelectedBonusOption(this.nextMode, this.prevData);
								if (e > -1) s.NolimitPromotionPlugin.apiPlugIn.betHandler.actionSpinsPickAndClickBet(e, !0), a.Logger.logDev("Action Spin : Saved pick mode has been taken : ", e);
								else {
									a.Logger.warn("Error :: Action Spin Bonus mode not selected, default zero index picked", this.view.gameOptionsView.selectedOptions);
									const t = 0;
									s.NolimitPromotionPlugin.apiPlugIn.betHandler.actionSpinsPickAndClickBet(t, !0)
								}
								return
							}
						} else t = l.APIBetType.ZERO_BET;
						let e = 0;
						const i = this.actionSpinDataPromise();
						_.ResponseParser.gameDataPromise().then((t => {
							this.replayController.accumulatedBet += e, this.onGameDataPromiseResolved(t, i)
						})).catch((t => {
							this.stopSpin()
						})), t === l.APIBetType.GAMBLE_BET ? s.NolimitPromotionPlugin.apiPlugIn.betHandler.gambleBet(!0, void 0, void 0, !0) : b.bonusBuyData && t !== l.APIBetType.ZERO_BET ? (s.NolimitPromotionPlugin.apiPlugIn.betHandler.lightningSpinsFeatureBet(b.bonusBuyData.featureData.name), m.Timer.measureTimeAtStateStart(p.Mode.NORMAL, m.FlowState.BET), this.replayController.placedBet = b.bonusBuyData.featureData.price * this.view.betPanel.getValue(), e = this.replayController.placedBet) : (t === l.APIBetType.NORMAL_BET && (this.replayController.placedBet = g.ASStopSettings.appliedBet, e = this.replayController.placedBet), s.NolimitPromotionPlugin.apiPlugIn.betHandler.lightningSpinsBet(t), m.Timer.measureTimeAtStateStart(p.Mode.NORMAL, m.FlowState.BET)), this.replayController.updateSpinsLeft(this.spinsLeft)
					}
					onGameDataPromiseResolved(t, e) {
						_.ResponseParser.addASReplayWinData(t, this._view.betPanel.getValue(), this._fsData), (t.asReplayWinData.freeSpinTriggeredThisSpin || this._fsData) && (this._fsData = t), t.nextMode === p.Mode.NORMAL && this._fsData && (this._fsData = void 0), t.asReplayWinData.isRoundComplete ? (a.Logger.logDev("Action Spin : onGameDataPromiseResolved round finished ", t, t.asReplayWinData), t.nextMode === this._normalMode ? this._actionSpinData ? (this._roundInfoTl = this._replayController.updateRawData(t.asReplayWinData, this._actionSpinData), this.onBetResponseReceived(t, t.asReplayWinData.waitForAnimation), this._actionSpinData = void 0) : e.then((e => {
							this._roundInfoTl = this._replayController.updateRawData(t.asReplayWinData, e), this.onBetResponseReceived(t, t.asReplayWinData.waitForAnimation), this._actionSpinData = void 0
						})) : (this._roundInfoTl = this._replayController.updateRawData(t.asReplayWinData), this.onBetResponseReceived(t, t.asReplayWinData.waitForAnimation))) : (a.Logger.logDev("Action Spin : onGameDataPromiseResolved round not finished ", t, t.asReplayWinData), this.onBetResponseReceived(t, t.asReplayWinData.waitForAnimation))
					}
					actionSpinDataPromise() {
						return new Promise((t => {
							s.NolimitPromotionPlugin.apiPlugIn.events.once(o.PromoPanelEvents.ACTION_SPIN_DATA, (e => {
								this._actionSpinData = e, t(e)
							}))
						}))
					}
					showInsufficientFunds() {
						this.stopSpin(), E.show(h.NolimitApplication.apiPlugin)
					}
					eligibleForNextSpin() {
						let t;
						const e = s.NolimitPromotionPlugin.apiPlugIn.balance.getAmount(),
							i = this._replayController.placedBet || g.ASStopSettings.appliedBet;
						return g.ASStopSettings.shouldReset = !1, t = i <= e, t && g.ASStopSettings.maxBalanceLimitAmount && (t = !(h.NolimitApplication.apiPlugin.balance.getAmount() > g.ASStopSettings.maxBalanceLimitAmount), g.ASStopSettings.shouldReset = !t), t && g.ASStopSettings.minBalanceLimitAmount && (t = !(h.NolimitApplication.apiPlugin.balance.getAmount() < g.ASStopSettings.minBalanceLimitAmount + i), g.ASStopSettings.shouldReset = !t), t && this.spinsLeft > -1
					}
					isBuyFeatureScreen() {
						return !this.view.mainGameView.visible
					}
					onBetResponseReceived(t, e = !1) {
						a.Logger.logDev("onBetResponseReceived : data ", t), this.prevData = t, s.NolimitPromotionPlugin.apiPlugIn.events.trigger(u.APIEvent.STOP);
						let i = .001 * s.NolimitPromotionPlugin.apiPlugIn.gameClientConfiguration.minimumSpinTime || .001;
						e && (i = Math.max(this._roundInfoTl.duration() - this._roundInfoTl.time() - .2, i)), c.TweenLite.to({}, i, {
							onComplete: () => this.proceedBetResponse(t)
						})
					}
					proceedBetResponse(t) {
						if (s.NolimitPromotionPlugin.apiPlugIn.events.trigger(u.APIEvent.DONE), m.Timer.measureTimeAtStateStart(p.Mode.NORMAL, m.FlowState.WIN), this._isResponseReceived = !0, this.nextMode = t.nextMode, this._singleWin = t.totalBetLineWinnings, this.nextMode === this._normalMode) h.NolimitApplication.apiPlugin.events.trigger(u.APIEvent.ACTION_SPINS_ROUND_COMPLETE), s.NolimitPromotionPlugin.apiPlugIn.events.trigger(u.APIEvent.FINISH), s.NolimitPromotionPlugin.apiPlugIn.dialog.unlock("PIXIDialog"), this.startWhenReady();
						else {
							if (this.shouldPlayMaxWinInGame(t)) return this.promotionPlugin.minimize(), this._isPlayingBonusInGame = !0, this.onBonusRedirectToGameSide(), void s.NolimitPromotionPlugin.ASOptionsData.maxWin.playMaxWinInGame(t).then((t => {
								this._returnedFromGame = !0, this._isPlayingBonusInGame = !1, this._replayController.view.maximized(), this.promotionPlugin.maximize(), this.startWhenReady()
							}));
							if (this.shouldStopOnBonus(t)) {
								const e = t.asReplayWinData.featureName || "";
								return this._replayController.view.createStopOnBonusRound(e, t.nextMode), this._replayController.view.enablePlayPauseBtn(!1), this._replayController.view.setPlayState(!1), this._wantsPause = !1, this._replayController.onClickContinuePlayBonusInReplayFunc = () => {
									this._replayController.view.removeStopOnBonusRound(), this.replayController.view.enablePlayPauseBtn(!0), this.startSpin()
								}, void(this._replayController.onClickPlayBonusInGamePlayFunc = () => {
									this.launchBonusInGame(t), this.replayController.view.removeStopOnBonusRound(), this.replayController.view.enablePlayPauseBtn(!0)
								})
							}
							this.startSpin()
						}
					}
					launchBonusInGame(t) {
						var e;
						this.promotionPlugin.minimize(), this._isPlayingBonusInGame = !0;
						const i = {
							type: "FAKE_BET",
							isFakeBet: !0,
							replayAndFeatureBuy: !0
						};
						if (null === (e = s.NolimitPromotionPlugin.promoPanelGameConfiguration) || void 0 === e ? void 0 : e.onPlayBonusInGame) s.NolimitPromotionPlugin.promoPanelGameConfiguration.onPlayBonusInGame(t), h.NolimitApplication.apiPlugin.events.trigger("redirectingToBonusInGame", t), this.onBonusRedirectToGameSide();
						else {
							const e = new c.TimelineMax;
							e.add((() => {
								h.NolimitApplication.apiPlugin.events.trigger("redirectingToBonusInGame", t)
							})), e.add((() => {
								h.NolimitApplication.apiPlugin.events.trigger(u.APIEvent.BET, i)
							})), e.add((() => {
								h.NolimitApplication.apiPlugin.events.trigger(u.APIEvent.GAME, t)
							}), .1), e.add((() => {
								this.onBonusRedirectToGameSide()
							}), .2)
						}
						h.NolimitApplication.apiPlugin.slotStates.stateIsReady().then((() => {
							this._returnedFromGame = !0, this._isPlayingBonusInGame = !1, this._replayController.view.maximized(), this.promotionPlugin.maximize(), h.NolimitApplication.apiPlugin.events.trigger("redirectingToBonusInGameComplete"), (new c.TimelineMax).add((() => {
								this.startSpin()
							}), .2)
						}))
					}
					onBonusRedirectToGameSide() {
						h.NolimitApplication.apiPlugin.events.once(u.APIEvent.GAME, (t => {
							if (_.ResponseParser.addASReplayWinData(t, this._view.betPanel.getValue(), this._fsData), (t.asReplayWinData.freeSpinTriggeredThisSpin || this._fsData) && (this._fsData = t), t.nextMode === p.Mode.NORMAL && this._fsData && (this._fsData = void 0), this.nextMode = t.nextMode, t.asReplayWinData.isRoundComplete)
								if (t.nextMode === this._normalMode)
									if (this._actionSpinData) {
										const e = {
											time: this._actionSpinData.time,
											gameRoundId: this._actionSpinData.gameRoundId
										};
										a.Logger.logDev("Action Spin : afterRedirectToMainGame data ", e, t.asReplayWinData), this._roundInfoTl = this._replayController.updateRawData(t.asReplayWinData, e), this._actionSpinData = void 0
									} else this.actionSpinDataPromise().then((e => {
										a.Logger.logDev("Action Spin : afterRedirectMainGame roundId data ", e, t.asReplayWinData), this._roundInfoTl = this._replayController.updateRawData(t.asReplayWinData, e), this._actionSpinData = void 0
									}));
							else a.Logger.logDev("Action Spin : onBonusRedirectToGameSide nextMode is not normal :: roundId data ", t.asReplayWinData), this._roundInfoTl = this._replayController.updateRawData(t.asReplayWinData), setTimeout((() => this.onBonusRedirectToGameSide()), 0);
							else setTimeout((() => this.onBonusRedirectToGameSide()), 0)
						}))
					}
					shouldPlayMaxWinInGame(t) {
						var e, i, n, o, r, a;
						if (!t.asReplayWinData.isWinCapHit) return !1;
						let l = !0;
						return (null === (i = null === (e = s.NolimitPromotionPlugin.ASOptionsData) || void 0 === e ? void 0 : e.maxWin) || void 0 === i ? void 0 : i.shouldPlayMaxWinInGame) && (l = null === (o = null === (n = s.NolimitPromotionPlugin.ASOptionsData) || void 0 === n ? void 0 : n.maxWin) || void 0 === o ? void 0 : o.shouldPlayMaxWinInGame(t)), l && null != (null === (a = null === (r = s.NolimitPromotionPlugin.ASOptionsData) || void 0 === r ? void 0 : r.maxWin) || void 0 === a ? void 0 : a.playMaxWinInGame)
					}
					shouldStopOnBonus(t) {
						const e = b.settings.stopOnBonus,
							i = b.isLegalStopOnBonusMode(t),
							n = t.asReplayWinData.freeSpinTriggeredThisSpin;
						let o = !0;
						const r = s.NolimitPromotionPlugin.apiPlugIn.betFeatureController.getActiveBetFeature();
						return "FREESPIN" === (null == r ? void 0 : r.type) && (o = !1), e && i && n && o
					}
					static isLegalStopOnBonusMode(t) {
						var e;
						return (null === (e = s.NolimitPromotionPlugin.promoPanelGameConfiguration) || void 0 === e ? void 0 : e.isLegalStopOnBonusMode) ? s.NolimitPromotionPlugin.promoPanelGameConfiguration.isLegalStopOnBonusMode(t) : b.isNormalMode(t.mode) || b.isPickMode(t.nextMode)
					}
					static isLegalGambleMode(t) {
						var e;
						return !!(null === (e = s.NolimitPromotionPlugin.promoPanelGameConfiguration) || void 0 === e ? void 0 : e.isLegalGambleMode) && s.NolimitPromotionPlugin.promoPanelGameConfiguration.isLegalGambleMode(t)
					}
					static isNormalMode(t) {
						return t.indexOf("NORMAL") > -1
					}
					static isGambleMode(t) {
						return !!(t.indexOf("GAMBLE") > -1 && b.isLegalGambleMode(t))
					}
					static isPickMode(t) {
						if (t.indexOf("PICK") > -1) return !0;
						for (let e of b.pickModes)
							if (e == t) return !0;
						return !1
					}
					static triggerSound(t) {
						var e;
						(null === (e = s.NolimitPromotionPlugin.promoPanelGameConfiguration) || void 0 === e ? void 0 : e.onActionSpinPlaySound) && s.NolimitPromotionPlugin.promoPanelGameConfiguration.onActionSpinPlaySound(t)
					}
				}
				b.bonusBuyData = void 0, e.ActionSpinsController = b
			},
			61982: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ActionSpinsView = void 0;
				const n = i(51797),
					s = i(50799),
					o = i(2425),
					r = i(56401),
					a = i(63288),
					l = i(91275),
					h = i(72468),
					u = i(71855),
					c = i(19803),
					d = i(39055),
					p = i(59934),
					_ = i(11395),
					m = i(77549),
					g = i(54004),
					f = i(61e3),
					S = i(8468),
					y = i(50061),
					v = i(79970);
				class T extends n.FeatureBasePanel {
					get capToggle() {
						return this._capToggle
					}
					get mainGameView() {
						return this._mainGameView
					}
					get gameOptionsView() {
						return this._gameOptionsView
					}
					constructor(t, e) {
						super(s.PromoPanelAssetConfig.ACTION_SPINS_ICON, o.NolimitPromotionPlugin.apiPlugIn.translations.translate(r.PromoPanelLabelIDs.ACTION_SPINS), a.PromoPanelTextStyles.FEATURE_ACTION_SPIN_REPLAY_TITLE), this._currentState = "", this.stopOnBonusCallback = t => {
							this.updateOptionsState()
						}, this._controller = t, this._scroll = e
					}
					init() {
						if (super.init(), this._wrapper = new PIXI.Container, this._wrapper.name = "MAIN_VIEW_WRAPPER", this.addChild(this._wrapper), this._mainGameView = new p.ActionSpinMainGameView(this._controller), this._gameOptionsView = new S.ASGameOptionsView(o.NolimitPromotionPlugin.ASOptionsData, this._controller.onGameOptionUpdate), this._nolimitBonusView = new y.ASNolimitBonusView(this._controller), this.betPanel = new g.ASBetPanelView(d.PromoPanelButtonIDs.ACTION_SPINS_BET_UP, d.PromoPanelButtonIDs.ACTION_SPINS_BET_DOWN, (t => this._controller.buttonClick(t)), T.ACTIVE_COLOR), this.spinsPanel = new g.ASBetPanelView(d.PromoPanelButtonIDs.ACTION_SPINS_COUNT_UP, d.PromoPanelButtonIDs.ACTION_SPINS_COUNT_DOWN, (t => this._controller.buttonClick(t)), T.ACTIVE_COLOR, !0), this._betAndSpinsContainer = new PIXI.Container, this._betAndSpinsContainer.addChild(this.betPanel, this.spinsPanel), this._betAndSpinsContainer.name = "betAndSpinsContainer", o.NolimitPromotionPlugin.apiPlugIn.betLevel.hasCapWinLimitToggle()) {
							this._capToggle = new v.LimitCapButton(d.PromoPanelButtonIDs.CAP_WIN_TOGGLE), this._capToggle.toggled = o.NolimitPromotionPlugin.apiPlugIn.betLevel.isCapWinLimitToggled(), this._capToggle.enable(!0), this._capToggle.addClickCallback((() => this._controller.buttonClick(this._capToggle)));
							const t = o.NolimitPromotionPlugin.apiPlugIn.betLevel.getButtonLabels();
							this._capToggle.addBylines(t.onLabel, t.offLabel), this._betAndSpinsContainer.addChild(this._capToggle)
						}
						this._wrapper.addChild(this._logo, this._title), this._wrapper.addChild(this._betAndSpinsContainer, this._nolimitBonusView, this._gameOptionsView, this._mainGameView), this._gameOptionsView.init(), this._gameOptionsView.setVisibleSelectors(!0, !0, !0), l.ActionSpinsController.settings.addCallback(l.ActionSpinsController.settings.STOP_ON_BONUS, this.stopOnBonusCallback), this.updateOptionsState()
					}
					onOrientationChanged() {
						this._controller.replayController.view.onOrientationChanged()
					}
					onResize() {
						if (this._isOpen) {
							const t = h.NolimitApplication.screenBounds,
								e = h.NolimitApplication.isLandscape && u.Helper.isDefaultScreenRatio(t);
							let i = t.width;
							this._scroll.position.set(0, 105);
							const n = new PIXI.Rectangle(c.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, 0, t.width - c.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, t.height - o.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - 1);
							if (e) i = t.width - c.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT;
							else if (h.NolimitApplication.isLandscape && !u.Helper.isDefaultScreenRatio(t)) i = t.width - c.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT;
							else {
								const e = f.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.TOP_BAR).height - 10;
								n.width = i, n.height = t.height - o.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - e - c.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, n.x = 0, n.y = e
							}
							this._scroll.resize(n.width, n.height), this._scroll.position.set(n.x, n.y), this.position.set(0, 0), super.onResize(), this._scroll.updateContent();
							const r = 7;
							this.betPanel.resize(e), this.betPanel.pivot.set(.5 * this.betPanel.width, 0), this.spinsPanel.resize(e), this.spinsPanel.pivot.set(.5 * this.spinsPanel.width, 0), this.spinsPanel.position.set(0, this.betPanel.height + r), this._capToggle && this._capToggle.position.set(Math.floor(-.5 * this._capToggle.width), this.spinsPanel.y + this.spinsPanel.height + r);
							let a = 145;
							this._betAndSpinsContainer.position.set(.5 * i, a), a += this._betAndSpinsContainer.height, this._nolimitBonusView.visible && (a += 2 * r, this._nolimitBonusView.position.set(.5 * i - .5 * this._nolimitBonusView.width, a), a += this._nolimitBonusView.height), a += 2 * r, this._gameOptionsView.position.set(.5 * i, a), this._gameOptionsView.pivot.set(.5 * this.betPanel.width, 0), a += this._gameOptionsView.height, a += 4 * r, this._mainGameView.resize(e), this._mainGameView.position.set(.5 * i, a), this._controller.replayController.view.onResize()
						}
					}
					onUpdateBuyFeaturePrice(t) {
						return 0
					}
					onUpdateSelectedFeatureBet() {
						this.updateOptionsState()
					}
					updateOptionsState() {
						var t, e, i;
						this._nolimitBonusView.updateBonusButtonStates();
						let n = !0;
						"FREESPIN" === (null === (t = this._controller.selectedFeatureBet) || void 0 === t ? void 0 : t.type) && (n = !1), this._mainGameView.setStopOnBonusEnableState(n);
						let s = !1;
						(null === (i = null === (e = o.NolimitPromotionPlugin.ASOptionsData) || void 0 === e ? void 0 : e.bonusGame) || void 0 === i ? void 0 : i.pickNeededForBuyFeatures) && this._controller.selectedFeatureBet && (s = o.NolimitPromotionPlugin.ASOptionsData.bonusGame.pickNeededForBuyFeatures.indexOf(this._controller.selectedFeatureBet.name) > -1), s || !l.ActionSpinsController.settings.stopOnBonus && n ? this._gameOptionsView.enableBonusOption(!0) : this._gameOptionsView.enableBonusOption(!1), this._controller.onGameOptionUpdate()
					}
					open() {
						super.open(), this.showWrapper(), this._controller.onGameOptionUpdate(), this._scroll.visible = !0, this.enableScroll(!0), this._scroll.updateContent()
					}
					close() {
						super.close(), _.ASStopSettings.reset(), this.enableScroll(!1), this._scroll.visible = !1, this._currentState = ""
					}
					disableBetButtons() {
						this.betPanel.betSelector.enableUpButton(!1), this.betPanel.betSelector.enableDownButton(!1)
					}
					onBetChange(t) {
						this.gameOptionsView.onUpdateBet(), this._nolimitBonusView.updateBetLevel(t), this.betPanel.setValue(+t)
					}
					getBet() {
						return this.betPanel.getValue()
					}
					hideWrapper() {
						this._wrapper.visible = !1, this._scroll.updateContent()
					}
					showWrapper() {
						this._wrapper.visible = !0, this._scroll.reAddMouseHoverListener(), this._scroll.updateContent()
					}
					enableScroll(t) {
						this._scroll.scrollEnabled = t
					}
					enableASMainTab() {
						this._controller.updateStartButtonState(), h.NolimitApplication.events.trigger(m.PromoPanelEvents.TOGGLE_BUTTONS_ON_LIGHTING_SPINS, !0)
					}
				}
				T.ACTIVE_COLOR = PIXI.utils.string2hex("#f57f20"), e.ActionSpinsView = T
			},
			14643: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ASMainGameActionButtonView = void 0;
				const n = i(39055),
					s = i(91275),
					o = i(35239),
					r = i(1694),
					a = i(2425),
					l = i(56401);
				class h extends PIXI.Container {
					get stopSpinOnBonusBtn() {
						return this._stopSpinOnBonusBtn
					}
					get startButton() {
						return this._startButton
					}
					constructor(t) {
						super(), this._controller = t, this.initAnimation()
					}
					resize(t) {
						this._startButton.position.set(177, 0), this._stopOnBonusContainer.position.set(-177, -51)
					}
					initAnimation() {
						this._stopOnBonusContainer = new PIXI.Container, this._stopSpinOnBonusBtn = new o.StopOnBonusTriggeredToggleBtn(n.PromoPanelButtonIDs.ACTION_SPIN_STOP_ON_BONUS_TRIGGERED, a.NolimitPromotionPlugin.apiPlugIn.translations.translate(l.PromoPanelLabelIDs.STOP_ON_BONUS)), this._stopSpinOnBonusBtn.pivot.set(50, 0), this._stopSpinOnBonusBtn.position.set(0, 38), this._stopOnBonusContainer.addChild(this._stopSpinOnBonusBtn);
						const t = new PIXI.Sprite(PIXI.Texture.WHITE);
						t.anchor.set(.5, .5), t.tint = PIXI.utils.string2hex("#f57f20"), t.height = 90, t.width = 2, this._startButton = new r.ActionSpinsStartButton(this._controller), this.addChild(this._stopOnBonusContainer, t, this._startButton), this._stopSpinOnBonusBtn.toggled = s.ActionSpinsController.settings.stopOnBonus
					}
				}
				e.ASMainGameActionButtonView = h
			},
			1694: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ActionSpinsStartButton = void 0;
				const n = i(91746),
					s = i(56254),
					o = i(46980),
					r = i(85136),
					a = i(50799),
					l = i(66515),
					h = i(39055),
					u = i(2425),
					c = i(56401),
					d = i(63288),
					p = i(19803),
					_ = i(61e3);
				class m extends PIXI.Container {
					constructor(t) {
						super(), this._controller = t, this.initAnimation()
					}
					enableStartBtn(t) {
						this._spinBtn.alpha = t ? p.PromoPanelConfig.ENABLE_BTN_ALPHA : p.PromoPanelConfig.DISABLE_BTN_ALPHA, this._spinBtn.enable(t)
					}
					initAnimation() {
						this._startLabel = this.createLabel(), this._spinBtn = this.createButton(), this._spinBtn.position.set(.5 * -this._spinBtn.width, .5 * -this._spinBtn.height), this._startLabel.position.set(0, -7), this.addChild(this._spinBtn, this._startLabel)
					}
					createButton() {
						const t = new s.PointerStateColorSet(4294967295);
						let e = new o.PointerStateIconSet(new r.Icon(_.ImgLoader.getImgTexture(a.PromoPanelAssetConfig.ACTION_SPINS_BUY_BTN)));
						const i = new l.IconToggleButton(h.PromoPanelButtonIDs.ACTION_SPINS_SPIN_BUTTON, e, t);
						return i.enable(!0), i.addClickCallback((() => {
							this._controller.buttonClick(i)
						})), i.toggled = !1, i.scale.set(1.25), i
					}
					createLabel() {
						const t = new n.PromoPanelTextLabel(u.NolimitPromotionPlugin.apiPlugIn.translations.translate(c.PromoPanelLabelIDs.START), d.PromoPanelTextStyles.GAME_FEATURE_BUY_TEXT, {
							landscapeMaxWidth: 292,
							portraitMaxWidth: 274
						});
						return t.anchor.set(.5), t
					}
				}
				e.ActionSpinsStartButton = m
			},
			78147: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ASFreeSpinRoundInfoView = void 0;
				const n = i(2425),
					s = i(13801),
					o = i(12489),
					r = i(91746),
					a = i(63288),
					l = i(13006),
					h = i(2821),
					u = i(31674),
					c = i(46334),
					d = i(14108),
					p = i(88458),
					_ = i(73021),
					m = i(11499),
					g = i(91275);
				class f extends PIXI.Container {
					constructor(t, e, i, n) {
						super(), this._winData = e, c.Logger.logDev("ASFreeSpinRoundInfoView constructor called win data is : ", e), this._controller = t, this._index = i, this._parentRound = n, this.init()
					}
					start(t = 0) {
						const e = new l.TimelineLite;
						return n.NolimitPromotionPlugin.IS_MINIMIZED ? (this.alpha = 1, this._parentRound.updateFSTotalBetAndWin(), e) : (t && e.delay(t), e.add((() => {
							this._parentRound.updateFSTotalBetAndWin()
						})), this._winData.isBigWin ? (e.add((() => {
							this.alpha = 1
						})), e.add(this.getBigWinAnimation())) : (e.add((() => {
							this.alpha = 1, this._timesBetDisplay.alpha = 0, this._winText.alpha = 0, this._topLine.width = 0, this._bottomLine.width = 0
						})), e.add(l.TweenLite.to(this._topLine, .2, {
							ease: l.Power1.easeOut,
							width: 500
						}), 0), e.add(l.TweenLite.to(this._bottomLine, .2, {
							ease: l.Power1.easeOut,
							width: 500
						}), 0), e.add(l.TweenLite.to(this._winText, .05, {
							alpha: 1
						}), .05), e.add(l.TweenLite.to(this._timesBetDisplay, .06, {
							alpha: 1
						}), .04), e.add(this.getWinAnimation(this._winData.totalSpinWinnings > 0), 0)), e)
					}
					init() {
						this.createInfo(), this.onResize(), this.alpha = 0
					}
					onResize() {
						this._winText.onResize(), this._timesBetDisplay.position.set(374, .5 * this._bottomLine.position.y), this._timesBetDisplay.pivot.x = this._timesBetDisplay.width, this._winText.position.set(this._topLine.position.x - 2, .5 * this._bottomLine.position.y)
					}
					createInfo() {
						const t = new PIXI.Sprite(PIXI.Texture.WHITE);
						t.width = 500, t.tint = 0, t.height = 1;
						const e = new PIXI.Sprite(PIXI.Texture.WHITE);
						e.width = 500, e.tint = 0, e.height = 1, this._topLine = t, this._bottomLine = e, this._topLine.position.set(s.ASRoundInfoView.NORMAL_ROUND_LEFT_MARGIN + this._topLine.width, 0), this._bottomLine.position.set(s.ASRoundInfoView.NORMAL_ROUND_LEFT_MARGIN + this._bottomLine.width, 60), this._winText = new r.PromoPanelTextLabel("", a.PromoPanelTextStyles.AS_ROUND_INFO_WIN_STYLE, {
							landscapeMaxWidth: 150,
							portraitMaxWidth: 150
						}), this._winText.name = "wintext", this._winText.anchor.set(1, .5), this.updateWin(this._winData.totalSpinWinnings);
						let i = this._winData.winType === p.WINTYPE.MULTIPLIER ? this._winData.totalSpinWinnings : this._winData.calculatedTimesBetThisSpin;
						this._timesBetDisplay = new o.TimesBetDisplay(i, 150), this._topLine.alpha = .5, this._bottomLine.alpha = .5, this._topLine.anchor.x = this._bottomLine.anchor.x = 1, this.addChild(this._topLine, this._timesBetDisplay, this._winText, this._bottomLine)
					}
					updateWin(t) {
						const e = t > 0 ? "#fbc217" : "#000000",
							i = this._winText.getStyleClone();
						i.fill = PIXI.utils.string2hex(e), i.dropShadow = t > 0, this._winText.setStyle(i), this._winData.winType === p.WINTYPE.MULTIPLIER ? this._winText.text = t + "x" : this._winText.text = m.CurrencyUtils.format(t), this._winText.onResize()
					}
					getWinAnimation(t) {
						const e = new l.TimelineLite;
						if (!this._winData.isWinBelowStake) {
							const i = t ? "winCoins" : "noWin",
								n = new h.TimelineSprite(_.AnimationHelper.getAnimationTextures(i));
							n.visible = !1, n.anchor.set(.5), n.position.set(this._winText.x - .5 * this._winText.width, this._winText.y), e.add((() => {
								t && g.ActionSpinsController.triggerSound(d.ActionSpinSound.WIN), this.addChild(n)
							})), e.add(n.getAnimationAutoShowHide()), e.add((() => {
								this.removeChild(n)
							}))
						}
						return e
					}
					getBigWinAnimation() {
						const t = new u.BigWin;
						t.position.set(this._topLine.position.x + 65 - .5 * t.width, .5 * this.height - 4), this.addChild(t);
						const e = new l.TimelineLite;
						return e.add((() => {
							g.ActionSpinsController.triggerSound(d.ActionSpinSound.BIG_WIN)
						})), e.add(t.start()), e
					}
				}
				e.ASFreeSpinRoundInfoView = f
			},
			1769: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ASReplayController = void 0;
				const n = i(2425),
					s = i(22284),
					o = i(72468),
					r = i(77549),
					a = i(46334),
					l = i(13006),
					h = i(49490);
				e.ASReplayController = class {
					get asController() {
						return this._asController
					}
					get isPlaying() {
						return this._isPlaying
					}
					set isPlaying(t) {
						this._isPlaying = t
					}
					set fsCount(t) {
						this._fsCount = t
					}
					get accumulatedBet() {
						return this._accumulatedBet
					}
					set accumulatedBet(t) {
						this._accumulatedBet = t, this._view.setAccumulatedBet(t), this._view.setNetPosition(this._accumulatedWin - this._accumulatedBet)
					}
					get accumulatedWin() {
						return this._accumulatedWin
					}
					set accumulatedWin(t) {
						this._accumulatedWin = t, this._view.setAccumulatedWin(t)
					}
					get placedBet() {
						return this._placedBet
					}
					set placedBet(t) {
						this._placedBet = t, this._view.setPlacedBet(t)
					}
					get view() {
						return this._view
					}
					constructor(t) {
						this._isPlaying = !0, this._fsCount = 0, this._accumulatedBet = 0, this._accumulatedWin = 0, this._placedBet = 0, this._asController = t;
						const e = n.NolimitPromotionPlugin.apiPlugIn.communication.getParameters();
						this._communicationDataKey = e.key, this._communicationReplayUrl = e.url.replace("gs", ""), this.createView()
					}
					playBonusInGame() {
						this.onClickPlayBonusInGamePlayFunc && this.onClickPlayBonusInGamePlayFunc()
					}
					playContinueBonusInReplay() {
						this.onClickContinuePlayBonusInReplayFunc && this.onClickContinuePlayBonusInReplayFunc()
					}
					updateRawData(t, e) {
						a.Logger.logDev("updateRawData ", t, e);
						const i = new l.TimelineLite;
						return t.freeSpinTriggeredThisSpin && (this._view.isFSStart = !0), this._view.isFSStart ? (i.add(this._view.addFSRound(t, e)), "NORMAL" === t.nextMode && (this._view.isFSStart = !1)) : i.add(this._view.addRound(t, e)), i
					}
					openReplay(t) {
						a.Logger.logDev("Action Spin : PlayReplay btn clicked gameRoundId : ", t), n.NolimitPromotionPlugin.apiPlugIn.openReplay(parseInt(t))
					}
					onExpandBtnClick(t) {
						this._isPlaying || this._view.onExpandCollapse(t)
					}
					onPlayPauseBtnClick() {
						const t = this._view.togglePlayPauseBtn();
						t ? (this.isPlaying = !1, this._view.enablePlayPauseBtn(!1)) : (this.isPlaying = !0, this._view.onResume()), this._view.enableCloseBtn(!1), this._asController.pauseGame(t, !t)
					}
					onGameStopped(t = !1) {
						this.isPlaying = !1, this._view.onGameStopped(t)
					}
					onReplayCloseButtonClick() {
						n.NolimitPromotionPlugin.sound.playKeypadEffect("click"), this._asController.onReplayCloseButtonClick()
					}
					open() {
						this._isOpen = !0, o.NolimitApplication.apiPlugin.events.trigger(h.APIEvent.ACTION_SPINS_IS_ACTIVE, !0), o.NolimitApplication.events.trigger(r.PromoPanelEvents.SHOW_HIDE_CLOSE_BUTTON, !1), this.accumulatedBet = 0, this.accumulatedWin = 0, this.fsCount = 0, this.isPlaying = !0, this._view.reset(), this._view.setNetPosition(0), this._view.show()
					}
					close() {
						this._isOpen && (this._isOpen = !1, o.NolimitApplication.apiPlugin.events.trigger(h.APIEvent.ACTION_SPINS_IS_ACTIVE, !1), n.NolimitPromotionPlugin.apiPlugIn.events.trigger(h.APIEvent.SCREEN, "open"), this._view.hide(), this._view.reset())
					}
					createView() {
						null == this._view && (this._view = new s.ASReplayView(this), this._asController.promotionPlugin.view.addChild(this._view))
					}
					updateSpinsLeft(t) {
						this._view.setSpinsLeft(t)
					}
				}
			},
			22284: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ASReplayView = void 0;
				const n = i(72468),
					s = i(66515),
					o = i(77549),
					r = i(56254),
					a = i(46980),
					l = i(85136),
					h = i(39055),
					u = i(50799),
					c = i(2425),
					d = i(19803),
					p = i(13801),
					_ = i(66099),
					m = i(46334),
					g = i(13006),
					f = i(49490),
					S = i(91275),
					y = i(61e3),
					v = i(10604),
					T = i(69743),
					E = i(61952);
				class b extends PIXI.Container {
					get isOpen() {
						return this._isOpen
					}
					get isFSStart() {
						return this._isFSStart
					}
					set isFSStart(t) {
						this._isFSStart = t
					}
					constructor(t) {
						super(), this._replayRounds = [], this._isBlurred = !1, this._roundCounts = 0, this._isOpen = !1, this._isFSStart = !1, this._controller = t, this.addEventListeners(), this.init()
					}
					addBlur() {
						const t = new g.TimelineLite;
						return this._isBlurred || (this._isBlurred = !0, null == this.filters && (this.filters = []), this.filters.push(this._blur1, this._blur2), t.add([new g.TweenLite(this._blur1, .2, {
							blurX: 16,
							blurY: 16
						}), new g.TweenLite(this._blur2, .2, {
							blurX: 10,
							blurY: 10
						})])), t
					}
					removeBlur() {
						if (this._isBlurred) {
							const t = new g.TimelineLite({
								onComplete: () => {
									for (let t = this.filters.length - 1; t >= 0; t--) {
										const e = this.filters[t];
										e != this._blur1 && e != this._blur2 || this.filters.splice(t, 1)
									}
									this._isBlurred = !1
								}
							});
							return t.add([new g.TweenLite(this._blur1, .2, {
								blurX: 0,
								blurY: 0
							}), new g.TweenLite(this._blur2, .2, {
								blurX: 0,
								blurY: 0
							})]), t
						}
					}
					reset() {
						this._gameFeed.removeAllItems(), this._gameFeed.enableScroll(!1), this._roundCounts = 0
					}
					addRound(t, e) {
						m.Logger.logDev("addRound ", t, e);
						const i = {
							winData: t,
							replayData: e || {
								gameRoundId: "",
								time: ""
							}
						};
						let n;
						const s = this._gameFeed.getLastRoundData(),
							o = new g.TimelineLite;
						s && !s.isFS && s.winText.latestValue <= 0 && i.winData.totalWin <= 0 ? (n = s, o.add(n.updateZeroWinRounds(i, this._roundCounts + 1))) : (n = new p.ASRoundInfoView(this._controller, i, this._roundCounts, !1), n.winText.latestValue = t.totalWin, this._controller.accumulatedWin += i.winData.totalWin, this._gameFeed.addRoundData(n), o.add(this._gameFeed.updateRoundPositions(!c.NolimitPromotionPlugin.IS_MINIMIZED)), o.add(n.start())), this._roundCounts++;
						const r = this._gameFeed._topInfoBar.getAccumulatedWin() - this._gameFeed._topInfoBar.getAccumulatedBet();
						return this.setNetPosition(r), o
					}
					addFSRound(t, e) {
						m.Logger.logDev("addFSRound ", t, e);
						const i = new g.TimelineLite,
							n = t.freeSpinTriggeredThisSpin && !S.ActionSpinsController.isPickMode(t.mode),
							s = t.nextMode === d.Mode.NORMAL;
						if (m.Logger.logDev("addFSRound isNewRound ", n, " isLastRound : ", s), n) {
							const e = {
									winData: t,
									replayData: {
										gameRoundId: "",
										time: ""
									}
								},
								n = new p.ASRoundInfoView(this._controller, e, this._roundCounts, !0);
							n.winText.latestValue = t.totalWin, n.timesBetDisplay.timesBetLabel.latestValue = t.calculatedTotalWinTimesBet, this._gameFeed.addRoundData(n), i.add([n.start(), this._gameFeed.updateRoundPositions()]), this._roundCounts++
						} else {
							const n = this._gameFeed.getLastRoundData();
							n.winText.latestValue = t.totalWin, n.timesBetDisplay.timesBetLabel.latestValue = t.calculatedTotalWinTimesBet;
							const o = 69,
								r = 8,
								a = 10,
								l = 145;
							let h = i.duration();
							if (n.isFS ? (c.NolimitPromotionPlugin.IS_MINIMIZED ? s && (m.Logger.logDev("addFSRound lastRound : and minimized", t), n.updateFSOutline(!1, o + r + (n.addedFSCount ? 0 : a), o * (n.addedFSCount + 1) + l), n.resetFSRoundYPosOnNewRoundAdded(), this._gameFeed.updateRoundPositions(!1)) : (i.add([n.updateFSOutline(!0, o + r + (n.addedFSCount ? 0 : a), o * (n.addedFSCount + 1) + l), n.resetFSRoundYPosOnNewRoundAdded(), this._gameFeed.updateRoundPositions(!0)]), h = i.duration()), i.add(n.addFSRound(t).start(0), h)) : m.Logger.logDev("addFSRound winData", t), s) {
								const s = {
									winData: t,
									replayData: e || {
										gameRoundId: "",
										time: ""
									}
								};
								s.replayData.gameRoundId || m.Logger.warn("Invalid gameRoundId"), n.isFS && (s.winData.waitForAnimation = !0, h = i.duration()), i.add((() => {
									n.onRoundComplete(s)
								}), h), this._controller.accumulatedWin += t.totalWin;
								const o = this._gameFeed._topInfoBar.getAccumulatedWin() - this._gameFeed._topInfoBar.getAccumulatedBet();
								this.setNetPosition(o)
							}
						}
						return i
					}
					onGameStopped(t) {
						this.enablePlayPauseBtn(t), this.setPlayState(!0), this._spinControls.enableRoundsButtons(!0, this._controller.asController.spinsLeft), this.setSpinsLeft(this._controller.asController.spinsLeft), this._gameFeed.enableInteraction(!0), this.enableCloseBtn(!0)
					}
					onResume() {
						this._spinControls.enableRoundsButtons(!1, this._controller.asController.spinsLeft), this._gameFeed.enableInteraction(!1)
					}
					show() {
						this._isOpen = !0, this.onResize(), this.visible = !0, this.setPlayState(!1), this.enablePlayPauseBtn(!0), this.enableCloseBtn(!1), this._spinControls.enableRoundsButtons(!1, this._controller.asController.spinsLeft), this._gameFeed.enableInteraction(!1), this.updateSoundButton()
					}
					maximized() {
						this.updateSoundButton()
					}
					hide() {
						this._soundButton.stopLoadingAnimation(), this._isOpen = !1, this.visible = !1
					}
					enableReplayButtons(t) {
						this._replayRounds.forEach((e => {
							e.enableReplayBtn(t)
						})), this._gameFeed.enableScroll(!0)
					}
					createStopOnBonusRound(t, e) {
						const i = this._gameFeed.getLastRoundData();
						this._replayItemWithStopOnBonusView = i;
						const n = new _.ASStopOnBonusRoundInfoView(this._controller, t, e);
						n.position.y = 0, n.position.x = 22, this._replayItemWithStopOnBonusView.addStopOnBonusRoundInfo(n), this._gameFeed.updateRoundPositions(!0)
					}
					removeStopOnBonusRound() {
						this._replayItemWithStopOnBonusView && (this._replayItemWithStopOnBonusView.removeStopOnBonusRoundInfo(), this._gameFeed.updateRoundPositions())
					}
					onExpandCollapse(t) {
						t.onExpandBtnClick(), this._gameFeed.updateRoundPositions(!1, this._gameFeed.currentlyVisible), this._gameFeed._scroll.updateContent()
					}
					onOrientationChanged() {
						this._gameFeed.orientationChanged()
					}
					onResize() {
						if (this._isOpen) {
							const t = n.NolimitApplication.screenBounds;
							this._bg.position.set(.5 * t.width, .5 * t.height), this._gameLogo.alpha = 1;
							const e = 80;
							if (n.NolimitApplication.isLandscape) {
								this._gameFeed.position.set(t.width - 840, 40), this._gameFeed.resize(664);
								const i = this._gameFeed.x + 16;
								this._gameLogo.position.set(.5 * i, 26), this._gameLogo.scale.set(1, 1), this._gameLogo.width > i ? (this._gameLogo.width = i, this._gameLogo.scale.y = this._gameLogo.scale.x, this._gameLogo.scale.x < .5 && (this._gameLogo.visible = !1)) : this._gameLogo.visible = !0, this._closeButton.position.set(t.width - e - .5 * this._closeButton.width, 36), this._closeBtnXmark.position.set(this._closeButton.x + .5 * this._closeButton.width, this._closeButton.y + .5 * this._closeButton.height - 4), this._spinControls.position.set(t.width - e, 420), this._soundButton.position.set(20, t.height - this._soundButton.height - 60)
							} else this._gameFeed.position.set(13, 210), this._gameLogo.position.set(.5 * t.width, 26), this._gameLogo.scale.set(1, 1), this._gameLogo.visible = !0, this._closeButton.position.set(t.width - this._closeButton.width - 5, 14), this._closeBtnXmark.position.set(this._closeButton.x + .5 * this._closeButton.width, this._closeButton.y + .5 * this._closeButton.height - 4), this._spinControls.position.set(.5 * t.width, Math.floor(t.height - this._spinControls.height - 10)), this._soundButton.position.set(20, t.height - this._soundButton.height - 60), this._gameFeed.resize(this._spinControls.y - this._gameFeed.position.y - 15);
							this._gameFeed._scroll.updateContent(), this._spinControls.resize()
						}
					}
					enableCloseBtn(t) {
						this._closeButton.enable(t), t ? (this._closeButton.alpha = d.PromoPanelConfig.ENABLE_BTN_ALPHA, this._closeBtnXmark.alpha = d.PromoPanelConfig.ENABLE_BTN_ALPHA) : (this._closeButton.alpha = d.PromoPanelConfig.DISABLE_BTN_ALPHA, this._closeBtnXmark.alpha = d.PromoPanelConfig.DISABLE_BTN_ALPHA)
					}
					togglePlayPauseBtn() {
						return this._spinControls.togglePlayButton()
					}
					setPlayState(t) {
						this._spinControls.setPlayState(t)
					}
					enablePlayPauseBtn(t) {
						this._spinControls.enablePlayPauseBtn(t)
					}
					setSpinsLeft(t) {
						this._spinControls.setSpinsLeft(t)
					}
					setPlacedBet(t) {
						this._gameFeed._topInfoBar.setPlacedBet(t)
					}
					setAccumulatedBet(t) {
						this._gameFeed._topInfoBar.setAccumulatedBet(t)
					}
					setAccumulatedWin(t) {
						this._gameFeed._topInfoBar.setAccumulatedWin(t)
					}
					setNetPosition(t) {
						c.NolimitPromotionPlugin.apiPlugIn.events.trigger(f.APIEvent.WIN)
					}
					createBlurFilters() {
						this._blur1 = new PIXI.filters.BlurFilter(0, 6), this._blur1.autoFit = !0, this._blur1.repeatEdgePixels = !1, this._blur2 = new PIXI.filters.BlurFilter(0, 6), this._blur2.autoFit = !0, this._blur2.repeatEdgePixels = !1
					}
					init() {
						var t, e;
						this._bg = new PIXI.Sprite(c.NolimitPromotionPlugin.imgLoader.getImgTexture((null === (e = null === (t = c.NolimitPromotionPlugin.ASOptionsData) || void 0 === t ? void 0 : t.graphics) || void 0 === e ? void 0 : e.backgroundTextureName) || "AS_REPLAY_BG")), this._bg.name = "AS_REPLAY_BG", this._bg.anchor.set(.5, .5), this._bg.interactive = !0, this._gameLogo = new PIXI.Sprite(c.NolimitPromotionPlugin.imgLoader.getImgTexture("AS_GAME_LOGO")), this._gameLogo.name = "AS_GAME_LOGO", this._gameLogo.anchor.set(.5, 0), this._gameFeed = new v.ActionSpinsGameFeedView;
						const i = new a.PointerStateIconSet(new l.Icon(y.ImgLoader.getImgTexture(u.PromoPanelAssetConfig.CLOSE_BG_ICON))),
							n = new r.PointerStateColorSet(4294967295);
						this._closeButton = new s.IconToggleButton(h.PromoPanelButtonIDs.CLOSE, i, n), this._closeButton.addClickCallback((() => this._controller.onReplayCloseButtonClick())), this._closeButton.toggled = !1, this._closeButton.enable(!0), this._closeBtnXmark = new PIXI.Sprite(y.ImgLoader.getImgTexture(u.PromoPanelAssetConfig.CLOSE)), this._closeBtnXmark.tint = 0, this._closeBtnXmark.anchor.set(.5, .5), this._closeBtnXmark.pivot.y = -3, this._spinControls = new T.SpinControls(this._controller), this._soundButton = new E.SoundButton("sound"), this._soundButton.position.set(200, 200), this._soundButton.addClickCallback((() => {
							c.NolimitPromotionPlugin.sound.toggleQuickMute(), this.updateSoundButton()
						})), this.updateSoundButton(), this.addChild(this._bg, this._gameLogo, this._gameFeed, this._closeButton, this._closeBtnXmark, this._spinControls, this._soundButton), this.createBlurFilters(), this.hide()
					}
					updateSoundButton() {
						const t = c.NolimitPromotionPlugin.sound.isLoaded,
							e = c.NolimitPromotionPlugin.sound.loading,
							i = !c.NolimitPromotionPlugin.sound.isQuickMute();
						e || i && !t ? (this._soundButton.toggled = !1, this._soundButton.enable(!1), this._soundButton.startLoadingAnimation((() => {
							this.updateSoundButton()
						}))) : (this._soundButton.stopLoadingAnimation(), this._soundButton.toggled = i, this._soundButton.enable(!0))
					}
					addEventListeners() {
						c.NolimitPromotionPlugin.apiPlugIn.events.on(o.PromoPanelEvents.AS_REPLAY_ADD_BLUR, (() => this.addBlur())), c.NolimitPromotionPlugin.apiPlugIn.events.on(o.PromoPanelEvents.AS_REPLAY_REMOVE_BLUR, (() => this.removeBlur()))
					}
				}
				e.ASReplayView = b
			},
			13801: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ASRoundInfoView = void 0;
				const n = i(66515),
					s = i(71855),
					o = i(56254),
					r = i(46980),
					a = i(85136),
					l = i(50799),
					h = i(39055),
					u = i(2425),
					c = i(63288),
					d = i(78147),
					p = i(68714),
					_ = i(91746),
					m = i(19803),
					g = i(46334),
					f = i(13006),
					S = i(2821),
					y = i(12489),
					v = i(31674),
					T = i(14108),
					E = i(61e3),
					b = i(73021),
					A = i(11499),
					P = i(50106),
					I = i(91275);
				class w extends PIXI.Container {
					get roundNo() {
						return this._roundNo
					}
					get timesBetDisplay() {
						return this._timesBetDisplay
					}
					get winText() {
						return this._winText
					}
					get isFS() {
						return this._isFS
					}
					get addedFSCount() {
						return this._fsRoundContainer.children.length
					}
					get data() {
						return this._data
					}
					get targetHeight() {
						return this._targetHeight ? this._targetHeight : this.height
					}
					set targetHeight(t) {
						this._targetHeight = t
					}
					constructor(t, e, i, n = !1) {
						super(), this._isFS = !1, this._isFSTriggeredRound = !1, this._isEnabled = !1, this._data = e, this._controller = t, this._roundNo = i, this._isFS = n, this._isFSTriggeredRound = e.winData.freeSpinTriggeredThisSpin, this.alpha = 0, this.init()
					}
					enableInteraction(t) {
						this._isEnabled = t, t ? this._isFS ? (this.enableReplayBtn(!0), this._balance.position.y = s.Helper.floorPos(65 + .5 * this._balance.height), this.updateFSOutline()) : this.enableReplayBtn(this._data.winData.totalWin > 0) : this.enableReplayBtn(!1)
					}
					start() {
						const t = new f.TimelineLite;
						return u.NolimitPromotionPlugin.IS_MINIMIZED ? (this.alpha = 1, this.isFS && (this.updateFSOutline(!1, 15), this._bonusSummaryContainer.alpha = 1), t) : (t.add((() => {
							this.alpha = 1
						})), this.isFS ? (t.add((() => {
							this._stopOnBonusRoundInfoView || this.updateFSOutline(!1)
						})), t.add(f.TweenLite.to(this._bonusSummaryContainer, .2, {
							alpha: 1
						}), .1)) : this._data.winData.isBigWin ? (t.add((() => {
							this._idAndDate.alpha = 0
						})), t.add(this.getBigWinAnimation()), t.add((() => {
							f.TweenLite.to(this._idAndDate, t.totalDuration(), {
								alpha: 1
							})
						}), .1)) : (t.add((() => {
							this._balance.alpha = 0, this._timesBetDisplay.alpha = 0, this._winText.alpha = 0, this._border.scale.x = 0, this._idAndDate.alpha = 0
						})), t.add(f.TweenLite.to(this._border.scale, .4, {
							ease: f.Power1.easeOut,
							x: 1
						}), 0), t.add(f.TweenLite.to(this._winText, .15, {
							alpha: 1
						}), .1), t.add(f.TweenLite.to(this._timesBetDisplay, .18, {
							alpha: 1
						}), .15), t.add(f.TweenLite.to(this._balance, .12, {
							alpha: 1
						}), .28), t.add(f.TweenLite.to(this._idAndDate, .12, {
							alpha: 1
						}), .28), t.add(this.getWinAnimation(this._data.winData.totalWin > 0), 0)), t)
					}
					updateZeroWinRounds(t, e) {
						return g.Logger.logDev("AS : updateZeroWinRounds : ", t, e, this._data), this.updateBalance(t), this._idAndDate.updateDate(t.replayData.time), this._idAndDate.updateId(e), this.updateTopline(), this._data.winData.totalWin > 0 && console.warn("invalid zero win rounds"), this.getWinAnimation(!1)
					}
					addStopOnBonusRoundInfo(t) {
						this._stopOnBonusRoundInfoView = t, this.addChild(this._stopOnBonusRoundInfoView), this._winText.visible = !1, this._bonusSummaryContainer.visible = !1, this.updateFSOutline(!1, 15), this.updateTransform()
					}
					removeStopOnBonusRoundInfo() {
						this._winText.visible = !0, this._bonusSummaryContainer.visible = !0, this._stopOnBonusRoundInfoView && (this.removeChild(this._stopOnBonusRoundInfoView), this._stopOnBonusRoundInfoView = void 0, this.updateFSOutline(!1, 15))
					}
					onExpandBtnClick() {
						this._expandButton.toggled = !this._expandButton.toggled, this._expandButton.toggled ? (this._fsRoundContainer.visible = !1, this._bonusSummaryContainer && (this._bonusSummaryContainer.visible = !1), this._expandButton.angle = -90) : (this._expandButton.angle = 0, this._fsRoundContainer.visible = !0, this._bonusSummaryContainer && (this._bonusSummaryContainer.visible = !0)), this.updateFSOutline()
					}
					collapseRound() {
						this._expandButton.toggled = !0, this._expandButton.toggled && (this._fsRoundContainer.visible = !1, this._bonusSummaryContainer && (this._bonusSummaryContainer.visible = !1), this._expandButton.angle = -90), this.updateFSOutline()
					}
					updateFSOutline(t = !1, e = 0, i = 0) {
						const n = new f.TimelineLite;
						if (!this.isFS) return n;
						if (this._border instanceof PIXI.NineSlicePlane) {
							this._border.visible = !1;
							const s = i || Math.max(this.height + e, 60) - 5;
							this._border.visible = !0, t ? n.add([f.TweenLite.to(this._border, .2, {
								height: s
							})]) : this._border.height = s, this.targetHeight = s - this.pivot.y
						}
						return n
					}
					enableReplayBtn(t) {
						t ? (this.isFS || +this._data.winData.totalWin > 0) && this._replayBtn.enable(t) : this._replayBtn.enable(t)
					}
					onRoundComplete(t) {
						this.setPlayBtnName(t.replayData.gameRoundId), this.isFS && (this._expandButton.visible = !0, this._controller.view.onExpandCollapse(this), this._idAndDate.updateDate(t.replayData.time), this.updateBalance(t))
					}
					updateTopline() {
						this._topLine && (this._topLine.position.set(this._idAndDate.width + 8, 0), this._topLine.width = 500 - this._topLine.position.x)
					}
					init() {
						var t;
						this._border = this.createInitialBorder(), this._border.name = "border", this.addChild(this._border), this._idAndDate = new P.IdAndDateBox(this._roundNo + 1 + "", null === (t = this._data.replayData) || void 0 === t ? void 0 : t.time), this._idAndDate.name = "idAndDate", this._idAndDate.position.set(50, -10), this.addChild(this._idAndDate), this.updateTopline(), this.createInfo(), this.createBtn(), this.isFS || this.setPlayBtnName(this._data.replayData.gameRoundId), this.onResize(), this.pivot.y = -10, this.targetHeight = this.height
					}
					addFSRound(t) {
						const e = this._fsRoundContainer.children.length,
							i = new d.ASFreeSpinRoundInfoView(this._controller, t, e, this);
						if (i.position.y = 8, this.updateFsRoundHeader(u.NolimitPromotionPlugin.apiPlugIn.translations.translate(t.featureName || "")), this._fsRoundContainer.addChild(i), t.nextMode === m.Mode.NORMAL) {
							const t = (new PIXI.Graphics).lineStyle(0, 0).moveTo(360, 1).lineTo(400, 1);
							this._fsRoundContainer.addChild(t), t.position.y = this._fsRoundContainer.height + 8
						}
						return this._bonusSummaryContainer && (this._bonusSummaryContainer.visible = !0), i
					}
					updateFsRoundHeader(t) {
						if (this._featureName.text != t && (this._featureName.text = t, this._featureName.width >= 330)) {
							const t = 330 / this._featureName.width,
								e = this._featureName.getStyleClone();
							e.fontSize = Number(e.fontSize) * t, this._featureName.setStyle(e)
						}
					}
					resetFSRoundYPosOnNewRoundAdded() {
						const t = new f.TimelineLite;
						let e = 8;
						for (let i = this._fsRoundContainer.children.length - 1; i >= 0; i--) {
							const n = this._fsRoundContainer.children[i];
							e += 69, t.to(n, .2, {
								y: e
							}, 0)
						}
						return t
					}
					createInitialBorder() {
						let t = new PIXI.Container;
						if (this.isFS) t = new PIXI.NineSlicePlane(E.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.BONUS_ROUND_OUTLINE), 140, 23, 23, 23), t.position.set(25, 0), t.width = 608, t.height = 44;
						else {
							const e = 500,
								i = new PIXI.Sprite(PIXI.Texture.WHITE);
							i.position.set(108, 0), i.width = e - 108, i.tint = 0, i.height = 1, this._topLine = i;
							const n = new PIXI.Sprite(PIXI.Texture.WHITE);
							n.tint = 0, n.width = e, n.height = 1, n.position.set(0, 60), t.addChild(i, n), t.pivot.set(e, 30), t.position.set(w.NORMAL_ROUND_LEFT_MARGIN + e, 30)
						}
						return t
					}
					updateFSTotalBetAndWin() {
						this._timesBetDisplay.updateTimesBet(this._timesBetDisplay.timesBetLabel.latestValue), this.updateWin(this.winText.latestValue), this.setTimesBetDisplayPos()
					}
					createInfo() {
						if (this._balance = new _.PromoPanelTextLabel("", c.PromoPanelTextStyles.AS_ROUND_INFO_X_BET_STYLE, {
								landscapeMaxWidth: 165,
								portraitMaxWidth: 165
							}), this._balance.name = "balance", this._balance.anchor.set(0, .5), this._balance.position.set(w.NORMAL_ROUND_LEFT_MARGIN, 30), this._timesBetDisplay = new y.TimesBetDisplay(this._data.winData.calculatedTotalWinTimesBet, 150), this._winText = new _.TextLabelAdvanced("", c.PromoPanelTextStyles.AS_ROUND_INFO_WIN_STYLE, {
								landscapeMaxWidth: 145,
								portraitMaxWidth: 145
							}), this._winText.name = "wintext", this._winText.anchor.set(1, .5), this.addChild(this._balance, this._timesBetDisplay, this._winText), this.updateWin(this._data.winData.totalWin), this.updateBalance(this._data), this.isFS) {
							const t = u.NolimitPromotionPlugin.apiPlugIn.translations.translate(this._data.winData.featureName || "");
							this._featureName = new p.Label("", c.PromoPanelTextStyles.AS_ROUND_INFO_RE_SPIN_STYLE), this._featureName.name = "featureNameLabel", this._featureName.anchor.set(0, .5), this.updateFsRoundHeader(t), this._fsRoundContainer = new PIXI.Container, this._fsRoundContainer.name = "subRoundContainer", this._fsRoundContainer.position.y = 102, this.addChild(this._featureName, this._fsRoundContainer), this._isFSTriggeredRound && (this._bonusSummaryContainer = new PIXI.Container, this._bonusSummaryContainer.name = "BonusSummeryContainer", this._blueBG = new PIXI.Sprite(E.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.GAME_FEED_BONUS_INFO_BG)), this._blueBG.width = 608, this._blueBG.position.set(.5 * w.NORMAL_ROUND_LEFT_MARGIN, 60), this._balance.position.y = this._blueBG.position.y + .5 * this._blueBG.height, this._winText.position.y = this._blueBG.position.y + .5 * this._blueBG.height, this._bonusSummaryContainer.addChild(this._blueBG, this._balance, this._timesBetDisplay), this.addChildAt(this._bonusSummaryContainer, 0), this._bonusSummaryContainer.alpha = 0)
						}
					}
					updateWin(t) {
						const e = t > 0 ? "#fbc217" : "#000000",
							i = this._winText.getStyleClone();
						i.fill = PIXI.utils.string2hex(e), i.dropShadow = t > 0, this._winText.setStyle(i), this._winText.text = A.CurrencyUtils.format(t), this._winText.onResize()
					}
					onResize() {
						var t;
						this._winText.onResize(), this.setTimesBetDisplayPos(), this._isFS ? (this._winText.position.set(548, 30), this._balance.position.y = this._blueBG.position.y + .5 * this._blueBG.height) : this._winText.position.set(548, 30), this._isFS ? (this._expandButton.position.set(50, 30), null === (t = this._featureName) || void 0 === t || t.position.set(70, 30), this._replayBtn.position.x = s.Helper.floorPos(w.NORMAL_ROUND_LEFT_MARGIN + 500 + this._replayBtn.pivot.x + 10), this._replayBtn.position.y = 30) : (this._replayBtn.position.x = s.Helper.floorPos(w.NORMAL_ROUND_LEFT_MARGIN + this._border.width + this._replayBtn.pivot.x + 10), this._replayBtn.position.y = 30)
					}
					setTimesBetDisplayPos() {
						this._timesBetDisplay.position.set(374, 30), this.isFS && (this._timesBetDisplay.position.y = this._blueBG.position.y + .5 * this._blueBG.height), this._timesBetDisplay.pivot.x = this._timesBetDisplay.width
					}
					getWinAnimation(t) {
						const e = new f.TimelineLite;
						if (!this._data.winData.isWinBelowStake) {
							const i = t ? "winCoins" : "noWin",
								n = new S.TimelineSprite(b.AnimationHelper.getAnimationTextures(i));
							n.visible = !1, n.anchor.set(.5), n.position.set(this._winText.x - .5 * this._winText.width, this._winText.y), e.add((() => {
								t && I.ActionSpinsController.triggerSound(T.ActionSpinSound.WIN), this.addChild(n)
							})), e.add(n.getAnimationAutoShowHide()), e.add((() => {
								this.removeChild(n)
							}))
						}
						return e
					}
					getBigWinAnimation() {
						const t = new v.BigWin;
						t.position.set(w.INFO_BG_WIDTH_LANDSCAPE / 2 + 4, .5 * this.height - 4), this.addChild(t);
						const e = new f.TimelineLite;
						return e.add((() => {
							I.ActionSpinsController.triggerSound(T.ActionSpinSound.BIG_WIN)
						})), e.add(t.start()), e
					}
					updateBalance(t) {
						t.winData.balance && (this._balance.value = A.CurrencyUtils.format(+t.winData.balance))
					}
					setPlayBtnName(t) {
						this._replayBtn.name = t
					}
					createToggleButton(t, e, i, s = 4294967295) {
						const l = new o.PointerStateColorSet(s);
						let h = new r.PointerStateIconSet(new a.Icon(E.ImgLoader.getImgTexture(e))),
							u = new r.PointerStateIconSet(new a.Icon(E.ImgLoader.getImgTexture(i)));
						const c = new n.IconToggleButton(t, h, l, u);
						return c.toggled = !1, c.enable(!0), c.pivot.set(.5 * c.width, .5 * c.height), c
					}
					createBtn() {
						const t = new o.PointerStateColorSet(4294967295);
						let e = new r.PointerStateIconSet(new a.Icon(E.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.ACTION_SPINS_REPLAY_GAME_REPLAY_BTN)), void 0, void 0, new a.Icon(E.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.ACTION_SPINS_REPLAY_GAME_REPLAY_DISABLED_BTN)));
						const i = new n.IconToggleButton(h.PromoPanelButtonIDs.PLAY_BTN, e, t);
						if (i.addClickCallback((() => this._controller.openReplay(i.name))), i.toggled = !1, i.enable(!1), this.addChild(i), i.pivot.set(i.width / 2, i.height / 2), this._replayBtn = i, this.isFS) {
							const t = this.createToggleButton(h.PromoPanelButtonIDs.ACTION_SPINS_REPLAY_EXPAND_BUTTON, l.PromoPanelAssetConfig.ACTION_SPINS_REPLAY_GAME_EXPAND, l.PromoPanelAssetConfig.ACTION_SPINS_REPLAY_GAME_EXPAND);
							t.addClickCallback((() => {
								this._controller.onExpandBtnClick(this)
							})), t.toggled = !1, t.enable(!0), t.name = "PLUS_MINUS", t.visible = !1, t.pivot.set(.5 * t.width, .5 * t.height), this._expandButton = t, this.addChild(this._expandButton)
						}
					}
				}
				w.INFO_BG_WIDTH_LANDSCAPE = 590, w.NORMAL_ROUND_LEFT_MARGIN = 50, w.BONUS_ROUND_LEFT_MARGIN = 25, e.ASRoundInfoView = w
			},
			66099: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ASStopOnBonusRoundInfoView = void 0;
				const n = i(68714),
					s = i(66515),
					o = i(56254),
					r = i(46980),
					a = i(85136),
					l = i(50799),
					h = i(39055),
					u = i(2425),
					c = i(63288),
					d = i(56401),
					p = i(61e3),
					_ = i(49792);
				class m extends PIXI.Container {
					constructor(t, e, i) {
						super(), this.createInfo(e), this.createPlayInGameBtn(t);
						const n = u.NolimitPromotionPlugin.ASOptionsData;
						if (n.bonusGame && n.bonusGame.pickNeededForModes.indexOf(i) > -1) {
							const e = e => {
									t.asController.view.gameOptionsView.selectedOptions.set(i.type, e.getSelection()), t.playContinueBonusInReplay()
								},
								i = new _.GameOptionSelectorComponent(n.bonusGame.type, e, n.bonusGame.options, "", "");
							i.position.set(0, 35), i.updateLayout(!0, 618), i.addContinueButtonGraphics(), this.addChild(i)
						} else this.createContinueBtn(t)
					}
					createContinueBtn(t) {
						const e = new o.PointerStateColorSet(4294967295);
						let i = new r.PointerStateIconSet(new a.Icon(p.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.ACTION_SPINS_GAME_CONTINUE))),
							_ = new r.PointerStateIconSet(new a.Icon(p.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.ACTION_SPINS_GAME_CONTINUE)));
						const m = new s.IconToggleButton(h.PromoPanelButtonIDs.ACTION_SPINS_GAME_CONTINUE_BUTTON, i, e, _);
						m.addClickCallback((() => t.playContinueBonusInReplay())), m.toggled = !1, m.enable(!0), m.pivot.set(.5 * m.width, .5 * m.height), m.position.set(295, 105), this.addChild(m);
						const g = new n.Label(u.NolimitPromotionPlugin.apiPlugIn.translations.translate(d.PromoPanelLabelIDs.CONTINUE), c.PromoPanelTextStyles.AS_ROUND_INFO_CONTINUE_STYLE);
						g.pivot.x = .5 * g.width, g.position.set(m.position.x, m.position.y + .5 * m.height + 5), this.addChild(g)
					}
					createPlayInGameBtn(t) {
						const e = new o.PointerStateColorSet(4294967295);
						let i = new r.PointerStateIconSet(new a.Icon(p.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.ACTION_SPINS_GAME_PLAY_BTN)));
						const _ = new s.IconToggleButton(h.PromoPanelButtonIDs.ACTION_SPINS_GAME_PLAY_BUTTON, i, e);
						_.addClickCallback((() => t.playBonusInGame())), _.toggled = !1, _.enable(!0), _.pivot.set(_.width / 2, _.height / 2), _.position.set(562, 30), this.addChild(_);
						const m = new n.Label(u.NolimitPromotionPlugin.apiPlugIn.translations.translate(d.PromoPanelLabelIDs.PLAY_BONUS_IN_GAME), c.PromoPanelTextStyles.AS_ROUND_INFO_PLAY_BONUS_IN_GAME_STYLE);
						if (m.width >= 145) {
							const t = 145 / m.width,
								e = m.getStyleClone();
							e.fontSize = Number(e.fontSize) * t, m.setStyle(e)
						}
						m.pivot.x = m.width, m.pivot.y = .5 * m.height, m.position.set(530, 30), this.addChild(m)
					}
					createInfo(t) {
						const e = new PIXI.Sprite(u.NolimitPromotionPlugin.imgLoader.getImgTexture(l.PromoPanelAssetConfig.BONUS_ROUND_BONUS_SUMMARY));
						e.position.set(30, 60), this.addChild(e)
					}
				}
				e.ASStopOnBonusRoundInfoView = m
			},
			10604: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ActionSpinsGameFeedView = void 0;
				const n = i(61e3),
					s = i(50799),
					o = i(9377),
					r = i(11877),
					a = i(55767),
					l = i(13006),
					h = i(54605),
					u = i(63288),
					c = i(56254),
					d = i(9886),
					p = i(71855);
				class _ extends PIXI.Container {
					constructor() {
						super(), this.currentlyVisible = 50, this._replayRounds = [], this._itemSpacing = 10, this._background = new PIXI.NineSlicePlane(n.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.ACTION_SPINS_REPLAY_FEED_BG), 30, 30, 30, 36), this._background.name = "_background", this._background.width = 692, this._background.height = 664, this._topInfoBar = new o.TopBar, this._topInfoBar.pivot.set(.5 * this._topInfoBar.width, .5 * this._topInfoBar.height), this._topInfoBar.position.set(.5 * this._background.width, 14), this._sortControls = new a.SortControls((t => this.sort(t))), this._sortControls.position.set(66, 55);
						const t = new c.PointerStateColorSet(d.GuiUtils.getARGB(0, 1));
						this._loadMoreButton = new h.SimpleLabelButton("loadmore", p.Helper.translate("Load more"), u.PromoPanelTextStyles.ROUND_INFO_DATE_TEXT, t), this._loadMoreButton.resizeButtonToLabelWithMargin(5, 15, 5, 15), this._loadMoreButton.pivot.set(.5 * this._loadMoreButton.width, 0), this._loadMoreButton.addClickCallback((() => {
							null != this._loadMoreCallback && (this._scroll.removeContent(this._loadMoreButton), this._loadMoreCallback())
						})), this._loadMoreButton.enable(!0), this._scroll = new r.GUIScrollContainer(660, this._background.height - 72, !1, !0, !0, {
							color: 16695821,
							thickness: 3
						}), this._scroll.position.set(17, 80), this._scrollContent = new PIXI.Container, this._scroll.addContent(this._scrollContent), this.addChild(this._background, this._scroll, this._topInfoBar, this._sortControls)
					}
					orientationChanged() {
						this._scroll.setScrollDelta(this._scroll, 0, 0)
					}
					resize(t) {
						this._background.height = t, this._scroll.resize(660, this._background.height - 111), this._topInfoBar.resize()
					}
					sort(t) {
						t ? this._replayRounds.sort(((t, e) => t.winText.latestValue - e.winText.latestValue)) : this._replayRounds.sort(((t, e) => t.roundNo - e.roundNo)), this._sortControls.update(t), this.updateRoundPositions(), this._scroll.setScrollDelta(this._scroll, 0, this._scroll.height), this._scroll.updateContent()
					}
					addRoundData(t) {
						this._replayRounds.push(t)
					}
					getLastRoundData() {
						return this._replayRounds[this._replayRounds.length - 1]
					}
					removeAllItems() {
						this._replayRounds = [], this._scrollContent.removeChildren(), this._scroll.updateContent()
					}
					enableInteraction(t) {
						if (t == this.interactionEnabled) return;
						t ? (this.enableInteractionAllRounds(), this.interactionEnabled = !0) : (this.interactionEnabled = !1, this.collapseAll(), this.sort(!1), null != this._loadMoreButton.parent && this._loadMoreButton.parent.removeChild(this._loadMoreButton)), this.updateRoundPositions(), this._scroll.updateContent(), this._sortControls.enable(t), this.enableScroll(t);
						const e = t ? 1 : .6;
						l.TweenMax.to(this._background, .2, {
							alpha: e
						})
					}
					enableScroll(t) {
						this._scroll.scrollEnabled = t
					}
					addLoadMoreButton(t, e) {
						this._loadMoreButton.parent || (this._loadMoreCallback = e, this._scroll.addContent(this._loadMoreButton)), this._loadMoreButton.position.set(.5 * this._background.width, t)
					}
					updateRoundPositions(t = !1, e = 50) {
						const i = new l.TimelineLite,
							n = this._replayRounds.length - 1,
							s = n - 16,
							o = n - e;
						this.currentlyVisible = e;
						let r = 0;
						for (let a = n; a >= 0; a--) {
							const n = this._replayRounds[a];
							a > o ? (null == n.parent && this._scrollContent.addChild(n), t && a > s ? i.to(n, .2, {
								y: r
							}, 0) : n.position.y = r, r += n.targetHeight + this._itemSpacing) : (this._scrollContent.removeChild(n), this.interactionEnabled && this.addLoadMoreButton(r, (() => {
								this.loadMoreRounds(e), this._scroll.updateContent()
							})))
						}
						return i
					}
					enableInteractionAllRounds() {
						this._replayRounds.forEach((t => {
							t.enableInteraction(!0)
						}))
					}
					collapseAll() {
						this._replayRounds.forEach((t => {
							t.enableInteraction(!1), t.isFS && t.collapseRound()
						}))
					}
					loadMoreRounds(t) {
						this.updateRoundPositions(!1, t + 20)
					}
				}
				e.ActionSpinsGameFeedView = _
			},
			31674: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BigWin = void 0;
				const n = i(2821),
					s = i(13006),
					o = i(73021);
				class r extends PIXI.Container {
					constructor() {
						super(), this.init(), this.name = "BIGWIN"
					}
					start() {
						const t = new s.TimelineLite;
						return t.add((() => {
							this._baseAnim.setFrame(0), this._textAnim.setFrame(0), this._coinAnim[0].setFrame(0), this._coinAnim[1].setFrame(0), this._coinAnim[2].setFrame(0), this._coinAnim[3].setFrame(0), this.visible = !0
						})), t.add([this._baseAnim.getAnimationAutoShowHide(!0, !0), this._textAnim.getAnimationAutoShowHide(!0, !0)], 0), t.add([this._coinAnim[1].getAnimationAutoShowHide(!0, !0), this._coinAnim[2].getAnimationAutoShowHide(!0, !0)], 1 / 30 * 4), t.add([this._coinAnim[0].getAnimationAutoShowHide(!0, !0), this._coinAnim[3].getAnimationAutoShowHide(!0, !0)], .2), t.add((() => {
							var t;
							this.visible = !1, null === (t = this.parent) || void 0 === t || t.removeChild(this)
						})), t
					}
					init() {
						this._baseAnim = new n.TimelineSprite(o.AnimationHelper.getAnimationTextures("bigWinBase")), this._textAnim = new n.TimelineSprite(o.AnimationHelper.getAnimationTextures("bigWinText")), this._coinAnim = [new n.TimelineSprite(o.AnimationHelper.getAnimationTextures("winCoins")), new n.TimelineSprite(o.AnimationHelper.getAnimationTextures("winCoins")), new n.TimelineSprite(o.AnimationHelper.getAnimationTextures("winCoins")), new n.TimelineSprite(o.AnimationHelper.getAnimationTextures("winCoins"))], this._baseAnim.anchor.set(.5), this._textAnim.anchor.set(.5), this._coinAnim[0].anchor.set(.5), this._coinAnim[1].anchor.set(.5), this._coinAnim[2].anchor.set(.5), this._coinAnim[3].anchor.set(.5), this._coinAnim[0].position.x = -210, this._coinAnim[1].position.x = -150, this._coinAnim[2].position.x = 140, this._coinAnim[3].position.x = 200, this._textAnim.position.y = 18, this.addChild(this._baseAnim, this._coinAnim[0], this._coinAnim[1], this._coinAnim[2], this._coinAnim[3], this._textAnim), this.visible = !1
					}
				}
				e.BigWin = r
			},
			37513: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SignLabel = e.SignLabelAlign = void 0;
				const n = i(91746),
					s = i(63288),
					o = i(61e3),
					r = i(11499);
				var a;
				! function(t) {
					t[t.LEFT = 0] = "LEFT", t[t.CENTER = 1] = "CENTER", t[t.RIGHT = 2] = "RIGHT"
				}(a = e.SignLabelAlign || (e.SignLabelAlign = {}));
				class l extends PIXI.Container {
					constructor(t, e, i, r, l) {
						super(), this._allowNegative = !1, this._margin = 5, this._align = a.LEFT, this.useDecimalCutoff = !0, this.name = "SignLabel_" + t, this.mainContainer = new PIXI.Container, this._sign = new PIXI.Sprite(o.ImgLoader.getImgTexture(e)), this._sign.anchor.set(0, .5), this.mainContainer.addChild(this._sign), this._label = new n.PromoPanelTextLabel("", i || s.PromoPanelTextStyles.AS_REPLAY_NUMBER_TEXT_STYLE, {
							landscapeMaxWidth: r || 158,
							portraitMaxWidth: l || 158
						}), this._label.anchor.set(0, .5), this._label.position.set(this._sign.width + this._margin, 0), this.mainContainer.addChild(this._label), this.addChild(this.mainContainer), this.value = 0
					}
					set value(t) {
						this._value != t && (this._value = t, (this._allowNegative || this._value > -1) && (this.useDecimalCutoff ? this._label.value = r.CurrencyUtils.formatWithDecimalCutOff(this.value) : this._label.value = r.CurrencyUtils.format(this.value)), this.align(this._align))
					}
					align(t) {
						this._align = t, this._align == a.RIGHT ? this.mainContainer.pivot.set(this.mainContainer.width, 0) : this._align == a.CENTER ? this.mainContainer.pivot.set(.5 * this.mainContainer.width, 0) : this.mainContainer.pivot.set(0, 0)
					}
					set allowNegative(t) {
						this._allowNegative = t
					}
					get value() {
						return this._value
					}
					onResize() {
						this._label.onResize()
					}
				}
				e.SignLabel = l
			},
			12489: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.TimesBetDisplay = void 0;
				const n = i(91746),
					s = i(68714),
					o = i(2425),
					r = i(50799),
					a = i(63288),
					l = i(11499);
				class h extends PIXI.Container {
					constructor(t, e) {
						super(), this._betSign = new PIXI.Sprite(o.NolimitPromotionPlugin.imgLoader.getImgTexture(r.PromoPanelAssetConfig.ACTION_SPINS_MENU_BET)), this._betSign.anchor.set(0, .5), this._betSign.tint = 0, this._betGroupMaxWidth = e || 150, this._betGroupMaxWidth -= this._betSign.width + 10, this._timesBetLabel = new n.TextLabelAdvanced("", a.PromoPanelTextStyles.AS_ROUND_INFO_X_BET_STYLE, {
							landscapeMaxWidth: this._betGroupMaxWidth,
							portraitMaxWidth: this._betGroupMaxWidth
						}), this._timesBetLabel.anchor.set(0, .5);
						const i = new s.Label("x", a.PromoPanelTextStyles.AS_ROUND_INFO_X_BET_STYLE);
						i.anchor.set(0, .5), this._xText = i, this.addChild(this._timesBetLabel, this._xText, this._betSign), this.updateTimesBet(t)
					}
					updateTimesBet(t) {
						this._timesBetLabel.text = l.CurrencyUtils.toFixedIfNecessary(t, 2), this.onResize()
					}
					onResize() {
						this._timesBetLabel.onResize(), this._timesBetLabel.position.set(0, 0), this._xText.position.set(this._timesBetLabel.width + 5, 0), this._betSign.position.set(this._xText.x + this._xText.width + 5, 0)
					}
					get timesBetLabel() {
						return this._timesBetLabel
					}
				}
				e.TimesBetDisplay = h
			},
			50106: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.IdAndDateBox = void 0;
				const n = i(82859),
					s = i(68714),
					o = i(61e3),
					r = i(50799),
					a = i(63288),
					l = i(71855),
					h = i(38801);
				class u extends n.Container {
					constructor(t, e) {
						super(), this._bp = new PIXI.NineSlicePlane(o.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.ACTION_SPINS_ROUNDS_NUMBER_BG), 7, 7, 7, 7), this._id = new s.Label(t, a.PromoPanelTextStyles.AS_ROUND_INFO_SPIN_NUMBER_TEXT_STYLE), this._id.anchor.set(.5, .5), this._bp.addChild(this._id), this._date = new s.Label(u.formatTime(e), a.PromoPanelTextStyles.ROUND_INFO_DATE_TEXT), this.addChild(this._bp, this._date), this.resize()
					}
					static formatTime(t) {
						if (null == t || "" == t) return "";
						const e = new Date(t);
						return l.Helper.padZero(e.getHours()) + ":" + l.Helper.padZero(e.getMinutes()) + ":" + l.Helper.padZero(e.getSeconds())
					}
					updateDate(t) {
						this._date.text = u.formatTime(t)
					}
					updateId(t) {
						const e = this._id.text.split("-")[0];
						this._id.text = e + "-" + t, this.resize()
					}
					resize() {
						this._bp.width = Math.max(this._id.width + 10, 30), this._bp.height = 14, this._id.position.set(.5 * this._bp.width, .5 * this._bp.height), h.GuiLayout.align([this._bp, this._date], 8, h.Align.CENTER, h.Direction.HORIZONTAL)
					}
				}
				e.IdAndDateBox = u
			},
			54605: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SimpleLabelButton = e.createDefaultButtonStroke = e.createDefaultButtonBackPlate = void 0;
				const n = i(61e3),
					s = i(50799),
					o = i(35235),
					r = i(68714),
					a = i(5158),
					l = i(56254),
					h = i(78229),
					u = i(9886);

				function c() {
					const t = new PIXI.NineSlicePlane(n.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.BUTTON_PLATE_20), 20, 20, 20, 20);
					return t.tint = 0, t.alpha = .15, t
				}

				function d() {
					const t = new PIXI.NineSlicePlane(n.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.BUTTON_STROKE_20), 20, 20, 20, 20);
					return t.tint = 16777215, t.alpha = .6, t
				}
				e.createDefaultButtonBackPlate = c, e.createDefaultButtonStroke = d;
				class p extends o.GuiToggleButton {
					constructor(t, e = "", i, n, s, o, u) {
						super(t, (() => this.toggleCallback())), i = i || h.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE, n = n || new l.PointerStateColorSet(4294966272, 4294966272, 4294966272, 872414208), s = s || new l.PointerStateColorSet(4294967295, 4294967295, 4294967295, 872415231), this._colorSets = new a.ToggleStateSet(n, s), this.value = void 0, this._label = new r.Label(e, i), this._backplate = o || c(), this._stroke = u || d(), this.addChild(this._backplate), this.addChild(this._stroke), this.addChild(this._label)
					}
					get label() {
						return this._label
					}
					get backplate() {
						return this._backplate
					}
					set backplate(t) {
						this._backplate = t
					}
					get stroke() {
						return this._stroke
					}
					set stroke(t) {
						this._stroke = t
					}
					setSize(t, e) {
						this._backplate.width = t, this._backplate.height = e, this._stroke.width = t, this._stroke.height = e, this._label.anchor.set(.5, .5), this._label.position.set(.5 * t, .5 * e)
					}
					resizeButtonToLabelWithMargin(t = 0, e = 0, i = 0, n = 0) {
						this.setSize(this._label.width + n + e, this._label.height + t + i), this._label.anchor.set(0, 0), this._label.position.set(n, t)
					}
					onPointerStateUpdate(t) {
						this.setColors()
					}
					setColors() {
						const t = this._colorSets.getItem(this.toggleState).getItem(this.pointerState);
						this._label.setColor(t), this._backplate.alpha = this.toggleState * u.GuiUtils.getAlphaFromARGB(t), this._stroke.tint = u.GuiUtils.getColorFromARGB(t), this._stroke.alpha = (1 - this.toggleState) * u.GuiUtils.getAlphaFromARGB(t)
					}
					toggleCallback() {
						this.setColors()
					}
				}
				e.SimpleLabelButton = p
			},
			74961: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SortButton = void 0;
				const n = i(66515),
					s = i(56254),
					o = i(61e3),
					r = i(50799),
					a = i(85136),
					l = i(46980),
					h = i(68714),
					u = i(63288);
				class c extends n.IconToggleButton {
					constructor(t, e) {
						const i = new s.PointerStateColorSet(4294966272, 4294966272, 4294966272, 872414208),
							n = new s.PointerStateColorSet(4294967295, 4294967295, 4294967295, 872415231),
							c = new l.PointerStateIconSet(new a.Icon(o.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.ACTION_SPINS_SORT_ARROW_RIGHT)));
						super(t, new l.PointerStateIconSet(new a.Icon(o.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.ACTION_SPINS_SORT_ARROW_DOWN))), i, c, n), null != e && (this.label = new h.Label(e, u.PromoPanelTextStyles.SORT_BUTTON), this.label.anchor.set(0, .5), this.addSubComponent(this.label, {
							x: 1,
							y: .5
						}, {
							x: 5,
							y: 0
						}))
					}
					enable(t) {
						super.enable(t), this.label && (this.label.tint = this._icon.tint, this.label.alpha = this._icon.alpha)
					}
				}
				e.SortButton = c
			},
			55767: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SortControls = void 0;
				const n = i(56254),
					s = i(9886),
					o = i(33169),
					r = i(2425),
					a = i(71855),
					l = i(74961);
				class h extends PIXI.Container {
					constructor(t) {
						super(), this.sortCallback = t, PIXI.utils.string2hex("#fbc217"), PIXI.utils.string2hex("#f57f20");
						const e = PIXI.utils.string2hex("#ffffff"),
							i = PIXI.utils.string2hex("#000000");
						new n.PointerStateColorSet(s.GuiUtils.getARGB(e, 1))[o.PointerState.DISABLED] = s.GuiUtils.getARGB(e, .5), new n.PointerStateColorSet(s.GuiUtils.getARGB(i, 1))[o.PointerState.DISABLED] = s.GuiUtils.getARGB(i, .5), this.roundButton = new l.SortButton("RoundId", a.Helper.translate("TIME")), this.winButton = new l.SortButton("WinId", a.Helper.translate("WIN")), this.winButton.position.set(415, 0), this.roundButton.addClickCallback((() => this.click(this.roundButton))), this.winButton.addClickCallback((() => this.click(this.winButton))), this.roundButton.enable(!1), this.winButton.enable(!1), this.roundButton.toggled = !0, this.winButton.toggled = !1, this.addChild(this.roundButton, this.winButton)
					}
					enable(t) {
						this.roundButton.enable(t), this.winButton.enable(t)
					}
					update(t) {
						this.roundButton.toggled = !t, this.winButton.toggled = t
					}
					click(t) {
						r.NolimitPromotionPlugin.sound.playKeypadEffect("click"), this.sortCallback(t == this.winButton)
					}
				}
				e.SortControls = h
			},
			69743: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SpinControls = void 0;
				const n = i(91746),
					s = i(63288),
					o = i(2425),
					r = i(50799),
					a = i(56254),
					l = i(46980),
					h = i(85136),
					u = i(61e3),
					c = i(66515),
					d = i(39055),
					p = i(19803),
					_ = i(72468);
				class m extends PIXI.Container {
					constructor(t) {
						super(), this._controller = t, this._spinsLeft = new n.PromoPanelTextLabel("", s.PromoPanelTextStyles.AS_ROUND_INFO_SPINS_LEFT_STYLE, {
							landscapeMaxWidth: 100,
							portraitMaxWidth: 100
						});
						const e = new a.PointerStateColorSet(4294967295, 4294967295, 4294967295, 872415231);
						let i = new l.PointerStateIconSet(new h.Icon(u.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.ACTION_SPINS_BTN_PLAY))),
							p = new l.PointerStateIconSet(new h.Icon(u.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.ACTION_SPINS_BTN_PAUSE)));
						this._playPauseBtn = new c.IconToggleButton(d.PromoPanelButtonIDs.PLAY_BTN, i, e, p), this._playPauseBtn.addClickCallback((() => {
							o.NolimitPromotionPlugin.sound.playKeypadEffect("click"), this._controller.onPlayPauseBtnClick()
						})), this._playPauseBtn.toggled = !1, this._playPauseBtn.enable(!0), this._playPauseBtn.pivot.x = .5 * this._playPauseBtn.width, this._playPauseBtn.position.x = this._spinsLeft.position.x, this._playPauseBtn.position.y = .5 * this._spinsLeft.height + 10;
						const _ = new PIXI.Sprite(o.NolimitPromotionPlugin.imgLoader.getImgTexture(r.PromoPanelAssetConfig.ACTION_SPINS_PLAYED_ROUNDS_BG));
						_.anchor.set(.5);
						const m = d.PromoPanelButtonIDs.ACTION_SPINS_COUNT_UP,
							g = d.PromoPanelButtonIDs.ACTION_SPINS_COUNT_DOWN,
							f = new l.PointerStateIconSet(new h.Icon(u.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.BET_UP)));
						this._upButton = new c.IconToggleButton(m, f, e), this._upButton.addClickCallback((() => this.buttonClick(this._upButton))), this._upButton.toggled = !1, this._upButton.pivot.set(38, 35), this._upButton.scale.set(.75, .75);
						const S = new l.PointerStateIconSet(new h.Icon(u.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.BET_DOWN)));
						this._downButton = new c.IconToggleButton(g, S, e), this._downButton.addClickCallback((() => this.buttonClick(this._downButton))), this._downButton.toggled = !1, this._downButton.pivot.set(38, 35), this._downButton.scale.set(.75, .75), this._divider = new PIXI.Sprite(PIXI.Texture.WHITE), this._divider.width = 2, this._divider.height = 50, this._divider.position.set(0, -80), this._divider.alpha = .6, this._upButton.enable(!0), this._downButton.enable(!0), this.addChild(_, this._spinsLeft, this._upButton, this._divider, this._downButton, this._playPauseBtn), this.resize()
					}
					resize() {
						_.NolimitApplication.isLandscape ? (this._upButton.position.set(40, this._spinsLeft.position.y - 55), this._downButton.position.set(-40, this._spinsLeft.position.y - 55), this._divider.visible = this._upButton.visible) : (this._upButton.position.set(75, this._spinsLeft.position.y), this._downButton.position.set(-75, this._spinsLeft.position.y), this._divider.visible = !1)
					}
					togglePlayButton() {
						return this._playPauseBtn.toggled = !this._playPauseBtn.toggled, this._playPauseBtn.toggled
					}
					setPlayState(t) {
						this._playPauseBtn.toggled = t
					}
					enablePlayPauseBtn(t) {
						this._playPauseBtn.enable(t), this._playPauseBtn.alpha = t ? p.PromoPanelConfig.ENABLE_BTN_ALPHA : p.PromoPanelConfig.DISABLE_BTN_ALPHA
					}
					setSpinsLeft(t) {
						t <= 0 && this.enablePlayPauseBtn(!1), t >= 0 && (this._spinsLeft.text = t.toString()), this.checkValidOptionForButtons(t)
					}
					checkValidOptionForButtons(t) {
						this._downButton.visible && (t <= this._controller.asController.spinCountList.getFirstValue() ? this._downButton.enable(!1) : this._downButton.enable(!0)), this._upButton.visible && (t >= this._controller.asController.spinCountList.getLastValue() ? this._upButton.enable(!1) : this._upButton.enable(!0))
					}
					enableRoundsButtons(t, e) {
						this._divider.visible = t && _.NolimitApplication.isLandscape, this._upButton.visible = t, this._upButton.enable(t), this._downButton.visible = t, this._downButton.enable(t), this.checkValidOptionForButtons(e)
					}
					buttonClick(t) {
						this._controller.asController.buttonClick(t)
					}
				}
				e.SpinControls = m
			},
			9377: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.TopBar = void 0;
				const n = i(61e3),
					s = i(50799),
					o = i(37513);
				class r extends PIXI.Container {
					constructor() {
						super(), this.name = "TOP_BAR", this.bg = new PIXI.Sprite(n.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.ACTION_SPINS_REPLAY_INFO_BG)), this._placedBet = new o.SignLabel("placedBet", s.PromoPanelAssetConfig.ACTION_SPINS_MENU_BET), this._accumulatedBet = new o.SignLabel("accumulatedBet", s.PromoPanelAssetConfig.ACTION_SPINS_REPLAY_MENU_TOTAL_BET), this._accumulatedWin = new o.SignLabel("accumulatedWin", s.PromoPanelAssetConfig.ACTION_SPINS_REPLAY_MENU_WIN), this._placedBet.align(o.SignLabelAlign.LEFT), this._accumulatedBet.align(o.SignLabelAlign.LEFT), this._accumulatedWin.align(o.SignLabelAlign.RIGHT), this._accumulatedWin.useDecimalCutoff = !1, this.addChild(this.bg), this.addChild(this._placedBet, this._accumulatedBet, this._accumulatedWin), this.resize()
					}
					resize() {
						this._placedBet.onResize(), this._accumulatedBet.onResize(), this._accumulatedWin.onResize(), this.reAlign()
					}
					setPlacedBet(t) {
						this._placedBet.value = t, this.reAlign()
					}
					setAccumulatedBet(t) {
						this._accumulatedBet.value = t, this.reAlign()
					}
					setAccumulatedWin(t) {
						this._accumulatedWin.value = t, this.reAlign()
					}
					getAccumulatedWin() {
						return this._accumulatedWin.value
					}
					getAccumulatedBet() {
						return this._accumulatedBet.value
					}
					reAlign() {
						this._placedBet.position.set(26, 36), this._accumulatedBet.position.set(this._placedBet.x + this._placedBet.width + 10, 36), this._accumulatedWin.position.set(this.bg.width - 26, 36)
					}
				}
				e.TopBar = r
			},
			9026: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ASSettingsModel = void 0;
				const n = i(2425),
					s = i(88458);
				e.ASSettingsModel = class {
					constructor() {
						this.STOP_ON_BONUS = "stopOnBonus", this.callbacks = {}, this._stopOnBonus = !0, this._stopOnBonus = n.NolimitPromotionPlugin.getFromLocalStorage(s.LocalStorageSettingsKey.AS_STOP_ON_BONUS, this._stopOnBonus)
					}
					addCallback(t, e) {
						this.callbacks[t] = this.callbacks[t] || [], this.callbacks[t].push(e)
					}
					triggerCallback(t, e) {
						if (this.callbacks[t])
							for (let i of this.callbacks[t]) i(e)
					}
					get stopOnBonus() {
						return this._stopOnBonus
					}
					set stopOnBonus(t) {
						this._stopOnBonus = t, n.NolimitPromotionPlugin.saveToLocalStorage(s.LocalStorageSettingsKey.AS_STOP_ON_BONUS, t), this.triggerCallback(this.STOP_ON_BONUS, t)
					}
				}
			},
			11395: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ASStopSettings = void 0;
				const n = i(2425);
				class s {
					constructor() {
						s.reset()
					}
					static get remainingRounds() {
						return this._remainingRounds
					}
					static set remainingRounds(t) {
						this._remainingRounds = t
					}
					static get minBalanceLimit() {
						return this._minBalanceLimit
					}
					static set minBalanceLimit(t) {
						this._minBalanceLimit = t, this._minBalanceLimitAmount = this.minBalanceLimit * n.NolimitPromotionPlugin.apiPlugIn.balance.getAmount()
					}
					static get minBalanceLimitAmount() {
						return this._minBalanceLimitAmount
					}
					static get maxBalanceLimit() {
						return this._maxBalanceLimit
					}
					static set maxBalanceLimit(t) {
						this._maxBalanceLimit = t, this._maxBalanceLimitAmount = this.maxBalanceLimit * n.NolimitPromotionPlugin.apiPlugIn.balance.getAmount()
					}
					static get maxBalanceLimitAmount() {
						return this._maxBalanceLimitAmount
					}
					static get xBetLimit() {
						return this._xBetLimit
					}
					static set xBetLimit(t) {
						this._xBetLimit = t
					}
					static get xBetLimitAmount() {
						return this._xBetLimit * +n.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel()
					}
					static get shouldReset() {
						return this._shouldReset
					}
					static set shouldReset(t) {
						this._shouldReset = t
					}
					static get appliedBet() {
						const t = n.NolimitPromotionPlugin.apiPlugIn.betHandler.betBoost;
						return t ? t.calculatedPrice : +n.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel()
					}
					static reset() {
						s.minBalanceLimit = 0, s.maxBalanceLimit = 0, s.xBetLimit = 0, s.remainingRounds = 0, s.shouldReset = !1
					}
					static update(t = !1) {
						(s.shouldReset || t) && (s.minBalanceLimit = s._minBalanceLimit, s.maxBalanceLimit = s._maxBalanceLimit)
					}
				}
				e.ASStopSettings = s
			},
			35239: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.StopOnBonusTriggeredToggleBtn = void 0;
				const n = i(66515),
					s = i(56254),
					o = i(46980),
					r = i(85136),
					a = i(2425),
					l = i(50799),
					h = i(91275),
					u = i(91746),
					c = i(63288);
				class d extends n.IconToggleButton {
					constructor(t, e) {
						const i = new s.PointerStateColorSet(4294966272, 4294966272, 4294966272, 1728052224),
							n = new s.PointerStateColorSet(4294967295, 4294967295, 4294967295, 1728053247),
							h = a.NolimitPromotionPlugin.imgLoader.getImgTexture(l.PromoPanelAssetConfig.ACTION_SPINS_GAME_CHECK_BOX_ACTIVE).clone(),
							d = new o.PointerStateIconSet(new r.Icon(a.NolimitPromotionPlugin.imgLoader.getImgTexture(l.PromoPanelAssetConfig.ACTION_SPINS_GAME_CHECK_BOX_INACTIVE)));
						super(t, new o.PointerStateIconSet(new r.Icon(h.clone())), i, d, n), this._label = new u.PromoPanelTextLabel(e, c.PromoPanelTextStyles.ACTION_SPINS_STOP_ON_BONUS_LABEL, {
							landscapeMaxWidth: 300,
							portraitMaxWidth: 300
						}), this._label.anchor.set(.5, 0), this.addSubComponent(this._label, {
							x: .5,
							y: 0
						}, {
							x: 0,
							y: -35
						}), this.toggleState = 0, this.enable(!0), this.addClickCallback((() => this.changeBtnState()))
					}
					enable(t) {
						super.enable(t), this._label.alpha = t ? 1 : .4
					}
					changeBtnState() {
						a.NolimitPromotionPlugin.sound.playKeypadEffect("click"), this.toggleState = Number(!this.toggled), h.ActionSpinsController.settings.stopOnBonus = this.toggled
					}
				}
				e.StopOnBonusTriggeredToggleBtn = d
			},
			8468: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ASGameOptionsView = void 0;
				const n = i(49792),
					s = i(38801),
					o = i(88458),
					r = i(2425),
					a = i(60767),
					l = i(56401),
					h = i(68714),
					u = i(63288);
				class c extends PIXI.Container {
					constructor(t, e) {
						if (super(), this.selectedOptions = new Map, this.visibleSelectorsAndElements = [], this.selectors = [], this.onSelection = t => {
								const e = t.getSelection();
								if (t.type == o.ASMainGamePickOptions.BOOSTED_BET) {
									if (e) {
										let i = "";
										e.id > 0 && (i = this.getTotalXBetCostFromFeatureName((null == e ? void 0 : e.name) || "")), t.setTitleValue(i), e.displayValue = i
									}
								} else t.setTitleValue((null == e ? void 0 : e.name) || "");
								this.selectedOptions.set(t.type, e), this.onUpdateCallback()
							}, this.onUpdateCallback = e, this.originalOptionData = t, t.mainGame && t.mainGame.type != o.ASMainGamePickOptions.BOOSTED_BET) {
							const e = new n.GameOptionSelectorComponent(t.mainGame.type, this.onSelection, t.mainGame.options, t.mainGame.header(), "");
							this.selectors.push(e), this.selectedOptions.set(e.type, void 0)
						}
						if (t.bonusGame) {
							const e = new n.GameOptionSelectorComponent(t.bonusGame.type, this.onSelection, t.bonusGame.options, t.bonusGame.header(), "");
							this.selectors.push(e), this.selectedOptions.set(e.type, void 0)
						}
						t.automaticPickGame && (this.automaticPickDisclaimer = new h.Label(t.automaticPickGame.header(), u.PromoPanelTextStyles.ACTION_SPINS_OPTIONS_DISCLAIMER))
					}
					init() {
						for (let t of this.selectors) t.type == o.ASMainGamePickOptions.BOOSTED_BET && t.select(0), t.type == o.ASMainGamePickOptions.VOLATILITY && t.select(0), t.type == o.ASBonusPickOptions.PICK_MODE && t.select(0), t.type == o.ASBonusPickOptions.ROW_OPTIONS && t.select(0)
					}
					enableBonusOption(t) {
						for (let e of this.selectors) e.type != o.ASBonusPickOptions.ROW_OPTIONS && e.type != o.ASBonusPickOptions.PICK_MODE || (e.enable(t), t ? this.selectedOptions.set(e.type, e.getSelection()) : this.selectedOptions.delete(e.type))
					}
					setVisibleSelectors(t, e, i) {
						this.removeChild(...this.visibleSelectorsAndElements), this.visibleSelectorsAndElements = [];
						for (let n of this.selectors) n.type == o.ASMainGamePickOptions.BOOSTED_BET && e && this.visibleSelectorsAndElements.push(n), n.type == o.ASMainGamePickOptions.VOLATILITY && i && this.visibleSelectorsAndElements.push(n), n.type == o.ASBonusPickOptions.PICK_MODE && t && this.visibleSelectorsAndElements.push(n), n.type == o.ASBonusPickOptions.ROW_OPTIONS && t && this.visibleSelectorsAndElements.push(n);
						this.automaticPickDisclaimer && t && this.visibleSelectorsAndElements.push(this.automaticPickDisclaimer), this.visibleSelectorsAndElements.length > 0 && (s.GuiLayout.align(this.visibleSelectorsAndElements, 25, s.Align.LEFT, s.Direction.VERTICAL), this.addChild(...this.visibleSelectorsAndElements))
					}
					onUpdateBet() {
						for (let t of this.selectors) {
							if (t.type == o.ASMainGamePickOptions.BOOSTED_BET) {
								const e = t.getSelection();
								if (e) {
									let i = "";
									e.id > 0 && (i = this.getTotalXBetCostFromFeatureName((null == e ? void 0 : e.name) || "")), t.setTitleValue(i), e.displayValue = i
								}
							}
							t.type == o.ASMainGamePickOptions.VOLATILITY && this.visibleSelectorsAndElements.push(t)
						}
					}
					isAllMandatorySelected() {
						for (let t of this.selectedOptions.values())
							if (null == t) return !1;
						return !0
					}
					getTotalXBetCostFromFeatureName(t) {
						const e = a.ResponseParser.getBoostCost(t),
							i = r.NolimitPromotionPlugin.apiPlugIn.currency.format(+e);
						return r.NolimitPromotionPlugin.apiPlugIn.translations.translate(l.PromoPanelLabelIDs.TOTAL_COST) + " " + i
					}
				}
				e.ASGameOptionsView = c
			},
			50061: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ASNolimitBonusView = void 0;
				const n = i(2425),
					s = i(78229),
					o = i(26733),
					r = i(55462),
					a = i(5117),
					l = i(77616),
					h = i(68714),
					u = i(61e3),
					c = i(38801);
				class d extends PIXI.Container {
					constructor(t) {
						super(), this.onFeatureBtnClick = t => {
							this.setFeature(t.name)
						}, this.asController = t;
						let e = n.NolimitPromotionPlugin.apiPlugIn.betFeatureController.getAllowedFeatures();
						this.buttons = [], this.bonusButtons = [], this.boosterButtons = [];
						for (let t = 0; t < e.length; t++) {
							const i = e[t],
								n = this.createBetFeatureBtn(i);
							this.buttons.push(n), "FREESPIN" === i.type ? this.bonusButtons.push(n) : this.boosterButtons.push(n)
						}
						this._backgroundPlate = new PIXI.NineSlicePlane(u.ImgLoader.getImgTexture(r.GuiDefaultTextures.PLATE_BASE_20), 20, 20, 20, 20), this._backgroundPlate.alpha = 1, this._backgroundPlate.tint = 15607379, this._backgroundPlate.width = 350, this._backgroundPlate.height = 200, this._backgroundPlate.position.set(0, 0), this.contentContainer = this.createContent(), this.addChild(this._backgroundPlate, this.contentContainer);
						const i = this.contentContainer.width + 30;
						if (i > 633) {
							let t = 633 / i;
							this.contentContainer.scale.set(t, t)
						}
						this.boxSize = new PIXI.Point(this.contentContainer.width + 30, this.contentContainer.height + 35), this.boxSize.x = Math.max(this.boxSize.x, 280), this._backgroundPlate.width = this.boxSize.x, this._backgroundPlate.height = this.boxSize.y;
						const s = Math.floor(.5 * (this.boxSize.x - this.contentContainer.width));
						this.contentContainer.position.set(s, 15), e.length <= 0 && (this.visible = !1)
					}
					createContent() {
						const t = new PIXI.Container,
							e = new PIXI.Container;
						if (this.bonusButtons.length > 0) {
							const e = new PIXI.Container;
							e.addChild(...this.bonusButtons), d.gridLayout(this.bonusButtons, 7, 18), this.bonusHeader = this.createHeader("Nolimit Bonus", u.ImgLoader.getImgTexture(r.GuiDefaultTextures.NOLIMIT_BONUS_ICON)), t.addChild(this.bonusHeader, e), this.bonusHeader.scale.set(.5, .5), this.bonusHeader.position.set(.5 * e.width, 0), e.position.set(0, this.bonusHeader.height + 10)
						}
						if (this.boosterButtons.length > 0) {
							const t = new PIXI.Container;
							t.addChild(...this.boosterButtons), d.gridLayout(this.boosterButtons, 7, 18), this.boosterHeader = this.createHeader("Nolimit Booster", u.ImgLoader.getImgTexture(r.GuiDefaultTextures.NOLIMIT_BOOSTER_ICON)), e.addChild(this.boosterHeader, t), this.boosterHeader.scale.set(.5, .5), this.boosterHeader.position.set(.5 * t.width, 0), t.position.set(0, this.boosterHeader.height + 10)
						}
						this.bonusButtons.length > 0 && this.boosterButtons.length > 0 && c.GuiLayout.align([t, e], 20, c.Align.LEFT, c.Direction.VERTICAL);
						const i = new PIXI.Container;
						return i.addChild(t, e), this.bonusHeader && this.bonusHeader.position.set(Math.floor(.5 * i.width), 0), this.boosterHeader && this.boosterHeader.position.set(Math.floor(.5 * i.width), 0), i
					}
					createHeader(t, e) {
						const i = new PIXI.Container,
							n = new PIXI.TextStyle({
								fill: "#ffffff",
								fontFamily: a.OpenSans.FAMILY,
								fontSize: 50,
								fontStyle: l.FontStyle.NORMAL,
								fontWeight: l.FontWeight.SEMI_BOLD,
								dropShadow: !0,
								dropShadowAngle: -1,
								dropShadowDistance: -3,
								dropShadowColor: "#b62449",
								padding: 50
							}),
							s = new PIXI.Sprite(e),
							o = new h.Label(t, n);
						return o.position.set(s.width + 10, 0), i.addChild(s, o), i.pivot.set(.5 * i.width, 0), i
					}
					updateBonusButtonStates() {
						const t = this.asController.selectedFeatureBet;
						for (let e of this.buttons)(null == t ? void 0 : t.name) == e.name ? e.toggled = !0 : e.toggled = !1
					}
					static gridLayout(t, e, i) {
						let n = 0,
							s = 0;
						for (let e of t) {
							const t = e.getBounds();
							n = t.width > n ? t.width : n, s = t.height > s ? t.height : s
						}
						for (let o = 0; o < t.length; o++) {
							const r = t[o];
							r.x = Math.floor(o % 3) * n, r.y = Math.floor(o / 3) * s, r.x > 0 && (r.x += e * Math.floor(o % 3)), r.y > 0 && (r.y += i * Math.floor(o / 3))
						}
					}
					createBetFeatureBtn(t) {
						s.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE.clone().fontSize = 20;
						const e = new o.BuyFeatureButton(t);
						return e.addClickCallback((() => this.onFeatureBtnClick(e))), e.toggled = !1, e.enable(!0), e
					}
					updateBetLevel(t) {
						const e = parseFloat(t),
							i = this.asController.selectedFeatureBet;
						for (let t of this.buttons) t.updateCostAndValidate(e) ? t.enable(!0) : (t.enable(!1), t.featureData.name == (null == i ? void 0 : i.name) && this.setFeature())
					}
					setFeature(t) {
						var e;
						if ((null === (e = this.asController.selectedFeatureBet) || void 0 === e ? void 0 : e.name) == t) return void this.asController.setFeatureBet();
						const i = n.NolimitPromotionPlugin.apiPlugIn.betFeatureController.getAllowedFeatures();
						let s;
						for (let e of i)
							if (e.name == t) {
								s = e;
								break
							} this.asController.setFeatureBet(s)
					}
				}
				e.ASNolimitBonusView = d
			},
			71738: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GameOptionButton = void 0;
				const n = i(35235),
					s = i(61e3),
					o = i(50799),
					r = i(5158);
				class a extends n.GuiToggleButton {
					constructor(t) {
						super(t.name, (() => this.toggleCallback())), this.data = t;
						const e = new PIXI.Container;
						if (t.image) {
							let i = s.ImgLoader.getImgTexture(t.image);
							i.baseTexture.setResolution(2);
							const n = new PIXI.Sprite(i),
								r = new PIXI.Sprite(s.ImgLoader.getImgTexture(o.PromoPanelAssetConfig.ACTION_SPINS_OPTIONS_BUTTON_MASK));
							e.addChild(n), e.addChild(r), n.mask = r
						}
						const i = new PIXI.Container;
						this.onSprite = new PIXI.Sprite(s.ImgLoader.getImgTexture(o.PromoPanelAssetConfig.ACTION_SPINS_OPTIONS_BUTTON_ACTIVE)), this.offSprite = new PIXI.Sprite(s.ImgLoader.getImgTexture(o.PromoPanelAssetConfig.ACTION_SPINS_OPTIONS_BUTTON_INACTIVE)), i.addChild(this.offSprite, this.onSprite), this.addChild(i), this.addChild(e)
					}
					virtualClick() {
						this.onClick()
					}
					toggleCallback() {
						this.onSprite.visible = this.toggleState == r.ToggleState.ON, this.offSprite.visible = !this.onSprite.visible
					}
				}
				e.GameOptionButton = a
			},
			49792: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GameOptionSelectorComponent = void 0;
				const n = i(68714),
					s = i(38801),
					o = i(63288),
					r = i(71738),
					a = i(61e3),
					l = i(50799),
					h = i(2425),
					u = i(56401);
				class c extends PIXI.Container {
					constructor(t, e, i, s, a = "", l = !1) {
						super(), this.buttons = [], this._enabled = !0, this.skipSound = !1, this.type = t, this.stateChangeCallback = e, this.deselectable = l, this.textContainer = new PIXI.Container, this.title = new n.Label(s, o.PromoPanelTextStyles.ACTION_SPINS_OPTIONS_TITLE), this.titleValue = new n.Label(a, o.PromoPanelTextStyles.ACTION_SPINS_OPTIONS_VALUE), this.textContainer.addChild(this.title, this.titleValue), this.buttonsContainer = new PIXI.Container;
						for (let t of i) {
							t.header = s;
							const e = new r.GameOptionButton(t);
							e.addClickCallback((() => {
								this.buttonClicked(e)
							})), e.toggled = !1, e.enable(!0), this.buttons.push(e), this.buttonsContainer.addChild(e)
						}
						this.updateLayout(!1, 633), this.addChild(this.textContainer, this.buttonsContainer)
					}
					enable(t) {
						this._enabled = t, this.alpha = t ? 1 : .4
					}
					addContinueButtonGraphics() {
						for (let t of this.buttons) {
							const e = new PIXI.Container,
								i = new PIXI.Sprite(a.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.ACTION_SPINS_GAME_CONTINUE_SMALL));
							i.anchor.set(0, 0);
							const s = new n.Label(h.NolimitPromotionPlugin.apiPlugIn.translations.translate(u.PromoPanelLabelIDs.CONTINUE), o.PromoPanelTextStyles.AS_ROUND_INFO_CONTINUE_STYLE);
							s.anchor.set(0, .5), s.position.set(i.width + 5, .5 * i.height), e.addChild(i, s), e.pivot.set(.5 * e.width, 0), e.position.set(.5 * t.width, t.height + 5), t.addChild(e)
						}
					}
					updateLayout(t, e) {
						t ? (s.GuiLayout.align([this.title, this.titleValue], 10, s.Align.LEFT, s.Direction.HORIZONTAL), s.GuiLayout.align(this.buttons, 25, s.Align.CENTER, s.Direction.HORIZONTAL), s.GuiLayout.align([this.textContainer, this.buttonsContainer], 10, s.Align.LEFT, s.Direction.VERTICAL), this.buttonsContainer.position.x = .5 * (e - this.buttonsContainer.width)) : (s.GuiLayout.align([this.title, this.titleValue], 10, s.Align.LEFT, s.Direction.HORIZONTAL), s.GuiLayout.align(this.buttons, 5, s.Align.CENTER, s.Direction.HORIZONTAL), s.GuiLayout.align([this.textContainer, this.buttonsContainer], 10, s.Align.LEFT, s.Direction.VERTICAL), this.buttonsContainer.position.x = 0)
					}
					getSelection() {
						return this.selection
					}
					setTitleValue(t) {
						this.titleValue.text = t
					}
					select(t) {
						this.skipSound = !0, this.buttons[t].virtualClick()
					}
					buttonClicked(t) {
						if (this._enabled)
							if (this.skipSound || h.NolimitPromotionPlugin.sound.playKeypadEffect("click"), this.skipSound = !1, t.toggled) this.deselectable && (t.toggled = !1, this.selection = void 0, this.stateChangeCallback(this));
							else {
								t.toggled = !0;
								for (let e of this.buttons) e != t && (e.toggled = !1);
								this.selection = t.data, this.stateChangeCallback(this)
							}
					}
				}
				e.GameOptionSelectorComponent = c
			},
			24390: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BonusBuyPopUpContent = void 0;
				const n = i(61e3),
					s = i(2425),
					o = i(68714),
					r = i(11499),
					a = i(63288),
					l = i(56401);
				class h extends PIXI.Container {
					constructor(t) {
						super(), this.featureName = t.name, this.featureImage = new PIXI.Sprite(n.ImgLoader.getImgTexture(t.name)), this.featureImage.anchor.set(.5, .5), this.bet = s.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel(), this.price = +this.bet * t.price, this.priceString = r.CurrencyUtils.formatWithDecimalCutOff(this.price), this.priceLabel = new o.Label(this.priceString, a.PromoPanelTextStyles.POP_UP_FORMATTED_PRICE), this.priceLabel.anchor.set(.5, .5), this.textLabel = new o.Label(s.NolimitPromotionPlugin.apiPlugIn.translations.translate(l.PromoPanelLabelIDs.CHARGE_FROM_WALLET), a.PromoPanelTextStyles.POP_UP_CHARGE_FROM_WALLET_TEXT), this.textLabel.anchor.set(.5, .5), this.featureImage.position.set(0, 150), this.priceLabel.position.set(0, 340), this.textLabel.position.set(0, 380), this.addChild(this.featureImage, this.priceLabel, this.textLabel)
					}
				}
				e.BonusBuyPopUpContent = h
			},
			2996: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ConfirmBetPopUpView = void 0;
				const n = i(61e3),
					s = i(50799),
					o = i(56254),
					r = i(39055),
					a = i(66619),
					l = i(2425),
					h = i(56401),
					u = i(63288),
					c = i(19803),
					d = i(68714),
					p = i(72468),
					_ = i(5117),
					m = i(77616),
					g = i(38801),
					f = i(13006),
					S = i(11499),
					y = i(24390);
				class v extends PIXI.Container {
					get isOpen() {
						return this.visible
					}
					constructor() {
						super(), this.init()
					}
					resize() {
						this._background.width = p.NolimitApplication.screenBounds.width, this._background.height = p.NolimitApplication.screenBounds.height, this._background.position.set(0, 0);
						const t = p.NolimitApplication.isLandscape ? 0 : p.NolimitApplication.screenBounds.height - this._popUpPlate.height;
						this._popUpPlate.position.set(.5 * p.NolimitApplication.screenBounds.width, .5 * t)
					}
					openActionSpins(t, e) {
						let i;
						i = this.createActionSpinsContent(e), this._contentContainer.addChild(i), this._buttonClickCallback = t, this._betFeature = e.featureData, this.show()
					}
					close() {
						this._buttonClickCallback = void 0, this._contentContainer.removeChildren(), this.blinkAnim && (this.blinkAnim.pause(), this.blinkAnim = void 0), this._betFeature = void 0, this.hide()
					}
					init() {
						this._background = new PIXI.Sprite(PIXI.Texture.WHITE), this._background.tint = 0, this._background.alpha = .6, this._background.interactive = !0, this._background.name = "_background", this._popUpPlate = new PIXI.NineSlicePlane(n.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.POP_UP_BG), 64, 64, 64, 64), this._popUpPlate.width = 640, this._popUpPlate.height = 700, this._popUpPlate.pivot.set(.5 * this._popUpPlate.width, 0), this._popUpPlate.name = "_popUpPlate";
						let t = new o.PointerStateColorSet(4294967295, 4294967295, 4294967295, 872415231),
							e = new o.PointerStateColorSet(4278190080, 4294966272, 4278190080, 872414208);
						this._cancelButton = new a.PromoPanelLabelButton(r.PromoPanelButtonIDs.POP_UP_CLOSE, l.NolimitPromotionPlugin.apiPlugIn.translations.translate(h.PromoPanelLabelIDs.POPUP_CANCEL), e, t, u.PromoPanelTextStyles.GAME_FEATURE_OK_TEXT, void 0, (0, a.createDefaultButtonStroke)()), this._cancelButton.setSize(c.PromoPanelConfig.DEFAULT_LARGE_BUTTON_SIZE.width, c.PromoPanelConfig.DEFAULT_LARGE_BUTTON_SIZE.height), this._cancelButton.enable(!0), this._cancelButton.addClickCallback((() => {
							this.buttonClicked(this._cancelButton)
						})), this._okButton = new a.PromoPanelLabelButton(r.PromoPanelButtonIDs.OK_BTN, l.NolimitPromotionPlugin.apiPlugIn.translations.translate(h.PromoPanelLabelIDs.POPUP_OK), e, t, u.PromoPanelTextStyles.GAME_FEATURE_OK_TEXT, void 0, (0, a.createDefaultButtonStroke)()), this._okButton.setSize(c.PromoPanelConfig.DEFAULT_LARGE_BUTTON_SIZE.width, c.PromoPanelConfig.DEFAULT_LARGE_BUTTON_SIZE.height), this._okButton.enable(!0), this._okButton.addClickCallback((() => {
							this.buttonClicked(this._okButton)
						})), this._cancelButton.resize(30), this._okButton.resize(30);
						const i = Math.max(this._cancelButton.width, this._okButton.width);
						this._cancelButton.setSize(i, this._cancelButton.height), this._okButton.setSize(i, this._okButton.height), this._okButton.pivot.set(0, 0), this._cancelButton.pivot.set(0, 0);
						const d = new PIXI.Container;
						d.addChild(this._cancelButton, this._okButton), d.position.set(320, 590), g.GuiLayout.align([this._cancelButton, this._okButton], 30, g.Align.LEFT, g.Direction.HORIZONTAL), d.pivot.set(.5 * d.width, .5 * d.height), this._contentContainer = new PIXI.Container, this._contentContainer.name = "content", this._contentContainer.position.set(320, 48), this._popUpPlate.addChild(d, this._contentContainer), this.addChild(this._background, this._popUpPlate), this.close()
					}
					buttonClicked(t) {
						l.NolimitPromotionPlugin.sound.playKeypadEffect("click"), this._buttonClickCallback && this._buttonClickCallback(t, this._betFeature)
					}
					show() {
						this.resize(), this.visible = !0, this._background.alpha = 0, f.TweenMax.to(this._background, .1, {
							alpha: .6
						})
					}
					hide() {
						this.visible = !1
					}
					createBonusBuyContent(t) {
						return new y.BonusBuyPopUpContent(t)
					}
					createActionSpinsContent(t) {
						const e = new PIXI.Container,
							i = new PIXI.Container;
						i.name = "Header";
						const o = new d.Label(h.PromoPanelLabelIDs.ACTION_SPINS, u.PromoPanelTextStyles.ACTION_SPINS_SETTINGS_HEADER);
						if (i.addChild(o), t.isBonusBuy) {
							const t = new PIXI.TextStyle({
									fontFamily: _.OpenSans.FAMILY,
									fontSize: 14,
									fontStyle: m.FontStyle.NORMAL,
									fontWeight: m.FontWeight.BOLD,
									fill: 0,
									wordWrap: !0,
									wordWrapWidth: 500,
									align: "center"
								}),
								e = l.NolimitPromotionPlugin.apiPlugIn.translations.translate("Warning! You are about to play Nolimit Bonus in Hyper speed!"),
								r = new d.Label(e, t);
							r.position.set(.5 * (500 - r.width), o.y + o.height + 15);
							const a = new PIXI.Sprite(n.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.NAV_NOLIMIT_BONUS));
							a.scale.set(.5, .5), a.anchor.set(1, 0), a.position.set(500, -9), this.blinkAnim = f.TweenMax.fromTo(a, .8, {
								alpha: 0
							}, {
								alpha: 1,
								repeat: -1,
								yoyo: !0,
								ease: f.Expo.easeInOut
							}), i.addChild(r, a)
						}
						const r = new PIXI.Container,
							a = [],
							c = this.createBasicAsSetting(l.NolimitPromotionPlugin.apiPlugIn.translations.translate("Bet"), t.bet);
						a.push(c);
						const p = this.createBasicAsSetting(l.NolimitPromotionPlugin.apiPlugIn.translations.translate("Rounds"), t.rounds + "");
						if (a.push(p), g.GuiLayout.align(a, 40, g.Align.LEFT, g.Direction.HORIZONTAL), r.addChild(...a), r.pivot.set(.5 * r.width, 0), t.image) {
							const i = new PIXI.Sprite(n.ImgLoader.getImgTexture(t.image));
							i.anchor.set(.5, .5), i.position.set(0, 200), e.addChild(i)
						}
						const y = new PIXI.Container,
							v = [];
						if (t.featureData) {
							const e = +l.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel() * t.featureData.price * t.rounds;
							v.push(this.createOneLabelOption(`(${t.bet} x ${t.rounds} = ${S.CurrencyUtils.formatWithDecimalCutOff(e)})`))
						}
						if (t.options)
							for (let e of t.options) null != e.displayValue ? v.push(this.createOption(e.header || "", e.displayValue)) : v.push(this.createOption(e.header || "", e.name));
						return t.stopOnBonus && v.push(this.createOption(l.NolimitPromotionPlugin.apiPlugIn.translations.translate(h.PromoPanelLabelIDs.STOP_ON_BONUS), l.NolimitPromotionPlugin.apiPlugIn.translations.translate(h.PromoPanelLabelIDs.YES))), v.length > 0 && (g.GuiLayout.align(v, 10, g.Align.CENTER, g.Direction.VERTICAL), y.addChild(...v)), y.pivot.set(.5 * y.width, 0), i.position.set(-250, 0), r.position.set(0, 350), y.position.set(0, 430), e.addChild(i, r, y), e
					}
					createBasicAsSetting(t, e) {
						const i = new PIXI.TextStyle({
							fontFamily: _.OpenSans.FAMILY,
							fontSize: 20,
							fontStyle: m.FontStyle.NORMAL,
							fontWeight: m.FontWeight.LIGHT,
							fill: 0
						});
						let n = new PIXI.TextStyle({
							fontFamily: _.OpenSans.FAMILY,
							fontSize: 35,
							fontStyle: m.FontStyle.NORMAL,
							fontWeight: m.FontWeight.NORMAL,
							fill: 0
						});
						const s = new d.Label(t, i),
							o = new d.Label(e, n);
						g.GuiLayout.align([s, o], 0, g.Align.CENTER, g.Direction.VERTICAL);
						const r = new PIXI.Container;
						return r.addChild(s, o), r.name = t, r
					}
					createOption(t, e) {
						const i = new PIXI.TextStyle({
							fontFamily: _.OpenSans.FAMILY,
							fontSize: 20,
							fontStyle: m.FontStyle.NORMAL,
							fontWeight: m.FontWeight.NORMAL,
							fill: 0
						});
						let n = new PIXI.TextStyle({
							fontFamily: _.OpenSans.FAMILY,
							fontSize: 20,
							fontStyle: m.FontStyle.NORMAL,
							fontWeight: m.FontWeight.BOLD,
							fill: 0
						});
						const s = new d.Label(t, i),
							o = new d.Label(e, n);
						g.GuiLayout.align([s, o], 10, g.Align.LEFT, g.Direction.HORIZONTAL);
						const r = new PIXI.Container;
						return r.addChild(s, o), r.name = t, r
					}
					createOneLabelOption(t) {
						let e = new PIXI.TextStyle({
							fontFamily: _.OpenSans.FAMILY,
							fontSize: 20,
							fontStyle: m.FontStyle.NORMAL,
							fontWeight: m.FontWeight.BOLD,
							fill: 0
						});
						const i = new d.Label(t, e);
						i.anchor.set(0, .5);
						const n = new PIXI.Container;
						return n.addChild(i), n
					}
				}
				e.ConfirmBetPopUpView = v
			},
			41284: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ReplayController = void 0;
				const n = i(64633),
					s = i(2425),
					o = i(72468),
					r = i(77549),
					a = i(39055),
					l = i(94183),
					h = i(10386),
					u = i(19803),
					c = i(46334),
					d = i(12342);
				e.ReplayController = class {
					constructor(t) {
						this._isRequestCompleted = !0, this._isCurrentGame = !0, this._isXBet = !0, this._isSinglePlayer = !1, this._promotionPlugin = t, this.init()
					}
					static makeIFrame(t) {
						const e = document.createElement("iframe");
						return e.name = t, e.style.width = "100%", e.style.height = "100%", e.style.position = "absolute", e.style.zIndex = "2147483647", e.style.overflow = "hidden", e.style.backgroundColor = "black", e.setAttribute("frameborder", "0"), e.setAttribute("allowfullscreen", ""), e.setAttribute("sandbox", "allow-forms allow-scripts allow-same-origin allow-top-navigation allow-popups"), e.setAttribute("allowfullscreen", ""), e.setAttribute("allow", "autoplay; fullscreen"), e.id = t, e
					}
					init() {
						this._communication = new h.Communication(s.NolimitPromotionPlugin.apiPlugIn), this.addEventListeners()
					}
					addEventListeners() {
						o.NolimitApplication.events.on(r.PromoPanelEvents.NAV_BUTTON_PRESSED, (t => this.onNavButtonPressed(t)))
					}
					createView(t) {
						null == this._view && (this._view = new n.ReplayView(this, t))
					}
					open() {
						this._view && (this._view.open(), this.isCurrentGame ? this.buttonClick(new l.GuiButton(a.PromoPanelButtonIDs.CURRENT_GAME_BTN), void 0, !0) : this.buttonClick(new l.GuiButton(a.PromoPanelButtonIDs.ALL_GAME_BTN), void 0, !0))
					}
					close() {
						this._view && this._view.close()
					}
					buttonClick(t, e, i = !1) {
						if (this._isRequestCompleted) switch (!i && s.NolimitPromotionPlugin.sound.playKeypadEffect("click"), t.name) {
							case a.PromoPanelButtonIDs.CURRENT_GAME_BTN:
								this.isCurrentGame = !0, this.getData();
								break;
							case a.PromoPanelButtonIDs.ALL_GAME_BTN:
								this.isCurrentGame = !1, this.getData();
								break;
							case a.PromoPanelButtonIDs.SINGLE_PLAYER_BTN:
								this.isSinglePlayer = !0, this.getData();
								break;
							case a.PromoPanelButtonIDs.ALL_PLAYER_BTN:
								this.isSinglePlayer = !1, this.getData();
								break;
							case a.PromoPanelButtonIDs.X_BET_FILTER_BTN:
								this.isXBet = !0, this.getData();
								break;
							case a.PromoPanelButtonIDs.X_WIN_FILTER_BTN:
								this.isXBet = !1, this.getData();
								break;
							default:
								c.Logger.warn("Replay Controller Button click :: no case match : ", t)
						}
					}
					openReplay(t) {
						s.NolimitPromotionPlugin.apiPlugIn.openReplay(t)
					}
					getTopMonetaryData(t) {
						this._isRequestCompleted = !1, this._communication.getTopMonetaryData(t).then((t => {
							this._view.update(t.rounds), this._isRequestCompleted = !0
						}), (t => {
							c.Logger.warn("ReplayController : promise reject data : ", t)
						}))
					}
					getXBetGameSpecificData(t, e) {
						this._isRequestCompleted = !1, this._communication.getXBetGameSpecificData(t, e).then((t => {
							this._view.update(t.rounds), this._isRequestCompleted = !0
						}), (t => {
							c.Logger.warn("ReplayController : promise reject data : ", t)
						}))
					}
					getMonetaryGameSpecificData(t, e) {
						this._isRequestCompleted = !1, this._communication.getMonetaryGameSpecificData(t, e).then((t => {
							this._view.update(t.rounds), this._isRequestCompleted = !0
						}), (t => {
							c.Logger.warn("ReplayController : promise reject data : ", t)
						}))
					}
					onNavButtonPressed(t) {
						t == a.PromoPanelButtonIDs.NOLIMIT_WINNERS ? this.open() : this.close()
					}
					receiveMessage(t) {
						var e;
						"exit-replay" === t.data && (null === (e = document.getElementById("replayIframe")) || void 0 === e || e.remove(), s.NolimitPromotionPlugin.sound.resume(), this._replayGameWindow && (this._replayGameWindow.close(), this._replayGameWindow = null))
					}
					getData() {
						this._view.update([]), this._view.playLoadingAnimation();
						const t = s.NolimitPromotionPlugin.apiPlugIn.options.operator;
						let e = s.NolimitPromotionPlugin.apiPlugIn.options.game;
						e = e.replace(u.PromoPanelConfig.GAME_NAME_FILTER_REG_EXP, ""), this.isCurrentGame ? this.isSinglePlayer ? this._isXBet ? this.getCurrentPlayerCurrentGameTopList(d.ReplayFilterTypes.MULTIPLIER) : this.getCurrentPlayerCurrentGameTopList(d.ReplayFilterTypes.MONETARY) : this._isXBet ? this.getXBetGameSpecificData(e, t) : this.getMonetaryGameSpecificData(e, t) : this.isSinglePlayer ? this._isXBet ? this.getCurrentPlayerAllGameTopList(d.ReplayFilterTypes.MULTIPLIER) : this.getCurrentPlayerAllGameTopList(d.ReplayFilterTypes.MONETARY) : this._isXBet ? this.getTopXBetData(t) : this.getTopMonetaryData(t)
					}
					getCurrentPlayerCurrentGameTopList(t) {
						this._isRequestCompleted = !1, this._communication.getTopListCurrentGame(t).then((t => {
							this._view.update(t), this._isRequestCompleted = !0
						}), (t => {
							c.Logger.warn("ReplayController : promise reject data : ", t)
						}))
					}
					getCurrentPlayerAllGameTopList(t) {
						this._isRequestCompleted = !1, this._communication.getTopListAnyGame(t).then((t => {
							this._view.update(t), this._isRequestCompleted = !0
						}), (t => {
							c.Logger.warn("ReplayController : promise reject data : ", t)
						}))
					}
					getTopXBetData(t) {
						this._isRequestCompleted = !1, this._communication.getTopXBetData(t).then((t => {
							this._view.update(t.rounds), this._isRequestCompleted = !0
						}), (t => {
							c.Logger.warn("ReplayController : promise reject data : ", t)
						}))
					}
					get view() {
						return this._view
					}
					set view(t) {
						this._view = t
					}
					get isCurrentGame() {
						return this._isCurrentGame
					}
					set isCurrentGame(t) {
						this._isCurrentGame = t, this._view.toggleButtons()
					}
					get isXBet() {
						return this._isXBet
					}
					set isXBet(t) {
						this._isXBet = t, this._view.toggleButtons()
					}
					get isSinglePlayer() {
						return this._isSinglePlayer
					}
					set isSinglePlayer(t) {
						this._isSinglePlayer = t, this._view.toggleButtons()
					}
				}
			},
			64633: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ReplayView = void 0;
				const n = i(51797),
					s = i(72468),
					o = i(50799),
					r = i(56401),
					a = i(56254),
					l = i(46980),
					h = i(85136),
					u = i(66515),
					c = i(39055),
					d = i(68714),
					p = i(63288),
					_ = i(2425),
					m = i(80362),
					g = i(19803),
					f = i(71855),
					S = i(91746),
					y = i(66619),
					v = i(13006),
					T = i(61e3);
				class E extends n.FeatureBasePanel {
					constructor(t, e) {
						super(o.PromoPanelAssetConfig.NOLIMIT_WINNERS_ICON, _.NolimitPromotionPlugin.apiPlugIn.translations.translate(r.PromoPanelLabelIDs.REPLAY_FEATURE_TITLE), p.PromoPanelTextStyles.FEATURE_BASE_REPLAY_TITLE), this._controller = t, this._scroll = e
					}
					init() {
						super.init(), this.createButtons(), this.createMiddleBarWithText(), this.createFilters(), this._roundInfoContainer = new PIXI.Container, this._roundInfoContainer.name = "ROUND_INFO_CONTAINER", this.addChild(this._roundInfoContainer), this.createLoadingAnimation()
					}
					toggleButtons() {
						this._currentGameBtn.toggled = this._controller.isCurrentGame, this._allGamesBtn.toggled = !this._controller.isCurrentGame, this._xBetFilterLabelBtn.toggled = this._controller.isXBet, this._xWinFilterLabelBtn.toggled = !this._controller.isXBet, this._singlePlayer.toggled = this._controller.isSinglePlayer, this._allPlayer.toggled = !this._controller.isSinglePlayer, this.updateButtonStyle(), this.updateMiddleBarText(this._singlePlayer.toggled)
					}
					clearRoundInfoData() {
						this._roundInfoContainer.removeChildren()
					}
					update(t) {
						this.stopLoadingAnimation(), this.clearRoundInfoData(), t.forEach(((t, e) => {
							this._roundInfoContainer.addChild(new m.RoundInfoView(this._controller, t, e))
						})), this._roundInfoContainer.children.forEach(((t, e) => {
							t.updateButtonStyle(this._xBetFilterLabelBtn.toggled)
						})), this._scroll.scrollEnabled = !0, this.updateScroll(), this._scroll.reAddMouseHoverListener(), this._scroll.updateContent()
					}
					disableButtons() {}
					onResize() {
						if (this._isOpen) {
							const t = s.NolimitApplication.screenBounds,
								e = s.NolimitApplication.isLandscape && f.Helper.isDefaultScreenRatio(t);
							let i = t.width;
							this._scroll.position.set(0, 105);
							let n = 10,
								r = m.RoundInfoView.INFO_BG_WIDTH_PORTRAIT;
							if (e) r = m.RoundInfoView.INFO_BG_WIDTH_LANDSCAPE, n = 25, i = t.width - g.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, this._separator.position.set(f.Helper.floorPos(i / 2), 213), this._scroll.resize(t.width - g.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, t.height - _.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - 1), this._scroll.position.set(g.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, 0);
							else if (s.NolimitApplication.isLandscape && !f.Helper.isDefaultScreenRatio(t)) i = t.width - g.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, this._separator.position.set(f.Helper.floorPos(i / 2), 213), this._scroll.position.set(g.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, 0), this._scroll.resize(t.width - g.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, t.height - _.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - 1);
							else {
								this._separator.position.set(f.Helper.floorPos(i / 2), 203);
								const e = T.ImgLoader.getImgTexture(o.PromoPanelAssetConfig.TOP_BAR).height - 10;
								this._scroll.position.set(0, e), this._scroll.resize(i, t.height - _.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - e - g.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT)
							}
							this._loadingCircle.position.set(Math.floor(i / 2), 360), this._currentGameBtn.position.set(f.Helper.floorPos(i / 2 - .5 * this._currentGameBtn.width - 38), this._separator.y), this._allGamesBtn.position.set(f.Helper.floorPos(i / 2 + .5 * this._currentGameBtn.width + 38), this._separator.y), this._currentGameText.position.set(this._currentGameBtn.x, this._currentGameBtn.y), this._allGameText.position.set(this._allGamesBtn.x, this._allGamesBtn.y), this._singlePlayer.position.set(f.Helper.floorPos(i / 2 - .5 * this._singlePlayer.width - 16), 338), this._allPlayer.position.set(f.Helper.floorPos(i / 2 + .5 * this._singlePlayer.width + 16), 338), this._middleBar.clear(), this._middleBar.beginFill(4283005114, 1), this._middleBar.drawRect(0, 407, i, 45), this._middleBarText.position.set(f.Helper.floorPos(i / 2), 432), this._xBetFilterLabelBtn.position.set(f.Helper.floorPos(i / 2), 506), this._xWinFilterLabelBtn.position.set(f.Helper.floorPos(i / 2 + .5 * r - this._xWinFilterLabelBtn.pivot.x - n), 506), this._roundInfoContainer.position.set(0, 518), this.position.set(0, 0), this._roundInfoContainer.children.forEach(((t, e) => {
								t.onResize()
							})), this._xBetFilterLabelBtn.resize(p.PromoPanelTextStyles.REPLAY_FILTER_STYLE_INACTIVE.padding), this._xWinFilterLabelBtn.resize(p.PromoPanelTextStyles.REPLAY_FILTER_STYLE_INACTIVE.padding), super.onResize(), this.resizeTextLabel(), this._scroll.scrollEnabled = !0, this._scroll.updateContent()
						}
					}
					playLoadingAnimation() {
						this._loadingCircle.visible = !0, this._loadingAnimation.play()
					}
					show() {
						this._scroll.visible = !0, super.show(), this._scroll.scrollEnabled = !0, this._scroll.updateContent()
					}
					hide() {
						super.hide(), this._scroll.visible = !1
					}
					updateScroll() {
						const t = s.NolimitApplication.screenBounds,
							e = s.NolimitApplication.isLandscape && f.Helper.isDefaultScreenRatio(t);
						if (this._scroll.position.set(0, 105), e) this._scroll.resize(t.width - g.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, t.height - _.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - 1), this._scroll.position.set(g.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, 0);
						else if (s.NolimitApplication.isLandscape && !f.Helper.isDefaultScreenRatio(t)) this._separator.position.set(f.Helper.floorPos(t.width / 2), 213), this._scroll.position.set(g.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, 0), this._scroll.resize(t.width - g.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, t.height - _.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - 1);
						else {
							const e = T.ImgLoader.getImgTexture(o.PromoPanelAssetConfig.TOP_BAR).height - 10;
							this._scroll.position.set(0, e), this._scroll.resize(t.width, t.height - _.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - e - g.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT)
						}
					}
					createButtons() {
						this._buttonContainer = new PIXI.Container, this.addChild(this._buttonContainer), this._currentGameBtn = this.createToggleButton(this._buttonContainer, c.PromoPanelButtonIDs.CURRENT_GAME_BTN, o.PromoPanelAssetConfig.GAME_TYPE_ACTIVE, o.PromoPanelAssetConfig.GAME_TYPE_INACTIVE, 4280173447, 4280173447), this._separator = new PIXI.Sprite(PIXI.Texture.WHITE), this._separator.anchor.set(.5, .5), this._separator.tint = 4280173447, this._separator.height = 90, this._separator.width = 2, this._allGamesBtn = this.createToggleButton(this._buttonContainer, c.PromoPanelButtonIDs.ALL_GAME_BTN, o.PromoPanelAssetConfig.GAME_TYPE_ACTIVE, o.PromoPanelAssetConfig.GAME_TYPE_INACTIVE, 4280173447, 4280173447), this._singlePlayer = this.createToggleButton(this._buttonContainer, c.PromoPanelButtonIDs.SINGLE_PLAYER_BTN, o.PromoPanelAssetConfig.PLAYER_ACTIVE, o.PromoPanelAssetConfig.PLAYER_INACTIVE), this._allPlayer = this.createToggleButton(this._buttonContainer, c.PromoPanelButtonIDs.ALL_PLAYER_BTN, o.PromoPanelAssetConfig.ALL_PLAYER_ACTIVE, o.PromoPanelAssetConfig.ALL_PLAYER_INACTIVE), this._currentGameText = new S.PromoPanelTextLabel(_.NolimitPromotionPlugin.apiPlugIn.translations.translate(r.PromoPanelLabelIDs.REPLAY_CURRENT_GAME), p.PromoPanelTextStyles.REPLAY_GAME_BTN_ACTIVE, {
							portraitMaxWidth: this._currentGameBtn.width - 15,
							landscapeMaxWidth: this._currentGameBtn.width - 15
						}), this._allGameText = new S.PromoPanelTextLabel(_.NolimitPromotionPlugin.apiPlugIn.translations.translate(r.PromoPanelLabelIDs.REPLAY_ALL_GAMES), p.PromoPanelTextStyles.REPLAY_GAME_BTN_INACTIVE, {
							portraitMaxWidth: this._allGamesBtn.width - 15,
							landscapeMaxWidth: this._allGamesBtn.width - 15
						}), this._currentGameText.anchor.set(.5, .5), this._allGameText.anchor.set(.5, .5), this._buttonContainer.addChild(this._currentGameText, this._separator, this._allGameText)
					}
					createToggleButton(t, e, i, n, s = 4294967295, o) {
						const r = new a.PointerStateColorSet(s);
						let c = new l.PointerStateIconSet(new h.Icon(T.ImgLoader.getImgTexture(i))),
							d = new l.PointerStateIconSet(new h.Icon(T.ImgLoader.getImgTexture(n)));
						const p = new u.IconToggleButton(e, c, r, d);
						return p.addClickCallback((() => this._controller.buttonClick(p))), p.toggled = !1, p.enable(!0), t && (t.addChild(p), p.pivot.set(.5 * p.width, .5 * p.height)), p
					}
					updateButtonStyle() {
						this._currentGameText.setStyle(this._currentGameBtn.toggled ? p.PromoPanelTextStyles.REPLAY_GAME_BTN_ACTIVE : p.PromoPanelTextStyles.REPLAY_GAME_BTN_INACTIVE), this._allGameText.setStyle(this._allGamesBtn.toggled ? p.PromoPanelTextStyles.REPLAY_GAME_BTN_ACTIVE : p.PromoPanelTextStyles.REPLAY_GAME_BTN_INACTIVE), this._xBetFilterLabelBtn.label.setColor(this._xBetFilterLabelBtn.toggled ? p.PromoPanelTextStyles.REPLAY_FILTER_STYLE_ACTIVE_FILL_COLOR : p.PromoPanelTextStyles.REPLAY_FILTER_STYLE_INACTIVE_FILL_COLOR), this._xWinFilterLabelBtn.label.setColor(this._xWinFilterLabelBtn.toggled ? p.PromoPanelTextStyles.REPLAY_FILTER_STYLE_ACTIVE_FILL_COLOR : p.PromoPanelTextStyles.REPLAY_FILTER_STYLE_INACTIVE_FILL_COLOR)
					}
					updateMiddleBarText(t) {
						this._middleBarText.text = _.NolimitPromotionPlugin.apiPlugIn.translations.translate(t ? r.PromoPanelLabelIDs.REPLAY_MY_TOP_WINS_HEADING : r.PromoPanelLabelIDs.REPLAY_TOP_WINS_HEADING)
					}
					createMiddleBarWithText() {
						this._middleBar = new PIXI.Graphics, this._middleBarText = new d.Label(_.NolimitPromotionPlugin.apiPlugIn.translations.translate(r.PromoPanelLabelIDs.REPLAY_TOP_WINS_HEADING), p.PromoPanelTextStyles.REPLAY_MIDDLE_BAR_TEXT), this._middleBarText.anchor.set(.5, .5), this.addChild(this._middleBar, this._middleBarText)
					}
					createFilters() {
						this._filterContainer = new PIXI.Container, this._filterContainer.name = "FILTER_CONTAINER", this.addChild(this._filterContainer), this._xBetFilterLabelBtn = this.createFilterButton(c.PromoPanelButtonIDs.X_BET_FILTER_BTN, r.PromoPanelLabelIDs.REPLAY_X_BET, p.PromoPanelTextStyles.REPLAY_FILTER_STYLE_INACTIVE), this._xWinFilterLabelBtn = this.createFilterButton(c.PromoPanelButtonIDs.X_WIN_FILTER_BTN, r.PromoPanelLabelIDs.REPLAY_X_WIN, p.PromoPanelTextStyles.REPLAY_FILTER_STYLE_INACTIVE), this._xBetFilterLabelBtn.label.text = "x" + g.PromoPanelConfig.SINGLE_BLANK_SPACE + this._xBetFilterLabelBtn.label.text, this._filterContainer.addChild(this._xBetFilterLabelBtn, this._xWinFilterLabelBtn);
						const t = _.NolimitPromotionPlugin.imgLoader.getImgTexture(o.PromoPanelAssetConfig.REPLAY_WIN_BUTTON_ACTIVE).height;
						this._xBetFilterLabelBtn.setSize(this._xBetFilterLabelBtn.label.width + p.PromoPanelTextStyles.REPLAY_FILTER_STYLE_INACTIVE.padding, t), this._xWinFilterLabelBtn.setSize(this._xWinFilterLabelBtn.label.width + p.PromoPanelTextStyles.REPLAY_FILTER_STYLE_INACTIVE.padding, t), this._xBetFilterLabelBtn.toggled = !0, this._xWinFilterLabelBtn.toggled = !1
					}
					createFilterButton(t, e, i) {
						const n = new PIXI.NineSlicePlane(_.NolimitPromotionPlugin.imgLoader.getImgTexture(o.PromoPanelAssetConfig.REPLAY_WIN_BUTTON_ACTIVE), 20, 20, 20, 20),
							s = new PIXI.NineSlicePlane(_.NolimitPromotionPlugin.imgLoader.getImgTexture(o.PromoPanelAssetConfig.REPLAY_WIN_BUTTON), 20, 20, 20, 20),
							r = new y.PromoPanelLabelButton(t, _.NolimitPromotionPlugin.apiPlugIn.translations.translate(e), void 0, void 0, i, n, void 0, s);
						return r.addClickCallback((() => this._controller.buttonClick(r))), r.enable(!0), r
					}
					createLoadingAnimation() {
						this._loadingCircle = new PIXI.Sprite(_.NolimitPromotionPlugin.imgLoader.getImgTexture(o.PromoPanelAssetConfig.LOADING_CIRCLE)), this._loadingCircle.anchor.set(.5), this._loadingAnimation = v.TweenMax.to(this._loadingCircle, 30, {
							rotation: "360",
							ease: v.Linear.easeNone,
							repeat: -1
						}), this.stopLoadingAnimation(), this.addChild(this._loadingCircle)
					}
					stopLoadingAnimation() {
						this._loadingCircle.visible = !1, this._loadingAnimation.pause()
					}
					resizeTextLabel() {
						this._currentGameText.onResize(), this._allGameText.onResize()
					}
				}
				e.ReplayView = E
			},
			80362: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.RoundInfoView = void 0;
				const n = i(2425),
					s = i(50799),
					o = i(66515),
					r = i(68714),
					a = i(56254),
					l = i(46980),
					h = i(85136),
					u = i(72468),
					c = i(39055),
					d = i(63288),
					p = i(1235),
					_ = i(71855),
					m = i(19803),
					g = i(46334),
					f = i(91746),
					S = i(61e3),
					y = i(38801);
				class v extends PIXI.Container {
					constructor(t, e, i) {
						super(), this._data = e, this._controller = t, this._index = i, this.init()
					}
					updateButtonStyle(t) {
						this._bet.setStyle(t ? d.PromoPanelTextStyles.ROUND_INFO_BET_TEXT_ACTIVE : d.PromoPanelTextStyles.ROUND_INFO_BET_TEXT_INACTIVE), this._currency.setStyle(t ? d.PromoPanelTextStyles.ROUND_INFO_BET_TEXT_INACTIVE : d.PromoPanelTextStyles.ROUND_INFO_BET_TEXT_ACTIVE), this._win.setStyle(t ? d.PromoPanelTextStyles.ROUND_INFO_BET_TEXT_INACTIVE : d.PromoPanelTextStyles.ROUND_INFO_BET_TEXT_ACTIVE)
					}
					onResize() {
						const t = u.NolimitApplication.screenBounds,
							e = u.NolimitApplication.isLandscape && _.Helper.isDefaultScreenRatio(t);
						let i = 20,
							n = 1,
							s = t.width - m.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT,
							o = v.INFO_BG_WIDTH_PORTRAIT;
						e ? (i = 30, n = 1, o = v.INFO_BG_WIDTH_LANDSCAPE) : u.NolimitApplication.isLandscape && !_.Helper.isDefaultScreenRatio(t) || (s = t.width), this.resizeTextLabel(), this._infoBg.position.set(_.Helper.floorPos(s / 2), _.Helper.floorPos(this._infoBg.height / 2)), this._infoBg.width = o, this._infoBg.pivot.x = _.Helper.floorPos(.5 * o), this._trophy.position.set(_.Helper.floorPos(this._infoBg.x - this._infoBg.width / 2 - 50), this._infoBg.y), this._date.position.set(_.Helper.floorPos(this._infoBg.x - .5 * this._infoBg.width + i), this._infoBg.y - n), this._featureIcons.position.set(this._date.position.x + this._date.width + 5, this._date.position.y), this._gameName.position.set(this._date.x, this._infoBg.y + n), this._bet.position.set(this._infoBg.x, this._infoBg.y), this._win.position.set(_.Helper.floorPos(this._infoBg.x + .5 * this._infoBg.width - i), this._infoBg.y), this._currency.position.set(_.Helper.floorPos(this._win.x - this._win.width - 5), this._infoBg.y), this._playBtn.position.set(_.Helper.floorPos(this._infoBg.width / 2 + this._infoBg.x + 10), this._infoBg.y), this.y = _.Helper.floorPos(this._index * (this.height + 15) + .5 * this.height)
					}
					init() {
						this.createTrophy(), this.createInfo(), this._featureIcons = this.createFeatureIcons(), this.addChild(this._featureIcons), this.createPlayBtn(), this.onResize()
					}
					createTrophy() {
						let t;
						switch (this._index) {
							case p.TrophyTypes.TROPHY_GOLD:
								t = new PIXI.Sprite(S.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.TROPHY_GOLD));
								break;
							case p.TrophyTypes.TROPHY_SILVER:
								t = new PIXI.Sprite(S.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.TROPHY_SILVER));
								break;
							case p.TrophyTypes.TROPHY_BRONZE:
								t = new PIXI.Sprite(S.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.TROPHY_BRONZE));
								break;
							default:
								t = new r.Label(this._index + 1 + "", d.PromoPanelTextStyles.ROUND_INFO_TROPHY_TEXT)
						}
						t instanceof PIXI.Sprite && t.pivot.set(-4, -4), t.anchor.set(.5, .5), this.addChild(t), this._trophy = t
					}
					createPlayBtn() {
						const t = new a.PointerStateColorSet(4294967295);
						let e = new l.PointerStateIconSet(new h.Icon(S.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.REPLAY_BUTTON)));
						const i = new o.IconToggleButton(c.PromoPanelButtonIDs.PLAY_BTN, e, t);
						i.addClickCallback((() => this._controller.openReplay(this._data.url))), i.toggled = !1, i.enable(!0), this.addChild(i), i.pivot.set(0, i.height / 2), this._playBtn = i
					}
					createInfo() {
						const t = new PIXI.NineSlicePlane(S.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.INFO_BG), 26, 26, 26, 26);
						t.pivot.set(.5 * t.width, .5 * t.height), this.addChild(t), this._infoBg = t;
						const e = new r.Label(this.getDateFormat(this._data.time), d.PromoPanelTextStyles.ROUND_INFO_DATE_TEXT);
						e.anchor.set(0, 1);
						const i = new r.Label(this.getGameNameFormat(this._data.game), d.PromoPanelTextStyles.ROUND_INFO_GAME_NAME_TEXT);
						i.anchor.set(0, 0);
						const o = new f.PromoPanelTextLabel(this._data.winMultiplication + " x", d.PromoPanelTextStyles.ROUND_INFO_BET_TEXT_ACTIVE, {
							landscapeMaxWidth: 150,
							portraitMaxWidth: 110
						});
						o.anchor.set(.5, .5);
						const a = new r.Label(this._data.currency, d.PromoPanelTextStyles.ROUND_INFO_CURRENCY_TEXT);
						a.anchor.set(1, .5), a.visible = !n.NolimitPromotionPlugin.apiPlugIn.options.hideCurrency;
						const l = this._data.win < m.PromoPanelConfig.NO_DECIMALS_CUTOFF_POINT || this._data.win % 1 != 0 ? 2 : 0,
							h = n.NolimitPromotionPlugin.apiPlugIn.currency.formatValue(this._data.win, {
								minimumPrecision: l
							}),
							u = new f.PromoPanelTextLabel(h + "", d.PromoPanelTextStyles.ROUND_INFO_WIN_TEXT, {
								landscapeMaxWidth: 180,
								portraitMaxWidth: 130
							});
						u.anchor.set(1, .5), this._date = e, this._gameName = i, this._bet = o, this._currency = a, this._win = u, this.addChild(this._date, this._gameName, this._bet, this._currency, this._win)
					}
					getDateFormat(t) {
						try {
							const e = new Date(t);
							return _.Helper.padZero(e.getFullYear()) + m.PromoPanelConfig.DATE_SEPARATOR + _.Helper.padZero(+e.getMonth() + 1) + m.PromoPanelConfig.DATE_SEPARATOR + _.Helper.padZero(e.getDate())
						} catch (e) {
							return g.Logger.warn("Invalid date format : ", t), t
						}
					}
					getGameNameFormat(t) {
						return t.length > 16 && (t = t.slice(0, 14) + ".."), t
					}
					resizeTextLabel() {
						this._bet.onResize(), this._win.onResize()
					}
					createFeatureIcons() {
						const t = new PIXI.Container;
						if (this._data.actionSpin) {
							const e = new PIXI.Sprite(S.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.ROUND_INFO_ACTION_SPINS_ICON));
							e.anchor.set(0, 1), t.addChild(e)
						}
						if (this._data.bonusBuy) {
							const e = new PIXI.Sprite(S.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.ROUND_INFO_BONUS_BUY_ICON));
							e.anchor.set(0, 1), t.addChild(e)
						}
						return y.GuiLayout.align(t.children, 3, y.Align.LEFT, y.Direction.HORIZONTAL), t
					}
				}
				v.INFO_BG_WIDTH_LANDSCAPE = 745, v.INFO_BG_WIDTH_PORTRAIT = 525, e.RoundInfoView = v
			},
			14108: (t, e) => {
				"use strict";
				var i;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ActionSpinSound = void 0, (i = e.ActionSpinSound || (e.ActionSpinSound = {}))[i.WIN = 0] = "WIN", i[i.BIG_WIN = 1] = "BIG_WIN"
			},
			3933: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.IntroPageCreator = void 0;
				const n = i(61e3),
					s = i(72468),
					o = i(50799),
					r = i(5117),
					a = i(50108),
					l = i(2425),
					h = i(54231),
					u = i(24591),
					c = i(13387),
					d = i(63288),
					p = i(56401);
				e.IntroPageCreator = class {
					constructor() {}
					getIntroPages(t) {
						const e = new a.FontLoader(s.NolimitApplication.resourcePath);
						e.add(r.OpenSans.NORMAL_600), e.add(r.OpenSans.NORMAL_800);
						const i = new n.ImgLoader(s.NolimitApplication.resourcePath);
						i.add("NolimitBonusAnimation", "/node_modules/@nolimitcity/promo-panel/resources/default/intro/NolimitBonusAnimation.json");
						for (let t of o.PromoPanelAssetConfig.getIntroAssets()) i.add(t.name, t.url);
						return Promise.all([i.load(), e.load()]).then((e => {
							const i = [];
							return t.hasActionSpin() && i.push(new c.NolimitActionSpinIntroPage(16695822, l.NolimitPromotionPlugin.apiPlugIn.translations.translate(p.PromoPanelLabelIDs.ACTION_SPINS), o.PromoPanelAssetConfig.ACTION_SPINS_ICON, d.PromoPanelTextStyles.FEATURE_ACTION_SPIN_REPLAY_TITLE)), t.hasNolimitWinners() && i.push(new h.NolimitWinnersIntroPage(6857945, l.NolimitPromotionPlugin.apiPlugIn.translations.translate(p.PromoPanelLabelIDs.REPLAY_FEATURE_TITLE), o.PromoPanelAssetConfig.NOLIMIT_WINNERS_ICON, d.PromoPanelTextStyles.FEATURE_BASE_REPLAY_TITLE)), t.hasNolimitTournaments() && i.push(new u.PromoPanelBaseIntroPage(16711680, "Nolimit Tournaments", o.PromoPanelAssetConfig.NOLIMIT_BONUS_ICON)), t.hasNolimitVoucher() && i.push(new u.PromoPanelBaseIntroPage(16711680, "Nolimit Voucher", o.PromoPanelAssetConfig.NOLIMIT_BONUS_ICON)), i
						}))
					}
				}
			},
			13387: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NolimitActionSpinIntroPage = void 0;
				const n = i(61e3),
					s = i(50799),
					o = i(24591),
					r = i(2425),
					a = i(78229),
					l = i(68714);
				class h extends o.PromoPanelBaseIntroPage {
					constructor(t, e, i, o) {
						super(t, e, i, o);
						const h = new l.Label(r.NolimitPromotionPlugin.apiPlugIn.translations.translate("Get your adrenaline flowing and play your regular or bonus rounds in HYPER MODE!"), a.GuiDefaults.INTRO_PAGE_TEXT);
						h.anchor.x = 1, h.anchor.y = .5, h.position.x = -10, h.position.y = 35;
						const u = new PIXI.Sprite(n.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.INTRO_ACTION_SPINS));
						u.anchor.set(.5, .5), u.position.set(200, 38), this.icon.scale.set(.7, .7), this.icon.position.set(44, 9), this.addChild(u, h)
					}
				}
				e.NolimitActionSpinIntroPage = h
			},
			54231: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NolimitWinnersIntroPage = void 0;
				const n = i(61e3),
					s = i(50799),
					o = i(24591),
					r = i(2425),
					a = i(78229),
					l = i(68714);
				class h extends o.PromoPanelBaseIntroPage {
					constructor(t, e, i, o) {
						super(t, e, i, o);
						const h = new l.Label(r.NolimitPromotionPlugin.apiPlugIn.translations.translate("Replay your own or others best game rounds for all Nolimit City games!"), a.GuiDefaults.INTRO_PAGE_TEXT);
						h.anchor.x = 1, h.anchor.y = .5, h.position.x = -10, h.position.y = 35;
						const u = new PIXI.Sprite(n.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.INTRO_NOLIMIT_WINNERS));
						u.anchor.set(.5, .5), u.position.set(200, 62), this.addChild(u, h)
					}
				}
				e.NolimitWinnersIntroPage = h
			},
			24591: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PromoPanelBaseIntroPage = void 0;
				const n = i(50799),
					s = i(58295),
					o = i(72468),
					r = i(61e3),
					a = i(38801),
					l = i(5117),
					h = i(77616),
					u = i(13006),
					c = i(2821),
					d = i(68714);
				class p extends s.SlideShowPage {
					constructor(t, e, i, n) {
						super(void 0, void 0, t);
						const s = this.createHeader(e, i, n || p.HEADER_STYLE);
						this._tabTarget = new PIXI.Point(-.5 * o.NolimitApplication.screenBounds.width - 40, -178), this._tab = this.createTab(), this._tab.alpha = 0, this.addChild(this._tab, s)
					}
					createHeader(t, e, i) {
						const n = new PIXI.Container,
							s = new PIXI.Sprite(r.ImgLoader.getImgTexture(e)),
							o = new d.Label(t, i),
							l = 65 / s.height;
						return s.scale.set(l, l), n.addChild(s, o), a.GuiLayout.align([s, o], 24, a.Align.TOP, a.Direction.HORIZONTAL), n.pivot.set(.5 * n.width, .5 * n.height), n.position.set(0, -139), this.icon = s, n
					}
					createTab() {
						const t = new PIXI.Container,
							e = new PIXI.Sprite(r.ImgLoader.getImgTexture(n.PromoPanelAssetConfig.INTRO_NO_LIMIT_PROMOTIONS_TAB));
						e.scale.set(.8, .8);
						const i = ["gamificationStar_00282.png", "gamificationStar_00283.png", "gamificationStar_00284.png", "gamificationStar_00285.png", "gamificationStar_00286.png", "gamificationStar_00287.png", "gamificationStar_00288.png", "gamificationStar_00289.png", "gamificationStar_00290.png", "gamificationStar_00291.png", "gamificationStar_00292.png", "gamificationStar_00293.png", "gamificationStar_00294.png", "gamificationStar_00295.png", "gamificationStar_00296.png", "gamificationStar_00297.png", "gamificationStar_00298.png", "gamificationStar_00299.png", "gamificationStar_00300.png", "gamificationStar_00301.png", "gamificationStar_00302.png", "gamificationStar_00303.png", "gamificationStar_00304.png", "gamificationStar_00305.png", "gamificationStar_00306.png", "gamificationStar_00307.png", "gamificationStar_00308.png", "gamificationStar_00309.png", "gamificationStar_00310.png", "gamificationStar_00311.png", "gamificationStar_00312.png", "gamificationStar_00313.png", "gamificationStar_00314.png", "gamificationStar_00315.png", "gamificationStar_00316.png", "gamificationStar_00317.png", "gamificationStar_00318.png", "gamificationStar_00319.png", "gamificationStar_00320.png", "gamificationStar_00321.png", "gamificationStar_00322.png", "gamificationStar_00323.png", "gamificationStar_00324.png", "gamificationStar_00325.png", "gamificationStar_00326.png", "gamificationStar_00327.png", "gamificationStar_00328.png", "gamificationStar_00329.png", "gamificationStar_00330.png", "gamificationStar_00331.png", "gamificationStar_00332.png", "gamificationStar_00333.png", "gamificationStar_00334.png", "gamificationStar_00335.png", "gamificationStar_00336.png", "gamificationStar_00337.png", "gamificationStar_00338.png", "gamificationStar_00339.png", "gamificationStar_00340.png", "gamificationStar_00341.png", "gamificationStar_00342.png", "gamificationStar_00343.png", "gamificationStar_00344.png", "gamificationStar_00345.png", "gamificationStar_00346.png", "gamificationStar_00347.png", "gamificationStar_00348.png", "gamificationStar_00349.png", "gamificationStar_00350.png", "gamificationStar_00351.png", "gamificationStar_00352.png", "gamificationStar_00353.png", "gamificationStar_00354.png", "gamificationStar_00355.png", "gamificationStar_00356.png", "gamificationStar_00357.png"],
							s = [];
						for (let t of i) s.push(r.ImgLoader.getImgTexture(t));
						const o = new c.TimelineSprite(s, 30);
						return o.anchor.set(.5, .5), o.position.set(113, 56), o.scale.set(.53, .53), e.addChild(o), t.addChild(e), this._starTween = new u.TimelineLite, this._starTween.add(o.getAnimationAutoShowHide(!0, !1)), this._starTween.add(o.getAnimationAutoShowHide(!0, !1, [70, 50]), "+=0.9"), this._starTween.add(o.getAnimationAutoShowHide(!0, !1, [49]), "+=0.5"), this._starTween.add(o.getAnimationAutoShowHide(!0, !1, [70, 50]), "+=0.7"), this._starTween.add(o.getAnimationAutoShowHide(!0, !1, [49]), "+=0.9"), t
					}
					resize() {
						this._tabTarget = new PIXI.Point(-.5 * o.NolimitApplication.screenBounds.width - 40, -178), this._tab.position.set(-.5 * o.NolimitApplication.screenBounds.width - 40, -178)
					}
					enable(t) {
						super.enable(t), t ? (this._starTween.play(0), u.TweenLite.fromTo(this._tab, .2, {
							x: this._tabTarget.x - 150
						}, {
							x: this._tabTarget.x
						}), u.TweenLite.to(this._tab, .2, {
							alpha: 1
						})) : (this._starTween.pause(0), u.TweenLite.to(this._tab, .2, {
							alpha: 0
						}))
					}
				}
				p.HEADER_STYLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: l.OpenSans.FAMILY,
					fontSize: 45,
					fontStyle: h.FontStyle.NORMAL,
					fontWeight: h.FontWeight.SEMI_BOLD,
					dropShadow: !0,
					dropShadowAngle: 1.57,
					dropShadowDistance: 3,
					dropShadowColor: "#000000",
					dropShadowAlpha: .2,
					padding: 50
				}), e.PromoPanelBaseIntroPage = p
			},
			73021: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.AnimationHelper = void 0;
				const n = i(61e3);
				class s {
					static getAnimationTextures(t) {
						if (Array.isArray(s.animationTextures[t])) return s.animationTextures[t];
						if (Array.isArray(s.animationTextureNames[t])) {
							s.animationTextures[t] = [];
							for (let e of s.animationTextureNames[t]) s.animationTextures[t].push(n.ImgLoader.getImgTexture(e));
							return s.animationTextures[t]
						}
						throw new Error("AnimationHelper: Could not find animation")
					}
				}
				s.animationTextureNames = {
					bigWinBase: ["bigwin/bigwinBase/bigwinBase_00018", "bigwin/bigwinBase/bigwinBase_00019", "bigwin/bigwinBase/bigwinBase_00020", "bigwin/bigwinBase/bigwinBase_00021", "bigwin/bigwinBase/bigwinBase_00022", "bigwin/bigwinBase/bigwinBase_00023", "bigwin/bigwinBase/bigwinBase_00024", "bigwin/bigwinBase/bigwinBase_00025", "bigwin/bigwinBase/bigwinBase_00026", "bigwin/bigwinBase/bigwinBase_00027", "bigwin/bigwinBase/bigwinBase_00028", "bigwin/bigwinBase/bigwinBase_00029", "bigwin/bigwinBase/bigwinBase_00030", "bigwin/bigwinBase/bigwinBase_00031", "bigwin/bigwinBase/bigwinBase_00032", "bigwin/bigwinBase/bigwinBase_00033", "bigwin/bigwinBase/bigwinBase_00034"],
					bigWinText: ["bigwin/bigwinText/bigwinText_00018", "bigwin/bigwinText/bigwinText_00019", "bigwin/bigwinText/bigwinText_00020", "bigwin/bigwinText/bigwinText_00021", "bigwin/bigwinText/bigwinText_00022", "bigwin/bigwinText/bigwinText_00023", "bigwin/bigwinText/bigwinText_00024", "bigwin/bigwinText/bigwinText_00025", "bigwin/bigwinText/bigwinText_00026", "bigwin/bigwinText/bigwinText_00027", "bigwin/bigwinText/bigwinText_00028", "bigwin/bigwinText/bigwinText_00029", "bigwin/bigwinText/bigwinText_00030", "bigwin/bigwinText/bigwinText_00031", "bigwin/bigwinText/bigwinText_00032", "bigwin/bigwinText/bigwinText_00033", "bigwin/bigwinText/bigwinText_00034", "bigwin/bigwinText/bigwinText_00035", "bigwin/bigwinText/bigwinText_00036", "bigwin/bigwinText/bigwinText_00037", "bigwin/bigwinText/bigwinText_00038", "bigwin/bigwinText/bigwinText_00039", "bigwin/bigwinText/bigwinText_00040", "bigwin/bigwinText/bigwinText_00041", "bigwin/bigwinText/bigwinText_00042", "bigwin/bigwinText/bigwinText_00043", "bigwin/bigwinText/bigwinText_00044", "bigwin/bigwinText/bigwinText_00045"],
					noWin: ["noWin/nowin_00001", "noWin/nowin_00002", "noWin/nowin_00003", "noWin/nowin_00004", "noWin/nowin_00005", "noWin/nowin_00006", "noWin/nowin_00007", "noWin/nowin_00008", "noWin/nowin_00009", "noWin/nowin_00010", "noWin/nowin_00011", "noWin/nowin_00012", "noWin/nowin_00013", "noWin/nowin_00014"],
					winCoins: ["winCoins/winCoins_00018", "winCoins/winCoins_00019", "winCoins/winCoins_00020", "winCoins/winCoins_00021", "winCoins/winCoins_00022", "winCoins/winCoins_00023", "winCoins/winCoins_00024", "winCoins/winCoins_00025", "winCoins/winCoins_00026", "winCoins/winCoins_00027", "winCoins/winCoins_00028", "winCoins/winCoins_00029", "winCoins/winCoins_00030", "winCoins/winCoins_00031", "winCoins/winCoins_00032", "winCoins/winCoins_00033", "winCoins/winCoins_00034", "winCoins/winCoins_00035", "winCoins/winCoins_00036", "winCoins/winCoins_00037", "winCoins/winCoins_00038", "winCoins/winCoins_00039", "winCoins/winCoins_00040", "winCoins/winCoins_00041", "winCoins/winCoins_00042"]
				}, s.animationTextures = {}, e.AnimationHelper = s
			},
			27713: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ArrayUtils = void 0;
				class i {
					static sum(t) {
						return t.reduce(((t, e) => t + e))
					}
					static multiplyAll(t) {
						return t.reduce(((t, e) => t * e))
					}
					static isAllTrue(t) {
						return !i.isAnyFalse(t)
					}
					static isAnyFalse(t) {
						for (let e of t)
							if (!e) return !0;
						return !1
					}
					static isAllFalse(t) {
						return !i.isAnyTrue(t)
					}
					static isAnyTrue(t) {
						for (let e of t)
							if (e) return !0;
						return !1
					}
					static shuffleArray(t) {
						let e = t.concat();
						for (let t = e.length; t; t--) {
							let i = Math.floor(Math.random() * t);
							[e[t - 1], e[i]] = [e[i], e[t - 1]]
						}
						return e
					}
					static unique(t) {
						return Array.from(new Set(t))
					}
					static getIndicesWhere(t, e) {
						const i = [];
						for (let n = 0; n < t.length; n++) e(t[n], n) && i.push(n);
						return i
					}
				}
				e.ArrayUtils = i
			},
			11499: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.CurrencyUtils = void 0;
				const n = i(19803),
					s = i(2425);
				e.CurrencyUtils = class {
					constructor() {}
					static formatWithDecimalCutOff(t) {
						const e = t < n.PromoPanelConfig.NO_DECIMALS_CUTOFF_POINT || t % 1 != 0 ? 2 : 0;
						return s.NolimitPromotionPlugin.apiPlugIn.currency.format(t, {
							minimumPrecision: e
						})
					}
					static format(t) {
						return s.NolimitPromotionPlugin.apiPlugIn.currency.format(t, {
							minimumPrecision: 2
						})
					}
					static formatValueWithDecimalCutOff(t) {
						const e = t < n.PromoPanelConfig.NO_DECIMALS_CUTOFF_POINT || t % 1 != 0 ? 2 : 0;
						return s.NolimitPromotionPlugin.apiPlugIn.currency.formatValue(t, {
							minimumPrecision: e
						})
					}
					static toFixedIfNecessary(t, e) {
						return +parseFloat("" + t).toFixed(e) + ""
					}
				}
			},
			71855: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Helper = void 0;
				const n = i(19803),
					s = i(2425);
				class o {
					static translate(t) {
						return s.NolimitPromotionPlugin.apiPlugIn.translations.translate(t)
					}
					static unique(t) {
						return Array.from(new Set(t))
					}
					static shrinkTextWidth(t, e, i) {
						for (; e.width > i;) {
							if (this.isString(e.style.fontSize)) {
								if (e.style.fontSize.indexOf("em") > -1) throw new Error("Helper.shrinkTextWidth(), I am lazy so I don't want to parse em, please use number or px.");
								e.style.fontSize = parseInt(e.style.fontSize)
							}
							if (e.style.fontSize--, e.style.fontSize <= 10) return void(e.style.fontSize = 10)
						}
					}
					static isDefaultScreenRatio(t) {
						return Math.max(t.width, t.height) / Math.min(t.width, t.height) > n.PromoPanelConfig.DEFAULT_SCREEN_MIN_RATIO
					}
					static isIphoneScreenRatio(t) {
						return Math.max(t.width, t.height) / Math.min(t.width, t.height) > n.PromoPanelConfig.DEFAULT_SCREEN_MIN_RATIO
					}
					static padZero(t) {
						return t.toString().padStart(2, "0")
					}
					static floorPos(t) {
						return Math.floor(t)
					}
					static getMaxFromArray(t) {
						let e = Number.MIN_VALUE;
						for (let i = 0; i < t.length; i++) e = Math.max(e, +t[i]);
						return e
					}
					static getTotalMultipliedWin(t, e) {
						const i = Math.pow(10, n.PromoPanelConfig.DECIMAL_CUTOFF - 1);
						return t * i / (e * i)
					}
					static formatCost(t) {
						return this.countDecimals(t) < 2 ? t.toFixed(2) : t.toString()
					}
					static isString(t) {
						return "string" == typeof t
					}
					static ceilToDecimals(t, e) {
						return Math.ceil(t * Math.pow(10, e)) / Math.pow(10, e)
					}
				}
				o.countDecimals = function(t) {
					return Math.floor(t) === t ? 0 : t.toString().split(".")[1].length || 0
				}, e.Helper = o
			},
			60767: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ResponseParser = void 0;
				const n = i(2425),
					s = i(19803),
					o = i(71855),
					r = i(88458),
					a = i(46334),
					l = i(72468),
					h = i(49490),
					u = i(58850);
				class c {
					static addASReplayWinData(t, e, i) {
						const a = c.getParsedData(t, e, i),
							l = a.totalWin,
							h = +a.totalSpinWinnings,
							u = a.winType || r.WINTYPE.NORMAL,
							d = {
								totalWin: l,
								totalSpinWinnings: h,
								calculatedTotalWinTimesBet: o.Helper.getTotalMultipliedWin(l, t.playedBetValue),
								calculatedTimesBetThisSpin: o.Helper.getTotalMultipliedWin(h, t.playedBetValue),
								nextMode: t.nextMode,
								mode: t.mode,
								wasFeatureBuy: a.wasFeatureBuy,
								freeSpinTriggeredThisSpin: a.freeSpinTriggeredThisSpin,
								balance: n.NolimitPromotionPlugin.apiPlugIn.balance.getAmount().toFixed(s.PromoPanelConfig.DECIMAL_CUTOFF),
								isBigWin: a.isBigWin,
								winType: u,
								featureName: a.featureName || "",
								isRoundComplete: a.isRoundComplete,
								isBonusEnd: a.isBonusEnd,
								isWinCapHit: a.isWinCapHit,
								isWinBelowStake: !1,
								waitForAnimation: a.waitForAnimation
							};
						return d.isWinBelowStake = this.isWinBelowStake(d, t), t.asReplayWinData = d, d
					}
					static getParsedData(t, e, i) {
						var s;
						if (null === (s = n.NolimitPromotionPlugin.ASOptionsData) || void 0 === s ? void 0 : s.getParsedData) return n.NolimitPromotionPlugin.ASOptionsData.getParsedData(t, e, i);
						throw new Error("ActionSpinOptions.getParsedData not found. Can't play action spins without it.")
					}
					static getBetCost(t) {
						let e, i = +n.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel();
						return e = "string" == typeof t ? n.NolimitPromotionPlugin.apiPlugIn.bonusFeatures.getFeatureDataByName(t) : t, e && (i = 100 * e.price * i * 1e4 / 1e6), i
					}
					static getBoostCost(t) {
						let e, i = +n.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel();
						e = "string" == typeof t ? n.NolimitPromotionPlugin.apiPlugIn.bonusFeatures.getFeatureDataByName(t) : t, e && (i = 100 * e.price * i * 1e4 / 1e6);
						const o = i < s.PromoPanelConfig.NO_DECIMALS_CUTOFF_POINT || i % 1 != 0 ? 2 : 0;
						return n.NolimitPromotionPlugin.apiPlugIn.currency.formatValue(i, {
							minimumPrecision: o
						})
					}
					static setBoostAndGetCost(t, e = !1) {
						let i, s = n.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel();
						if (t) {
							const e = n.NolimitPromotionPlugin.apiPlugIn.bonusFeatures.getFeatureDataByName(t);
							e && (i = {
								featureName: e.name,
								price: e.price
							}, s = c.getBoostCost(e))
						}
						return e && n.NolimitPromotionPlugin.apiPlugIn.betHandler.setBoost(i), s
					}
					static isWinBelowStake(t, e) {
						let i = +t.totalSpinWinnings;
						return t.isRoundComplete && t.nextMode === s.Mode.NORMAL && (i = +t.totalWin), t.winType === r.WINTYPE.MULTIPLIER && (i *= e.playedBetValue), n.NolimitPromotionPlugin.apiPlugIn.gameClientConfiguration.belowStakeWinRestriction && i <= e.playedBetValue
					}
					static gameDataPromise() {
						return new Promise(((t, e) => {
							l.NolimitApplication.apiPlugin.events.once(h.APIEvent.GAME, (i => {
								i.isFakeData ? (n.NolimitPromotionPlugin.apiPlugIn.events.trigger(h.APIEvent.FINISH), e()) : (a.Logger.logDev("Promo Panel GameData", i.mode, i.nextMode), u.Timer.measureTimeAtStateStart(s.Mode.NORMAL, u.FlowState.BET_COMPLETED), t(i))
							}))
						}))
					}
				}
				e.ResponseParser = c
			},
			13553: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.StepList = void 0;
				const n = i(27713);
				e.StepList = class {
					constructor(t) {
						if (this._randomizeOnWrapAround = !1, this._wrapAround = !1, t.length <= 0) throw new Error("List can't be empty.");
						this._list = t, this._index = 0
					}
					get length() {
						return this._list.length
					}
					replaceList(t) {
						if (t.length <= 0) throw new Error("List can't be empty.");
						this._list = t, this._index = this.wrapIndex(this._index)
					}
					reset() {
						this._index = this._list.length - 1
					}
					setIndex(t) {
						this._index = this.wrapIndex(t)
					}
					next() {
						const t = this.increment();
						return this._list[t]
					}
					prev() {
						const t = this.decrement();
						return this._list[t]
					}
					current() {
						return this._list[this._index]
					}
					isFirst() {
						return 0 == this._index
					}
					isLast() {
						return this._index == this._list.length - 1
					}
					setRandomizeAtWrapAround(t) {
						return this._randomizeOnWrapAround = t, this
					}
					setWrapAround(t) {
						return this._wrapAround = t, this
					}
					getListClone(t) {
						return t ? n.ArrayUtils.shuffleArray(this._list) : this._list.concat()
					}
					increment() {
						return this._index = this.wrapIndex(++this._index), this._index
					}
					decrement() {
						return this._index = this.wrapIndex(--this._index), this._index
					}
					wrapIndex(t) {
						return t >= this._list.length ? this._wrapAround ? (t = 0, this._randomizeOnWrapAround && (this._list = n.ArrayUtils.shuffleArray(this._list))) : t = this._list.length - 1 : t < 0 && (t = this._wrapAround ? this._list.length - 1 : 0), t
					}
					getFirstValue() {
						return this._list[0]
					}
					getLastValue() {
						return this._list[this._list.length - 1]
					}
				}
			},
			2821: function(t, e, i) {
				"use strict";
				var n = this && this.__createBinding || (Object.create ? function(t, e, i, n) {
						void 0 === n && (n = i);
						var s = Object.getOwnPropertyDescriptor(e, i);
						s && !("get" in s ? !e.__esModule : s.writable || s.configurable) || (s = {
							enumerable: !0,
							get: function() {
								return e[i]
							}
						}), Object.defineProperty(t, n, s)
					} : function(t, e, i, n) {
						void 0 === n && (n = i), t[n] = e[i]
					}),
					s = this && this.__setModuleDefault || (Object.create ? function(t, e) {
						Object.defineProperty(t, "default", {
							enumerable: !0,
							value: e
						})
					} : function(t, e) {
						t.default = e
					}),
					o = this && this.__importStar || function(t) {
						if (t && t.__esModule) return t;
						var e = {};
						if (null != t)
							for (var i in t) "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
						return s(e, t), e
					};
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.TimelineSprite = void 0;
				const r = o(i(82859)),
					a = i(13006);
				class l extends r.Sprite {
					get totalFrames() {
						return this._textures.length
					}
					get totalDuration() {
						return this._totalDuration
					}
					get frameDuration() {
						return this._frameDuration
					}
					get currentFrame() {
						const t = Math.floor(this.currentTweenFrame);
						return Math.max(0, Math.min(t, this._textures.length - 1))
					}
					constructor(t, e = 30) {
						super(t[0]), this._textures = t, this._sourceFPS = e, this._totalDuration = this._textures.length / this._sourceFPS, this._frameDuration = this._totalDuration / this._textures.length, this.currentTweenFrame = 0
					}
					getAnimation(t, e, i) {
						1 === (t = null != t ? t : [0]).length && t.push(this._textures.length - 1);
						const n = new a.TimelineLite;
						n.add((() => this.setFrame(l.wrapIndex(this._textures.length, t[0]))));
						for (let s = 1; s < t.length; s++) {
							const o = l.wrapIndex(this._textures.length, t[s - 1]),
								r = l.wrapIndex(this._textures.length, t[s]),
								h = (Math.abs(o - r) + 1) * this._frameDuration;
							n.add(new a.TweenLite(this, h, {
								currentTweenFrame: r + (r >= o ? .99 : -.99),
								ease: a.Linear.easeNone,
								onUpdate: () => {
									this.applyFrame(), e && e()
								},
								onComplete: s === t.length - 1 ? () => {
									i && i()
								} : void 0
							}))
						}
						return n
					}
					static wrapIndex(t, e) {
						if (t <= 0) throw new Error("Error: ArrayHelper.getValueInLoopRange(): length must bigger than zero!");
						return e > t - 1 ? e % t : e < 0 ? t - Math.abs(e) % t : e
					}
					getAnimationAutoShowHide(t = !0, e = !0, i, n, s) {
						const o = new a.TimelineLite;
						return t && o.add((() => this.show())), o.add(this.getAnimation(i, n, (() => {
							e && this.hide(), s && s()
						}))), o
					}
					setFrame(t) {
						this.currentTweenFrame = t, this.applyFrame()
					}
					applyFrame() {
						this.texture = this._textures[this.currentFrame]
					}
					playLoop(t) {
						this._loopAnimation && this._loopAnimation.isActive() || (this._loopAnimation = this.getAnimation([0], t, (() => this.playLoop(t))))
					}
					stopLoop() {
						this._loopAnimation && this._loopAnimation.isActive() && (this._loopAnimation.pause(), this._loopAnimation.kill())
					}
					show() {
						this.visible = !0
					}
					hide() {
						this.visible = !1
					}
				}
				e.TimelineSprite = l
			},
			58850: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Timer = e.FlowState = void 0;
				const n = i(19803),
					s = i(46334),
					o = i(2425);
				var r;
				! function(t) {
					t.IDLE = "IDLE", t.BET = "BET", t.BET_COMPLETED = "BET_COMPLETED", t.RESULT = "RESULT", t.WIN = "WIN"
				}(r = e.FlowState || (e.FlowState = {}));
				class a {
					static measureTimeAtStateStart(t, e) {
						if (t == n.Mode.NORMAL) {
							if (e == r.BET && (this._betStartDateTime = Date.now()), e == r.WIN) {
								const t = o.NolimitPromotionPlugin.apiPlugIn.gameClientConfiguration.minimumSpinTime,
									e = Date.now() - this._betStartDateTime;
								e < t ? this.roundStatsLogger.log(`%c Duration BET_START -> RESULT_END:  ${e} ms, (jurisdiction requirement: ${t})`, "background-color:#AA0000; color:white;") : this.roundStatsLogger.log(`%c Duration BET_START -> RESULT_END:  ${e} ms, (jurisdiction requirement: ${t})`, "background-color:#00AA00; color:white;")
							}
							if (e == r.BET_COMPLETED) {
								const t = o.NolimitPromotionPlugin.apiPlugIn.gameClientConfiguration.minimumSpinTime,
									e = Date.now() - this._betStartDateTime;
								e < t ? this.roundStatsLogger.log(`%c Duration BET_START -> BET_COMPLETED:  ${e} ms, (jurisdiction requirement: ${t})`, "background-color:#AA00AA; color:white;") : this.roundStatsLogger.log(`%c Duration BET_START -> BET_COMPLETED:  ${e} ms, (jurisdiction requirement: ${t})`, "background-color:#00AA00; color:white;")
							}
						}
					}
				}
				a.roundStatsLogger = s.Logger.createNamedLogger("Stats"), a._betStartDateTime = 0, e.Timer = a
			},
			63071: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NolimitAudioPlayer = void 0;
				const n = i(380),
					s = i(46334),
					o = i(21802),
					r = i(94196);
				class a {}
				a.MUSIC = "loops", a.EFFECT = "effects", a.KEYPAD = "keypad", e.NolimitAudioPlayer = class {
					get isLoaded() {
						return this._isLoaded
					}
					get isLoading() {
						return this._isLoading
					}
					get isLoadReady() {
						return !!this._playCatalog
					}
					get catalogs() {
						return this._playCatalog.catalogs
					}
					constructor() {
						this.name = "AudioPlayer", this.FADE_TIME = 500, this._loopToBePlayed = [], this._loadingData = {
							howlerPlayers: [],
							configs: []
						}, this._loggerEnabled = !1, this._isLoaded = !1, this._isLoading = !1, this._singelPlayers = {}, this._loopCache = []
					}
					getEffectDuration(t) {
						return this.isLoaded ? this._singelPlayers.effects.duration(t) : 0
					}
					showLogs(t) {
						this._loggerEnabled = t
					}
					soundLog(t, e) {
						s.Logger.log("[SOUND" + (t ? "-" + t + "] : " : "] : ") + e)
					}
					createPlaylist(t) {
						return t.then((t => {
							this._playCatalog = {
								catalogs: []
							}, t = t.filter((t => !!t));
							const e = [],
								i = [];
							t.forEach((t => {
								const n = t.name.split("Censored");
								n.length > 1 ? (t.name = n[0], t.censored = !0, i.push(t)) : e.push(t)
							}));
							let n = e;
							if (!0 === o.NolimitSlotAudio.apiPlugIn.gameClientConfiguration.useCensoredSoundUS)
								for (let t of i)
									for (let e = 0; e < n.length; e++) n[e].name == t.name && (n[e] = t);
							n.forEach((t => {
								const e = {
										categoryName: t.name,
										soundList: {}
									},
									i = Object.keys(t.sprite);
								this._loadingData.configs.push({
									src: t.src,
									loop: t.name === a.MUSIC,
									sprite: t.sprite
								});
								for (let t = 0; t < i.length; t++) e.soundList[i[t]] = void 0;
								this._playCatalog.catalogs.push(e)
							}))
						}))
					}
					startLoading() {
						return this._isLoading = !0, new Promise((t => {
							for (let t = 0; t < this._loadingData.configs.length; t++) this._loadingData.howlerPlayers.push(new r.Howl(this._loadingData.configs[t]));
							t()
						}))
					}
					checkLoadingState() {
						for (let t = 0; t < this._loadingData.howlerPlayers.length; t++)
							if ("loaded" !== this._loadingData.howlerPlayers[t].state()) return !1;
						for (let t = 0; t < this.catalogs.length; t++) {
							const e = this.getCategory(this.catalogs[t].categoryName),
								i = this.getAllSoundInCatalog(e);
							this.catalogs[t].categoryName == a.EFFECT && (this._singelPlayers.effects = new n.singelEffectsPlayer(this._loadingData.configs[t])), this.catalogs[t].categoryName == a.MUSIC && (this._singelPlayers.loops = new n.singelLoopPlayer(this._loadingData.configs[t]));
							for (let s = 0; s < i.length; s++) {
								const o = new r.Howl(this._loadingData.configs[t]);
								e.soundList[i[s]] = new n.NolimitHowl(o, this._loadingData.configs[t]), e.soundList[i[s]].setSoundName(s)
							}
							this._loadingData.howlerPlayers[t].unload(), delete this._loadingData.howlerPlayers[t], delete this._loadingData.configs[t]
						}
						return this._loadingData = void 0, this._isLoading = !1, this._isLoaded = !0, !0
					}
					getCategory(t) {
						let e = this.catalogs.find((e => e.categoryName === t));
						if (!e) throw new Error("Trying to fetch sound from undefined soundFolder: " + t);
						return e
					}
					getAllSoundInCatalog(t) {
						return Object.keys(t.soundList)
					}
					getCategoryPlayer(t) {
						const e = [],
							i = Array.isArray(t) ? t : [t];
						for (let t = 0; t < i.length; t++) {
							const n = this.getCategory(i[t]),
								s = this.getAllSoundInCatalog(n);
							e.push(...s.map((t => n.soundList[t])))
						}
						return e
					}
					allPlayers() {
						return this.getCategoryPlayer([a.KEYPAD, a.MUSIC, a.EFFECT])
					}
					getPlayerAtCategory(t, e) {
						const i = Array.isArray(t) ? t : [t];
						for (let t = 0; t < i.length; t++) {
							let n = this.getCategory(i[t]);
							if (-1 !== this.getAllSoundInCatalog(n).indexOf(e)) return n.soundList[e]
						}
					}
					fetchSoundPlayer(t) {
						for (let e = 0; e < this.catalogs.length; e++) {
							let i = this.getCategory(this.catalogs[e].categoryName);
							if (-1 !== this.getAllSoundInCatalog(i).indexOf(t)) return i.soundList[t]
						}
					}
					getContext() {
						return r.Howler.ctx
					}
					getMasterGain() {
						return r.Howler.masterGain
					}
					setPause(t) {
						this.isLoaded && (this.getCategoryPlayer([a.KEYPAD, a.MUSIC, a.EFFECT]).forEach((e => {
							t ? e.pause() : e.resume()
						})), this.onOldPause(t))
					}
					onOldPause(t) {
						t ? (this._singelPlayers.loops.pause(), this._singelPlayers.effects.pause()) : (this._loopCache.length > 0 && (this._singelPlayers.loops.loop(this._loopCache), this._loopCache = []), this._singelPlayers.loops.resume(this.FADE_TIME), this._singelPlayers.effects.resume())
					}
					onHalt() {
						this.setPause(!0), r.Howler.unload()
					}
					onSingleMusic(t) {
						t ? (this._loopCache.length > 0 && (this._singelPlayers.loops.loop(this._loopCache), this._loopCache = []), this._singelPlayers.loops.resume(this.FADE_TIME)) : this._singelPlayers.loops.pause(this.FADE_TIME)
					}
					onSingleSfx(t) {
						this._singelPlayers.effects.mute(t)
					}
					onMusic(t) {
						this.isLoaded && (this._loggerEnabled && this.soundLog("MUSIC-MUTE", !t), this.onSingleMusic(t), this.getCategoryPlayer(a.MUSIC).forEach((e => {
							if (null != this._loopToBePlayed && t) {
								for (let t = 0; t < this._loopToBePlayed.length; t++)
									if (e.isPlayerWithSound(this._loopToBePlayed[t].name)) {
										this._loggerEnabled && this.soundLog("MUSIC-PLAY", "Name: " + this._loopToBePlayed[t].name + ", Volume: " + this._loopToBePlayed[t].volume), e.fade(0, this._loopToBePlayed[t].volume, this.FADE_TIME);
										break
									} e.mute(!t)
							} else e.fadeToMute(!t, this.FADE_TIME)
						})), null != this._loopToBePlayed && t && delete this._loopToBePlayed)
					}
					onSfx(t) {
						this.isLoaded && (this._loggerEnabled && this.soundLog("SFX-MUTE", !t), this.onSingleSfx(!t), this.getCategoryPlayer([a.KEYPAD, a.EFFECT]).forEach((e => {
							e.fadeToMute(!t, this.FADE_TIME)
						})))
					}
					playEffect(t, e = 1) {
						return s.Logger.deprecated("playEffect, use SlotGame.Sound.PlayTrack instead.", "0.4.3"), this.isLoaded ? (this._loggerEnabled && this.soundLog("PLAY-EFFECT", "Name: " + t + ", Amount: " + e), Promise.resolve(this._singelPlayers.effects.play(t, e))) : Promise.resolve("Not Loaded")
					}
					stopEffect(t, e = 0) {
						return s.Logger.deprecated("stopEffect, use SlotGame.Sound.StopTrack instead.", "0.4.3"), this.isLoaded ? (this._loggerEnabled && this.soundLog("STOP-EFFECT", "Name: " + t + ", FadeDurationMs: " + e), e <= 0 ? (this._singelPlayers.effects.stop(t), Promise.resolve(t)) : this.fadeEffect(t, 0, e).then((t => this.stopEffect(t, 0)))) : Promise.resolve("Not Loaded")
					}
					fadeEffect(t, e, i) {
						return s.Logger.deprecated("fadeEffect, use SlotGame.Sound.FadeTrack instead.", "0.4.3"), this.isLoaded ? (this._loggerEnabled && this.soundLog("FADE-EFFECT", "Name: " + t + ", ToVolume: " + e + ", DurationMS: " + i), this._singelPlayers.effects.fade(e, i, t)) : Promise.resolve("Not Loaded")
					}
					playAmbience(t, e, i) {
						s.Logger.deprecated("playAmbience, use SlotGame.Sound.PlayTrack instead.", "0.4.3"), this._loopCache = Array.isArray(t) ? t : [t], this.isLoaded && (this._loggerEnabled && this.soundLog("AMBIENCE-PLAY", "Sounds: " + this._loopCache + ", FadeOutMS: " + e + ", FadeInMs: " + i), this._singelPlayers.loops.loop(this._loopCache, e, i), this._loopCache = [])
					}
					pauseAmbience(t = 0) {
						return s.Logger.deprecated("pauseAmbience, use SlotGame.Sound.PlayTrack instead.", "0.4.3"), this.isLoaded ? (this._loggerEnabled && this.soundLog("AMBIENCE-PAUSE", "FadeOutDurationMs: " + t), this._singelPlayers.loops.pause(t)) : Promise.resolve("Not Loaded")
					}
					resumeAmbience(t = 0) {
						return s.Logger.deprecated("resumeAmbience, use SlotGame.Sound.PlayTrack instead.", "0.4.3"), this.isLoaded ? (this._loggerEnabled && this.soundLog("AMBIENCE-RESUME", "FadeInDurationMs: " + t), this._singelPlayers.loops.resume(t)) : Promise.resolve("Not Loaded")
					}
					fadeAmbience(t, e) {
						return s.Logger.deprecated("fadeAmbience, use SlotGame.Sound.FadeTrack instead.", "0.4.3"), this.isLoaded ? (this._loggerEnabled && this.soundLog("AMBIENCE-FADE", "ToVolume: " + t + ", FadeDurationMs: " + e), this._singelPlayers.loops.fade(t, e)) : Promise.resolve("Not Loaded")
					}
					playTrack(t) {
						if (this._loopToBePlayed) {
							const e = null != t.volume ? t.volume : 1,
								i = this._loopToBePlayed.findIndex((e => e.name == t.name)); - 1 == i ? this._loopToBePlayed.push({
								name: t.name,
								volume: e
							}) : this._loopToBePlayed[i].volume = e
						}
						if (!this.isLoaded) return;
						const e = this.getPlayerAtCategory([a.EFFECT, a.MUSIC], t.name);
						return e && (this._loggerEnabled && this.soundLog("PLAY", "Name: " + t.name + ", Volume: " + (null != t.volume ? t.volume : 1) + ", Repeat: " + (null != t.repeat ? t.repeat : 0)), e.play(t.repeat, null != t.volume ? t.volume : 1)), e
					}
					stopTrack(t) {
						if (this._loopToBePlayed && (this._loopToBePlayed = this._loopToBePlayed.filter((e => t != e.name))), !this.isLoaded) return;
						const e = this.getPlayerAtCategory([a.EFFECT, a.MUSIC], t);
						return e && (this._loggerEnabled && this.soundLog("STOP", "Name: " + t), e.stop()), e
					}
					fadeTrack(t) {
						if (this._loopToBePlayed) {
							const e = this._loopToBePlayed.findIndex((e => e.name == t.name));
							e >= 0 && (this._loopToBePlayed[e].volume = null != t.to ? t.to : 1)
						}
						if (!this.isLoaded) return;
						const e = this.getPlayerAtCategory([a.EFFECT, a.MUSIC], t.name);
						return e && (this._loggerEnabled && this.soundLog("FADE", "Name: " + t.name + ", FromVolume: " + t.from + ", FromVolume: " + t.to + ", Duration: " + (t.duration ? t.duration : e.trackDuration())), e.fade(t.from, t.to, t.duration ? t.duration : e.trackDuration())), e
					}
					getSoundDuration(t) {
						return this.isLoaded && this.getPlayerAtCategory([a.EFFECT, a.MUSIC], t) ? this.getPlayerAtCategory([a.EFFECT, a.MUSIC], t).trackDuration() : 0
					}
					playKeypadSound(t) {
						if (!this.isLoaded || document.hidden) return;
						const e = this.getPlayerAtCategory([a.KEYPAD], t);
						return e && (this._loggerEnabled && this.soundLog("KEYPAD-PLAY", "Name: " + t), e.play(void 0, 1)), e
					}
					stopKeypadSound(t) {
						if (!this.isLoaded || document.hidden) return;
						const e = this.getPlayerAtCategory([a.KEYPAD], t);
						return e && (this._loggerEnabled && this.soundLog("KEYPAD-STOP", "Name: " + t), e.stop()), e
					}
				}
			},
			380: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NolimitHowl = e.singelLoopPlayer = e.singelEffectsPlayer = e.HowlerStates = void 0;
				const n = i(94196);
				var s;
				(s = e.HowlerStates || (e.HowlerStates = {})).unloaded = "unloaded", s.loading = "loading", s.loaded = "loaded", e.singelEffectsPlayer = class {
					constructor(t) {
						this.playing = {}, this.durations = {}, this.timesLeft = {}, this.paused = !1, this._player = new n.Howl(t);
						for (let e in t.sprite) this.durations[e] = t.sprite[e][1]
					}
					play(t, e = 1) {
						const i = this._player.play(t);
						e > 1 && this._player.loop(!0, i), this.playing[t] && this.stop(t), this.playing[t] = i, this.timesLeft[i] = e, this._player.on("end", (e => {
							this.timesLeft[e] = this.timesLeft[e] - 1, 1 === this.timesLeft[e] ? this._player.loop(!1, e) : this.timesLeft[e] < 1 && (delete this.playing[t], this._player.off("end", void 0, e))
						}), i)
					}
					stop(t) {
						t ? this.playing[t] && (this._player.off("end", void 0, this.playing[t]), this._player.stop(this.playing[t]), delete this.playing[t]) : Object.keys(this.playing).forEach((t => {
							this.stop(t)
						}))
					}
					pause() {
						this.paused || (this.paused = !0, this._player.pause())
					}
					resume() {
						if (this.paused) {
							this.paused = !1;
							for (const t in this.playing) this._player.play(this.playing[t])
						}
					}
					duration(t) {
						return this.durations[t]
					}
					volume(t) {
						return this._player.volume(t)
					}
					fade(t, e, i) {
						return new Promise((n => {
							if (i && this.playing[i]) {
								const s = this.playing[i];
								this._player.once("fade", (() => n(i))), this._player.fade(this._player.volume(s), t, e, s)
							} else n(i)
						}))
					}
					mute(t) {
						this._player.mute(t)
					}
					unload() {
						return this._player.unload()
					}
				}, e.singelLoopPlayer = class {
					constructor(t) {
						this.paused = !0, this.loopNames = [], this.currentLoopName = "", this.volume = 1, this._player = new n.Howl({
							src: t.src,
							sprite: t.sprite,
							loop: !1
						}), this._player.on("end", (() => this.playNext()))
					}
					loop(t, e = 0, i = e) {
						if (this.loopNames = Array.isArray(t) ? t : [t], this.paused || this.loopNames[0] === this.currentLoopName) return Promise.resolve(0);
						const n = this.currentLoopId;
						return this.currentLoopName = this.loopNames[0], this.currentLoopId = this._player.play(this.currentLoopName), i > 0 && (this._player.volume(0, this.currentLoopId), this.fadeTo(this.currentLoopId, this.volume, i)), this.fadeTo(n, 0, e).then((t => (t && this._player.stop(t), Promise.resolve(t))))
					}
					pause(t = 0) {
						return this.paused ? Promise.resolve() : (this.paused = !0, this.fadeTo(this.currentLoopId, 0, t).then((t => {
							this.currentLoopId === t && this._player.pause(t)
						})))
					}
					resume(t = 0) {
						if (this.paused) {
							if (this.paused = !1, this.currentLoopId && this.loopNames[0] === this.currentLoopName) return this._player.play(this.currentLoopId), this.fadeTo(this.currentLoopId, this.volume, t);
							this.currentLoopId && this._player.stop(this.currentLoopId), this.loopNames && this.loopNames.length > 0 && (this.currentLoopName = this.loopNames[0], this.currentLoopId = this._player.play(this.currentLoopName), this.fadeTo(this.currentLoopId, this.volume, t))
						}
						return Promise.resolve()
					}
					fade(t, e = 0) {
						return Number.isFinite(t) && t >= 0 && t <= 1 ? (this.volume = t, this.fadeTo(this.currentLoopId, this.volume, e)) : Promise.reject("Invalid volume: " + t)
					}
					fadeTo(t, e, i) {
						return new Promise((n => {
							if (t) {
								if (!(i > 0 && this._player.volume(t) !== e)) return this._player.volume(e, t), n(t);
								this._player.once("fade", (t => n(t))), this._player.fade(this._player.volume(t), e, i, t)
							} else setTimeout(n, i)
						}))
					}
					playNext() {
						this.paused || (this.loopNames.push(this.loopNames.shift()), this.currentLoopName = this.loopNames[0], this.currentLoopId = this._player.play(this.currentLoopName), this._player.volume(this.volume, this.currentLoopId))
					}
					unload() {
						return this._player.unload()
					}
				}, e.NolimitHowl = class {
					constructor(t, e) {
						this._playIDs = [], this._soundName = "", this._repeatCount = 0, this._isPaused = !1, this._expectedVolume = 1, this._expectedMuteState = void 0, this._config = e, this._player = t
					}
					get config() {
						return this._config
					}
					setSoundName(t = 0) {
						this._soundName = Object.keys(this._config.sprite)[t], this.eventTriggers()
					}
					isPlayerWithSound(t) {
						return this.soundName === t
					}
					eventTriggers() {
						this.player.on("end", (() => this.cleanIDs()))
					}
					get soundName() {
						return this._soundName
					}
					get triggerIDs() {
						return this._playIDs
					}
					get lastTriggeredID() {
						return this._playIDs[this.amountOfInstances - 1]
					}
					get amountOfInstances() {
						return this._playIDs.length
					}
					get isEmpty() {
						return 0 === this.amountOfInstances
					}
					get player() {
						return this._player
					}
					get repeatCounter() {
						return this._repeatCount
					}
					get isLooping() {
						return this.player.loop() || this.repeatCounter > 0
					}
					get isPlaying() {
						return this.player.playing()
					}
					setLoop(t) {
						return this.player.loop(t)
					}
					play(t = 0, e = this.currentVolume(), i = 0) {
						if (this._repeatCount = Math.max(0, t), this._expectedVolume = e, this.setVolume(this._expectedVolume), this.player.playing()) {
							if (this.isLooping) this.player.play(this.lastTriggeredID);
							else {
								const t = this.player.play(this.soundName); - 1 == this._playIDs.indexOf(t) && this._playIDs.push(t)
							}
							return
						}
						const n = this.player.play(this.isEmpty ? this.soundName : this.lastTriggeredID); - 1 == this._playIDs.indexOf(n) && this._playIDs.push(n)
					}
					cleanIDs() {
						if (this._repeatCount > 0) this.play(--this._repeatCount, this.currentVolume());
						else if (!this.isEmpty) {
							for (let t = 0; t < this.amountOfInstances; t++)
								if (this.player.playing(this._playIDs[t])) return;
							this.player.stop(), this._playIDs = []
						}
					}
					resume() {
						return !this.isEmpty && this._isPaused && (this.play(this._repeatCount, this._expectedVolume), this._isPaused = !1), this.soundName
					}
					pause() {
						return !this.isEmpty && this.isPlaying && (this.player.pause(), this._isPaused = !0), this.soundName
					}
					stop() {
						this._repeatCount = 0, this.player.stop(), this.cleanIDs()
					}
					isMuted() {
						return this.player.mute()
					}
					mute(t) {
						return this.player.mute(t), this._expectedMuteState = t, this.player
					}
					currentVolume() {
						return this.player.volume()
					}
					setVolume(t) {
						return this.player.volume(t)
					}
					fade(t = this.currentVolume(), e, i = 1) {
						this.isEmpty && this.play(), this._expectedVolume = e, i <= 1 ? this.setVolume(this._expectedVolume) : (this.player.off("fade"), null != this._expectedMuteState && this.mute(this._expectedMuteState), this.player.fade(t, this._expectedVolume, i).once("fade", (() => {
							this.setVolume(this._expectedVolume)
						})))
					}
					fadeToMute(t, e = 1) {
						this.player.off("fade"), this._expectedMuteState = t, !this.isEmpty && this.isPlaying ? this._expectedMuteState ? this.player.fade(this.currentVolume(), 0, e).once("fade", (() => {
							this.mute(this._expectedMuteState)
						})) : (this.mute(this._expectedMuteState), 0 == this._expectedVolume ? this.setVolume(this._expectedVolume) : this.player.fade(this.currentVolume(), this._expectedVolume, e)) : this.mute(this._expectedMuteState)
					}
					currentRate() {
						return this.player.rate()
					}
					setRate(t) {
						return this.player.rate(t)
					}
					idRate(t) {
						this.player.rate(t, this.lastTriggeredID)
					}
					seek(t) {
						return this.player.seek(t, this.lastTriggeredID)
					}
					trackDuration() {
						return this._config.sprite[this.soundName][1]
					}
					currentState() {
						return this.player.state()
					}
					load() {
						this.player.load()
					}
					unload() {
						this.player.unload()
					}
				}
			},
			21802: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NolimitSlotAudio = void 0;
				const n = i(91980),
					s = i(64118),
					o = i(49490),
					r = i(30835),
					a = i(70329),
					l = i(46334),
					h = i(63071),
					u = i(31763);
				class c {
					get AudioPlayer() {
						return c._audioPlayer
					}
					get loading() {
						return !!this.AudioPlayer && this.AudioPlayer.isLoading
					}
					get isLoaded() {
						return !!this.AudioPlayer && this.AudioPlayer.isLoaded
					}
					get isLoading() {
						return !!this.AudioPlayer && this.AudioPlayer.isLoading
					}
					constructor() {
						this.name = "NolimitSlotAudio", this.muteSettingName = "mute", this._ignoreClick = !1, this.AudioPlayer || this.createAudioPlayer()
					}
					createAudioPlayer() {
						c._audioPlayer = new h.NolimitAudioPlayer
					}
					get isEnabled() {
						return !!c.apiPlugIn.settings.get(this.muteSettingName)
					}
					set isEnabled(t) {
						c.apiPlugIn.settings.set(this.muteSettingName, t)
					}
					get isFirstOpened() {
						return void 0 === c.apiPlugIn.settings.get(r.APISetting.SFX) || void 0 === c.apiPlugIn.settings.get(r.APISetting.MUSIC) || void 0 === c.apiPlugIn.settings.get(this.muteSettingName)
					}
					get isSettingsOff() {
						return !c.apiPlugIn.settings.get(r.APISetting.SFX) && !c.apiPlugIn.settings.get(r.APISetting.MUSIC)
					}
					get isSettingsModified() {
						return c.apiPlugIn.settings.get(r.APISetting.SFX) != c.apiPlugIn.settings.get(r.APISetting.MUSIC)
					}
					get sfxOn() {
						return c.apiPlugIn.settings.get(r.APISetting.SFX)
					}
					get musicOn() {
						return c.apiPlugIn.settings.get(r.APISetting.MUSIC)
					}
					get player() {
						return this.AudioPlayer
					}
					addEventListeners() {
						const t = c.apiPlugIn.events,
							e = c.apiPlugIn.settings;
						t.on(o.APIEvent.PAUSE, (t => this.eventTrigger(o.APIEvent.PAUSE, !0))), t.on(o.APIEvent.RESUME, (t => this.eventTrigger(o.APIEvent.RESUME, !1))), t.on(o.APIEvent.HALT, (t => this.eventTrigger(o.APIEvent.HALT, t))), t.on(o.APIEvent.HIDDEN, (t => this.eventTrigger(o.APIEvent.HIDDEN, t))), e.on(r.APISetting.SFX, (() => this.setInteractiveSettings(r.APISetting.SFX))), e.on(r.APISetting.MUSIC, (() => this.setInteractiveSettings(r.APISetting.MUSIC)))
					}
					eventTrigger(t, e) {
						if (this.checkIsLoaded()) switch (t) {
							case o.APIEvent.PAUSE:
							case o.APIEvent.RESUME:
							case o.APIEvent.HIDDEN:
								this.isEnabled && this.AudioPlayer.setPause(!!e);
								break;
							case o.APIEvent.HALT:
								this.AudioPlayer.onHalt();
								break;
							default:
								throw new Error("Unkown Event Called: " + t)
						}
					}
					checkIsLoaded() {
						return this.AudioPlayer.isLoadReady ? (!this.isEnabled || this.isLoaded || this.isLoading || (l.Logger.logDev("SOUND: Start Loading"), this.load().then((() => {
							this.tryStartSound()
						}))), this.isLoaded) : this.AudioPlayer.isLoadReady
					}
					load() {
						return this.AudioPlayer.startLoading().then((() => this.AudioPlayer))
					}
					tryStartSound() {
						this.player.checkLoadingState() ? (this.loadTimeOutLoop = void 0, l.Logger.logDev("SOUND: Loaded"), c.apiPlugIn.settings.trigger(r.APISetting.SFX), c.apiPlugIn.settings.trigger(r.APISetting.MUSIC)) : (this.loadTimeOutLoop && clearTimeout(this.loadTimeOutLoop), this.loadTimeOutLoop = setTimeout((() => this.tryStartSound()), 200), l.Logger.logDev("SOUND: Checking if it's complete."))
					}
					setInteractiveSettings(t) {
						this.updateSoundSetting() || (t == r.APISetting.SFX ? this.isEnabled ? this.AudioPlayer.onSfx(this.sfxOn) : this.AudioPlayer.onSfx(!1) : t == r.APISetting.MUSIC && (this.isEnabled ? this.AudioPlayer.onMusic(this.musicOn) : this.AudioPlayer.onMusic(!1)))
					}
					updateSoundSetting() {
						return this._ignoreClick || (this.sfxOn || this.musicOn || (this.isEnabled = !1), this.isSettingsModified && (this.isEnabled = !0)), !this.checkIsLoaded()
					}
					setSoundSettings() {
						const t = !!c.apiPlugIn.options.replay && !!c.apiPlugIn.options.replay.sound;
						if (t && !this.isEnabled) return this.toggleMute(), void l.Logger.logDev("SOUND: isReplayWithSound: " + t);
						const e = !!c.apiPlugIn.options.mute;
						if (e && this.isEnabled) return this.toggleMute(), void l.Logger.logDev("SOUND: isMutedInOptions: " + e);
						!(c.apiPlugIn.options.device === a.Device.MOBILE) && this.isFirstOpened && this.toggleMute(), this.isFirstOpened && (this.isEnabled = !(!c.apiPlugIn.settings.get(r.APISetting.SFX) && !c.apiPlugIn.settings.get(r.APISetting.MUSIC)))
					}
					isQuickMute() {
						return !this.isEnabled
					}
					toggleQuickMute() {
						return this.toggleMute(!1)
					}
					toggleMute(t = !0) {
						return this.isEnabled = !this.isEnabled, this._ignoreClick = !0, t || !this.isSettingsModified ? (c.apiPlugIn.settings.set(r.APISetting.SFX, this.isEnabled), c.apiPlugIn.settings.set(r.APISetting.MUSIC, this.isEnabled)) : (c.apiPlugIn.settings.trigger(r.APISetting.SFX), c.apiPlugIn.settings.trigger(r.APISetting.MUSIC)), this._ignoreClick = !1, this.isEnabled
					}
					pause() {
						this.eventTrigger(o.APIEvent.PAUSE, !0)
					}
					resume() {
						this.eventTrigger(o.APIEvent.RESUME, !1)
					}
					init() {
						return new Promise(((t, e) => {
							for (let t of n.NolimitLauncher.plugins)(0, s.isApiPlugin)(t) && (c.apiPlugIn = t);
							this.setSoundSettings(), this.addEventListeners(), t(this)
						}))
					}
					getReady() {
						return new Promise(((t, e) => {
							this.getSoundUrl().then((i => {
								u.get(i).json((e => {
									this.AudioPlayer.createPlaylist(this.loadPlayer(e, i)).then((() => {
										this.updateSoundSetting(), t(this)
									}))
								})).catch(e)
							})).catch(e)
						}))
					}
					getReadyToStart() {
						return Promise.resolve(this)
					}
					start() {
						return Promise.resolve(this)
					}
					getSoundUrl() {
						return new Promise(((t, e) => {
							const i = c.apiPlugIn.resources.getConfig();
							i ? t(i.staticRoot + c.AUDIO_JSON) : c.apiPlugIn.events.on(o.APIEvent.CONFIG, (() => {
								const e = c.apiPlugIn.resources.getConfig();
								t(e.staticRoot + c.AUDIO_JSON)
							}))
						}))
					}
					loadPlayer(t, e) {
						return t = Array.isArray(t) ? t : [t], Promise.all(t.map((t => this.processSoundData(e, t))))
					}
					processSoundData(t, e) {
						const i = this.getBaseUrl(t),
							n = e[c.apiPlugIn.options.device] || e.src;
						return e.src = n.map((t => `${i}/${t}`)), e
					}
					getBaseUrl(t) {
						return t.substring(0, t.lastIndexOf("/"))
					}
					playKeypadEffect(t) {
						this.player.playKeypadSound(t)
					}
				}
				c.AUDIO_JSON = "/resources/sounds/audio.json", e.NolimitSlotAudio = c
			},
			23110: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SlotGame = void 0, i(13006);
				const n = i(12355),
					s = i(91980),
					o = i(64118),
					r = i(3307),
					a = i(68610),
					l = i(83900),
					h = i(34018),
					u = i(97182),
					c = i(81029),
					d = i(46334),
					p = i(70975),
					_ = i(31801),
					m = i(37418),
					g = i(17774),
					f = i(52409),
					S = i(44679),
					y = i(75367),
					v = i(80927),
					T = i(76065),
					E = i(93924),
					b = i(2706),
					A = i(28147),
					P = i(23792),
					I = i(48840),
					w = i(84433),
					L = i(91305),
					C = i(88240),
					x = i(9220),
					B = i(15662),
					O = i(15904),
					N = i(330),
					M = i(80781),
					R = i(52475),
					D = i(72361),
					k = i(72519),
					F = i(85206),
					G = i(40745),
					U = i(56665),
					W = i(91265),
					H = i(61734),
					V = i(72468),
					X = i(57284);
				class Y {
					constructor(t) {
						this._resourcesLoaded = !1, this._initDataParsed = !1, this._isRestoreState = !1, this.name = "SlotGame", this.legacyIntro = !0, R.GameSetting.isDevMode = v.NolimitConfig.isDevMode, A.GameModuleConfig.instance = t
					}
					getNoWinGameData() {
						console.warn("GamePlugin.getNoWinData is not overridden in concrete game plugin, unable to soft reset")
					}
					fetchPlugins() {
						for (let t of s.NolimitLauncher.plugins)(0, u.isKeypadPlugin)(t) && (Y.keypad = t), (0, c.isSoundPlugin)(t) && (Y.sound = t.player), (0, o.isApiPlugin)(t) && (Y.api = t), (0, r.isAutoPlayPlugin)(t) && (Y.autoPlay = t), (0, l.isJackpotPlugin)(t) && (Y.jackpot = t), (0, h.isGamblePlugin)(t) && (Y.gamblePlugin = t), (0, a.isNolimitGameIntroPlugin)(t) && (this.legacyIntro = !1);
						return null == Y.keypad ? Promise.reject(new Error("SlotGame is missing KeypadPlugin")) : null == Y.sound ? Promise.reject(new Error("SlotGame is missing SoundPlugin")) : null == Y.api ? Promise.reject(new Error("SlotGame is missing ApiPlugin")) : null == Y.autoPlay ? Promise.reject(new Error("SlotGame is missing AutoPlayPlugin")) : Promise.resolve()
					}
					init() {
						return new Promise(((t, e) => {
							if (this.fetchPlugins().catch((t => Promise.reject(t))), Y.model = this.initServer(), f.EventHandler.addLastEventListener(this, N.ServerEvent.INIT_DATA_PARSED, (t => this.onInitDataParsed(t.params[0]))), this.initGameBase(Y.api), this.initStage(), this.initDevTools(), this.initGame(), A.GameModuleConfig.instance.GAME_FEATURE_CREATOR && A.GameModuleConfig.instance.GAME_FEATURE_CREATOR(), this.initGameResources(), this.legacyIntro) {
								f.EventHandler.addEventListener(this, X.StageEvent.STAGE_RESIZED, (t => this._legacyIntroResizeData = t.params[0]));
								const e = new Promise((t => {
										f.EventHandler.addEventListener(this, "SlotGame.intro_loaded", (() => {
											t()
										}))
									})),
									i = Y.api.resources,
									n = Y.api.translations,
									s = n.language + ".json",
									o = new Promise((t => {
										i.loadJson("translations/" + s).then((e => {
											this.loadTranslations(i, n, t, e)
										}), (() => {
											console.warn(n.language + " not found, defaulting to en"), n.language = "en", i.loadJson("translations/en.json").then((e => {
												this.loadTranslations(i, n, t, e)
											}))
										})), Y.gameResource.loadImages(x.ResourcesGroupName.INTRO)
									}));
								Promise.all([e, o]).then((() => {
									this.introAssetsAndTranslationsLoaded(), t(this)
								}))
							} else t(this)
						}))
					}
					getReady() {
						return new Promise(((t, e) => {
							this._slotApiAdapter.getReady(), f.EventHandler.addEventListener(this, "SlotGame.mainLoadedAndInitDataParsed", (() => {
								t(this)
							})), this.legacyIntro ? this._introController.show() : Y.gameResource.loadImages(x.ResourcesGroupName.INTRO), Y.model.initComplete()
						}))
					}
					getReadyToStart() {
						return new Promise(((t, e) => {
							f.EventHandler.dispatchEvent(new S.GameEvent(b.GameModeEvent.CHANGE_MODE, {
								newMode: this._initMode
							})), this._isRestoreState && (this._isRestoreState = !1, f.EventHandler.dispatchEvent(new S.GameEvent(O.ScreenEvent.GAME_RESTORE))), this.legacyIntro ? (this._introController.gameReady(), f.EventHandler.addEventListener(this, "SlotGame.introClosed", (() => {
								t(this)
							}))) : t(this)
						}))
					}
					start() {
						return new Promise((t => {
							this.startMainAmbience(), F.StageManager.legacyScaling && V.NolimitApplication.resize(), f.EventHandler.dispatchEvent(new S.GameEvent(O.ScreenEvent.GAME_START)), t(this)
						}))
					}
					startMainAmbience() {
						const t = null != B.SoundConfig.instance.START_GAME_AMBIANCE_CROSS_FADE_DURATION ? B.SoundConfig.instance.START_GAME_AMBIANCE_CROSS_FADE_DURATION : 1e3;
						B.SoundConfig.instance.MAIN_GAME_AMBIANCE && Y.sound.playAmbience(B.SoundConfig.instance.MAIN_GAME_AMBIANCE, t)
					}
					getPaytable() {
						const t = new n.TemplateLoader(Y.api.resources.getStaticRoot());
						return t.add({
							name: "Paytable",
							url: "nolimit/screens/paytable.mustache"
						}), t.load().then((t => {
							for (let e of t)
								if ("Paytable" == e.name && e.loadedData) return e.loadedData;
							throw new Error("SlotGame could not load Paytable")
						}))
					}
					getGameRules() {
						const t = new n.TemplateLoader(Y.api.resources.getStaticRoot());
						return t.add({
							name: "Rules",
							url: "nolimit/screens/rules.mustache"
						}), t.load().then((t => {
							for (let e of t)
								if ("Rules" == e.name && e.loadedData) return e.loadedData;
							throw new Error("SlotGame could not load Rules")
						}))
					}
					initServer() {
						return new M.ServerController
					}
					initGameBase(t) {
						this._slotApiAdapter = new D.SlotApiAdapter(t), new R.GameSetting(this._slotApiAdapter), new U.UserAgent(this._slotApiAdapter), new m.Currency(this._slotApiAdapter), new G.Translation(this._slotApiAdapter), Y.winFieldController = this.createWinFieldController()
					}
					createWinFieldController() {
						return new W.WinFieldController
					}
					initStage() {
						new F.StageManager
					}
					initDevTools() {
						R.GameSetting.isDevMode && (null != y.GameConfig.instance.GAME_TWEAKER_CONFIG && new _.GameTweaker(y.GameConfig.instance.GAME_TWEAKER_CONFIG), !0 === y.GameConfig.instance.PERFORMANCE_LOGGER && new p.PerformanceLogger, A.GameModuleConfig.instance.GAME_DEV_TOOLS_CREATOR && A.GameModuleConfig.instance.GAME_DEV_TOOLS_CREATOR())
					}
					initIntro() {
						d.Logger.deprecated("This game intro is deprecated, please use NolimitGameIntroPlugin instead", "slot-launcher 1.3.x"), this._introController = this.createIntroController(), f.EventHandler.addLastEventListener(this, T.GameIntroController.CLOSE, (() => this.onIntroClose()))
					}
					introAssetsAndTranslationsLoaded() {
						this.initIntro(), this._introController.introAssetsAndTranslationsLoaded(this._legacyIntroResizeData), f.EventHandler.removeEventListener(this, X.StageEvent.STAGE_RESIZED)
					}
					initGame() {
						A.GameModuleConfig.instance.GAME_CONTROLLER ? (A.GameModuleConfig.instance.GAME_CONTROLLER(), d.Logger.logDev("%c GameFlow: GameController ", "background-color:#777777;; color:white; font-size: 12px; padding: 4px;")) : (this.createSpinController(), P.Reels.init(), this.createBeforeSpinStopPresentationManager(), this.createReelStopPresentationManager(), this.createWinPresentationManager(), d.Logger.logDev("%c GameFlow: SpinController ", "background-color:#777777;; color:white; font-size: 12px; padding: 4px;"))
					}
					createIntroController() {
						const t = A.GameModuleConfig.instance.INTRO_VIEW ? A.GameModuleConfig.instance.INTRO_VIEW : t => new E.GameIntroView({
							layer: y.GameConfig.instance.LAYERS.INTRO.name,
							onButtonClickCallback: t,
							resourceGroup: x.ResourcesGroupName.INTRO
						});
						return A.GameModuleConfig.instance.INTRO_CONTROLLER ? A.GameModuleConfig.instance.INTRO_CONTROLLER(t) : new T.GameIntroController(t)
					}
					createSpinController() {
						return A.GameModuleConfig.instance.SPIN_CONTROLLER ? A.GameModuleConfig.instance.SPIN_CONTROLLER() : new k.SpinController
					}
					createBeforeSpinStopPresentationManager() {
						return new g.BeforeSpinStopPresentationManager
					}
					createReelStopPresentationManager() {
						return new I.ReelStopPresentationManager
					}
					createWinPresentationManager() {
						return new H.WinPresentationManager
					}
					initGameResources() {
						Y.gameResource = new C.GameResources, w.AssetsConfig.addToAssetsConfig(w.AssetsConfig._defaultResources), f.EventHandler.addLastEventListener(this, L.LoaderEvent.RESOURCES_LOADED, (t => this.onInitResourcesLoaded(t))), Y.gameResource.loadFonts()
					}
					onInitDataParsed(t) {
						this._isRestoreState = t.isRestoreState, this._initDataParsed = !0, this._initMode = t.mode, d.Logger.logDev("SlotGame.onInitDataParsed()"), this.checkReady()
					}
					onInitResourcesLoaded(t) {
						d.Logger.logDev(`SlotGame.onInitResourcesLoaded: ${t.key}`), t.key == x.ResourcesGroupName.INTRO ? f.EventHandler.dispatchEvent(new S.GameEvent("SlotGame.intro_loaded")) : t.key == x.ResourcesGroupName.MAIN && (this._resourcesLoaded = !0, this.checkReady())
					}
					onIntroClose() {
						d.Logger.logDev("SlotGame.onIntroClose():Game is Ready!"), f.EventHandler.removeLastEventListener(this, T.GameIntroController.CLOSE), f.EventHandler.dispatchEvent(new S.GameEvent("SlotGame.introClosed"))
					}
					checkReady() {
						this._initDataParsed && this._resourcesLoaded && (f.EventHandler.dispatchEvent(new S.GameEvent(O.ScreenEvent.GAME_READY)), f.EventHandler.dispatchEvent(new S.GameEvent("SlotGame.mainLoadedAndInitDataParsed")))
					}
					loadTranslations(t, e, i, n) {
						const s = e.language + ".json";
						t.loadJson(s, "/node_modules/@nolimitcity/game-api/resources/translations/").then((o => {
							e.add(o), t.loadJson(s, "/node_modules/@nolimitcity/slot-translations/resources/translations/").then((t => {
								e.add(t), e.add(n), i()
							}))
						}))
					}
				}
				e.SlotGame = Y
			},
			74233: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SpineTween = void 0;
				const n = i(13006);
				class s extends n.TimelineLite {
					constructor(t, e, i, o = 0, r = 1) {
						if (super(), null == i) return void s.clearAnimation(t, e);
						const a = t.spineData.findAnimation(i),
							l = 0 != o,
							h = Math.max(a.duration, a.duration + a.duration * o),
							u = new n.TweenLite(t, h, {});
						this.add([u, () => s.setAnimation(t, e, a, l, r)]), o > 0 && this.add((() => s.stopLoop(t, e, a)))
					}
					static clearAnimation(t, e) {
						t.state.setEmptyAnimation(e, 0)
					}
					static stopLoop(t, e, i) {
						const n = t.state.getCurrent(e);
						n.animation == i && (n.loop = !1)
					}
					static setAnimation(t, e, i, n, s) {
						t.state.setAnimationWith(e, i, n).alpha = s
					}
				}
				e.SpineTween = s
			},
			7057: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.TimelineSprite = void 0;
				const n = i(13006);
				class s extends PIXI.Sprite {
					get totalFrames() {
						return this._textures.length
					}
					get totalDuration() {
						return this._totalDuration
					}
					get frameDuration() {
						return this._frameDuration
					}
					get currentFrame() {
						const t = Math.floor(this.currentTweenFrame);
						return Math.max(0, Math.min(t, this._textures.length - 1))
					}
					constructor(t, e = 30) {
						super(t[0]), this._textures = t, this._sourceFPS = e, this._totalDuration = this._textures.length / this._sourceFPS, this._frameDuration = this._totalDuration / this._textures.length, this.currentTweenFrame = 0
					}
					getAnimation(t, e, i) {
						1 === (t = null != t ? t : [0]).length && t.push(this._textures.length - 1);
						const o = new n.TimelineLite;
						o.add((() => this.setFrame(s.wrapIndex(this._textures.length, t[0]))));
						for (let r = 1; r < t.length; r++) {
							const a = s.wrapIndex(this._textures.length, t[r - 1]),
								l = s.wrapIndex(this._textures.length, t[r]),
								h = (Math.abs(a - l) + 1) * this._frameDuration;
							o.add(new n.TweenLite(this, h, {
								currentTweenFrame: l + (l >= a ? .99 : -.99),
								ease: n.Linear.easeNone,
								onUpdate: () => {
									this.applyFrame(), e && e()
								},
								onComplete: r === t.length - 1 ? () => {
									i && i()
								} : void 0
							}))
						}
						return o
					}
					static wrapIndex(t, e) {
						if (t <= 0) throw new Error("Error: ArrayHelper.getValueInLoopRange(): length must bigger than zero!");
						return e > t - 1 ? e % t : e < 0 ? t - Math.abs(e) % t : e
					}
					getAnimationAutoShowHide(t = !0, e = !0, i, s, o) {
						const r = new n.TimelineLite;
						return t && r.add((() => this.show())), r.add(this.getAnimation(i, s, (() => {
							e && this.hide(), o && o()
						}))), r
					}
					setFrame(t) {
						this.currentTweenFrame = t, this.applyFrame()
					}
					applyFrame() {
						this.texture = this._textures[this.currentFrame]
					}
					playLoop(t) {
						this._loopAnimation && this._loopAnimation.isActive() || (this._loopAnimation = this.getAnimation([0], t, (() => this.playLoop(t))))
					}
					stopLoop() {
						this._loopAnimation && this._loopAnimation.isActive() && (this._loopAnimation.pause(), this._loopAnimation.kill())
					}
					show() {
						this.visible = !0
					}
					hide() {
						this.visible = !1
					}
				}
				e.TimelineSprite = s
			},
			17259: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Background = void 0;
				const n = i(73044),
					s = i(52409),
					o = i(2706),
					r = i(85206);
				class a extends n.BaseView {
					constructor(t, e) {
						super(e), this._layer = r.StageManager.getLayer(t.layer)
					}
					addEventListeners() {
						s.EventHandler.addEventListener(this, o.GameModeEvent.CHANGE_MODE, (t => this.onChangeBackground(t.params[0])))
					}
					initAnimations() {
						this._layer.addChild(this)
					}
					onChangeBackground(t) {
						return t.newMode !== this._currentMode && (this._currentMode = t.newMode, !0)
					}
				}
				e.Background = a
			},
			37418: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Currency = void 0;
				const n = i(52409),
					s = i(59848);
				class o {
					constructor(t) {
						if (o._instance) throw new Error("Error: Currency.constructor() - Instantiation failed: Singleton.");
						o._instance = this, o._instance._apiAdapter = t, o._instance._playerCurrency = {
							before: !0,
							symbol: "",
							code: ""
						}, n.EventHandler.addEventListener(this, s.BalanceEvent.CURRENCY, (t => o.onCurrency(t.params[0])))
					}
					static onCurrency(t) {
						null !== t.before && (o._instance._playerCurrency.before = t.before), null !== t.symbol && (o._instance._apiAdapter.hideCurrency ? o._instance._playerCurrency.symbol = "" : o._instance._playerCurrency.symbol = t.symbol), null !== t.code && (o._instance._apiAdapter.hideCurrency ? o._instance._playerCurrency.code = "" : o._instance._playerCurrency.code = t.code)
					}
					static format(t, e) {
						return o._instance._apiAdapter.formatCurrency(t, e)
					}
					static formatValue(t, e) {
						return o._instance._apiAdapter.formatCurrencyValue(t, e)
					}
					static getPlayerCurrency() {
						return o._instance._playerCurrency
					}
				}
				e.Currency = o
			},
			59848: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BalanceEvent = void 0;
				class i {}
				i.BALANCE = "balanceEvent_balance", i.CURRENCY = "balanceEvent_currency", i.CURRENT_BET = "balanceEvent_currentBet", i.BET_LEVELS = "balanceEvent_betLevels", i.FREE_BETS = "balanceEvent_freeBets", i.BET = "balanceEvent_bet", i.ZERO_BET = "balanceEvent_zeroBet", i.PICK_AND_CLICK = "balanceEvent_pickAndClick", e.BalanceEvent = i
			},
			46289: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BaseController = void 0;
				const n = i(71027),
					s = i(52409),
					o = i(44679),
					r = i(75367);
				e.BaseController = class {
					get moduleName() {
						return this._name
					}
					constructor(t = !1, e, i) {
						this.checkBetWinMode(i), this._tweakEnabled = t, this._name = e, this._tweakEnabled && this.initTweakModule()
					}
					checkBetWinMode(t) {
						if (t || (t = 0), 0 !== t && t != r.GameConfig.instance.BET_WIN_MODE) throw new Error(`Moudle ${this.moduleName} doesn't support the current Bet_WIN_MODE in the GameConfig!`)
					}
					initTweakModule() {
						if (null == this._name) throw new Error("Error: BaseController.initTweakModule(): name is missing when tweak is enabled!");
						s.EventHandler.dispatchEvent(new o.GameEvent(n.TweakEvent.ADD_MODULE, this._name))
					}
					addTweakModuleSlider(t) {
						if (null == this._name) throw new Error("Error: BaseController.addTweakModuleSlider(): name is missing when tweak is enabled!");
						s.EventHandler.dispatchEvent(new o.GameEvent(n.TweakEvent.ADD_SLIDER_TO_MODULE, this._name, t))
					}
				}
			},
			73044: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BaseView = void 0;
				const n = i(52409),
					s = i(91305),
					o = i(9220),
					r = i(57284);
				class a extends PIXI.Container {
					constructor(t = o.ResourcesGroupName.MAIN) {
						super(), this._isResizeDirty = !1, this._hasInit = !1, this._resourcesGroup = t, this.addBaseEventListeners(), this.addEventListeners && this.addEventListeners()
					}
					addBaseEventListeners() {
						n.EventHandler.addEventListener(this, s.LoaderEvent.RESOURCES_LOADED, (t => this.onResourcesLoaded(t))), n.EventHandler.addEventListener(this, r.StageEvent.STAGE_RESIZED, (t => this.onStageResized(t.params[0])))
					}
					onResourcesLoaded(t) {
						t.key == this._resourcesGroup && (this.initAnimations && this.initAnimations(), this._hasInit = !0, this._isResizeDirty && this.onResize && (this._isResizeDirty = !1, this.onResize(this._resizeData)))
					}
					onStageResized(t) {
						this._resizeData = t, this.onResize && this._hasInit ? (this._isResizeDirty = !1, this.onResize(t)) : this._isResizeDirty = !0
					}
				}
				e.BaseView = a
			},
			17774: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BeforeSpinStopPresentationManager = void 0;
				const n = i(52409),
					s = i(44679),
					o = i(28147),
					r = i(91812),
					a = i(330),
					l = i(32696);
				e.BeforeSpinStopPresentationManager = class {
					constructor() {
						this._presentations = [];
						const t = o.GameModuleConfig.instance.BEFORE_SPIN_STOP_PRESENTATIONS;
						t && t.forEach(((t, e) => {
							this._presentations.push(t(e))
						})), this.addEventListeners()
					}
					addEventListeners() {
						n.EventHandler.addEventListener(this, l.SpinEvent.BEFORE_START, (t => this.onBeforeSpinStart())), n.EventHandler.addEventListener(this, a.ServerEvent.GAME_DATA_PARSED, (t => this.onGameDataParsed(t.params[0]))), n.EventHandler.addEventListener(this, r.ReelEvent.ALL_REELS_STOP_SPIN, (t => this.onStartStopSpin(t.params[0])))
					}
					onBeforeSpinStart() {
						this._presentations.forEach((t => {
							t.reset()
						}))
					}
					onGameDataParsed(t) {
						let e = 0;
						this._presentations.forEach(((i, n) => {
							e = Math.max(e, i.tryStartPresentation(t))
						})), n.EventHandler.dispatchEvent(new s.GameEvent(l.SpinEvent.ADD_STOP_DELAY, e))
					}
					onStartStopSpin(t) {
						this._presentations.forEach((e => {
							e.abort(t)
						}))
					}
				}
			},
			64625: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BetLine = void 0;
				const n = i(52409),
					s = i(53108);
				class o extends PIXI.Container {
					get index() {
						return this._index
					}
					constructor(t, e, i, n) {
						super(), this._isPlayingWin = !1, this._index = t, this.draw(e, i, n), this.addEventListeners()
					}
					addEventListeners() {
						n.EventHandler.addEventListener(this, s.BetLineEvent.SHOW_STATIC_BET_LINE, (t => this.onShowStaticBetLine(t.params[0]))), n.EventHandler.addEventListener(this, s.BetLineEvent.HIDE_STATIC_BET_LINE, (t => this.onHideStaticBetLine(t.params[0]))), n.EventHandler.addEventListener(this, s.BetLineEvent.SHOW_WIN_BET_LINE, (t => this.onShowWinBetLine(t.params[0]))), n.EventHandler.addEventListener(this, s.BetLineEvent.HIDE_WIN_BET_LINE, (t => this.onHideWinBetLine(t.params[0]))), n.EventHandler.addEventListener(this, s.BetLineEvent.HIDE_ALL_BET_LINES, (t => this.onHideAllBetLines()))
					}
					onShowStaticBetLine(t) {
						t === this._index && (this._isPlayingWin || this.showStatic())
					}
					onHideStaticBetLine(t) {
						t === this._index && (this._isPlayingWin || this.hideAll())
					}
					onShowWinBetLine(t) {
						t === this._index && (this._isPlayingWin = !0, this.showWin())
					}
					onHideWinBetLine(t) {
						t === this._index && this.onHideAllBetLines()
					}
					onHideAllBetLines() {
						this._isPlayingWin = !1, this.hideAll()
					}
				}
				e.BetLine = o
			},
			77016: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BetLineNumber = void 0;
				const n = i(52409),
					s = i(44679),
					o = i(56665),
					r = i(53108);
				class a extends PIXI.Container {
					get index() {
						return this._index
					}
					constructor(t, e) {
						super(), this._isPlayingWin = !1, this._index = t, this.draw(e), this.initButtonMode(), this.addEventListeners()
					}
					initButtonMode() {
						this.setEnabled(!0), this.on("mouseover", this.onMouseOver), this.on("mouseout", this.onMouseOut)
					}
					onMouseOver() {
						this._isPlayingWin || o.UserAgent.isMobile || (this.showMouseOver(), n.EventHandler.dispatchEvent(new s.GameEvent(r.BetLineEvent.SHOW_STATIC_BET_LINE, this.index)))
					}
					onMouseOut() {
						this._isPlayingWin || (this.showMouseOut(), n.EventHandler.dispatchEvent(new s.GameEvent(r.BetLineEvent.HIDE_STATIC_BET_LINE, this.index)))
					}
					addEventListeners() {
						n.EventHandler.addEventListener(this, r.BetLineEvent.SHOW_WIN_BET_LINE, (t => this.onShowWinBetLine(t.params[0]))), n.EventHandler.addEventListener(this, r.BetLineEvent.HIDE_WIN_BET_LINE, (t => this.onHideWinBetLine(t.params[0]))), n.EventHandler.addEventListener(this, r.BetLineEvent.HIDE_ALL_BET_LINES, (t => this.onHideAllBetLines())), n.EventHandler.addEventListener(this, r.BetLineEvent.SET_ENABLED, (t => this.setEnabled(t.params[0])))
					}
					onShowWinBetLine(t) {
						t === this._index && (this._isPlayingWin = !0, this.showWin())
					}
					onHideWinBetLine(t) {
						t === this._index && this.onHideAllBetLines()
					}
					onHideAllBetLines() {
						this._isPlayingWin = !1, this.showNormal()
					}
					setEnabled(t) {
						this.interactive = t, this.onHideAllBetLines()
					}
				}
				e.BetLineNumber = a
			},
			68093: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BetLinesView = void 0;
				const n = i(73044),
					s = i(52409),
					o = i(330);
				class r extends n.BaseView {
					constructor(t, e, i) {
						super(), this._betLines = [], this._betLineNumbers = [], this._resourcesLoaded = !1, this._dataInitialized = !1, this._numberFactoryMethod = e, this._lineFactoryMethod = i, this._config = t
					}
					addEventListeners() {
						s.EventHandler.addEventListener(this, o.ServerEvent.INIT_DATA_PARSED, (t => this.onInitDataParsed(t.params[0])))
					}
					initAnimations() {
						this._resourcesLoaded = !0, this.draw()
					}
					onInitDataParsed(t) {
						if (this._betLinesData = t.betLines, this._betLinesData.length != this._config.map.length) throw new Error(`Error: There are only ${this._config.map.length} betLines in the config order while the server sends ${this._betLinesData.length} lines.`);
						this._dataInitialized = !0, this.draw()
					}
					draw() {
						if (!this._resourcesLoaded || !this._dataInitialized) return;
						const t = this._config.map;
						for (let e = 0; e < t.length; e++) {
							const i = this._numberFactoryMethod(t[e]),
								n = i.setPosition(this._betLinesData.length, e);
							this._betLineNumbers.push(i);
							const s = this._lineFactoryMethod(t[e], n, this._betLinesData[t[e] - 1]);
							this._betLines.push(s)
						}
						this._betLines.sort(((t, e) => t.index - e.index)), this._betLineNumbers.sort(((t, e) => t.index - e.index))
					}
				}
				e.BetLinesView = r
			},
			53108: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BetLineEvent = void 0;
				class i {}
				i.SHOW_STATIC_BET_LINE = "betLineEvent_showStaticBetLine", i.HIDE_STATIC_BET_LINE = "betLineEvent_hideStaticBetLine", i.SHOW_WIN_BET_LINE = "betLineEvent_showWinBetLine", i.HIDE_WIN_BET_LINE = "betLineEvent_hideWinBetLine", i.HIDE_ALL_BET_LINES = "betLineEvent_hideAllBetLines", i.SET_ENABLED = "betLineEvent_setEnabled", e.BetLineEvent = i
			},
			86069: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BitmapCountUp = void 0;
				const n = i(46334),
					s = i(13006),
					o = i(37418),
					r = i(75367);
				class a extends PIXI.BitmapText {
					get shrinkSize() {
						return this._shrinkSize
					}
					set shrinkSize(t) {
						this._shrinkSize = t
					}
					get maxTextWidth() {
						return this._maxTextWidth
					}
					set maxTextWidth(t) {
						this._maxTextWidth = t, this.parent ? this.updateCountUpTextPivot() : this._isResizeDirty = !0
					}
					get currentValue() {
						return this._currentValue
					}
					set currentValue(t) {
						this._currentValue = t
					}
					get scaling() {
						return this._scaling
					}
					set scaling(t) {
						this._scaling = t
					}
					get width() {
						return this.textWidth
					}
					constructor(t) {
						super("0", {
							fontName: t.style.font.name ? t.style.font.name : "",
							fontSize: t.style.font.size,
							align: t.style.align,
							tint: t.style.tint ? t.style.tint : 16777215
						}), this._highestTriggeredAnchorIndex = -1, this._isCountingUp = !1, this._scaling = 1, this._isResizeDirty = !1, this._evenWidth = !0, this._anchors = [], this._externalOnUpdateCallbacks = [], this._onWidthChangeCallback = t.onWidthChangeCallback, this._numberFormat = t.numberFormat, this._originalFontSize = t.style.font.size, this._evenWidth = !1 !== t.evenWidth, this.on("added", this.onAdded)
					}
					onAdded() {
						this._isResizeDirty && this.updateCountUpTextPivot()
					}
					addAnchor(t) {
						if (this._isCountingUp) throw new Error("Error: BitmapCountUp.addAnchor():Not allow to edit anchors while counting up!");
						this._anchors.push(t), this._anchors.sort(((t, e) => t.value - e.value))
					}
					clearAllAnchors() {
						if (this._isCountingUp) throw new Error("Error: BitmapCountUp.clearAllAnchors():Not allow to edit anchors while counting up!");
						this._anchors = []
					}
					addExternalOnUpdateCallback(t) {
						this._externalOnUpdateCallbacks.push(t)
					}
					getCountUpAnimation(t, e, i, o) {
						i.scaling = i.scaling || {
							from: 1,
							to: 1
						};
						const r = new s.TimelineLite;
						return r.add(s.TweenLite.fromTo(this, i.duration, {
							currentValue: t,
							scaling: i.scaling.from
						}, {
							currentValue: e,
							scaling: i.scaling.to,
							ease: i.ease ? i.ease : s.Power3.easeInOut,
							onStart: () => {
								this._isCountingUp && n.Logger.logDev("BigmapCountUp.getCountUpAnimation():Start count up when it's already counting. it might be no problem. just log for warning."), this._shrinkSize && (this.fontSize = this._originalFontSize), this.onCountUpUpdate(), this.updateCountUpTextPivot(), this._isCountingUp = !0
							},
							onUpdate: () => this.onCountUpUpdate(),
							onComplete: () => {
								this.resetCountUp(), this.onCountUpUpdate(), o && o()
							}
						})), r
					}
					onCountUpUpdate() {
						const t = this.text.length;
						this.text = o.Currency.formatValue(this._currentValue, this._numberFormat), this.scale.set(this.scaling, this.scaling), this._evenWidth && t == this.text.length || (this.updateCountUpTextPivot(), this._onWidthChangeCallback && this._onWidthChangeCallback());
						for (let t = 0; t < this._externalOnUpdateCallbacks.length; t++) this._externalOnUpdateCallbacks[t]();
						if (this._highestTriggeredAnchorIndex < this._anchors.length - 1)
							for (let t = this._highestTriggeredAnchorIndex + 1; t < this._anchors.length; t++) this._anchors[t].value <= this._currentValue && (this._anchors[t].callback(), this._anchors[t].oneTimeUse ? (this._anchors.splice(t, 1), t--) : this._highestTriggeredAnchorIndex = t)
					}
					updateCountUpTextPivot() {
						if (this.parent) {
							if (this.dirty = !0, this.updateTransform(), this._shrinkSize)
								for ((null == this._maxTextWidth || this._maxTextWidth <= 0) && (this._maxTextWidth = r.GameConfig.instance.REEL_AREA_WIDTH); this.textWidth * this._scaling > this._maxTextWidth;) this.fontSize--, this.dirty = !0, this.updateTransform();
							this.pivot.set(.5 * this.textWidth, .5 * this.height), this._isResizeDirty = !1
						} else this._isResizeDirty = !0
					}
					resetCountUp() {
						this._isCountingUp = !1, this._highestTriggeredAnchorIndex = -1
					}
				}
				e.BitmapCountUp = a
			},
			11112: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Button = e.ButtonState = void 0;
				const n = i(7057);
				var s;
				! function(t) {
					t[t.disabled = 0] = "disabled", t[t.loading = 1] = "loading", t[t.idle = 2] = "idle", t[t.over = 3] = "over", t[t.down = 4] = "down"
				}(s = e.ButtonState || (e.ButtonState = {}));
				class o extends PIXI.Sprite {
					set enabled(t) {
						this._enabled != t && (this._enabled = t, this.setState(this._enabled ? s.idle : s.disabled))
					}
					get enabled() {
						return this._enabled
					}
					get width() {
						return this._currentState.width
					}
					constructor(t, e, i = 30) {
						super(), this._idleState = this.createState(t.idle, i), this._overState = this.createState(t.over, i), this._downState = this.createState(t.disabled, i), this._disabledState = this.createState(t.disabled, i), this._onClickedCallback = e, this.init()
					}
					createState(t, e) {
						let i;
						return i = Array.isArray(t) ? new n.TimelineSprite(t, e) : new n.TimelineSprite([t], e), this.addChild(i), i.visible = !1, i.anchor.set(.5, .5), i
					}
					setState(t, e = !0) {
						switch (this._idleState.hide(), this._idleState.stopLoop(), this._overState.hide(), this._overState.stopLoop(), this._downState.hide(), this._downState.stopLoop(), this._disabledState.hide(), this._disabledState.stopLoop(), t) {
							case s.disabled:
								this._currentState = this._disabledState;
								break;
							case s.idle:
								this._currentState = this._idleState;
								break;
							case s.over:
								this._currentState = this._overState;
								break;
							case s.down:
								this._currentState = this._downState;
								break;
							default:
								throw new Error(`Button.setState(): Illegal button state ${t}`)
						}
						e ? this._currentState.playLoop() : this._currentState.getAnimation([0, 0]), this._currentState.show()
					}
					init() {
						this._enabled = !0, this.interactive = !0, this.buttonMode = !0, this.anchor.set(.5, .5), this.on("pointerdown", this.onDown), this.on("pointerout", this.onIdle), this.on("pointerover", this.onOver), this.on("pointertap", this.onUp), this.setState(s.idle)
					}
					onIdle() {
						this._enabled && this.setState(s.idle)
					}
					onOver() {
						this._enabled && this.setState(s.over)
					}
					onDown() {
						this._enabled && this.setState(s.down)
					}
					onUp() {
						this._enabled && (this._currentState != this._downState && this.setState(s.down), this._onClickedCallback())
					}
					click() {
						this.onUp()
					}
				}
				e.Button = o
			},
			33704: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.CountDownTimer = void 0;
				const n = i(52585);
				class s extends PIXI.Container {
					constructor(t) {
						super(), this._prefixSingularString = t.prefixTextSingular, this._prefixPluralString = t.prefixTextPlural, this._postfixSecondsPluralString = t.postfixSecondsTextPlural, this._postfixSecondSingularString = t.postfixSecondTextSingular, this._textPrefixStyle = null == t.prefixTextStyle ? s.DEFAULT_TEXT_STYLE : t.prefixTextStyle, this._textTimeStyle = null == t.timeTextStyle ? s.DEFAULT_TEXT_TIME_STYLE : t.timeTextStyle, this._textSecondsStyle = null == t.postfixTextStyle ? s.DEFAULT_TEXT_STYLE : t.postfixTextStyle, this._textSpacing = null == t.textSpacing ? s.DEFAULT_TEXT_SPACING : t.textSpacing, this._isRunning = !1, this.initAnimations()
					}
					initAnimations() {
						this._textsLine = new n.DynamicTextsLine(.5, this._textSpacing), this.addChild(this._textsLine), this._textPrefix = this._textsLine.createText(this._prefixPluralString, this._textPrefixStyle), this._textTime = this._textsLine.createText("-", this._textTimeStyle), this._textSecondsPostfix = this._textsLine.createText(this._postfixSecondsPluralString, this._textSecondsStyle), this._textsLine.arrange()
					}
					setScale(t) {
						this._textsLine.setScale(t)
					}
					start(t, e = null) {
						this.abort(), this._timeTotal = t, this._timeLeft = this._timeTotal + 1, this._completeCallback = e, this.onTimer(), this._timer = window.setInterval((() => this.onTimer()), 1e3), this._isRunning = !0
					}
					abort() {
						this._isRunning && (window.clearInterval(this._timer), this._isRunning = !1)
					}
					onTimer() {
						this._timeLeft--, this._textTime.text = this._timeLeft.toString(), this._textPrefix.text = 1 === this._timeLeft ? this._prefixSingularString : this._prefixPluralString, this._textSecondsPostfix.text = 1 === this._timeLeft ? this._postfixSecondSingularString : this._postfixSecondsPluralString, this._textsLine.arrange(), 0 === this._timeLeft && (this.abort(), this._completeCallback && this._completeCallback())
					}
				}
				s.DEFAULT_TEXT_STYLE = {
					fontFamily: "Open Sans",
					fontSize: "13px",
					fontWeight: "300",
					fill: "#ffffff"
				}, s.DEFAULT_TEXT_TIME_STYLE = {
					fontFamily: "Open Sans",
					fontSize: "13px",
					fontWeight: "700",
					fill: "#ffffff"
				}, s.DEFAULT_TEXT_SPACING = 5, e.CountDownTimer = s
			},
			52585: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.DynamicTextsLine = void 0;
				const n = i(2501);
				class s extends PIXI.Container {
					get verticalAlignment() {
						return this._verticalAlignment
					}
					set verticalAlignment(t) {
						this._verticalAlignment = t, this.arrange()
					}
					get textSpacing() {
						return this._textSpacing
					}
					set textSpacing(t) {
						this._textSpacing = t, this.arrange()
					}
					constructor(t = .5, e = 0, i) {
						super(), this._textSpacing = 0, this._internalScale = 1, this._anchor = i || new PIXI.Point(.5, .5), this._verticalAlignment = t, this._textSpacing = e, this._texts = []
					}
					createText(t, e) {
						const i = new n.SharpText(t, e);
						return this._texts.push(i), this.addChild(i), i
					}
					setAnchor(t, e) {
						e = e || t, this._anchor.set(t, e), this.arrange()
					}
					setScale(t) {
						if (t !== this._internalScale) {
							this._internalScale = t;
							for (let e of this._texts) e.setScale(t);
							this.arrange()
						}
					}
					arrange() {
						let t = 0;
						for (let e of this._texts) e.position.set(t, 0), t += e.width + this._textSpacing * this._internalScale;
						this.updateVerticalAlignment(), this.pivot.set(this.width * this._anchor.x, this.height * this._anchor.y)
					}
					updateVerticalAlignment() {
						let t = 0;
						for (let e of this._texts) e.anchor.set(0, this._verticalAlignment), t = e.height > t ? e.height : t;
						for (let e of this._texts) e.y = Math.ceil(t * this._verticalAlignment)
					}
				}
				e.DynamicTextsLine = s
			},
			87091: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LoaderButton = void 0;
				const n = i(13006),
					s = i(74922),
					o = i(11112),
					r = i(376);
				class a extends r.NineSliceButton {
					constructor(t, e, i, n) {
						super(t, e, n), this._loadingText = i
					}
					initAnimations() {
						super.initAnimations(), this._loadProgress = 0, this._loaderOutline = this.createLoaderOutline(), this._loaderOutlineMask = new PIXI.Graphics, this._loaderOutline.mask = this._loaderOutlineMask, this._startAngle = -90, this._endAngle = this._startAngle + 360, this._graphicsContainer.addChild(this._backplateMesh), this._graphicsContainer.addChild(this._loaderOutline), this._graphicsContainer.addChild(this._loaderOutlineMask), this._graphicsContainer.addChild(this._buttonText), this._animationGetters[o.ButtonState.loading] = () => this.getToLoading()
					}
					createLoaderOutline() {
						return new s.BasePlateMesh({
							cornerRadius: 12,
							lineThickness: 2,
							lineColor: 16777215,
							lineAlpha: 1,
							backgroundColor: 0,
							backgroundAlpha: 0
						})
					}
					setState(t) {
						t == o.ButtonState.loading && (this.enabled = !1), super.setState(t)
					}
					updateMask(t) {
						if (this._loadProgress == t) return;
						this._loadProgress = t;
						const e = this._startAngle + 360 * this._loadProgress;
						this._loaderOutlineMask.clear(), this._loaderOutlineMask.beginFill(16711680), this._loaderOutlineMask.arc(0, 0, this._maskRadius, this._startAngle * PIXI.DEG_TO_RAD, e * PIXI.DEG_TO_RAD, !1), this._loaderOutlineMask.lineTo(0, 0), this._loaderOutlineMask.endFill()
					}
					setSize(t, e, i) {
						super.setSize(t, e, i), this._loaderOutline.width = t, this._loaderOutline.height = e, this._loaderOutline.update(i), this._loaderOutline.pivot.set(.5 * this._loaderOutline.width, .5 * this._loaderOutline.height), this._maskRadius = Math.max(this._loaderOutline.width, this._loaderOutline.height), this.updateMask(this._loadProgress)
					}
					startLoadingTextLoop() {
						this.stopLoadingTextLoop(), this._loadingLoop = new n.TimelineMax({
							repeat: -1,
							yoyo: !0
						}), this._loadingLoop.add(n.TweenLite.fromTo(this._buttonText, 1, {
							alpha: .8,
							ease: n.Power2.easeInOut
						}, {
							alpha: .4,
							ease: n.Power2.easeInOut
						}))
					}
					stopLoadingTextLoop() {
						this._loadingLoop && this._loadingLoop.isActive() && this._loadingLoop.pause(), this._loadingLoop = null
					}
					getToLoading() {
						const t = new n.TimelineLite;
						return t.add([() => this.setButtonText(this._loadingText), new n.TweenLite(this._buttonText, this._animationDuration, {
							alpha: .4
						}), new n.TweenLite(this._backplateMesh, this._animationDuration, {
							alpha: .2
						}), new n.TweenLite(this._loaderOutline, this._animationDuration, {
							alpha: .6
						}), new n.TweenLite(this._graphicsContainer.scale, this._animationDuration, {
							x: .95,
							y: .95
						})]), t.add((() => this.startLoadingTextLoop())), t
					}
					getToDisabled() {
						const t = new n.TimelineLite;
						return t.add((() => this.stopLoadingTextLoop())), t.add([() => this.setButtonText(this._normalTextString), new n.TweenLite(this._buttonText, this._animationDuration, {
							alpha: .4
						}), new n.TweenLite(this._backplateMesh, this._animationDuration, {
							alpha: .2
						}), new n.TweenLite(this._loaderOutline, this._animationDuration, {
							alpha: .6
						}), new n.TweenLite(this._graphicsContainer.scale, this._animationDuration, {
							x: .95,
							y: .95
						})]), t
					}
					getToIdle() {
						const t = new n.TimelineLite;
						return t.add((() => this.stopLoadingTextLoop())), t.add([() => this.setButtonText(this._normalTextString), new n.TweenLite(this._buttonText, this._animationDuration, {
							alpha: .8
						}), new n.TweenLite(this._backplateMesh, this._animationDuration, {
							alpha: .6
						}), new n.TweenLite(this._loaderOutline, this._animationDuration, {
							alpha: 0
						}), new n.TweenLite(this._graphicsContainer.scale, this._animationDuration, {
							x: 1,
							y: 1
						})]), t
					}
					getToOver() {
						const t = new n.TimelineLite;
						return t.add((() => this.stopLoadingTextLoop())), t.add([() => this.setButtonText(this._normalTextString), new n.TweenLite(this._buttonText, this._animationDuration, {
							alpha: 1
						}), new n.TweenLite(this._backplateMesh, this._animationDuration, {
							alpha: 1
						}), new n.TweenLite(this._graphicsContainer.scale, this._animationDuration, {
							x: 1,
							y: 1
						})]), t
					}
					getToDown() {
						const t = new n.TimelineLite;
						return t.add((() => this.stopLoadingTextLoop())), t.add([() => this.setButtonText(this._normalTextString), new n.TweenLite(this._buttonText, this._animationDuration, {
							alpha: 1
						}), new n.TweenLite(this._backplateMesh, this._animationDuration, {
							alpha: 1
						}), new n.TweenLite(this._graphicsContainer.scale, this._animationDuration, {
							x: .95,
							y: .95
						})]), t
					}
				}
				e.LoaderButton = a
			},
			376: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NineSliceButton = void 0;
				const n = i(77616),
					s = i(74922),
					o = i(56682),
					r = i(11112),
					a = i(13006);
				class l extends PIXI.Container {
					set enabled(t) {
						this._enabled != t && (this._enabled = t, this.setState(this._enabled ? r.ButtonState.idle : r.ButtonState.disabled), this._backplateMesh.buttonMode = this._enabled)
					}
					get enabled() {
						return this._enabled
					}
					constructor(t, e, i, n) {
						super(), this._animationDuration = .1, this._onClickedCallback = t, this._normalTextString = e, this._textStyle = null != i ? i : this.getDefaultTextStyle(), this._backgroundConfig = null != n ? n : this.getDefaultBackgroundConfig(), this.initAnimations(), this.init()
					}
					initAnimations() {
						this._graphicsContainer = new PIXI.Container, this.addChild(this._graphicsContainer), this._backplateMesh = this.createBackPlate(), this._buttonText = this.createText(this._normalTextString, this._textStyle), this._currentTextString = this._normalTextString, this._graphicsContainer.addChild(this._backplateMesh), this._graphicsContainer.addChild(this._buttonText), this._animationGetters = {}, this._animationGetters[r.ButtonState.disabled] = () => this.getToDisabled(), this._animationGetters[r.ButtonState.idle] = () => this.getToIdle(), this._animationGetters[r.ButtonState.over] = () => this.getToOver(), this._animationGetters[r.ButtonState.down] = () => this.getToDown()
					}
					createBackPlate() {
						return new s.BasePlateMesh(this._backgroundConfig)
					}
					getDefaultBackgroundConfig() {
						return {
							cornerRadius: 12,
							lineThickness: 2,
							lineColor: 16777215,
							lineAlpha: 1,
							backgroundColor: 0,
							backgroundAlpha: .4
						}
					}
					createText(t, e) {
						const i = new PIXI.Text(t, e);
						return i.style.align = "center", i.anchor.set(.5, .5), i
					}
					getDefaultTextStyle() {
						return {
							fontFamily: "Open Sans",
							fontStyle: n.FontStyle.ITALIC,
							fontSize: 28,
							fill: "#ffffff",
							fontWeight: n.FontWeight.EXTRA_BOLD
						}
					}
					setSize(t, e, i) {
						this._backplateMesh.width = t, this._backplateMesh.height = e, this._backplateMesh.update(i), this._backplateMesh.pivot.set(.5 * this._backplateMesh.width, .5 * this._backplateMesh.height), this._buttonText.style.fontSize = this._textStyle.fontSize, o.Helper.shrinkTextWidth(this._currentTextString, this._buttonText, this._backplateMesh.width / this.scale.x)
					}
					setButtonText(t) {
						this._currentTextString != t && (this._currentTextString = t, this._buttonText.text = t, this._buttonText.style.fontSize = this._textStyle.fontSize, o.Helper.shrinkTextWidth(this._currentTextString, this._buttonText, this._backplateMesh.width / this.scale.x))
					}
					setState(t) {
						if (t != this._currentState) {
							if (this._currentAnimation && this._currentAnimation.isActive() && (this._currentAnimation.pause(this._currentAnimation.totalDuration()), this._currentAnimation.kill()), null == this._animationGetters[t]) throw new Error(`Button.setState(): Illegal button state ${t}`);
							this._currentAnimation = this._animationGetters[t](), this._currentState = t
						}
					}
					init() {
						this._backplateMesh.interactive = !0, this.enabled = !0, this._backplateMesh.on("pointerdown", this.onDown, this), this._backplateMesh.on("pointerout", this.onIdle, this), this._backplateMesh.on("pointerover", this.onOver, this), this._backplateMesh.on("pointertap", this.onUp, this)
					}
					onIdle() {
						this._enabled && this.setState(r.ButtonState.idle)
					}
					onOver() {
						this._enabled && this.setState(r.ButtonState.over)
					}
					onDown() {
						this._enabled && this.setState(r.ButtonState.down)
					}
					onUp() {
						this._enabled && (this._currentState != r.ButtonState.down && this.setState(r.ButtonState.down), this._onClickedCallback())
					}
					click() {
						this.onUp()
					}
					getToDisabled() {
						const t = new a.TimelineLite;
						return t.add([new a.TweenLite(this._buttonText, this._animationDuration, {
							alpha: .4
						}), new a.TweenLite(this._backplateMesh, this._animationDuration, {
							alpha: .2
						}), new a.TweenLite(this._graphicsContainer.scale, this._animationDuration, {
							x: .95,
							y: .95
						})]), t
					}
					getToIdle() {
						const t = new a.TimelineLite;
						return t.add([new a.TweenLite(this._buttonText, this._animationDuration, {
							alpha: .8
						}), new a.TweenLite(this._backplateMesh, this._animationDuration, {
							alpha: .6
						}), new a.TweenLite(this._graphicsContainer.scale, this._animationDuration, {
							x: 1,
							y: 1
						})]), t
					}
					getToOver() {
						const t = new a.TimelineLite;
						return t.add([new a.TweenLite(this._buttonText, this._animationDuration, {
							alpha: 1
						}), new a.TweenLite(this._backplateMesh, this._animationDuration, {
							alpha: 1
						}), new a.TweenLite(this._graphicsContainer.scale, this._animationDuration, {
							x: 1,
							y: 1
						})]), t
					}
					getToDown() {
						const t = new a.TimelineLite;
						return t.add([new a.TweenLite(this._buttonText, this._animationDuration, {
							alpha: 1
						}), new a.TweenLite(this._backplateMesh, this._animationDuration, {
							alpha: 1
						}), new a.TweenLite(this._graphicsContainer.scale, this._animationDuration, {
							x: .95,
							y: .95
						})]), t
					}
				}
				e.NineSliceButton = l
			},
			2501: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SharpText = void 0;
				class i extends PIXI.Text {
					constructor(t = "", e, i) {
						if (super(t, e, i), "string" == typeof this.style.fontSize) {
							if (this.style.fontSize.indexOf("em") > -1) throw new Error("SharpText.constructor(), I am lazy so I don't want to parse em, please use number or px.");
							this.style.fontSize = parseInt(this.style.fontSize)
						}
						this._originalSize = this.style.fontSize
					}
					setScale(t) {
						this.style.fontSize = Math.ceil(this._originalSize * t)
					}
				}
				e.SharpText = i
			},
			22365: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Slider = void 0;
				const n = i(57244);
				class s extends PIXI.Container {
					constructor(t, e, i, n, s) {
						super(), this._sliderWidth = 200, this._sliderHeight = 3, this._isDragging = !1, this._noOfDecimals = 2, this._sliderTextStyle = {
							fontFamily: "Arial",
							fontSize: 20,
							fill: "#FFFFFF"
						}, this._text = t, this._minValue = e, this._maxValue = i, this._initValue = n, this._changeCallback = s, this._sliderNumber = this._initValue, this.init()
					}
					init() {
						this.createSliderBackground(), this.createSliderButton(), this.makeButtonDraggable()
					}
					scaleTextToComponentWidth() {
						let t = "?";
						for (let e = 0; e < this._noOfDecimals; e++) t += "?";
						for (; new PIXI.Text(this._text + " " + this._maxValue.toString() + t, this._sliderTextStyle).width > this.parent.parent.width;) {
							if (!(0, n.isNumber)(this._sliderTextStyle.fontSize)) throw new Error("Slider.scaleTextToComponentWidth():Please use number for fontSize!");
							this._sliderTextStyle.fontSize--
						}
						this.createText()
					}
					createText() {
						this._componentText = new PIXI.Text(this._text + " " + this._sliderNumber.toString(), this._sliderTextStyle), this._componentText.x = s.TEXT_POSITION.x, this._componentText.y = s.TEXT_POSITION.y, this.addChild(this._componentText)
					}
					getSliderValues() {
						return {
							name: this._text,
							value: this._sliderNumber
						}
					}
					updateText() {
						let t = this._sliderButton.position.x / this._sliderWidth,
							e = this._minValue + (this._maxValue - this._minValue) * t;
						this._sliderNumber = n.MathHelper.roundToDecimals(e, this._noOfDecimals), this._componentText.text = this._text + " " + this._sliderNumber.toString(), this._changeCallback(this._text, this._sliderNumber)
					}
					createSliderBackground() {
						let t = new PIXI.Graphics;
						t.beginFill(15790320, 1), t.drawRect(0, 0, this._sliderWidth, this._sliderHeight), t.endFill(), this.addChild(t)
					}
					createSliderButton() {
						this._sliderButton = new PIXI.Graphics, this._sliderButton.lineStyle(1, 10526975), this._sliderButton.beginFill(15794175, 1), this._sliderButton.drawCircle(0, 0, 9), this._sliderButton.endFill(), this._sliderButton.position.y = 1;
						let t = this._maxValue - this._minValue,
							e = (this._initValue - this._minValue) / t;
						this._sliderButton.position.x = this._sliderWidth * e, this.addChild(this._sliderButton), this._sliderButton.interactive = !0
					}
					makeButtonDraggable() {
						let t = t => this.onDragStart(t),
							e = () => this.onDragEnd(),
							i = () => this.onDragMove();
						this._sliderButton.on("mousedown", t), this._sliderButton.on("touchstart", t), this._sliderButton.on("mouseup", e), this._sliderButton.on("mouseupoutside", e), this._sliderButton.on("touchend", e), this._sliderButton.on("touchendoutside", e), this._sliderButton.on("mousemove", i), this._sliderButton.on("touchmove", i)
					}
					onDragStart(t) {
						this._dragData = t.data, this._isDragging = !0
					}
					onDragEnd() {
						this._isDragging = !1, this._dragData = null
					}
					onDragMove() {
						if (1 == this._isDragging) {
							let t = this._dragData.getLocalPosition(this._sliderButton.parent);
							t.x < 0 ? t.x = 0 : t.x > this._sliderWidth && (t.x = this._sliderWidth), this._sliderButton.position.x = t.x, this.updateText()
						}
					}
				}
				s.TEXT_POSITION = new PIXI.Point(-2, -30), e.Slider = s
			},
			13663: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.TextButton = void 0;
				const n = i(56682),
					s = i(11112);
				class o extends s.Button {
					get buttonText() {
						return this._buttonText
					}
					constructor(t, e, i, n) {
						super(t, e), this._buttonTextString = i, this._textStyle = null != n ? n : this.getDefaultTextStyle(), this.createText()
					}
					createText() {
						this._buttonText = new PIXI.Text(this._buttonTextString, this._textStyle), n.Helper.shrinkTextWidth(this._buttonTextString, this._buttonText, this.width / this.scale.x), this._buttonText.style.align = "center", this._buttonText.anchor.set(.5, .5), this.addChild(this._buttonText)
					}
					getDefaultTextStyle() {
						return {
							fontFamily: "Arial",
							fontSize: 11,
							fill: "#000000",
							wordWrap: !1
						}
					}
					updateText(t) {
						this._buttonTextString = t, this._buttonText.text = t, this._buttonText.style.fontSize = this._textStyle.fontSize, n.Helper.shrinkTextWidth(this._buttonTextString, this._buttonText, this.width)
					}
				}
				e.TextButton = o
			},
			74922: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BasePlateMesh = void 0;
				const n = i(85206);
				class s extends PIXI.NineSlicePlane {
					get shape() {
						return this._shape
					}
					constructor(t) {
						super(PIXI.Texture.EMPTY), this._config = t
					}
					updateTexture() {
						this._shape = new PIXI.RoundedRectangle(0, 0, 128 - 2 * this._scaleRelativeTexturePadding, 128 - 2 * this._scaleRelativeTexturePadding, this._config.cornerRadius);
						const t = new PIXI.Graphics;
						t.lineStyle(this._scaleRelativeLineThickness, this._config.lineColor, this._config.lineAlpha), t.beginFill(this._config.backgroundColor, this._config.backgroundAlpha), t.drawShape(this._shape), t.endFill(), t.position.set(this._scaleRelativeTexturePadding, this._scaleRelativeTexturePadding);
						const e = 2 * this._scaleRelativeTexturePadding;
						this.texture = this.generateCanvasTexture(t), this.topHeight = this._config.cornerRadius + e, this.rightWidth = this._config.cornerRadius + e, this.bottomHeight = this._config.cornerRadius + e, this.leftWidth = this._config.cornerRadius + e
					}
					generateCanvasTexture(t) {
						let e = PIXI.RenderTexture.create({
							width: 128,
							height: 128,
							scaleMode: PIXI.SCALE_MODES.LINEAR
						});
						return n.StageManager.renderer.render(t, e, !1), e
					}
					update(t) {
						this._scaleRelativeLineThickness = Math.max(this._config.lineThickness, this._config.lineThickness / t), this._scaleRelativeTexturePadding = Math.ceil(this._scaleRelativeLineThickness), this._oldScaleRelativePadding != this._scaleRelativeTexturePadding && (this.updateTexture(), this._oldScaleRelativePadding = this._scaleRelativeTexturePadding)
					}
				}
				e.BasePlateMesh = s
			},
			11084: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ErrorEvent = void 0;
				const n = i(44679);
				class s extends n.GameEvent {
					get errorMessage() {
						return this._errorMessage
					}
					get code() {
						return this._code
					}
					constructor(t, e, i = 0) {
						super(t, e, i), this._errorMessage = e, this._code = i
					}
				}
				s.WEB_GL_CONTEXT_LOST = -1005, s.FONT_LOAD_ERROR = 0, s.ASSET_LOAD_ERROR = 0, s.ERROR = "errorEvent_error", e.ErrorEvent = s
			},
			64572: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.EventDispatcher = void 0;
				const n = i(70713);
				e.EventDispatcher = class {
					constructor() {
						this._listeners = {}, this._lastListeners = {}, this._firstListeners = {}, n.DevConsole.addCommand("printEventListeners", (() => {
							console.log(this._firstListeners), console.log(this._listeners), console.log(this._lastListeners)
						}))
					}
					hasEventHandler(t, e) {
						return !!this._listeners[e] && this._listeners[e].some(((e, i, n) => e.source === t))
					}
					addEventListener(t, e, i, n) {
						this.hasEventHandler(t, e) || (this._listeners[e] = this._listeners[e] || [], this._listeners[e].push({
							source: t,
							type: e,
							callback: i,
							params: n
						}))
					}
					addLastEventListener(t, e, i, n) {
						if (this._lastListeners[e]) throw new Error("Error: EventDispatcher.addLastEventListener(): Can only add one LastEventHandler on type " + e);
						this._lastListeners[e] = {
							source: t,
							type: e,
							callback: i,
							params: n
						}
					}
					removeLastEventListener(t, e) {
						return !!this._lastListeners[e] && this._lastListeners[e].source === t && (delete this._lastListeners[e], !0)
					}
					addFirstEventListener(t, e, i, n) {
						if (this._firstListeners[e]) throw new Error("Error: EventDispatcher.addFirstEventListener(): Can only add one FirstEventHandler on type " + e);
						this._firstListeners[e] = {
							source: t,
							type: e,
							callback: i,
							params: n
						}
					}
					removeFirstEventListener(t, e) {
						return !!this._firstListeners[e] && this._firstListeners[e].source === t && (delete this._firstListeners[e], !0)
					}
					removeEventListener(t, e) {
						if (this._listeners[e]) {
							let i = this._listeners[e];
							for (let n = i.length - 1; n >= 0; n--)
								if (i[n].source === t) return i.splice(n, 1), 0 === i.length && delete this._listeners[e], !0
						}
						return !1
					}
					dispatchEvent(t) {
						let e = this._firstListeners[t.type];
						if (e && e.callback.call(this, t, e.params), this._listeners[t.type])
							for (let e = this._listeners[t.type].length - 1; e >= 0; e--) {
								const i = this._listeners[t.type][e];
								i.callback.call(this, t, i.params)
							}
						let i = this._lastListeners[t.type];
						i && i.callback.call(this, t, i.params)
					}
				}
			},
			52409: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.EventHandler = void 0;
				const n = i(64572);
				class s {
					static get enabled() {
						return this._enabled
					}
					static set enabled(t) {
						this._enabled = t
					}
					constructor() {
						if (s._instance) throw new Error("Error: EventHandler.constructor() - Instantiation failed: Use EventHandler.instance instead of new.")
					}
					static dispatchEvent(t) {
						s._enabled && this._eventDispatcher.dispatchEvent(t)
					}
					static addEventListener(t, e, i, ...n) {
						this._eventDispatcher.addEventListener(t, e, i, n)
					}
					static removeEventListener(t, e) {
						return this._eventDispatcher.removeEventListener(t, e)
					}
					static addLastEventListener(t, e, i, ...n) {
						this._eventDispatcher.addLastEventListener(t, e, i, n)
					}
					static removeLastEventListener(t, e) {
						return this._eventDispatcher.removeLastEventListener(t, e)
					}
					static addFirstEventListener(t, e, i, ...n) {
						this._eventDispatcher.addFirstEventListener(t, e, i, n)
					}
					static removeFirstEventListener(t, e) {
						return this._eventDispatcher.removeFirstEventListener(t, e)
					}
				}
				s._instance = new s, s._eventDispatcher = new n.EventDispatcher, s._enabled = !0, e.EventHandler = s
			},
			44679: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GameEvent = void 0, e.GameEvent = class {
					get type() {
						return this._type
					}
					get params() {
						return this._params
					}
					constructor(t, ...e) {
						this._type = t, this._params = e
					}
				}
			},
			75367: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GameConfig = void 0;
				const n = i(55058);
				class s {
					static set gameConfig(t) {
						s._gameConfig = t, s.updateGameConfig()
					}
					static get instance() {
						return s._gameConfig
					}
					static updateGameConfig() {
						if (null != s.instance.STACKED_SYMBOLS)
							for (let t in s.instance.REEL_SETS) s.instance.REEL_SETS[t].forEach(((e, i) => {
								s.instance.REEL_SETS[t][i] = n.StateReelSymbol.filterStackedSymbolsReelSet(s.instance.REEL_SETS[t][i], i)
							}));
						s.instance.updateGameConfig && s.instance.updateGameConfig()
					}
				}
				e.GameConfig = s
			},
			80927: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NolimitConfig = void 0;
				const n = i(46334);
				class s {
					static get instance() {
						return this._instance || (this._instance = new s), this._instance
					}
					static get isDevMode() {
						return s.instance._isDevMode
					}
					static get forceCanvas() {
						return s.instance._forceCanvas
					}
					constructor() {
						if (s._instance) throw new Error("NolimitConfig.constructor() - Instantiation failed: Singleton.");
						try {
							this._isDevMode = "true" === window.sessionStorage.getItem("nolimit.development") || !1
						} catch (t) {
							n.Logger.log("Internal Error: dev state is not valid! Force off!"), this._isDevMode = !1
						}
						try {
							this._forceCanvas = window.nolimit.options.forceCanvas || !1
						} catch (t) {
							n.Logger.log("Internal Error: forceCanvas state is not valid! Force off!"), this._forceCanvas = !1
						}
					}
				}
				e.NolimitConfig = s
			},
			76065: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GameIntroController = void 0;
				const n = i(46334),
					s = i(52409),
					o = i(44679),
					r = i(60055),
					a = i(9220),
					l = i(13006);
				class h {
					constructor(t) {
						this._view = t((() => this.onClickCallback())), this.addEventListeners(), this.progress = 0
					}
					addEventListeners() {
						s.EventHandler.addEventListener(this, r.AssetLoaderEvent.PROGRESS, (t => this.onLoadProgress(t)))
					}
					introAssetsAndTranslationsLoaded(t) {
						this._view.introAssetsAndTranslationsLoaded(t)
					}
					show() {
						this._view.show()
					}
					loaderDone() {
						const t = new l.TimelineLite;
						t.add(new l.TweenLite(this, .3, {
							progress: 100,
							onUpdate: () => this.updateProgress()
						})), t.add((() => this._view.enableButton()))
					}
					onLoadProgress(t) {
						t.name == a.ResourcesGroupName.MAIN && (this.progress = .9 * t.progress, this.updateProgress())
					}
					updateProgress() {
						this._view.updateLoadProgress(this.progress)
					}
					onClickCallback() {
						this._view.close((() => this.onCloseCompleteCallback())), s.EventHandler.dispatchEvent(new o.GameEvent(h.CLOSE))
					}
					onCloseCompleteCallback() {
						n.Logger.logDev("GameIntroController.onCloseCompleteCallback()")
					}
					resourcesReady() {
						s.EventHandler.removeEventListener(this, r.AssetLoaderEvent.PROGRESS)
					}
					gameReady() {
						this.resourcesReady(), this.loaderDone()
					}
				}
				h.CLOSE = "GameIntroController.close", e.GameIntroController = h
			},
			93924: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GameIntroView = e.IntroFeatureLogo = void 0;
				const n = i(77616),
					s = i(11112),
					o = i(87091),
					r = i(88240),
					a = i(28054),
					l = i(66493),
					h = i(40745),
					u = i(13006),
					c = i(52585);
				var d;
				(d = e.IntroFeatureLogo || (e.IntroFeatureLogo = {})).VOLATILITY_EXTREME = "volatilityExtreme", d.VOLATILITY_HIGH = "volatilityHigh", d.VOLATILITY_MEDIUM = "volatilityMed", d.X_NUDGE = "xNudge", d.X_WAYS = "xWays";
				class p extends a.ScreenView {
					constructor(t) {
						super(t), this.DEFAULT_BRAND_NAME = "NOLIMIT CITY", this.DEFAULT_BRAND_TEXT_STYLES = {
							brand: {
								fontFamily: "Open Sans",
								fontSize: 15,
								fill: "#ffffff",
								fontWeight: n.FontWeight.BOLD,
								align: "left"
							},
							production: {
								fontFamily: "Open Sans",
								fontSize: 15,
								fill: "#ffffff",
								fontWeight: n.FontWeight.LIGHT,
								align: "left"
							}
						}, this.DEFAULT_BRAND_TEXT_PADDING = 15, this._introConfig = t
					}
					introAssetsAndTranslationsLoaded(t) {
						this._button || this._brandText || (this._resizeData = t, this.initAnimations && this.initAnimations(), this._hasInit = !0, this.onResize && (this._isResizeDirty = !1, this.onResize(this._resizeData)))
					}
					initAnimations() {
						super.initAnimations(), this._brandText = this.createBrandText(), this.addChild(this._brandText), this._introConfig.featureIcons && (this._featureLogoContainer = this.createFeatureLogos(), this.addChild(this._featureLogoContainer))
					}
					createBackground() {
						return new PIXI.Graphics
					}
					createButton() {
						const t = h.Translation.translate(this._config.buttonText ? this._config.buttonText : "CONTINUE"),
							e = h.Translation.translate("LOADING"),
							i = this.getScaledButtonTextStyle(),
							n = new o.LoaderButton((() => this._onButtonClickCallback()), ` ${t} `, ` ${e} `, i);
						return n.enabled = !1, n
					}
					createBrandText() {
						const t = null != this._introConfig.brand && null != this._introConfig.brand.brandTextStyles ? this._introConfig.brand.brandTextStyles : this.DEFAULT_BRAND_TEXT_STYLES,
							e = new c.DynamicTextsLine(.5, 0, new PIXI.Point(0, 0));
						return e.createText(h.Translation.translate("A "), t.production), e.createText(null != this._introConfig.brand && null != this._introConfig.brand.brandName ? this._introConfig.brand.brandName : this.DEFAULT_BRAND_NAME, t.brand), e.createText(h.Translation.translate(" PRODUCTION"), t.production), e.arrange(), e.alpha = .6, e
					}
					createFeatureLogos() {
						const t = new PIXI.Container,
							e = null != this._introConfig.featureIcons.logoSpace ? this._introConfig.featureIcons.logoSpace : 20;
						let i = 0;
						return this._introConfig.featureIcons.icons.forEach((n => {
							const s = new PIXI.Sprite(r.GameResources.getTextures(n)[0]);
							s.anchor.set(0, .5), s.position.set(i, 0), t.addChild(s), i += s.width + e
						})), t
					}
					startPresentation(t, e) {
						this._button.setState(s.ButtonState.loading), super.startPresentation(t, e)
					}
					onResize(t) {
						this._isShowing ? (super.onResize(t), this.onResizeBrandText(t), this._featureLogoContainer && this.onResizeFeatureLogos(t)) : this._isResizeDirty = !0
					}
					onResizeBackground(t) {
						const e = this._background;
						e.clear(), e.beginFill(0, 1), e.drawRect(0, 0, this._screenWidth, this._screenHeight), e.endFill()
					}
					onResizeBrandText(t) {
						const e = this._orientationScale * this._deviceScale,
							i = (null != this._introConfig.brand && this._introConfig.brand.brandTextPadding ? this._introConfig.brand.brandTextPadding : this.DEFAULT_BRAND_TEXT_PADDING) * e;
						this._brandText.setScale(e), t.orientation === l.Orientation.PORTRAIT ? (this._brandText.setAnchor(.5, 0), this._brandText.position.set(this._screenWidth / 2, i)) : (this._brandText.setAnchor(0, 0), this._brandText.position.set(i, i))
					}
					onResizeFeatureLogos(t) {
						const e = null != this._introConfig.featureIcons.sideBorder ? this._introConfig.featureIcons.sideBorder : 20,
							i = null != this._introConfig.featureIcons.bottomBorder ? this._introConfig.featureIcons.bottomBorder : 20,
							n = .8 * this._orientationScale * this._deviceScale;
						if (this._featureLogoContainer.scale.set(n), t.orientation === l.Orientation.PORTRAIT) {
							const t = 1.8 * i;
							this._featureLogoContainer.position.set(this._screenWidth / 2 - this._featureLogoContainer.width / 2, this._screenHeight - this._featureLogoContainer.height / 2 - t)
						} else {
							const t = e * n,
								s = i * n;
							this._featureLogoContainer.position.set(0 + t, this._screenHeight - this._featureLogoContainer.height / 2 - s)
						}
					}
					stopPresentation(t) {
						let e = new u.TimelineLite;
						e.add(new u.TweenLite(this, .3, {
							alpha: 0
						})), e.add((() => super.stopPresentation(t)))
					}
					updateLoadProgress(t) {
						1 == this._hasInit && (t = Math.round(t), this._button.updateMask(t / 100))
					}
				}
				e.GameIntroView = p
			},
			83673: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GameMode = void 0;
				class i {}
				i.NORMAL = "NORMAL", i.RESPIN = "RESPIN", i.FREESPIN = "FREESPIN", i.GAMBLE = "GAMBLE", i.FREESPIN_RESPIN = "FREESPIN_RESPIN", i.NORMAL_AVALANCHE = "NORMAL_AVALANCHE", i.FREESPIN_AVALANCHE = "FREESPIN_AVALANCHE", e.GameMode = i
			},
			2706: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GameModeEvent = void 0;
				const n = i(44679);
				class s extends n.GameEvent {
					constructor(t, e, i) {
						super(t, e, i), this.fromMode = e, this.toMode = i
					}
				}
				s.CHANGE_MODE = "gameModeEvent_changeMode", s.GAME_MODE_TRANSITION_STARTED = "GameModeEvent_GAME_MODE_TRASITION_STARTED", s.GAME_MODE_TRANSITION_FINISHED = "GameModeEvent_GAME_MODE_TRASITION_FINISHED", s.GAME_MODE_TRANSITION_PREPARE = "GAME_MODE_TRANSITION_PREPARE", e.GameModeEvent = s
			},
			28147: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GameModuleConfig = void 0;
				const n = i(75367),
					s = i(84433),
					o = i(15662);
				class r {
					static set instance(t) {
						if (r._moduleConfig) throw new Error("GameModuleConfig.instance() - Instantiation failed: Singleton.");
						r._moduleConfig = t, n.GameConfig.gameConfig = t.GAME_CONFIG, o.SoundConfig.soundConfig = t.SOUND_CONFIG, s.AssetsConfig.addToAssetsConfig(t.RESOURCES_CONFIG)
					}
					static get instance() {
						return r._moduleConfig
					}
				}
				e.GameModuleConfig = r
			},
			34365: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.JurisdictionEvent = void 0;
				const n = i(44679);
				class s extends n.GameEvent {}
				s.MINIMUM_STOP_TIME = "MINIMUM_STOP_TIME", e.JurisdictionEvent = s
			},
			59854: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ParticlesManager = void 0, i(7615);
				const n = i(13006);
				class s {
					constructor() {
						if (s._instance) throw new Error("Error: ParticlesManager.constructor() - Instantiation failed: Singleton.");
						s._instance = this, s._emitters = [], this.createMainLoop()
					}
					createMainLoop() {
						const t = PIXI.Ticker.shared;
						t.autoStart = !1, t.stop(), n.TweenLite.ticker.addEventListener("tick", this.update, this)
					}
					update() {
						if (0 === s._emitters.length) return;
						let t = Date.now();
						s._emitters.forEach((e => {
							e.update(.001 * (t - s._elapsed))
						})), s._elapsed = t
					}
					static addEmitter(t, e = !0) {
						s._instance || new s, s._emitters.push(t), t.emit = e, s._elapsed = Date.now(), s._instance.update()
					}
					static removeEmitter(t, e = !1) {
						if (!s._instance) return !1;
						const i = s._emitters.indexOf(t);
						return -1 !== i && (s._emitters.splice(i, 1), t.emit = !1, t.destroy(), e && s._emitters.length, s._elapsed = Date.now(), s._instance.update(), !0)
					}
				}
				e.ParticlesManager = s
			},
			10403: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PickAndClickController = void 0;
				const n = i(46334),
					s = i(59848),
					o = i(46289),
					r = i(53108),
					a = i(52409),
					l = i(44679),
					h = i(15904),
					u = i(82210),
					c = i(330),
					d = i(52475),
					p = i(32696),
					_ = i(57284),
					m = i(23110);
				class g extends o.BaseController {
					get isTriggered() {
						return this._isTriggered
					}
					get isRestoreSelectedTriggered() {
						return this._isRestoreSelectedTriggered
					}
					constructor(t, e, i) {
						super(i, t), this._autoClick = !1, this._isTriggered = !1, this._isRestoreSelectedTriggered = !1, this._isWaiting = !1, this._replayPlayerSelectionIndex = -1, this._autoClick = null != e.autoClickTime && e.autoClickTime > 0, this._autoClick && (this._autoClickTime = e.autoClickTime), this._view = e.viewCreator(((t, e) => this.onButtonClick(t, e)), this._autoClick), this._showWinPresentations = e.showWinPresentations, this.addEventListeners()
					}
					addEventListeners() {
						a.EventHandler.addEventListener(this, p.SpinEvent.BEFORE_START, (t => this.onBeforeSpinStart())), a.EventHandler.addEventListener(this, c.ServerEvent.GAME_DATA_PARSED, (t => this.onGameDataParsed(t.params[0]))), a.EventHandler.addEventListener(this, c.ServerEvent.INIT_DATA_PARSED, (t => this.onGameDataParsed(t.params[0]))), this.addFeatureEventHandlers && this.addFeatureEventHandlers()
					}
					onBeforeSpinStart() {
						this.reset()
					}
					reset() {
						this._serverData = null, this._buttonConfigs = null, this._isTriggered = !1, this._isWaiting = !1, this._replayPlayerSelectionIndex = -1, this.resetFeatureGameData && this.resetFeatureGameData()
					}
					onGameDataParsed(t) {
						if (this._serverData = t, this._isWaiting) this._isWaiting = !1, this.finish();
						else if (this._isRestoreSelectedTriggered = t instanceof u.ParsedInitData && t.isRestoreState && this.calculateIsRestoreTriggered(t), this._isTriggered = this.calculateIsTriggered(t), this._isTriggered || this._isRestoreSelectedTriggered) {
							if (this._buttonConfigs = this.parseButtonConfigs(t), d.GameSetting.replayMode) {
								if (null == t.replayNextPlayerInteraction) throw new Error("PickAndClickController.onGameDataParsed() nextPlayerInteraction is missing from the server response when replay!");
								if (this._replayPlayerSelectionIndex = t.replayNextPlayerInteraction.selectedIndex, this._replayPlayerSelectionIndex < 0) throw new Error("PickAndClickController.onGameDataParsed() nextPlayerInteraction.selectedIndex is not a valid number!")
							}
							this.parseFeatureGameData && this.parseFeatureGameData(t)
						}
					}
					start(t) {
						n.Logger.logDev(`Starting PickAndClick ${this.moduleName}`), a.EventHandler.dispatchEvent(new l.GameEvent(h.ScreenEvent.PICK_AND_CLICK_START)), this.show(t)
					}
					show(t) {
						this._view.show(this._buttonConfigs, this._serverData, t ? () => this.finish() : () => this.onShowComplete()), this.hideKeypad(), a.EventHandler.dispatchEvent(new l.GameEvent(r.BetLineEvent.SET_ENABLED, !1)), a.EventHandler.dispatchEvent(new l.GameEvent(r.BetLineEvent.HIDE_ALL_BET_LINES)), a.EventHandler.dispatchEvent(new l.GameEvent(_.StageEvent.WANT_RESIZE)), this.doTransitions && this.doTransitions()
					}
					onShowComplete() {
						this._view.enableButtons(!0), d.GameSetting.replayMode ? this.playReplay() : this._autoClick && this._view.startTimer(this._autoClickTime)
					}
					playReplay() {
						this._view.clickButton(this._replayPlayerSelectionIndex)
					}
					onButtonClick(t, e = !1) {
						this._isWaiting || (this._isWaiting = !0, this._view.enableButtons(!1), this._view.stopTimer(), this._view.wait(), n.Logger.logDev(`Selected index - ${t}`), a.EventHandler.dispatchEvent(new l.GameEvent(s.BalanceEvent.PICK_AND_CLICK, t)))
					}
					finish() {
						this.close()
					}
					close() {
						this._view.close(this._serverData, (() => this.onCloseComplete()))
					}
					onCloseComplete() {
						n.Logger.logDev(`Close PickAndClick ${this.moduleName}`), this.reset(), this.showKeypad(), a.EventHandler.dispatchEvent(new l.GameEvent(_.StageEvent.WANT_RESIZE)), a.EventHandler.dispatchEvent(new l.GameEvent(r.BetLineEvent.SET_ENABLED, !0)), a.EventHandler.dispatchEvent(new l.GameEvent(h.ScreenEvent.PICK_AND_CLICK_CLOSED, this._showWinPresentations))
					}
					hideKeypad() {
						m.SlotGame.keypad.hide()
					}
					showKeypad() {
						m.SlotGame.keypad.show()
					}
				}
				e.PickAndClickController = g
			},
			89768: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PickAndClickManager = void 0;
				const n = i(28147);
				e.PickAndClickManager = class {
					constructor() {
						this._screens = [];
						const t = n.GameModuleConfig.instance.PICK_AND_CLICKS;
						if (t)
							for (let e = 0; e < t.length; e++) this._screens.push(t[e]())
					}
					tryPlayPickAndClick() {
						for (let t = 0; t < this._screens.length; t++)
							if (this._screens[t].isTriggered) return this._screens[t].start(!1), !0;
						return !1
					}
					isNextPickAndClick() {
						for (let t = 0; t < this._screens.length; t++)
							if (this._screens[t].isTriggered) return !0;
						return !1
					}
					tryRestoreSelectedPickAndClick() {
						for (let t = 0; t < this._screens.length; t++)
							if (this._screens[t].isRestoreSelectedTriggered) return this._screens[t].start(!0), !0;
						return !1
					}
				}
			},
			5398: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PickAndClickView = void 0;
				const n = i(73044),
					s = i(33704),
					o = i(9220),
					r = i(66493),
					a = i(85206),
					l = i(40745),
					h = i(56665);
				class u extends n.BaseView {
					constructor(t, e = !1) {
						super(t.resourceGroup ? t.resourceGroup : o.ResourcesGroupName.MAIN), this.DEFAULT_MOBILE_SCALE = 1.6, this.DEFAULT_PORTRAIT_SCALE = 1.7, this._isShowing = !1, this._autoClicked = !1, this._autoClick = !1, this._config = t, this._onButtonClickCallback = t.onButtonClickCallback, this._autoClick = e, this._layer = a.StageManager.getLayer(t.layer)
					}
					initAnimations() {
						this._deviceScale = h.UserAgent.isMobile ? this._config.mobileScale ? this._config.mobileScale : this.DEFAULT_MOBILE_SCALE : 1, this.createBackground && (this._background = this.createBackground(), this.addChild(this._background)), this.createGameGraphics && this.addChild(this.createGameGraphics()), this._autoClick && (this._autoClickTimer = this.createAutoClickTimer(), this.addChild(this._autoClickTimer))
					}
					createAutoClickTimer() {
						const t = l.Translation.translate("Auto select in ${sec} second").split("${sec}"),
							e = l.Translation.translate("Auto select in ${sec} seconds").split("${sec}");
						return new s.CountDownTimer(this._config.autoClickText ? this._config.autoClickText : {
							prefixTextSingular: t[0],
							prefixTextPlural: e[0],
							postfixSecondTextSingular: t[1],
							postfixSecondsTextPlural: e[1]
						})
					}
					onResize(t) {
						this._isShowing ? (this._screenWidth = t.width / this._layer.scale.x, this._screenHeight = t.height / this._layer.scale.y, this._orientationScale = t.orientation === r.Orientation.PORTRAIT ? this._config.portraitScale ? this._config.portraitScale : this.DEFAULT_PORTRAIT_SCALE : 1, this.createBackground && this.onResizeBackground && this.onResizeBackground(t), this.onResizeButtons(t), this._autoClick && this.onResizeAutoClickTimer(t), this.createGameGraphics && this.onResizeGameGraphics && this.onResizeGameGraphics(t), this.x = -this._layer.x / this._layer.scale.x, this.y = -this._layer.y / this._layer.scale.y, this._isResizeDirty = !1) : this._isResizeDirty = !0
					}
					onResizeAutoClickTimer(t) {
						const e = this._orientationScale * this._deviceScale;
						this._autoClickTimer.setScale(e), this.setAutoClickTimerPosition(t)
					}
					setAutoClickTimerPosition(t) {
						this._autoClickTimer.position.set(this._screenWidth / 2, .9 * this._screenHeight)
					}
					show(t, e, i) {
						this._isShowing = !0, null != this._buttons && 0 !== this._buttons.length && 1 != this._config.recreateButtons || (this._buttons = this.createButtons(t), this._isResizeDirty = !0), this._autoClick && (this._autoClickTimer.visible = !1), this._isResizeDirty && this.onResize(this._resizeData), this._layer.addChild(this), this.startPresentation(e, i)
					}
					createButtons(t) {
						const e = [];
						return t.forEach(((t, i) => {
							const n = this.createButton(i, t, this._onButtonClickCallback);
							n.enabled = !1, e.push(n)
						})), e
					}
					startPresentation(t, e) {
						e && e()
					}
					close(t, e) {
						this._isShowing && this.stopPresentation(t, e)
					}
					stopPresentation(t, e) {
						if (this._layer.removeChild(this), this._config.recreateButtons)
							for (; this._buttons.length > 0;) this.removeChild(this._buttons.pop());
						this._isShowing = !1, this._autoClicked = !1, e && e()
					}
					enableButtons(t) {
						this._buttons.forEach((e => {
							e.enabled = t
						}))
					}
					startTimer(t) {
						this._autoClick && (this._autoClickTimer.visible = !0, this._autoClickTimer.start(t, (() => this.autoClickButton())))
					}
					autoClickButton() {
						const t = Math.floor(Math.random() * this._buttons.length);
						this.clickButton(t, !0)
					}
					clickButton(t, e = !1) {
						if (t < 0) throw new Error("PickAndClickView.clickButton() button index is -1!");
						this._autoClicked = e, this._buttons[t].click()
					}
					stopTimer() {
						this._autoClick && (this._autoClickTimer.abort(), this._autoClickTimer.visible = !1)
					}
				}
				e.PickAndClickView = u
			},
			91812: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ReelEvent = void 0;
				class i {}
				i.REEL_SPIN_STARTED = "reelEvent_reelSpinStarted", i.ALL_REELS_SPIN_STARTED = "reelEvent_allReelSpinStarted", i.ALL_REELS_STOP_SPIN = "reelEvent_allReelsStopSpin", i.REEL_STOP_SPIN_STARTED = "reelEvent_reelStopSpinStarted", i.REEL_STOP_SPIN_ANIMATION_COMPLETE = "reelEvent_reelStopSpinAnimationComplete", i.REEL_STOP_PRESENTATIONS_COMPLETE = "reelEvent_reelStopPresentationsComplete", i.REEL_STOP_SPIN_COMPLETE = "reelEvent_reelStopSpinComplete", i.ALL_REELS_SPIN_ANIMATION_STOPPED = "reelEvent_allReelsSpinAnimationStopped", i.ALL_REELS_SPIN_STOPPED = "reelEvent_allReelsSpinStopped", i.REEL_ADD_STOP_DELAY = "reelEvent_reelAddStopDelay", i.REEL_REFRESH_STOP_DELAY = "reelEvent_reelRefreshStopDelay", e.ReelEvent = i
			},
			86033: (t, e) => {
				"use strict";
				var i;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ReelAnimationState = void 0, (i = e.ReelAnimationState || (e.ReelAnimationState = {})).IDLE = "idle", i.INACTIVE = "inactive", i.START_SPIN = "start_spin", i.SPIN = "spin", i.STOP_SPIN = "stop_spin", i.ALL_OUT = "all_out", i.AVALANCHE_START = "avalanche_start", i.ALL_IN = "all_in", i.AVALANCHE = "avalanche", i.AVALANCHE_NEW = "avalanche_new"
			},
			39386: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ReelController = void 0;
				const n = i(46334),
					s = i(13006),
					o = i(46289),
					r = i(52409),
					a = i(44679),
					l = i(75367),
					h = i(28147),
					u = i(55058),
					c = i(82903),
					d = i(91305),
					p = i(9220),
					_ = i(330),
					m = i(34785),
					g = i(91812),
					f = i(86033),
					S = i(49707),
					y = i(54504),
					v = i(57244);
				class T extends o.BaseController {
					get isNearWin() {
						return this._isNearWin
					}
					get reelId() {
						return this._reelId
					}
					get view() {
						return this._reelView
					}
					get currentState() {
						return this._currentState
					}
					get allSymbols() {
						return this._reelPartAnimator.symbolsToAnimate
					}
					get symStep() {
						try {
							return this._reelPartAnimator.symStep
						} catch (t) {
							return
						}
					}
					constructor(t) {
						super(!T._configInitialized, `Reel${t}`), this._addedStopDelay = 0, this._initDataParsed = !1, this._resourcesLoaded = !1, this._reelInitialized = !1, this._isNearWin = !1, this._reelId = t, this.initConfig(), this.initValues(), this._reelView = this.createReelView(), this._reelPartAnimator = this.createReelPartAnimator(), this._reelPartCreator = this.createReelPartCreator(), this.addEventListeners()
					}
					initConfig() {
						if (T._configInitialized) return;
						const t = l.GameConfig.instance.REEL_START_DELAY ? l.GameConfig.instance.REEL_START_DELAY : 0;
						if ((0, v.isNumber)(t)) this.addTweakModuleSlider({
							text: "Reel Start Delay",
							minValue: 0,
							maxValue: 2,
							startValue: t,
							onValueChangeCallback: (t, e) => T.onReelStartDelayChanged(e)
						}), T._reelStartDelays = m.ArrayHelper.initArrayWithValues(l.GameConfig.instance.REELS_NUM, (() => t));
						else if (T._reelStartDelays = t, T._reelStartDelays.length != l.GameConfig.instance.REELS_NUM) throw new Error("ReelController.initConfig(): Invalid config REEL_START_DELAY, the length doesn't match the amount of reels!");
						const e = l.GameConfig.instance.REEL_FAST_SPIN_START_DELAY ? l.GameConfig.instance.REEL_FAST_SPIN_START_DELAY : 0;
						if ((0, v.isNumber)(e)) this.addTweakModuleSlider({
							text: "Reel Fast Start Delay",
							minValue: 0,
							maxValue: 2,
							startValue: e,
							onValueChangeCallback: (t, e) => T.onReelFastStartDelayChanged(e)
						}), T._reelFastStartDelays = m.ArrayHelper.initArrayWithValues(l.GameConfig.instance.REELS_NUM, (() => e));
						else if (T._reelFastStartDelays = e, T._reelFastStartDelays.length != l.GameConfig.instance.REELS_NUM) throw new Error("ReelController.initConfig(): Invalid config REEL_FAST_SPIN_START_DELAY, the length doesn't match the amount of reels!");
						const i = l.GameConfig.instance.REEL_STOP_DELAY;
						if ((0, v.isNumber)(i)) this.addTweakModuleSlider({
							text: "Reel Stop Delay",
							minValue: .1,
							maxValue: 2,
							startValue: i,
							onValueChangeCallback: (t, e) => T.onReelStopDelayChanged(e)
						}), T._reelStopDelays = m.ArrayHelper.initArrayWithValues(l.GameConfig.instance.REELS_NUM, (() => i));
						else if (T._reelStopDelays = i, T._reelStopDelays.length != l.GameConfig.instance.REELS_NUM) throw new Error("ReelController.initConfig(): Invalid config REEL_STOP_DELAY, the length doesn't match the amount of reels!");
						const n = l.GameConfig.instance.REEL_QUICK_STOP_DELAY;
						if ((0, v.isNumber)(n)) this.addTweakModuleSlider({
							text: "Reel Quick Stop Delay",
							minValue: .1,
							maxValue: 2,
							startValue: n,
							onValueChangeCallback: (t, e) => T.onReelQuickStopDelayChanged(e)
						}), T._reelQuickStopDelays = m.ArrayHelper.initArrayWithValues(l.GameConfig.instance.REELS_NUM, (() => n));
						else if (T._reelQuickStopDelays = n, T._reelQuickStopDelays.length != l.GameConfig.instance.REELS_NUM) throw new Error("ReelController.initConfig(): Invalid config REEL_QUICK_STOP_DELAY, the length doesn't match the amount of reels!");
						const s = l.GameConfig.instance.REEL_NEAR_WIN_STOP_DELAY;
						if ((0, v.isNumber)(s)) this.addTweakModuleSlider({
							text: "Reel Near Win Stop Delay",
							minValue: .1,
							maxValue: 5,
							startValue: s,
							onValueChangeCallback: (t, e) => T.onReelNearWinStopDelayChanged(e)
						}), T._reelNearWinStopDelays = m.ArrayHelper.initArrayWithValues(l.GameConfig.instance.REELS_NUM, (() => s));
						else if (T._reelNearWinStopDelays = s, T._reelNearWinStopDelays.length != l.GameConfig.instance.REELS_NUM) throw new Error("ReelController.initConfig(): Invalid config REEL_NEAR_WIN_STOP_DELAY, the length doesn't match the amount of reels!");
						T._configInitialized = !0
					}
					static onReelStartDelayChanged(t) {
						this._reelStartDelays = m.ArrayHelper.initArrayWithValues(l.GameConfig.instance.REELS_NUM, (() => t))
					}
					static onReelFastStartDelayChanged(t) {
						this._reelFastStartDelays = m.ArrayHelper.initArrayWithValues(l.GameConfig.instance.REELS_NUM, (() => t))
					}
					static onReelStopDelayChanged(t) {
						this._reelStopDelays = m.ArrayHelper.initArrayWithValues(l.GameConfig.instance.REELS_NUM, (() => t))
					}
					static onReelQuickStopDelayChanged(t) {
						this._reelQuickStopDelays = m.ArrayHelper.initArrayWithValues(l.GameConfig.instance.REELS_NUM, (() => t))
					}
					static onReelNearWinStopDelayChanged(t) {
						this._reelNearWinStopDelays = m.ArrayHelper.initArrayWithValues(l.GameConfig.instance.REELS_NUM, (() => t))
					}
					initValues() {
						this._currentState = f.ReelAnimationState.IDLE, this._symNumTotal = m.ArrayHelper.arraySum(l.GameConfig.instance.SYMBOLS_NUM_IN_REEL), this._isSpinning = !1, this._isSpinBlurred = !1, this._reelStopPresentationCompleted = !1
					}
					createReelView() {
						if (null == l.GameConfig.instance.REEL_DISPLAY_POSITIONS || null == l.GameConfig.instance.REEL_DISPLAY_POSITIONS[this._reelId]) throw new Error(`Error: ReelController.init(): config REEL_DISPLAY_POSITIONS is missing or REEL_DISPLAY_POSITIONS[${this._reelId}] is missing!`);
						return h.GameModuleConfig.instance.REEL_VIEW ? h.GameModuleConfig.instance.REEL_VIEW(this._reelId) : new PIXI.Sprite
					}
					createReelPartCreator() {
						return h.GameModuleConfig.instance.REEL_PART_CREATOR ? h.GameModuleConfig.instance.REEL_PART_CREATOR() : new S.ReelPartCreator
					}
					addEventListeners() {
						r.EventHandler.addEventListener(this, d.LoaderEvent.RESOURCES_LOADED, (t => this.onInitResourcesLoaded(t))), r.EventHandler.addEventListener(this, _.ServerEvent.INIT_DATA_PARSED, (t => this.onInitDataParsed(t.params[0]))), r.EventHandler.addEventListener(this, _.ServerEvent.GAME_DATA_PARSED, (t => this.onGameDataParsed(t.params[0]))), r.EventHandler.addEventListener(this, g.ReelEvent.REEL_STOP_PRESENTATIONS_COMPLETE, (t => this.onReelStopPresentationsComplete(t.params[0]))), r.EventHandler.addEventListener(this, g.ReelEvent.REEL_ADD_STOP_DELAY, (t => this.addStopDelay(t.params[0]))), r.EventHandler.addEventListener(this, g.ReelEvent.REEL_REFRESH_STOP_DELAY, (t => this.refreshStopDelay(t.params[0])))
					}
					onInitResourcesLoaded(t) {
						t.key == p.ResourcesGroupName.MAIN && (this._resourcesLoaded = !0, this.initReelStrip())
					}
					onInitDataParsed(t) {
						this.parseInitData(t), this.initAnimator(), this.initReelStrip()
					}
					parseInitData(t) {
						this._gameMode = t.mode, this._nextGameMode = t.nextMode, this._stopReelSet = t.reels[this._reelId].concat(), n.Logger.logDev(`init reel ${this._reelId} ${this._stopReelSet}`);
						const e = l.GameConfig.instance.SYMBOLS_NUM_IN_REEL[1] + l.GameConfig.instance.SYMBOLS_NUM_IN_REEL[2] + l.GameConfig.instance.SYMBOLS_NUM_IN_REEL[3];
						if (this._stopReelSet.length != e) throw new Error(`Error: ReelController.onInitDataParsed(): reelId = ${this._reelId}. There are ${e} symbols in reel config while ${this._stopReelSet.length} in server data `);
						this._initDataParsed = !0
					}
					onGameDataParsed(t) {
						this._gameMode = t.mode, this._nextGameMode = t.nextMode, this._stopReelSet = t.reels[this._reelId], n.Logger.logDev(`stop reel ${this._reelId} ${this._stopReelSet}`)
					}
					initAnimator() {
						this._reelPartAnimator.symWidth = l.GameConfig.instance.SYMBOL_WIDTH, this._reelPartAnimator.symHeight = l.GameConfig.instance.SYMBOL_HEIGHT, this._reelPartAnimator.symBottomPadding = l.GameConfig.instance.SYMBOL_BOTTOM_PADDING
					}
					initReelStrip() {
						if (!this._resourcesLoaded || !this._initDataParsed) return;
						this._currentReelSet = this.makeUpStopReelSet(l.GameConfig.instance.SYMBOLS_NUM_IN_REEL[4], !0), this._currentReelSetPosition = this._currentReelSet.length;
						const t = [];
						for (let e = 0; e < this._symNumTotal; e++) t.unshift(this.createNextSymbol(0 === e ? null : t[0], !0));
						this._reelPartAnimator.initSymbols(t.map((t => t))), this._reelInitialized = !0
					}
					getRandomSymbolFromReelSet(t) {
						let e;
						do {
							e = m.ArrayHelper.getRandomElementFromArray(t)
						} while (this.isSpecialSymbol(e));
						return e
					}
					isSpecialSymbol(t) {
						return u.StateReelSymbol.parseStackedSymbolName(t, this._reelId).isStacked || t === y.ReelSymbolName.WILD || t === y.ReelSymbolName.SCATTER || t === y.ReelSymbolName.BONUS
					}
					createNextSymbol(t, e) {
						this.moveReelSetPosition();
						const i = this._currentReelSet[this._currentReelSetPosition];
						if (null == i || 0 === i.length) throw new Error("ReelController.createNextSymbol(): symbol name cannot be empty!");
						let n = this.addNewSymbol(i);
						return this.updateStackedSymbols(n, void 0 === t ? this._reelPartAnimator.symbolsToAnimate[0] : t, -1, !0), n
					}
					addNewSymbol(t, e) {
						null == e && (e = this._isSpinBlurred ? l.GameConfig.instance.SYMBOL_STATES.spin : l.GameConfig.instance.SYMBOL_STATES.normal);
						const i = this._reelPartCreator.createNewSymbol(t, this._reelId, e, {
							width: this._reelPartAnimator.symWidth,
							height: this._reelPartAnimator.symHeight,
							bottomPadding: this._reelPartAnimator.symBottomPadding
						});
						return i.x = 0, i.y = -i.symHeight / 2 - l.GameConfig.instance.REEL_AREA_POS_Y - l.GameConfig.instance.REEL_DISPLAY_POSITIONS[this._reelId][1], this._reelView.addChild(i), i
					}
					updateStackedSymbols(t, e, i, n) {
						if (null != l.GameConfig.instance.STACKED_SYMBOLS && t.stackedSymName.isStacked) {
							if (null == e || !e.stackedSymName.isStacked || e.stackedSymName.symName != t.stackedSymName.symName || T.isNewStackedStackedSymbol(t, e, i, n)) return n && (t.stack = new c.SymbolStack(t.stackedSymName.symName, t.stackedSymName.totalNum)), void t.setVisibility(!0);
							if (t.stackedSymName.index - e.stackedSymName.index != i) throw new Error(`ReelController.updateStackedSymbols():Stacked Symbol index error at reel ${this._reelId}! targetSymbol = ${t.symName}, compareSymbol = ${e.symName}`);
							n && (t.stack = e.stack), i > 0 ? e.setVisibility(!1) : t.setVisibility(!1)
						}
					}
					static isNewStackedStackedSymbol(t, e, i, n) {
						return e.stackedSymName.index + i !== t.stackedSymName.index && m.ArrayHelper.reviseIndexInLoopRange(e.stackedSymName.totalNum, e.stackedSymName.index + i) === t.stackedSymName.index
					}
					startSpin(t, e) {
						return this.setStartSpinData(t), t.active ? (this._stopReelSet = [], this._isSpinning = !0, this._reelStopPresentationCompleted = !1, this.startSpinAnimation(t, e)) : (this._currentState = f.ReelAnimationState.INACTIVE, r.EventHandler.dispatchEvent(new a.GameEvent(g.ReelEvent.REEL_SPIN_STARTED, this._reelId)), e)
					}
					setStartSpinData(t) {
						this._gameMode = this._nextGameMode, this._reelPartAnimator.resetStartSpin(t.fastSpin)
					}
					removeSymbol(t) {
						this._reelView.removeChild(t), this._reelPartCreator.deleteSymbol(t)
					}
					clearStopDelay(t = !1) {
						if (!t && this._addedStopDelay > 0) return this._reelStopDelayTimer = s.TweenLite.to(this, this._addedStopDelay, {
							onComplete: () => this.clearStopDelay()
						}), void(this._addedStopDelay = 0);
						this._reelStopDelayTimer && this._reelStopDelayTimer.isActive() && (this._reelStopDelayTimer.pause(), this._reelStopDelayTimer.kill()), this._reelStopDelayTimer = null, this._addedStopDelay = 0, this.onStopDelayDone()
					}
					onSpinStopStarted() {
						r.EventHandler.dispatchEvent(new a.GameEvent(g.ReelEvent.REEL_STOP_SPIN_STARTED, this._reelId))
					}
					onSpinStopAnimationCompleted() {
						r.EventHandler.dispatchEvent(new a.GameEvent(g.ReelEvent.REEL_STOP_SPIN_ANIMATION_COMPLETE, {
							reelId: this._reelId,
							fastSpin: this._reelPartAnimator.isFastSpin,
							quickStop: this._reelPartAnimator.isQuickStop,
							active: !0
						})), this._isSpinning = !1, this._isNearWin = !1, this.tryCompleteSpin()
					}
					onReelStopPresentationsComplete(t) {
						this._reelId == t && (this._reelStopPresentationCompleted = !0, this.tryCompleteSpin())
					}
					tryCompleteSpin() {
						this._isSpinning || this._reelStopPresentationCompleted && (this._currentState = f.ReelAnimationState.IDLE, this.completeSpin())
					}
					completeSpin() {
						r.EventHandler.dispatchEvent(new a.GameEvent(g.ReelEvent.REEL_STOP_SPIN_COMPLETE, this._reelId))
					}
					addStopDelay(t) {
						t.reelId > this._reelId || (this._addedStopDelay += t.delay)
					}
					refreshStopDelay(t) {
						t.reelId === this.reelId && (null != this._reelStopDelayTimer && this._reelStopDelayTimer.isActive() ? (this._reelStopDelayTimer.pause(), this._reelStopDelayTimer.kill(), this._reelStopDelayTimer = s.TweenLite.to(this, t.delay, {
							onComplete: () => this.clearStopDelay()
						})) : n.Logger.logDev(`ReelController.refreshStopDelay() reelId = ${t.reelId}, the reel stop delay timer is not active!`))
					}
					findSymbol(t, e = !0) {
						const i = this.allSymbols[t];
						if (null == i || !i.stackedSymName.isStacked) return i;
						if (!e) return i;
						for (let t = i.stackedSymName.totalNum - 1; t >= 0; t--) {
							const e = i.stack.symbols[t];
							if (null != e && null != e.parent) return i.stack.symbols[t]
						}
						return i
					}
					moveSymbolToTop(t) {
						const e = this.findSymbol(t);
						return null != e && (this._reelView.addChild(e), !0)
					}
					addChildOnView(t) {
						this._reelView.addChild(t)
					}
					removedChildOnView(t) {
						this._reelView.removeChild(t)
					}
				}
				T._configInitialized = !1, e.ReelController = T
			},
			56978: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ReelPartAnimator = void 0;
				const n = i(57244),
					s = i(46289),
					o = i(75367),
					r = i(34785);
				class a extends s.BaseController {
					get symWidth() {
						var t;
						return null !== (t = this._symWidth) && void 0 !== t ? t : o.GameConfig.instance.SYMBOL_WIDTH
					}
					set symWidth(t) {
						this._symWidth = t
					}
					get symHeight() {
						var t;
						return null !== (t = this._symHeight) && void 0 !== t ? t : o.GameConfig.instance.SYMBOL_HEIGHT
					}
					set symHeight(t) {
						this._symHeight = t
					}
					get symBottomPadding() {
						var t;
						return null !== (t = this._symBottomPadding) && void 0 !== t ? t : o.GameConfig.instance.SYMBOL_BOTTOM_PADDING
					}
					set symBottomPadding(t) {
						this._symBottomPadding = t
					}
					get symStep() {
						return this.symHeight + this.symBottomPadding
					}
					get symbolsToAnimate() {
						return this._symbolsToAnimate
					}
					get startSpeed() {
						return this._startSpinSpeed
					}
					set startSpeed(t) {
						this._startSpinSpeed = t
					}
					get spinSpeed() {
						return this._spinSpeed
					}
					set spinSpeed(t) {
						this._spinSpeed = t
					}
					get stopSpeed() {
						return this._stopSpinSpeed
					}
					set stopSpeed(t) {
						this._stopSpinSpeed = t
					}
					get isFastSpin() {
						return this._isFastSpin
					}
					set isFastSpin(t) {
						this._isFastSpin = t
					}
					get isQuickStop() {
						return this._isQuickStop
					}
					set isQuickStop(t) {
						this._isQuickStop = t
					}
					constructor(t) {
						super(!a._configInitialized, `ReelPartAnimator${t}`), this._reelId = t, this.initConfig()
					}
					initConfig() {
						if (a._configInitialized) return;
						const t = o.GameConfig.instance.REEL_SPIN_START_SPEED;
						if ((0, n.isNumber)(t)) this.addTweakModuleSlider({
							text: "Spin Start Speed",
							minValue: .1,
							maxValue: 2.2,
							startValue: t,
							onValueChangeCallback: (t, e) => a.onSpinStartSpeedChanged(e)
						}), a._spinStartSpeeds = r.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => t));
						else if (a._spinStartSpeeds = t, a._spinStartSpeeds.length != o.GameConfig.instance.REELS_NUM) throw new Error("ReelPartAnimator.initConfig(): Invalid config REEL_SPIN_START_SPEED, the length doesn't match the amount of reels!");
						if (o.GameConfig.instance.REEL_FAST_SPIN_START_SPEED) {
							const t = o.GameConfig.instance.REEL_FAST_SPIN_START_SPEED;
							if ((0, n.isNumber)(t)) this.addTweakModuleSlider({
								text: "Fast Spin Start Speed",
								minValue: .1,
								maxValue: 2.2,
								startValue: t,
								onValueChangeCallback: (t, e) => a.onFastSpinStartSpeedChanged(e)
							}), a._fastSpinStartSpeeds = r.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => t));
							else if (a._fastSpinStartSpeeds = t, a._fastSpinStartSpeeds.length != o.GameConfig.instance.REELS_NUM) throw new Error("ReelPartAnimator.initConfig(): Invalid config REEL_FAST_SPIN_START_SPEED, the length doesn't match the amount of reels!")
						} else a._fastSpinStartSpeeds = a._spinStartSpeeds.concat();
						const e = o.GameConfig.instance.REEL_SPIN_SPIN_SPEED;
						if ((0, n.isNumber)(e)) this.addTweakModuleSlider({
							text: "Spin Spin Speed",
							minValue: .012,
							maxValue: 2,
							startValue: e,
							onValueChangeCallback: (t, e) => a.onSpinSpinSpeedChanged(e)
						}), a._spinSpinSpeeds = r.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => e));
						else if (a._spinSpinSpeeds = e, a._spinSpinSpeeds.length != o.GameConfig.instance.REELS_NUM) throw new Error("ReelPartAnimator.initConfig(): Invalid config REEL_SPIN_SPIN_SPEED, the length doesn't match the amount of reels!");
						const i = o.GameConfig.instance.REEL_NEAR_WIN_SPIN_SPEED;
						if ((0, n.isNumber)(i)) this.addTweakModuleSlider({
							text: "Near Win Spin Speed",
							minValue: .01,
							maxValue: 2,
							startValue: i,
							onValueChangeCallback: (t, e) => a.onNearWinSpinSpeedChanged(e)
						}), a._nearWinSpinSpeeds = r.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => i));
						else if (a._nearWinSpinSpeeds = i, a._nearWinSpinSpeeds.length != o.GameConfig.instance.REELS_NUM) throw new Error("ReelPartAnimator.initConfig(): Invalid config REEL_NEAR_WIN_SPIN_SPEED, the length doesn't match the amount of reels!");
						const s = o.GameConfig.instance.REEL_SPIN_STOP_SPEED;
						if ((0, n.isNumber)(s)) this.addTweakModuleSlider({
							text: "Spin Stop Speed",
							minValue: .1,
							maxValue: 5,
							startValue: s,
							onValueChangeCallback: (t, e) => a.onSpinStopSpeedChanged(e)
						}), a._spinStopSpeeds = r.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => s));
						else if (a._spinStopSpeeds = s, a._spinStopSpeeds.length != o.GameConfig.instance.REELS_NUM) throw new Error("ReelPartAnimator.initConfig(): Invalid config REEL_SPIN_STOP_SPEED, the length doesn't match the amount of reels!");
						const l = o.GameConfig.instance.REEL_SPIN_QUICK_STOP_SPEED;
						if ((0, n.isNumber)(l)) this.addTweakModuleSlider({
							text: "Spin Quick Stop Speed",
							minValue: .1,
							maxValue: 5,
							startValue: l,
							onValueChangeCallback: (t, e) => a.onSpinQuickStopSpeedChanged(e)
						}), a._spinQuickStopSpeeds = r.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => l));
						else if (a._spinQuickStopSpeeds = l, a._spinQuickStopSpeeds.length != o.GameConfig.instance.REELS_NUM) throw new Error("ReelPartAnimator.initConfig(): Invalid config REEL_SPIN_QUICK_STOP_SPEED, the length doesn't match the amount of reels!");
						a._configInitialized = !0
					}
					static onSpinStartSpeedChanged(t) {
						this._spinStartSpeeds = r.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => t))
					}
					static onFastSpinStartSpeedChanged(t) {
						this._fastSpinStartSpeeds = r.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => t))
					}
					static onSpinSpinSpeedChanged(t) {
						this._spinSpinSpeeds = r.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => t))
					}
					static onNearWinSpinSpeedChanged(t) {
						this._nearWinSpinSpeeds = r.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => t))
					}
					static onSpinStopSpeedChanged(t) {
						this._spinStopSpeeds = r.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => t))
					}
					static onSpinQuickStopSpeedChanged(t) {
						this._spinQuickStopSpeeds = r.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => t))
					}
					initSymbols(t) {
						this.setAllSymbols(t), this.initTargetPositions(), this.initSymbolsPosition()
					}
					setAllSymbols(t) {
						this._symbolsToAnimate = t
					}
					resetStartSpin(t) {
						this.isFastSpin = t, this.isQuickStop = !1, this.startSpeed = t ? a._fastSpinStartSpeeds[this._reelId] : a._spinStartSpeeds[this._reelId], this.spinSpeed = a._spinSpinSpeeds[this._reelId], this.stopSpeed = t ? a._spinQuickStopSpeeds[this._reelId] : a._spinStopSpeeds[this._reelId]
					}
				}
				a._configInitialized = !1, e.ReelPartAnimator = a
			},
			49707: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ReelPartCreator = void 0;
				const n = i(55058);
				e.ReelPartCreator = class {
					constructor(t) {
						null != t && (this._newSymbolCreator = t)
					}
					createNewSymbol(t, e, i, s) {
						return this._newSymbolCreator ? this._newSymbolCreator(t, e, i, s) : new n.StateReelSymbol(t, e, i, s)
					}
					deleteSymbol(t) {
						t.onRemove()
					}
				}
			},
			53397: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ReelAreaView = void 0;
				const n = i(73044),
					s = i(75367),
					o = i(85206);
				class r extends n.BaseView {
					constructor(t) {
						super(t), this._reelViews = [], this._layer = o.StageManager.getLayer(s.GameConfig.instance.LAYERS.SYMBOLS.name), this._layer.addChild(this)
					}
					UpdateReelAreaMask() {
						if (!1 === s.GameConfig.instance.REEL_AREA_MASK) return;
						const t = null != s.GameConfig.instance.REEL_AREA_MASK_RECT ? s.GameConfig.instance.REEL_AREA_MASK_RECT : new PIXI.Rectangle(s.GameConfig.instance.REEL_AREA_POS_X, s.GameConfig.instance.REEL_AREA_POS_Y, s.GameConfig.instance.REEL_AREA_WIDTH, s.GameConfig.instance.REEL_AREA_HEIGHT),
							e = new PIXI.Graphics;
						e.beginFill(16777215, 1), e.drawRect(t.x - s.GameConfig.instance.REEL_AREA_POS_X, t.y - s.GameConfig.instance.REEL_AREA_POS_Y, t.width, t.height), e.endFill(), null != this._reelAreaMask && this.removeChild(this._reelAreaMask), this._reelAreaMask = e, this.addChild(this._reelAreaMask), this.mask = this._reelAreaMask
					}
					onResize(t) {
						this.x = s.GameConfig.instance.REEL_AREA_POS_X, this.y = s.GameConfig.instance.REEL_AREA_POS_Y, this._reelViews.forEach(((t, e) => {
							this.updateReelViewPosition(t, e)
						})), this.UpdateReelAreaMask()
					}
					updateReelViewPosition(t, e) {
						const i = s.GameConfig.instance.REEL_DISPLAY_POSITIONS[e];
						t.x = i[0], t.y = i[1]
					}
					addReelView(t) {
						this._reelViews[t.reelId] = t.view, this.updateReelViewPosition(t.view, t.reelId), this.addChild(t.view)
					}
				}
				e.ReelAreaView = r
			},
			23792: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Reels = void 0;
				const n = i(46334),
					s = i(13006),
					o = i(5351),
					r = i(671),
					a = i(7157),
					l = i(52601),
					h = i(46289),
					u = i(52409),
					c = i(44679),
					d = i(75367),
					p = i(28147),
					_ = i(15662),
					m = i(23110),
					g = i(32696),
					f = i(34785),
					S = i(91812),
					y = i(86033),
					v = i(53397);
				class T extends h.BaseController {
					constructor() {
						if (super(!0, "Reels"), T._instance) throw new Error("Error: Reels.constructor() - Instantiation failed: Singleton.");
						this._reelsNum = d.GameConfig.instance.REELS_NUM, this._reelsSpinStates = f.ArrayHelper.initArrayWithValues(this._reelsNum, (() => !1)), this._reelsActualSpinningStates = f.ArrayHelper.initArrayWithValues(this._reelsNum, (() => !1)), this._quickStop = !1, this._fastSpin = !1, this._isSpinSoundPlaying = !1;
						const t = null != _.SoundConfig.instance.REELS_SPINNING_STOP_DELAY ? _.SoundConfig.instance.REELS_SPINNING_STOP_DELAY : 0;
						this.addTweakModuleSlider({
							text: "Spinning Sound Stop Delay",
							minValue: 0,
							maxValue: 1,
							startValue: t,
							onValueChangeCallback: (t, e) => this.onSpinningSoundStopDelayChanged(e)
						}), this._spinningSoundStopDelay = t, T._reelAreaView = p.GameModuleConfig.instance.REEL_AREA_VIEW ? p.GameModuleConfig.instance.REEL_AREA_VIEW() : new v.ReelAreaView, this.addEventListeners()
					}
					onSpinningSoundStopDelayChanged(t) {
						this._spinningSoundStopDelay = t
					}
					static init() {
						this._instance = p.GameModuleConfig.instance.REELS ? p.GameModuleConfig.instance.REELS() : new T;
						for (let t = 0; t < d.GameConfig.instance.REELS_NUM; t++) {
							const e = p.GameModuleConfig.instance.REEL_CONTROLLER ? p.GameModuleConfig.instance.REEL_CONTROLLER(t) : this.createDefaultReelController(t);
							T._reels[e.reelId] = e, T._reelAreaView.addReelView(e)
						}
					}
					static createDefaultReelController(t) {
						switch (d.GameConfig.instance.SPIN_MODE) {
							case 0:
								return new a.SpinReelController(t);
							case 1:
								return new o.AvalancheReelController(t);
							default:
								throw new Error("Reels.createDefaultReelController() Invalid spin type in config")
						}
					}
					addEventListeners() {
						u.EventHandler.addEventListener(this, g.SpinEvent.BEFORE_START, (t => this.onBeforeSpinStart())), u.EventHandler.addEventListener(this, g.SpinEvent.START, (t => this.onSpinStart(t.params[0]))), u.EventHandler.addEventListener(this, S.ReelEvent.REEL_SPIN_STARTED, (t => this.onReelSpinStarted(t.params[0]))), u.EventHandler.addLastEventListener(this, S.ReelEvent.ALL_REELS_STOP_SPIN, (t => this.onStopSpin(t.params[0]))), u.EventHandler.addLastEventListener(this, S.ReelEvent.REEL_STOP_SPIN_ANIMATION_COMPLETE, (t => this.onReelSpinAnimationStopped(t.params[0]))), u.EventHandler.addEventListener(this, S.ReelEvent.REEL_STOP_SPIN_COMPLETE, (t => this.onReelSpinStopped(t.params[0]))), 0 === d.GameConfig.instance.SPIN_MODE && u.EventHandler.addLastEventListener(this, l.SpinReelEvent.REEL_STOP_SPIN_BOUNCE_STARTED, (t => this.onReelBounceStarted(t.params[0])))
					}
					static addReelAvalancheToTimeline(t, e, i = 0, s = !1, o) {
						return 1 != d.GameConfig.instance.SPIN_MODE ? (n.Logger.logDev("Reels.addReelAvalancheToTimeline() only support avalanche game!"), 0) : this._reels[t].addAvalancheToTimeline(e, i, s, o)
					}
					static allReelsAvalanche() {
						if (1 != d.GameConfig.instance.SPIN_MODE) return n.Logger.logDev("Reels.addReelAvalancheToTimeline() only support avalanche game!"), new s.TimelineLite;
						const t = new s.TimelineLite;
						t.add((() => u.EventHandler.dispatchEvent(new c.GameEvent(r.AvalancheReelEvent.ALL_REELS_AVALANCHE_STARTED))));
						let e = 0;
						return T._reels.forEach(((i, n) => {
							e = this.addReelAvalancheToTimeline(n, t, e, n > 0)
						})), t.add((() => u.EventHandler.dispatchEvent(new c.GameEvent(r.AvalancheReelEvent.ALL_REELS_AVALANCHE_COMPLETE)))), t
					}
					onBeforeSpinStart() {
						this._quickStop = !1
					}
					onSpinStart(t) {
						this._fastSpin = t.isFastSpin, this._activeReels = t.activeReels;
						let e = 0;
						for (let t = 0; t < this._reelsNum; t++) e = T._reels[t].startSpin({
							active: this._activeReels[t],
							fastSpin: this._fastSpin
						}, e);
						this.startSpinSounds()
					}
					startSpinSounds() {
						null != _.SoundConfig.instance.REELS_SPINNING_START_ON_SPIN_START && (m.SlotGame.sound.playEffect(_.SoundConfig.instance.REELS_SPINNING_START_ON_SPIN_START), this._isSpinSoundPlaying = !0)
					}
					onReelSpinStarted(t) {
						this._reelsSpinStates[t] = !0, this._reelsActualSpinningStates[t] = !0, -1 === this._reelsSpinStates.indexOf(!1) && (null != _.SoundConfig.instance.REELS_SPINNING && (m.SlotGame.sound.playEffect(_.SoundConfig.instance.REELS_SPINNING), this._isSpinSoundPlaying = !0), u.EventHandler.dispatchEvent(new c.GameEvent(S.ReelEvent.ALL_REELS_SPIN_STARTED)))
					}
					onStopSpin(t) {
						this._quickStop = t.quickStop, this._fastSpin = t.fastSpin;
						const e = this.getSpinStopOffset();
						let i = 0;
						for (let t = 0; t < this._reelsNum; t++) {
							const n = T._reels[t];
							if (n.currentState === y.ReelAnimationState.IDLE) continue;
							const s = {
								quickStop: this._quickStop,
								fastSpin: this._fastSpin,
								active: this._activeReels[t],
								spinStopOffset: e
							};
							i = n.stopSpin(s, i)
						}
					}
					getSpinStopOffset() {
						let t = 0;
						return 0 === d.GameConfig.instance.SPIN_MODE && T._reels.forEach(((e, i) => {
							t = Math.max(t, e.getSpinStopOffset())
						})), t
					}
					onReelBounceStarted(t) {
						this._reelsActualSpinningStates[t.reelId] = !1, this.stopSpinSoundOnLastReel()
					}
					stopSpinSoundOnLastReel() {
						this._isSpinSoundPlaying && (this._reelsActualSpinningStates.includes(!0) || this.stopSpinSounds())
					}
					stopSpinSounds() {
						null != _.SoundConfig.instance.REELS_SPINNING && m.SlotGame.sound.stopEffect(_.SoundConfig.instance.REELS_SPINNING, this._spinningSoundStopDelay), null != _.SoundConfig.instance.REELS_SPINNING_START_ON_SPIN_START && m.SlotGame.sound.stopEffect(_.SoundConfig.instance.REELS_SPINNING_START_ON_SPIN_START, this._spinningSoundStopDelay), this._isSpinSoundPlaying = !1
					}
					onReelSpinAnimationStopped(t) {
						this._reelsActualSpinningStates[t.reelId] = !1, this.stopSpinSoundOnLastReel(), this._reelsActualSpinningStates.includes(!0) || u.EventHandler.dispatchEvent(new c.GameEvent(S.ReelEvent.ALL_REELS_SPIN_ANIMATION_STOPPED))
					}
					onReelSpinStopped(t) {
						this._reelsSpinStates[t] = !1, -1 == this._reelsSpinStates.indexOf(!0) && (n.Logger.logDev("Reels.onReelSpinStopped():All reels stopped!"), u.EventHandler.dispatchEvent(new c.GameEvent(S.ReelEvent.ALL_REELS_SPIN_STOPPED)))
					}
					static getReel(t) {
						return T._reels[t]
					}
					static getSymbol(t, e, i = !0) {
						return T._reels[t].findSymbol(e, i)
					}
					static allSymbols(t) {
						return T._reels[t].allSymbols
					}
					static moveSymbolToTop(t, e) {
						return T._reels[t].moveSymbolToTop(e)
					}
					static addChildOnReel(t, e) {
						return T._reels[t].addChildOnView(e)
					}
					static removedChildOnReel(t, e) {
						return T._reels[t].removedChildOnView(e)
					}
				}
				T._reels = [], e.Reels = T
			},
			3043: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ReelStopPresentationController = void 0;
				const n = i(46289),
					s = i(52409),
					o = i(44679),
					r = i(75367),
					a = i(330);
				class l extends n.BaseController {
					get completeEvent() {
						return `reelStopPresentationEvent_${this.moduleName}Completed`
					}
					constructor(t, e, i, n) {
						if (super(i, e, n), !this.onReelBounce && !this.onReelSpinStopped) throw new Error(`ReelStopPresentation${e}.constructor():must implement at least one of onReelBounce and onReelSpinStopped to run dispatchCompleteEvent()!`);
						if (1 === r.GameConfig.instance.SPIN_MODE && !this.onReelSpinStopped) throw new Error(`ReelStopPresentation${e}.constructor():must implement onReelSpinStopped to dispatchCompleteEvent() for avalanche game!`);
						this._index = t, this.addEventListeners()
					}
					addEventListeners() {
						s.EventHandler.addEventListener(this, a.ServerEvent.GAME_DATA_PARSED, (t => this.onGameDataParsed(t.params[0]))), this.addFeatureEventHandlers && this.addFeatureEventHandlers()
					}
					onGameDataParsed(t) {
						this._gameData = t, this.parseFeatureGameData && this.parseFeatureGameData(t)
					}
					dispatchCompleteEvent(t) {
						s.EventHandler.dispatchEvent(new o.GameEvent(this.completeEvent, {
							reelId: t,
							presentationIndex: this._index
						}))
					}
					reset() {
						this._gameData = null, this.resetFeature && this.resetFeature()
					}
				}
				e.ReelStopPresentationController = l
			},
			48840: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ReelStopPresentationManager = void 0;
				const n = i(671),
					s = i(52601),
					o = i(52409),
					r = i(44679),
					a = i(75367),
					l = i(28147),
					h = i(91812),
					u = i(15662),
					c = i(32696),
					d = i(34785),
					p = i(23110);
				e.ReelStopPresentationManager = class {
					constructor() {
						this._numReels = a.GameConfig.instance.REELS_NUM, this._presentations = [];
						const t = l.GameModuleConfig.instance.REEL_STOP_PRESENTATIONS;
						t && t.forEach(((t, e) => {
							this._presentations.push(t(e))
						})), this.addEventListeners()
					}
					addEventListeners() {
						o.EventHandler.addEventListener(this, c.SpinEvent.BEFORE_START, (t => this.onBeforeSpinStart())), o.EventHandler.addEventListener(this, h.ReelEvent.REEL_STOP_SPIN_ANIMATION_COMPLETE, (t => this.onReelSpinStopped(t.params[0]))), 1 === a.GameConfig.instance.SPIN_MODE ? o.EventHandler.addEventListener(this, n.AvalancheReelEvent.REEL_STOP_SPIN_SYMBOL_ATTENTION_START, (t => this.onReelSpinStopSymbolAttentionStart(t.params[0]))) : o.EventHandler.addEventListener(this, s.SpinReelEvent.REEL_STOP_SPIN_BOUNCE_STARTED, (t => this.onReelBounce(t.params[0])));
						for (let t = 0; t < this._presentations.length; t++) o.EventHandler.addEventListener(this, this._presentations[t].completeEvent, (t => this.onPresentationComplete(t.params[0])))
					}
					onBeforeSpinStart() {
						this._presentationStates = d.ArrayHelper.initArrayWithValues(this._numReels, (() => d.ArrayHelper.initArrayWithValues(this._presentations.length, (() => !1))));
						for (let t = 0; t < this._presentations.length; t++) this._presentations[t].reset()
					}
					onReelBounce(t) {
						this._presentations.forEach((e => {
							e.onReelBounce && e.onReelBounce(t)
						})), this.playReelBouncingSound(t)
					}
					playReelBouncingSound(t) {
						for (let e = 0; e < this._presentations.length; e++)
							if (this._presentations[e].playReelBouncingSound && this._presentations[e].playReelBouncingSound(t)) return;
						null != u.SoundConfig.instance.REELS_DEFAULT_BOUNCE && null != u.SoundConfig.instance.REELS_DEFAULT_BOUNCE[t.reelId] && p.SlotGame.sound.playEffect(u.SoundConfig.instance.REELS_DEFAULT_BOUNCE[t.reelId])
					}
					onReelSpinStopSymbolAttentionStart(t) {
						this._presentations.forEach((e => {
							e.onReelStopSymbolAttention && e.onReelStopSymbolAttention(t)
						}))
					}
					onReelSpinStopped(t) {
						this._presentations.forEach((e => {
							e.onReelSpinStopped && e.onReelSpinStopped(t)
						})), this.playReelStopSound(t), 0 === this._presentations.length && o.EventHandler.dispatchEvent(new r.GameEvent(h.ReelEvent.REEL_STOP_PRESENTATIONS_COMPLETE, t.reelId))
					}
					playReelStopSound(t) {
						if (t.active) {
							for (let e = 0; e < this._presentations.length; e++)
								if (this._presentations[e].playReelStopSound && this._presentations[e].playReelStopSound(t)) return;
							null != u.SoundConfig.instance.REELS_DEFAULT_STOP && null != u.SoundConfig.instance.REELS_DEFAULT_STOP[t.reelId] && p.SlotGame.sound.playEffect(u.SoundConfig.instance.REELS_DEFAULT_STOP[t.reelId])
						}
					}
					onPresentationComplete(t) {
						const e = this._presentationStates[t.reelId];
						e[t.presentationIndex] = !0;
						for (let t = 0; t < e.length; t++)
							if (!e[t]) return;
						o.EventHandler.dispatchEvent(new r.GameEvent(h.ReelEvent.REEL_STOP_PRESENTATIONS_COMPLETE, t.reelId))
					}
				}
			},
			54504: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ReelSymbolName = void 0;
				class i {}
				i.WILD = "W", i.SCATTER = "S", i.BONUS = "B", i.MYSTERY = "M", i.EMPTY = "X", e.ReelSymbolName = i
			},
			71404: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ReelSymbolStateCreator = void 0;
				const n = i(75367),
					s = i(88240),
					o = i(55058),
					r = i(7057);
				class a {
					constructor() {}
					createStateAnimation(t, e) {
						return this[`${e.keyword}StateCreator`] ? this[`${e.keyword}StateCreator`](t, e.keyword, e) : this.getBasicStateAnimation(t, e.keyword, e)
					}
					getBasicStateAnimation(t, e, i) {
						if (i.symbols && -1 === i.symbols.indexOf(t.stackedSymName.symName)) return null;
						i.texturesCreator || (i.texturesCreator = (t, e) => a.defaultSymbolStateTexturesCreator(t, e));
						const s = i.texturesCreator(t.stackedSymName.symName, e);
						if (null == s || 0 === s.length) return null;
						const l = i.fpsGetter ? i.fpsGetter(t.stackedSymName.symName, e) : n.GameConfig.instance.BROWSER_FPS,
							h = new r.TimelineSprite(s, l);
						if (i.scaleGetter) {
							const n = i.scaleGetter(t.stackedSymName.symName, e);
							h.scale.set(n[0], n[1])
						}
						if (o.StateReelSymbol.setStackedSymbolStateAnchor(t, h), i.offsetGetter) {
							const n = i.offsetGetter(t.stackedSymName.symName, e);
							h.position.set(n[0], n[1])
						}
						return h
					}
					hiddenStateCreator(t, e, i) {
						return null
					}
					static defaultSymbolStateTexturesCreator(t, e) {
						return s.GameResources.getTextures(`${t}_${e}`)
					}
				}
				e.ReelSymbolStateCreator = a
			},
			55058: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.StateReelSymbol = e.SymbolStateTransition = void 0;
				const n = i(46334),
					s = i(75367),
					o = i(28147),
					r = i(57244),
					a = i(71404),
					l = i(82903),
					h = i(13006);
				class u {
					constructor(t, e) {
						this.state = t.state, this.frames = null != t.frames ? t.frames : [0], this.alpha = null != t.alpha ? t.alpha : 1, this.autoPlay = null == t.autoPlay || t.autoPlay, this.replay = null == t.replay || t.replay, this.prioCheck = null != t.prioCheck && t.prioCheck, this.fadeInDuration = null != t.fadeInDuration ? t.fadeInDuration : 0, this.fadeInDelay = null != t.fadeInDelay ? t.fadeInDelay : 0, this.fadeInEase = null != t.fadeInEase ? t.fadeInEase : h.Linear.ease, this.onUpdateCallback = t.onUpdateCallback, this.onCompleteCallback = t.onCompleteCallback, this.fadeOutDuration = e && null != e.fadeOutDuration ? e.fadeOutDuration : this.fadeInDuration, this.fadeOutDelay = e && null != e.fadeOutDelay ? e.fadeOutDelay : this.fadeInDelay, this.fadeOutEase = e && null != e.fadeOutEase ? e.fadeOutEase : h.Linear.ease
					}
				}
				e.SymbolStateTransition = u;
				class c extends PIXI.Container {
					get symName() {
						return this._symName
					}
					get reelId() {
						return this._reelId
					}
					set reelId(t) {
						this._reelId = t
					}
					get stackedSymName() {
						return this._stackedSymName
					}
					get stack() {
						return this._stack
					}
					set stack(t) {
						if (this._stack || null == t) throw new Error("StateReelSymbol.set stack():Cannot change stack!");
						this._stack = t, this._stack.addSymbol(this)
					}
					get symWidth() {
						return null == this._symWidth ? s.GameConfig.instance.SYMBOL_WIDTH : this._symWidth
					}
					set symWidth(t) {
						this._symWidth = t
					}
					get symHeight() {
						return null == this._symHeight ? s.GameConfig.instance.SYMBOL_HEIGHT : this._symHeight
					}
					set symHeight(t) {
						if (t !== this._symHeight) {
							this._symHeight = t;
							for (let t in this._stateAnimations) {
								const e = this._stateAnimations[t];
								null != e && c.setStackedSymbolStateAnchor(this, e)
							}
						}
					}
					get bottomPadding() {
						return null == this._bottomPadding ? s.GameConfig.instance.SYMBOL_BOTTOM_PADDING : this._bottomPadding
					}
					set bottomPadding(t) {
						if (t !== this._bottomPadding) {
							this._bottomPadding = t;
							for (let t in this._stateAnimations) {
								const e = this._stateAnimations[t];
								null != e && c.setStackedSymbolStateAnchor(this, e)
							}
						}
					}
					get currentState() {
						return this._currentState
					}
					get currentStateAnimation() {
						return this._currentStateAnimation
					}
					get currentTimeline() {
						return this._currentTimeline
					}
					constructor(t, e, i, n) {
						super(), this._stateCreator = o.GameModuleConfig.instance.SYMBOL_STATE_CREATOR ? o.GameModuleConfig.instance.SYMBOL_STATE_CREATOR() : new a.ReelSymbolStateCreator, this.replaceWith(t, e, i, n)
					}
					setVisibility(t) {
						this.visible !== t && (this.visible = t)
					}
					replaceWith(t, e, i, n) {
						this._reelId = e;
						const s = c.parseStackedSymbolName(t, e);
						return null != this.stackedSymName && this.stackedSymName.isStacked && s.isStacked ? this.stackedReplaceWithStacked(s, i) : this.simpleReplaceWith(t, i, n)
					}
					simpleReplaceWith(t, e, i) {
						return this.reset(!1), this._symName = t, this._stackedSymName = c.parseStackedSymbolName(t, this._reelId), this.initAnimations && this.initAnimations(), i && (i.width && (this.symWidth = i.width), i.height && (this.symHeight = i.height), i.bottomPadding && (this.bottomPadding = i.bottomPadding)), e = null != e ? e : s.GameConfig.instance.SYMBOL_STATES.normal, this._currentState = e, this.changeState({
							state: e,
							replay: !0
						})
					}
					stackedReplaceWithStacked(t, e) {
						if (n.Logger.logDev("WARNING: this should not be used any more. should create new symbol and replace in reelAnimation.symbolsToBeAnimated"), this.stackedSymName.totalNum != t.totalNum) throw new Error("StateReelSymbol.stackedReplaceWithStacked(): Doesn't support replace stacked symbol with another stacked symbol with different length. Please talk to Ning if you need this feature!");
						const i = new h.TimelineLite,
							s = this.stack.symbols,
							o = new l.SymbolStack(t.symName, t.totalNum);
						return s.forEach((n => {
							if (null != n) {
								const s = new h.TimelineLite;
								s.add(n.simpleReplaceWith(`${t.symName}*${n.stackedSymName.index}`, e)), s.add((() => {
									n.stack = o
								})), i.add(s, 0)
							}
						})), i.add((() => {
							let t = !1;
							for (let e = o.symbols.length - 1; e >= 0; e--) {
								const i = o.symbols[e];
								null != i && (t ? i.setVisibility(!1) : null != i.parent && (i.setVisibility(!0), t = !0))
							}
						})), i
					}
					reset(t) {
						if (this._currentState = null, this._currentStateAnimation = null, null != this._stack && (this._stack.removeSymbol(this), this._stack = null), this._stackedSymName = null, this._stateAnimations)
							for (let t in this._stateAnimations) this._stateAnimations[t] && (this.removeChild(this._stateAnimations[t]), this._stateAnimations[t].destroy({
								children: !0
							}));
						this._stateAnimations = {}, this.setVisibility(!0), this.alpha = 1, this._symWidth = null, this._symHeight = null, this._bottomPadding = null
					}
					initState(t) {
						return !this._stateAnimations.hasOwnProperty(t.keyword) && (this._stateAnimations[t.keyword] = this._stateCreator.createStateAnimation(this, t), !!this._stateAnimations[t.keyword] && (this._stateAnimations[t.keyword].alpha = 0, this.addChild(this._stateAnimations[t.keyword]), !0))
					}
					changeState(t, e) {
						const i = new h.TimelineLite,
							n = new u(t, e);
						return i.add(this.getStateChangingAnimation(n), 0), t.setStack && this.stack && this.stackedSymName.isStacked && (t.setStack = !1, this.stack.symbols.forEach(((n, s) => {
							s != this.stackedSymName.index && null != n && i.add(n.changeState(t, e), 0)
						}))), i
					}
					checkReplay(t, e) {
						!e.replay && this._currentState && e.state.keyword === this._currentState.keyword && t.kill()
					}
					setCurrentState(t, e) {
						if (null != this._currentTimeline) {
							if (e.prioCheck && e.state.prio < this._currentState.prio) return void t.kill();
							this._currentTimeline.isActive() && this._currentTimeline.kill()
						}
						this._currentTimeline = t, this._currentState = e.state, this._currentStateAnimation = this._stateAnimations[e.state.keyword]
					}
					getStateChangingAnimation(t) {
						this.initState(t.state);
						let e = new h.TimelineLite({
							paused: !t.autoPlay
						});
						e.addLabel(t.state.keyword, 0), e.add((() => this.checkReplay(e, t))), e.add((() => this.setCurrentState(e, t)));
						for (let i in this._stateAnimations) null != this._stateAnimations[i] && (i === t.state.keyword ? this.addNewStateAnimation(e, t, this._stateAnimations[i], t.fadeInDelay) : this.addOldStateAnimation(e, t, this._stateAnimations[i], t.fadeOutDelay));
						return e
					}
					addNewStateAnimation(t, e, i, n) {
						let s;
						s = e.fadeInDuration > 0 ? new h.TweenLite(i, e.fadeInDuration, {
							alpha: e.alpha,
							ease: e.fadeInEase
						}) : () => i.alpha = e.alpha, t.add(s, n), t.add(i.getAnimation(e.frames, e.onUpdateCallback, e.onCompleteCallback), n)
					}
					addOldStateAnimation(t, e, i, n) {
						let s;
						s = e.fadeOutDuration > 0 ? new h.TweenLite(i, e.fadeOutDuration, {
							alpha: 0,
							ease: e.fadeOutEase
						}) : () => i.alpha = 0, t.add(s, n)
					}
					onRemove() {
						this.reset(!0), this.destroy({
							children: !0
						})
					}
					static parseStackedSymbolName(t, e) {
						if (null == t) throw new Error("StackedReelSymbol.parseStackedSymbol(): symName cannot be null!");
						if (null == s.GameConfig.instance.STACKED_SYMBOLS) return {
							isStacked: !1,
							symName: t,
							totalNum: 1,
							index: 0
						};
						const i = t.split("*");
						let n = null != s.GameConfig.instance.STACKED_SYMBOLS[i[0]];
						return {
							isStacked: n,
							symName: i[0],
							totalNum: n ? (0, r.isNumber)(s.GameConfig.instance.STACKED_SYMBOLS[i[0]].totalNum) ? s.GameConfig.instance.STACKED_SYMBOLS[i[0]].totalNum : s.GameConfig.instance.STACKED_SYMBOLS[i[0]].totalNum[e] : 1,
							index: n ? parseInt(i[1]) : 0
						}
					}
					static filterStackedSymbolsReelSet(t, e) {
						const i = [];
						let n = "",
							s = -1,
							o = 0;
						for (let r of t) {
							const t = c.parseStackedSymbolName(r, e);
							if (t.isStacked) {
								if ("" === n || t.symName != n) {
									if (s != o - 1) throw new Error("StateReelSymbol.filterStackedSymbolsReelSet():Broken stacked symbol error_2!");
									n = r, s = -1, o = t.totalNum
								}
								s++, i.push(`${r}*${s.toString()}`)
							} else {
								if (i.push(r), s != o - 1) throw new Error("StateReelSymbol.filterStackedSymbolsReelSet():Broken stacked symbol error_1!");
								n = "", s = -1, o = 0
							}
						}
						return i
					}
					static setStackedSymbolStateAnchor(t, e) {
						t.stackedSymName.isStacked ? e.anchor.set(.5, r.MathHelper.roundToDecimals((.5 * e.height - t.stackedSymName.totalNum * t.symHeight * .5 - (t.stackedSymName.totalNum - 1) * t.bottomPadding * .5 + (t.stackedSymName.index + .5) * t.symHeight + t.stackedSymName.index * t.bottomPadding) / e.height, 4)) : e.anchor.set(.5, .5)
					}
				}
				e.StateReelSymbol = c
			},
			82903: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SymbolStack = void 0;
				const n = i(34785);
				e.SymbolStack = class {
					get symName() {
						return this._symName
					}
					get totalNum() {
						return this._totalNum
					}
					get symbols() {
						return this._symbols
					}
					constructor(t, e) {
						this._symName = t, this._totalNum = e, this._symbols = n.ArrayHelper.initArrayWithValues(e, (t => null))
					}
					addSymbol(t) {
						if (this.verifySymbol(t)) {
							if (null != this._symbols[t.stackedSymName.index]) throw new Error("SymbolStack.addSymbol():There is symbol exist in the index where the symbol is going to be added!");
							this._symbols[t.stackedSymName.index] = t
						}
					}
					removeSymbol(t) {
						if (this.verifySymbol(t)) {
							if (this._symbols[t.stackedSymName.index] != t) throw new Error("SymbolStack.removeSymbol():The index of the symbol to be removed does not match the stack!");
							this._symbols[t.stackedSymName.index] = null
						}
					}
					verifySymbol(t) {
						return !!t.stackedSymName.isStacked && t.stackedSymName.symName == this._symName
					}
				}
			},
			88240: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GameResources = void 0;
				const n = i(77616),
					s = i(46334),
					o = i(52409),
					r = i(75367),
					a = i(28147),
					l = i(78973),
					h = i(44415),
					u = i(60055),
					c = i(84433),
					d = i(91305),
					p = i(9220),
					_ = i(11084),
					m = i(56665),
					g = i(23110),
					f = i(49490),
					S = i(78904);
				class y {
					constructor() {
						if (this._fontsLoaded = !1, this._introImagesLoaded = !1, this._configLoaded = !1, y._instance) throw new Error("Error: GameResources.constructor() - Instantiation failed: Singleton.");
						const t = null != r.GameConfig.instance.RESOURCE_BASE_URL ? r.GameConfig.instance.RESOURCE_BASE_URL : y._DEFAULT_RESOURCE_BASE_URL;
						this._baseUrl = y.getGamePath() + t, this._fontConfig = a.GameModuleConfig.instance.FONTS_CONFIG, this._assetLoader = new h.AssetLoader(this._baseUrl), o.EventHandler.addEventListener(this, u.AssetLoaderEvent.LEVEL_COMPLETE, (t => this.onAssetLevelComplete(t))), o.EventHandler.addEventListener(this, u.AssetLoaderEvent.ALL_LEVELS_COMPLETE, (t => this.onAssetAllLevelsComplete(t))), o.EventHandler.addLastEventListener(this, l.SystemEvent.CONFIG_LOADED, (() => this.onConfigLoaded())), g.SlotGame.api.events.on(f.APIEvent.HALT, (() => this._assetLoader.halt())), y._instance = this
					}
					static getGamePath() {
						let t = "";
						const e = document.getElementsByTagName("script");
						for (let i = 0; i < e.length; i++) {
							const n = e[i].src;
							if (/\/game\.js$/.test(n)) {
								t = n.substr(0, n.length - 8);
								break
							}
						}
						return t
					}
					loadImages(t) {
						const e = c.AssetsConfig.getResourcesGroup(t);
						for (let t of e) t && t.device && t.device !== m.UserAgent.deviceName && e.splice(e.indexOf(t), 1);
						this._assetLoader.loadResourceGroup(t, e)
					}
					onAssetLevelComplete(t) {
						1 == t.level && this.onImagesLoadComplete(t.name)
					}
					onAssetAllLevelsComplete(t) {
						t.name === p.ResourcesGroupName.INTRO && this.loadImages(p.ResourcesGroupName.MAIN)
					}
					onImagesLoadComplete(t) {
						s.Logger.logDev(`%cGameResource.onImagesLoadComplete resourceGroup:${t}`, "background:#00ff00;"), t === p.ResourcesGroupName.INTRO ? (this._introImagesLoaded = !0, this.checkInitResourcesLoading()) : this.dispatchLoadComplete(t)
					}
					dispatchLoadComplete(t) {
						o.EventHandler.dispatchEvent(new d.LoaderEvent(d.LoaderEvent.RESOURCES_LOADED, t))
					}
					onConfigLoaded() {
						this._configLoaded = !0, this.checkInitResourcesLoading()
					}
					checkInitResourcesLoading() {
						this._introImagesLoaded && this._fontsLoaded && this._configLoaded && this.dispatchLoadComplete(p.ResourcesGroupName.INTRO)
					}
					loadFonts() {
						let t = 0;
						for (let e in this._fontConfig) t++;
						for (let e in this._fontConfig) {
							const i = this._fontConfig[e],
								o = document.createElement("style"),
								r = "font-family: '" + i.fontFamily + "';\n";
							let a = "src: ";
							for (let t = 0; t < i.src.length; t++) {
								const e = "url('" + this._baseUrl + i.src[t].url + "') ",
									n = "format('" + i.src[t].format + "')";
								a = a + e + n + (t === i.src.length - 1 ? ";\n" : ",\n")
							}
							const l = "font-weight: " + (i.fontWeight ? i.fontWeight : n.FontWeight.NORMAL) + ";\n",
								h = "font-style: " + (i.fontStyle ? i.fontStyle : n.FontStyle.NORMAL) + ";\n",
								u = "@font-face {\n" + r + a + l + h + "}";
							o.appendChild(document.createTextNode(u)), document.head.appendChild(o), new S(i.fontFamily, {
								weight: i.fontWeight ? i.fontWeight : n.FontWeight.NORMAL,
								style: i.fontStyle ? i.fontStyle : n.FontStyle.NORMAL
							}).load(null, 6e4).then((() => {
								t--, this.checkFontsLoaded(t)
							}), (() => {
								s.Logger.logDev(`Font loading failed: ${a}`), this.onFontLoadError("Font loading failed")
							}))
						}
						this.checkFontsLoaded(t)
					}
					onFontLoadError(t) {
						o.EventHandler.dispatchEvent(new _.ErrorEvent(_.ErrorEvent.ERROR, t, _.ErrorEvent.FONT_LOAD_ERROR)), this._assetLoader.halt()
					}
					checkFontsLoaded(t) {
						0 !== t || this._fontsLoaded || (this._fontsLoaded = !0, s.Logger.logDev("%cGameResource.checkFontsLoaded: true", "background:#ccffcc;"), this.checkInitResourcesLoading())
					}
					static getTextures(t) {
						return y._instance._assetLoader.getTextures(t)
					}
					static getSpineAsset(t) {
						return y._instance._assetLoader.getSpineAsset(t)
					}
				}
				y._DEFAULT_RESOURCE_BASE_URL = "/resources/", e.GameResources = y
			},
			9220: (t, e) => {
				"use strict";
				var i;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ResourcesGroupName = void 0, (i = e.ResourcesGroupName || (e.ResourcesGroupName = {})).INTRO = "intro", i.MAIN = "main", i.FREESPIN = "freespin", i.BONUS = "bonus"
			},
			88424: (t, e) => {
				"use strict";
				var i, n, s;
				Object.defineProperty(e, "__esModule", {
						value: !0
					}), e.Asset = e.AssetQualityLevel = e.SpriteSheetNameExtension = e.DefaultQualityExtension = void 0,
					function(t) {
						t.LOW = "@0.25x.", t.MEDIUM = "@0.5x.", t.HIGH = "."
					}(i = e.DefaultQualityExtension || (e.DefaultQualityExtension = {})),
					function(t) {
						t.SPRITE_SHEET_SAME_LAYOUT = "_sheetSameLayout.", t.SPRITE_SHEET = "_sheet."
					}(n = e.SpriteSheetNameExtension || (e.SpriteSheetNameExtension = {})),
					function(t) {
						t[t.META = 0] = "META", t[t.LOW = 1] = "LOW", t[t.MEDIUM = 2] = "MEDIUM", t[t.HIGH = 3] = "HIGH"
					}(s = e.AssetQualityLevel || (e.AssetQualityLevel = {}));
				class o {
					constructor(t, e, i = !0, r) {
						this._qualityExtensions = o.createQualityExtensions(r), this.variants = [], this.name = t;
						let a = o.getExtension(e);
						const l = o.stripUrl(e, a);
						"fnt" != a ? ("json" == a && (t += i ? n.SPRITE_SHEET_SAME_LAYOUT : n.SPRITE_SHEET), this.createVariants(t, l, a), console.warn("Asset deprecated. Use relevant specific asset class instead: TextureAsset, BitmapFontAsset or SpineAsset")) : this.variants[s.META] = {
							name: t,
							url: e
						}
					}
					createVariants(t, e, i) {
						this.variants[s.HIGH] = {
							name: t,
							url: e + this._qualityExtensions[s.HIGH] + i
						}, this.variants[s.MEDIUM] = {
							name: t,
							url: e + this._qualityExtensions[s.MEDIUM] + i
						}, this.variants[s.LOW] = {
							name: t,
							url: e + this._qualityExtensions[s.LOW] + i
						}
					}
					static getExtension(t) {
						let e = t.split(".").pop();
						if (e) return e;
						throw new Error("Asset url is not pointing to a valid file.")
					}
					static stripUrl(t, e) {
						return t.slice(0, -(e.length + 1))
					}
					static createQualityExtensions(t) {
						let e = [];
						return e[s.HIGH] = t && t.high ? t.high : i.HIGH, e[s.MEDIUM] = t && t.medium ? t.medium : i.MEDIUM, e[s.LOW] = t && t.low ? t.low : i.LOW, e
					}
				}
				e.Asset = o
			},
			44415: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.AssetLoader = void 0;
				const n = i(88424),
					s = i(21664),
					o = i(52409),
					r = i(60055),
					a = i(11084),
					l = i(9220),
					h = i(52475),
					u = i(61976),
					c = i(46334);
				class d {
					constructor(t) {
						this._baseUrl = t, this.createLoader()
					}
					loadResourceGroup(t, e) {
						if (this._loadLoopIndex = 0, this._totalAutoLoadLoops = 0, this._resourceGroup = t, null == e) return console.warn("AssetLoader.loadResourceGroup, assetGroups is null"), this._loadLoopIndex = 1, this.dispatchLoadLoopComplete(), void this.dispatchAllLoopsComplete();
						this._assetsGroups = e;
						for (let t of this._assetsGroups) null == t.autoLoad && (t.autoLoad = h.GameSetting.getDefaultQualities().concat()), t.autoLoad.unshift(n.AssetQualityLevel.META), this._totalAutoLoadLoops = this._totalAutoLoadLoops < t.autoLoad.length ? t.autoLoad.length : this._totalAutoLoadLoops, t.animations && this._textureParser.addAnimationRegister(t.animations);
						this.autoLoadLevel()
					}
					createLoader() {
						this._loader = new PIXI.Loader(void 0, 1e4), this._textureParser = new s.TextureParser(this._loader), this._spineAssetParser = new u.SpineAssetParser(this._loader);
						const t = this._loader._afterMiddleware[0],
							e = (this._loader._afterMiddleware[1], this._loader._afterMiddleware[2]);
						this._loader._afterMiddleware[3], this._loader._afterMiddleware[4], this._loader._afterMiddleware = [], this._loader._afterMiddleware.push(t), this._loader._afterMiddleware.push(e), this._loader.use(((t, e) => this._textureParser.parseResource(t, e))), this._loader.use(((t, e) => this._spineAssetParser.parseResource(t, e))), this._loader.onProgress.add(((t, e) => this.onLoaderProgress(t, e))), this._loader.onError.add(((t, e, i) => d.onLoaderError(t, e, i)))
					}
					addGroupToLoader(t) {
						const e = t.autoLoad.shift();
						if (null == e) return 0;
						let i = 0;
						for (let n of t.assets) {
							let t = n.variants[e];
							t && (this._loader.add(t.name, this._baseUrl + t.url), i++)
						}
						return i
					}
					autoLoadLevel() {
						let t = 0;
						for (let e = 0; e < this._assetsGroups.length; e++) t += this.addGroupToLoader(this._assetsGroups[e]);
						t > 0 ? this._loader.load(((t, e) => this.onLevelLoaded(t, e))) : this.onLevelLoaded(this._loader, this._resources)
					}
					onLevelLoaded(t, e) {
						if (t.reset(), this.dispatchLoadLoopComplete(), this._loadLoopIndex < this._totalAutoLoadLoops - 1) return this._loadLoopIndex++, void this.autoLoadLevel();
						this.dispatchAllLoopsComplete()
					}
					dispatchAllLoopsComplete() {
						c.Logger.logDev(`%cAssetLoader.dispatchAllLoopsComplete resourceGroup:${this._resourceGroup} , loadLoop: ${this._loadLoopIndex}`, "background:#99ea99;"), o.EventHandler.dispatchEvent(new r.AssetLoaderEvent(r.AssetLoaderEvent.ALL_LEVELS_COMPLETE, this._resourceGroup, this._loadLoopIndex))
					}
					dispatchLoadLoopComplete() {
						c.Logger.logDev(`%cAssetLoader.dispatchLoadLoopComplete resourceGroup:${this._resourceGroup} , loadLoop: ${this._loadLoopIndex}`, "background:#ddffdd;"), this._resourceGroup === l.ResourcesGroupName.INTRO && (this._textureParser.ready = !0), o.EventHandler.dispatchEvent(new r.AssetLoaderEvent(r.AssetLoaderEvent.LEVEL_COMPLETE, this._resourceGroup, this._loadLoopIndex))
					}
					getTextures(t) {
						return this._textureParser.getFrameTextures(t)
					}
					getSpineAsset(t) {
						return this._spineAssetParser.getSpineAsset(t)
					}
					onLoaderProgress(t, e) {
						this.dispatchProgress(t.progress)
					}
					dispatchProgress(t) {
						o.EventHandler.dispatchEvent(new r.AssetLoaderEvent(r.AssetLoaderEvent.PROGRESS, this._resourceGroup, this._loadLoopIndex, t))
					}
					static onLoaderError(t, e, i) {
						const n = t.message;
						c.Logger.logDev(t.message, e, i), 0 == h.GameSetting.isDevMode && o.EventHandler.dispatchEvent(new a.ErrorEvent(a.ErrorEvent.ERROR, n, a.ErrorEvent.ASSET_LOAD_ERROR))
					}
					halt() {
						this._loader.destroy()
					}
				}
				e.AssetLoader = d
			},
			60055: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.AssetLoaderEvent = void 0;
				const n = i(44679);
				class s extends n.GameEvent {
					constructor(t, e, i, n) {
						super(t), this.name = e, this.level = i, this.progress = n || 100
					}
				}
				s.LEVEL_COMPLETE = "levelComplete", s.ALL_LEVELS_COMPLETE = "allLevelsComplete", s.PROGRESS = "progress", e.AssetLoaderEvent = s
			},
			84433: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.AssetsConfig = void 0;
				const n = i(88424),
					s = i(54707);
				class o {
					static addToAssetsConfig(t) {
						for (let e in t) o._assetsConfig[e] ? o._assetsConfig[e] = o._assetsConfig[e].concat(t[e]) : o._assetsConfig[e] = t[e]
					}
					static get instance() {
						return o._assetsConfig
					}
					static getResourcesGroup(t) {
						return o._assetsConfig[t]
					}
				}
				o._defaultResources = {
					intro: [{
						name: "defaultIntro",
						autoLoad: [n.AssetQualityLevel.HIGH],
						assets: [new s.TextureAsset("slotGameIntro0", "../node_modules/@nolimitcity/slot-game/resources/sheets/intro/intro0.json")],
						animations: {
							missingResource: "missing",
							volatilityExtreme: "volatility_extreme",
							volatilityHigh: "volatility_high",
							volatilityMed: "volatility_medium",
							xNudge: "x_nudge",
							xWays: "x_ways"
						}
					}],
					main: [{
						name: "defaultMain",
						assets: [new s.TextureAsset("slotGameMain0", "../node_modules/@nolimitcity/slot-game/resources/sheets/main/main0.json")],
						animations: {
							button: "ui/gameTweakerButton/button",
							"button-disabled": "ui/gameTweakerButton/button-disabled"
						}
					}]
				}, o._assetsConfig = {
					main: [],
					intro: []
				}, e.AssetsConfig = o
			},
			61976: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SpineAssetParser = void 0;
				const n = i(88240);
				class s {
					constructor(t) {
						this._loader = t, this._rawResource = {}, this._spineDataCache = {}
					}
					parseResource(t, e) {
						if (!t.data || t.type !== PIXI.LoaderResource.TYPE.JSON || !t.data.bones) return e();
						this._rawResource[t.name] = t, e()
					}
					getSpineAsset(t, e = /^\w+\//gi, i = "") {
						if (this._spineDataCache[t]) return this._spineDataCache[t];
						const o = this._rawResource[t],
							r = o.data;
						let a = s.getAllRegionNamesFromSpineData(r);
						a = s.removeDuplicates(a);
						const l = [];
						for (let t of a) {
							let n = {
								regionName: t,
								textureId: t.replace(e, i)
							};
							l.push(n)
						}
						const h = new PIXI.spine.core.TextureAtlas;
						for (let t of l) h.addTexture(t.regionName, n.GameResources.getTextures(t.textureId)[0]);
						const u = new PIXI.spine.core.AtlasAttachmentLoader(h),
							c = new PIXI.spine.core.SkeletonJson(u),
							d = (o.metadata, o.metadata.spineSkeletonScale);
						return d && (c.scale = d), this._spineDataCache[t] = c.readSkeletonData(o.data), this._spineDataCache[t]
					}
					static getAllRegionNamesFromSpineData(t) {
						let e = [];
						for (let i in t.skins) {
							const n = t.skins[i],
								s = this.findTexturesInSkin(n);
							e = e.concat(s)
						}
						return e
					}
					static findTexturesInSkin(t) {
						let e = [];
						for (let i in t) {
							const n = t[i];
							for (let t in n) {
								const i = n[t];
								if (!i.type || "mesh" == i.type)
									if ("mesh" == i.type || i.width && i.height) {
										let n;
										n = i.path ? i.path : i.name ? i.name : t, e.push(n)
									} else {
										const t = s.findTexturesInSkin(i);
										e = e.concat(t)
									}
							}
						}
						return e
					}
					static removeDuplicates(t) {
						const e = [];
						for (let i = 0; i < t.length; i++) {
							const n = t[i];
							e.indexOf(n) < 0 && e.push(n)
						}
						return e
					}
				}
				e.SpineAssetParser = s
			},
			21664: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.TextureParser = void 0;
				const n = i(88424),
					s = i(46334);
				class o {
					constructor(t) {
						this.ready = !1, this._loader = t, this._spriteSheetCache = {}, this._animationCache = {}, this._animationRegister = {}, this._oldBaseTextures = []
					}
					parseResource(t, e) {
						t.type == PIXI.LoaderResource.TYPE.JSON && t.data.frames && this.processSpriteSheet(t), t.data && t.type === PIXI.LoaderResource.TYPE.IMAGE && this.processBaseTexture(t), e()
					}
					addAnimationRegister(t) {
						for (let e in t) this._animationRegister[e] = t[e]
					}
					getFrameTextures(t) {
						let e = t;
						if (this._animationRegister[t] && (e = this._animationRegister[t]), PIXI.utils.TextureCache[e]) return [PIXI.utils.TextureCache[e]];
						if (!this._animationCache[t]) {
							let i = [];
							for (let t in PIXI.utils.TextureCache) {
								if (t.search("^" + e) < 0) continue;
								let n = t.split(e).pop();
								if (!n) continue;
								let s = parseFloat(n);
								isNaN(s) || i.push(t)
							}
							0 != i.length && (i = i.sort(), this._animationCache[t] = i)
						}
						if (this._animationCache[t]) {
							let e = [];
							for (let i of this._animationCache[t]) e.push(PIXI.utils.TextureCache[i]);
							return e
						}
						if (this.ready) {
							if ("missingResource" === t) throw new Error(`Error: TextureParser.getTexture(): [${t}] is not in texture cache, please check if you install slot-game correctly!`);
							return s.Logger.logDev(`Error: TextureParser.getTexture(): [${t}] is not in texture cache`), this.getFrameTextures("missingResource")
						}
						throw new Error(`Error: TextureParser.getTexture(): [${t}] You cannot use texture before it's loaded!`)
					}
					processSpriteSheet(t) {
						const e = t.name.search(n.SpriteSheetNameExtension.SPRITE_SHEET_SAME_LAYOUT) >= 0,
							i = t.name.search(n.SpriteSheetNameExtension.SPRITE_SHEET);
						if (i >= 0) {
							let s = t.name.substring(0, i);
							s += t.name.substring(i - 1 + n.SpriteSheetNameExtension.SPRITE_SHEET.length);
							let o = t.data;
							this._spriteSheetCache[s] && 0 == e && (o.dirty = !0), this._spriteSheetCache[s] = o;
							const r = t.url.substring(0, t.url.lastIndexOf("/")) + "/";
							let a = {
								crossOrigin: t.crossOrigin,
								loadType: PIXI.LoaderResource.LOAD_TYPE.IMAGE,
								metadata: t.metadata.imageMetadata,
								parentResource: t
							};
							this._loader.add(s, r + o.meta.image, a)
						}
					}
					postProcessFrames(t) {
						const e = t.name;
						if (!this._spriteSheetCache[e]) return;
						const i = this._spriteSheetCache[e];
						let n = PIXI.utils.BaseTextureCache[e];
						for (let t in i.frames) {
							let e, s = n.resolution;
							if (PIXI.utils.TextureCache[t]) e = PIXI.utils.TextureCache[t], e.baseTexture = n, 1 == i.dirty && o.updateTextureFrame(e, i.frames[t], s), e.updateUvs();
							else {
								const e = new PIXI.Texture(n);
								o.updateTextureFrame(e, i.frames[t], s), PIXI.Texture.addToCache(e, t)
							}
						}
					}
					static updateTextureFrame(t, e, i) {
						const n = e.frame;
						n && (e.trimmed && (t.trim ? (t.trim.x = e.spriteSourceSize.x / i, t.trim.y = e.spriteSourceSize.y / i, t.trim.width = n.w / i, t.trim.height = n.h / i) : t.trim = new PIXI.Rectangle(e.spriteSourceSize.x / i, e.spriteSourceSize.y / i, n.w / i, n.h / i)), t.rotate = e.rotated ? 2 : 0, t.frame.x = n.x / i, t.frame.y = n.y / i, t.frame.width = e.rotated ? n.h / i : n.w / i, t.frame.height = e.rotated ? n.w / i : n.h / i, t.orig = new PIXI.Rectangle(0, 0, e.sourceSize.w / i, e.sourceSize.h / i)), t.updateUvs()
					}
					processBaseTexture(t) {
						if (t.data && t.type === PIXI.LoaderResource.TYPE.IMAGE) {
							const e = t.name;
							if (PIXI.utils.BaseTextureCache[e]) {
								const i = PIXI.BaseTexture.removeFromCache(e),
									n = new PIXI.BaseTexture(t.data, {
										scaleMode: PIXI.settings.SCALE_MODE,
										resolution: PIXI.utils.getResolutionOfUrl(t.url)
									});
								n.resolution = PIXI.utils.getResolutionOfUrl(t.url), PIXI.utils.TextureCache[e].baseTexture = n, PIXI.BaseTexture.addToCache(n, e), this._oldBaseTextures.push(i), n.update()
							} else {
								let i = new PIXI.BaseTexture(t.data, {
									scaleMode: PIXI.settings.SCALE_MODE,
									resolution: PIXI.utils.getResolutionOfUrl(t.url)
								});
								i.resolution = PIXI.utils.getResolutionOfUrl(t.url), t.texture = new PIXI.Texture(i), PIXI.BaseTexture.addToCache(i, e), PIXI.Texture.addToCache(t.texture, e)
							}
							this.postProcessFrames(t)
						}
						this.destroyOldBaseTextures()
					}
					destroyOldBaseTextures() {
						let t = this._oldBaseTextures.pop();
						for (; t;) t.destroy(), t = this._oldBaseTextures.pop()
					}
				}
				e.TextureParser = o
			},
			90394: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BitmapFontAsset = void 0;
				const n = i(88424);
				e.BitmapFontAsset = class {
					constructor(t, e) {
						this.name = t, this.variants = [], this.variants[n.AssetQualityLevel.META] = {
							name: this.name,
							url: e
						}
					}
				}
			},
			87691: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SpineAsset = void 0;
				const n = i(88424);
				e.SpineAsset = class {
					constructor(t, e) {
						this.name = t, this.variants = [], this.variants[n.AssetQualityLevel.META] = {
							name: this.name,
							url: e
						}
					}
				}
			},
			54707: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.TextureAsset = void 0;
				const n = i(88424);
				class s {
					constructor(t, e, i = !0, o) {
						this.name = t, this.variants = [], this._qualityExtensions = s.createQualityExtensions(o);
						let r = s.getExtension(e);
						const a = s.stripUrl(e, r);
						"json" == r && (t += i ? n.SpriteSheetNameExtension.SPRITE_SHEET_SAME_LAYOUT : n.SpriteSheetNameExtension.SPRITE_SHEET), this.createVariants(t, a, r)
					}
					createVariants(t, e, i) {
						this.variants[n.AssetQualityLevel.HIGH] = {
							name: t,
							url: e + this._qualityExtensions[n.AssetQualityLevel.HIGH] + i
						}, this.variants[n.AssetQualityLevel.MEDIUM] = {
							name: t,
							url: e + this._qualityExtensions[n.AssetQualityLevel.MEDIUM] + i
						}, this.variants[n.AssetQualityLevel.LOW] = {
							name: t,
							url: e + this._qualityExtensions[n.AssetQualityLevel.LOW] + i
						}
					}
					static getExtension(t) {
						let e = t.split(".").pop();
						if (e) return e;
						throw new Error("Asset url is not pointing to a valid file.")
					}
					static stripUrl(t, e) {
						return t.slice(0, -(e.length + 1))
					}
					static createQualityExtensions(t) {
						let e = [];
						return e[n.AssetQualityLevel.HIGH] = t && t.high ? t.high : n.DefaultQualityExtension.HIGH, e[n.AssetQualityLevel.MEDIUM] = t && t.medium ? t.medium : n.DefaultQualityExtension.MEDIUM, e[n.AssetQualityLevel.LOW] = t && t.low ? t.low : n.DefaultQualityExtension.LOW, e
					}
				}
				e.TextureAsset = s
			},
			91305: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LoaderEvent = void 0;
				const n = i(44679);
				class s extends n.GameEvent {
					get key() {
						return this._key
					}
					constructor(t, e) {
						super(t, e), this._key = e
					}
				}
				s.RESOURCES_LOADED = "loaderEvent_resourcesLoaded", e.LoaderEvent = s
			},
			15662: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SoundConfig = void 0;
				class i {
					static set soundConfig(t) {
						i._soundConfig = t
					}
					static get instance() {
						return i._soundConfig
					}
				}
				e.SoundConfig = i
			},
			69363: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SoundEvent = void 0;
				class i {}
				i.LOOPS_SETTING = "soundEvent_loopsSetting", i.EFFECTS_SETTING = "soundEvent_effectsSetting", e.SoundEvent = i
			},
			92323: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ScreenController = void 0;
				const n = i(46334),
					s = i(46289),
					o = i(53108),
					r = i(52409),
					a = i(44679),
					l = i(330),
					h = i(32696),
					u = i(57284),
					c = i(15904),
					d = i(23110);
				class p extends s.BaseController {
					get isTriggered() {
						return this._isTriggered
					}
					constructor(t, e, i) {
						super(i, t), this._autoClose = !1, this._isTriggered = !1, this._hasStarted = !1, this._isShowing = !1, this._autoClose = null != e.autoCloseTime && e.autoCloseTime > 0, this._autoClose && (this._autoCloseTime = e.autoCloseTime), this._view = e.viewCreator((() => this.finish()), this._autoClose), this.addEventListeners()
					}
					addEventListeners() {
						r.EventHandler.addEventListener(this, h.SpinEvent.BEFORE_START, (t => this.onBeforeSpinStart())), r.EventHandler.addEventListener(this, l.ServerEvent.GAME_DATA_PARSED, (t => this.onGameDataParsed(t.params[0]))), r.EventHandler.addEventListener(this, l.ServerEvent.INIT_DATA_PARSED, (t => this.onGameDataParsed(t.params[0]))), this.addFeatureEventHandlers && this.addFeatureEventHandlers()
					}
					onBeforeSpinStart() {
						this._serverData = null, this._isTriggered = !1, this.resetFeatureGameData && this.resetFeatureGameData()
					}
					onGameDataParsed(t) {
						this._serverData = t, this._isTriggered = this.calculateIsTriggered(t), this._isTriggered && this.parseFeatureGameData && this.parseFeatureGameData(t)
					}
					start() {
						n.Logger.logDev(`Starting Screen ${this.moduleName}`), r.EventHandler.dispatchEvent(new a.GameEvent(c.ScreenEvent.SCREEN_START)), this._hasStarted = !0, this.show() || this.finish()
					}
					show() {
						return this.shouldShow() && (this._view.show(this._serverData, (() => this.onShowComplete())), this.hideKeypad(), r.EventHandler.dispatchEvent(new a.GameEvent(o.BetLineEvent.SET_ENABLED, !1)), r.EventHandler.dispatchEvent(new a.GameEvent(o.BetLineEvent.HIDE_ALL_BET_LINES)), r.EventHandler.dispatchEvent(new a.GameEvent(u.StageEvent.WANT_RESIZE)), this._isShowing = !0), this.doTransitions && this.doTransitions(), this._isShowing
					}
					shouldShow() {
						return !0
					}
					onShowComplete() {
						this._autoClose && this._view.startTimer(this._autoCloseTime, (() => this.finish())), this._view.enableButton()
					}
					finish() {
						this._hasStarted && (this._hasStarted = !1, this.close())
					}
					close() {
						this._isShowing ? (this._view.stopTimer(), this._view.close((() => this.onCloseComplete())), this._isShowing = !1) : this.onCloseComplete()
					}
					onCloseComplete() {
						n.Logger.logDev(`Close Screen ${this.moduleName}`), this.showKeypad(), r.EventHandler.dispatchEvent(new a.GameEvent(u.StageEvent.WANT_RESIZE)), r.EventHandler.dispatchEvent(new a.GameEvent(o.BetLineEvent.SET_ENABLED, !0)), r.EventHandler.dispatchEvent(new a.GameEvent(c.ScreenEvent.SCREEN_CLOSED))
					}
					shouldOnlyHideKeypadButtons() {
						return !1
					}
					hideKeypad() {
						d.SlotGame.keypad.hide()
					}
					showKeypad() {
						d.SlotGame.keypad.show()
					}
				}
				e.ScreenController = p
			},
			79752: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ScreenManager = void 0;
				const n = i(28147);
				e.ScreenManager = class {
					constructor() {
						this._screens = [];
						const t = n.GameModuleConfig.instance.SCREENS;
						if (t)
							for (let e = 0; e < t.length; e++) this._screens.push(t[e]())
					}
					tryPlayScreen() {
						for (let t = 0; t < this._screens.length; t++)
							if (this._screens[t].isTriggered) return this._screens[t].start(), !0;
						return !1
					}
				}
			},
			28054: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ScreenView = void 0;
				const n = i(77616),
					s = i(73044),
					o = i(33704),
					r = i(376),
					a = i(9220),
					l = i(66493),
					h = i(85206),
					u = i(40745),
					c = i(56665),
					d = i(57244);
				class p extends s.BaseView {
					constructor(t, e = !1) {
						super(t.resourceGroup ? t.resourceGroup : a.ResourcesGroupName.MAIN), this.DEFAULT_BUTTON_SIZE = new PIXI.Point(240, 64), this.DEFAULT_BUTTON_TEXT_STYLE = {
							fontFamily: "Open Sans",
							fontStyle: n.FontStyle.ITALIC,
							fontSize: 34,
							fill: "#ffffff",
							fontWeight: n.FontWeight.EXTRA_BOLD
						}, this.DEFAULT_MOBILE_SCALE = 1.6, this.DEFAULT_PORTRAIT_SCALE = 1.7, this._isShowing = !1, this._autoClose = !1, this._config = t, this._onButtonClickCallback = t.onButtonClickCallback, this._autoClose = e, this._layer = h.StageManager.getLayer(t.layer)
					}
					initAnimations() {
						this._deviceScale = c.UserAgent.isMobile ? this._config.mobileScale ? this._config.mobileScale : this.DEFAULT_MOBILE_SCALE : 1, this.createBackground && (this._background = this.createBackground(), this.addChild(this._background)), this.createGameGraphics && this.addChild(this.createGameGraphics()), this._button = this.createButton(), this.addChild(this._button), this._autoClose && (this._autoCloseTimer = this.createAutoCloseTimer(), this.addChild(this._autoCloseTimer))
					}
					createButton() {
						const t = u.Translation.translate(this._config.buttonText ? this._config.buttonText : "CONTINUE"),
							e = this.getScaledButtonTextStyle(),
							i = new r.NineSliceButton((() => this.onButtonClick()), ` ${t} `, e, this._config.buttonBackgroundConfig);
						return i.enabled = !1, i
					}
					onButtonClick() {
						this._onButtonClickCallback()
					}
					getScaledButtonTextStyle() {
						const t = this._config.buttonTextStyle ? this._config.buttonTextStyle : this.DEFAULT_BUTTON_TEXT_STYLE;
						if (!(0, d.isNumber)(t.fontSize)) throw new Error("Error: IntoView.getScaledButtonTextStyle(): please use number fontSize!");
						return t.fontSize = t.fontSize * this._deviceScale, t
					}
					createAutoCloseTimer() {
						const t = u.Translation.translate("Closes in ${sec} second").split("${sec}"),
							e = u.Translation.translate("Closes in ${sec} seconds").split("${sec}");
						return new o.CountDownTimer(this._config.autoCloseText ? this._config.autoCloseText : {
							prefixTextSingular: t[0],
							prefixTextPlural: e[0],
							postfixSecondTextSingular: t[1],
							postfixSecondsTextPlural: e[1]
						})
					}
					onResize(t) {
						this._isShowing ? (this._screenWidth = t.width / this._layer.scale.x, this._screenHeight = t.height / this._layer.scale.y, this._orientationScale = t.orientation === l.Orientation.PORTRAIT ? this._config.portraitScale ? this._config.portraitScale : this.DEFAULT_PORTRAIT_SCALE : 1, this.createBackground && this.onResizeBackground && this.onResizeBackground(t), this.onResizeButton(t), this._autoClose && this.onResizeAutoCloseTimer(t), this.createGameGraphics && this.onResizeGameGraphics && this.onResizeGameGraphics(t), this.x = -this._layer.x / this._layer.scale.x, this.y = -this._layer.y / this._layer.scale.y, this._isResizeDirty = !1) : this._isResizeDirty = !0
					}
					onResizeButton(t) {
						const e = this.getScaledButtonSize();
						this._button.setSize(e.x, e.y, this._layer.scale.x * this._orientationScale), this._button.scale.set(this._orientationScale, this._orientationScale), this.setButtonPosition(t)
					}
					getScaledButtonSize() {
						const t = this._config.buttonSize ? this._config.buttonSize : this.DEFAULT_BUTTON_SIZE;
						return new PIXI.Point(t.x * this._deviceScale, t.y * this._deviceScale)
					}
					setButtonPosition(t) {
						this._button.position.set(.5 * this._screenWidth, .85 * this._screenHeight)
					}
					onResizeAutoCloseTimer(t) {
						const e = this._orientationScale * this._deviceScale;
						this._autoCloseTimer.setScale(e), this._autoCloseTimer.position.set(this._button.x, this._button.y + .5 * this._button.height + this._autoCloseTimer.height)
					}
					show(t, e) {
						this._isShowing = !0, this._isResizeDirty && this.onResize(this._resizeData), this._layer.addChild(this), this.startPresentation(t, e)
					}
					startPresentation(t, e) {
						e && e()
					}
					close(t) {
						this._isShowing && this.stopPresentation(t)
					}
					stopPresentation(t) {
						this._layer.removeChild(this), this._button.enabled = !1, t && t(), this._isShowing = !1
					}
					enableButton() {
						this._button.enabled = !0
					}
					startTimer(t, e) {
						this._autoClose && this._autoCloseTimer.start(t, e)
					}
					stopTimer() {
						this._autoClose && this._autoCloseTimer.abort()
					}
				}
				e.ScreenView = p
			},
			15904: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ScreenEvent = void 0;
				class i {}
				i.GAME_RESTORE = "screenEvent_gameRestore", i.GAME_READY = "screenEvent_gameReady", i.GAME_START = "screenEvent_gameStart", i.SCREEN_START = "screenEvent_screenStart", i.SCREEN_CLOSED = "screenEvent_screenClosed", i.PICK_AND_CLICK_START = "screenEvent_pickAndClickStart", i.PICK_AND_CLICK_CLOSED = "screenEvent_pickAndClickClosed", i.BET_OPTION_CHANGED = "screenEvent_betOptionChanged", e.ScreenEvent = i
			},
			80781: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ServerController = void 0;
				const n = i(70713),
					s = i(52409),
					o = i(44679),
					r = i(28147),
					a = i(13182),
					l = i(82210),
					h = i(330),
					u = i(17206);
				class c {
					get data() {
						return c._latestData
					}
					get initData() {
						return this._parsedInitData
					}
					get gameData() {
						return this._parsedGameData
					}
					constructor() {
						this._initComplete = !1, this._dataParser = r.GameModuleConfig.instance.SERVER_PARSER ? r.GameModuleConfig.instance.SERVER_PARSER() : new u.ServerDataParser, s.EventHandler.addLastEventListener(this, h.ServerEvent.INIT_DATA_RECEIVED, (t => this.onInitDataReceived(t.params[0]))), s.EventHandler.addLastEventListener(this, h.ServerEvent.GAME_DATA_RECEIVED, (t => this.onGameDataReceived(t.params[0]))), n.DevConsole.addCommand("printLatestData", (() => {
							console.log(this.data)
						})), n.DevConsole.addCommand("printGameData", (() => {
							console.log(this.gameData)
						})), n.DevConsole.addCommand("printInitData", (() => {
							console.log(this.initData)
						}))
					}
					onInitDataReceived(t) {
						this._parsedInitData = r.GameModuleConfig.instance.PARSED_INIT_DATA ? r.GameModuleConfig.instance.PARSED_INIT_DATA(t, this._dataParser) : new l.ParsedInitData(t, this._dataParser), c._latestData = this._parsedInitData, this.tryDispatchInitParsed(), s.EventHandler.removeLastEventListener(this, h.ServerEvent.INIT_DATA_RECEIVED)
					}
					onGameDataReceived(t) {
						this._parsedGameData = r.GameModuleConfig.instance.PARSED_GAME_DATA ? r.GameModuleConfig.instance.PARSED_GAME_DATA(t, this._dataParser) : new a.ParsedGameData(t, this._dataParser), c._latestData = this._parsedGameData, s.EventHandler.dispatchEvent(new o.GameEvent(h.ServerEvent.GAME_DATA_PARSED, this.gameData))
					}
					initComplete() {
						this._initComplete = !0, this.tryDispatchInitParsed()
					}
					tryDispatchInitParsed() {
						this._initComplete && null != this._parsedInitData && s.EventHandler.dispatchEvent(new o.GameEvent(h.ServerEvent.INIT_DATA_PARSED, this.initData))
					}
					static getData() {
						return c._latestData
					}
				}
				e.ServerController = c
			},
			17206: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ServerDataParser = void 0;
				const n = i(46334),
					s = i(75367),
					o = i(55058),
					r = i(52475);
				class a {
					constructor() {}
					parseMode(t) {
						return t.mode
					}
					parseNextMode(t) {
						return t.nextMode
					}
					parseReels(t) {
						return a.parseStackedSymbolsInReels(t.reels)
					}
					static parseStackedSymbolsInReels(t, e) {
						let i = [];
						for (let n = 0; n < t.length; n++) null == s.GameConfig.instance.STACKED_SYMBOLS ? i.push(t[n].concat()) : i.push(this.parseStackedSymbolsInReel(t[n], n, null == e ? void 0 : e[n]));
						return i
					}
					static parseStackedSymbolsInReel(t, e, i) {
						const s = t.concat(),
							r = [];
						if (null == i) {
							let t = o.StateReelSymbol.parseStackedSymbolName(s[s.length - 1], e);
							if (t.isStacked) {
								let n;
								for (n = 1; n < s.length; n++) {
									const i = o.StateReelSymbol.parseStackedSymbolName(s[s.length - 1 - n], e);
									if (!i.isStacked || i.symName !== t.symName) break;
									t = i
								}
								n %= t.totalNum, i = `${t.symName}*${n.toString()}`
							} else i = "NonStackedDummySym"
						}
						for (; s.length > 0;) {
							const a = o.StateReelSymbol.parseStackedSymbolName(r.length > 0 ? r[0] : i, e),
								l = o.StateReelSymbol.parseStackedSymbolName(s.pop(), e);
							if (a.isStacked && a.index > 0) {
								if (!l.isStacked || l.symName !== a.symName) throw n.Logger.logDev("If you are using the outcome setter, this might be a case that the outcome made an illegal server data. Please take to the server dev to check if that worth a fix."), new Error(`ServerDataParser.parseStackedSymbolsInReel():reelId = ${e}, reelData = ${t.toString()}, symName = ${l.symName}, the symbol should be ${l.totalNum}-stacked!`);
								r.unshift(`${l.symName}*${(a.index-1).toString()}`)
							} else l.isStacked ? r.unshift(`${l.symName}*${(l.totalNum-1).toString()}`) : r.unshift(l.symName)
						}
						return r
					}
					parseNextReelSetName(t) {
						return t.reelsNextSpin
					}
					parseInitReelSet(t) {
						return t.initReelSet ? t.initReelSet : (n.Logger.logDev("ServerDataParser.parseInitReelSet(): initReelSet is missing, use nextReelSetName for init. This might not be a problem if your game doesn't have full Stacked reel."), this.parseNextReelSetName(t))
					}
					parseTotalWin(t) {
						return null != t.accumulatedRoundWin ? parseFloat(t.accumulatedRoundWin) : 0
					}
					parseCurrentMultiplier(t) {
						return null != t.currentMultiplier ? t.currentMultiplier : 1
					}
					parseOverlayWilds(t) {
						return t.overlayWilds
					}
					parseFreespinsLeft(t) {
						return null != t.freespinsLeft ? t.freespinsLeft : 0
					}
					parseFreespinTriggeredThisSpin(t) {
						return null != t.freespinTriggeredThisSpin && t.freespinTriggeredThisSpin
					}
					parseAddedNumberOfFreespinsThisSpin(t) {
						return null != t.addedNumberOfFreespinsThisSpin ? t.addedNumberOfFreespinsThisSpin : 0
					}
					parseReplayNextPlayerInteraction(t) {
						if (r.GameSetting.replayMode) return t.nextPlayerInteraction
					}
					parseScatterPositionsEnteringFreespin(t) {
						return t.scatterPositionsEnteringFreespin
					}
					parseBetLines(t) {
						return t.betLines
					}
					parseSymbolValues(t) {
						return t.symbolValues
					}
					parseIsRestoreState(t) {
						return t.isRestoreState
					}
					parseBetWins(t) {
						switch (s.GameConfig.instance.BET_WIN_MODE) {
							case 1:
								return t.betLineWins;
							case 2:
								return t.betWayWins;
							default:
								throw new Error("ServerDataParser.parseBetWins(): Invalid BetWinMode from GameConfig!")
						}
					}
					parseSingleWin(t) {
						return parseFloat(t.totalSpinWinnings)
					}
					parsePlayedBetValue(t) {
						return parseFloat(t.playedBetValue)
					}
					parseWasFeatureBuy(t) {
						return t.wasFeatureBuy
					}
					parseScatterPositions(t) {
						return t.scatterPositions
					}
					parseReelsEnteringFreespin(t) {
						if (null != t.reelsEnteringFreespin) return a.parseStackedSymbolsInReels(t.reelsEnteringFreespin)
					}
					parseBetLineWinsEnteringFreespin(t) {
						return t.betLineWinsEnteringFreespin
					}
					parseNumberOfFreespinsPlayed(t) {
						return t.numberOfFreespinsPlayed
					}
				}
				e.ServerDataParser = a
			},
			13182: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ParsedGameData = void 0;
				const n = i(75367),
					s = i(46379);
				class o extends s.ParsedServerData {
					get betWins() {
						return this._betWins
					}
					get singleWin() {
						return this._singleWin
					}
					get playedBetValue() {
						return this._playedBetValue
					}
					get wasFeatureBuy() {
						return this._wasFeatureBuy
					}
					get reelsEnteringFreespin() {
						return this._reelsEnteringFreespin
					}
					get betLineWinsEnteringFreespin() {
						return this._betLineWinsEnteringFreespin
					}
					get scatterPositionsEnteringFreespin() {
						return this._scatterPositionsEnteringFreespin
					}
					get currentWinRatio() {
						return this._currentWinRatio
					}
					get isBigWin() {
						return this._isBigWin
					}
					get currentWinRatioConfig() {
						return this._currentWinRatioConfig
					}
					constructor(t, e) {
						super(t, e), this._betWins = e.parseBetWins(t), this._singleWin = e.parseSingleWin(t), this._playedBetValue = e.parsePlayedBetValue(t), this._reelsEnteringFreespin = e.parseReelsEnteringFreespin(t), this._betLineWinsEnteringFreespin = e.parseBetLineWinsEnteringFreespin(t), this._scatterPositionsEnteringFreespin = e.parseScatterPositionsEnteringFreespin(t), this._wasFeatureBuy = e.parseWasFeatureBuy(t), this._currentWinRatio = this._singleWin / this._playedBetValue, this._isBigWin = this._currentWinRatio >= n.GameConfig.instance.WIN_RATIOS.bigWin[0].ratio, this._currentWinRatioConfig = o.getWinRatioConfig(this._currentWinRatio)
					}
					static getWinRatioConfig(t) {
						let e = n.GameConfig.instance.WIN_RATIOS.normalWin.concat();
						e = e.concat(n.GameConfig.instance.WIN_RATIOS.bigWin);
						for (let i = e.length - 1; i >= 0; i--) {
							const n = e[i];
							if (t >= n.ratio) return n
						}
						return null
					}
					parseScatterPositions(t, e) {
						return e.parseScatterPositions(t)
					}
				}
				e.ParsedGameData = o
			},
			82210: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ParsedInitData = void 0;
				const n = i(46379);
				class s extends n.ParsedServerData {
					get betLines() {
						return this._betLines
					}
					get symbolValues() {
						return this._symbolValues
					}
					get isRestoreState() {
						return this._isRestoreState
					}
					get initReelSet() {
						return this._initReelSet
					}
					constructor(t, e) {
						super(t, e), this._betLines = e.parseBetLines(t), this._symbolValues = e.parseSymbolValues(t), this._isRestoreState = e.parseIsRestoreState(t), this._initReelSet = e.parseInitReelSet(t)
					}
					parseScatterPositions(t, e) {
						return e.parseScatterPositionsEnteringFreespin(t)
					}
				}
				e.ParsedInitData = s
			},
			46379: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ParsedServerData = void 0;
				const n = i(83673);
				e.ParsedServerData = class {
					get mode() {
						return this._mode
					}
					get nextMode() {
						return this._nextMode
					}
					get reels() {
						return this._reels
					}
					get nextReelSetName() {
						return this._nextReelSetName
					}
					get totalWin() {
						return this._totalWin
					}
					get currentMultiplier() {
						return this._currentMultiplier
					}
					get overlayWilds() {
						return this._overlayWilds
					}
					get scatterPositions() {
						return this._scatterPositions
					}
					get freespinsLeft() {
						return this._freespinsLeft
					}
					get freespinTriggeredThisSpin() {
						return this._freespinTriggeredThisSpin
					}
					get addedNumberOfFreespinsThisSpin() {
						return this._addedNumberOfFreespinsThisSpin
					}
					get numberOfFreespinsPlayed() {
						return this._numberOfFreespinsPlayed
					}
					get isTotalWin() {
						return this._isTotalWin
					}
					get isNextTotalWin() {
						return this._isNextTotalWin
					}
					get replayNextPlayerInteraction() {
						return this._replayNextPlayerInteraction
					}
					constructor(t, e) {
						this._mode = e.parseMode(t), this._nextMode = e.parseNextMode(t), this._reels = e.parseReels(t), this._nextReelSetName = e.parseNextReelSetName(t), this._totalWin = e.parseTotalWin(t), this._currentMultiplier = e.parseCurrentMultiplier(t), this._overlayWilds = e.parseOverlayWilds(t), this._scatterPositions = this.parseScatterPositions(t, e), this._freespinsLeft = e.parseFreespinsLeft(t), this._freespinTriggeredThisSpin = e.parseFreespinTriggeredThisSpin(t), this._addedNumberOfFreespinsThisSpin = e.parseAddedNumberOfFreespinsThisSpin(t), this._numberOfFreespinsPlayed = e.parseNumberOfFreespinsPlayed(t), this._replayNextPlayerInteraction = e.parseReplayNextPlayerInteraction(t), this._isTotalWin = this.parseIsTotalWin(t), this._isNextTotalWin = this.parseIsNextTotalWin(t)
					}
					parseIsTotalWin(t) {
						return this.isRespin(t) || this.isFreespin(t) || this.isFreespinTriggered(t) || this.isFeatureTotalWin(t)
					}
					parseIsNextTotalWin(t) {
						return this.isNextRespin(t) || this.isNextFreespin(t) || this.isNextFeatureTotalWin(t)
					}
					isRespin(t) {
						return this.mode === n.GameMode.RESPIN || this.mode === n.GameMode.NORMAL_AVALANCHE || this.mode === n.GameMode.FREESPIN_AVALANCHE
					}
					isFreespin(t) {
						return this.mode === n.GameMode.FREESPIN
					}
					isFreespinTriggered(t) {
						return this.freespinTriggeredThisSpin
					}
					isFeatureTotalWin(t) {
						return !1
					}
					isNextRespin(t) {
						return this.nextMode === n.GameMode.RESPIN || this.nextMode === n.GameMode.NORMAL_AVALANCHE || this.nextMode === n.GameMode.FREESPIN_AVALANCHE
					}
					isNextFreespin(t) {
						return this.nextMode === n.GameMode.FREESPIN
					}
					isNextFeatureTotalWin(t) {
						return !1
					}
				}
			},
			330: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ServerEvent = void 0;
				class i {}
				i.INIT_DATA_RECEIVED = "serverEvent_initDataReceived", i.INIT_DATA_PARSED = "serverEvent_initDataParsed", i.GAME_DATA_RECEIVED = "serverEvent_gameDataReceived", i.GAME_DATA_PARSED = "serverEvent_gameDataParsed", e.ServerEvent = i
			},
			52475: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GameSetting = e.AssetsQualitySetting = void 0;
				const n = i(88424),
					s = i(56665);
				var o;
				! function(t) {
					t[t.NONE = 0] = "NONE", t[t.LOW = 1] = "LOW", t[t.MEDIUM = 2] = "MEDIUM", t[t.HIGH = 3] = "HIGH"
				}(o = e.AssetsQualitySetting || (e.AssetsQualitySetting = {}));
				class r {
					constructor(t) {
						if (r._instance) throw new Error("Error: GameSetting.constructor() - Instantiation failed: Singleton.");
						r._instance = this, r._instance._apiAdapter = t, r._quality = r.getQualitySetting(t.getQuality()), r._smartLoading = t.getSmartLoading(), r._replayMode = t.getReplayMode()
					}
					static getQualitySetting(t) {
						switch (t) {
							case "high":
								return o.HIGH;
							case "medium":
								return o.MEDIUM;
							case "low":
								return o.LOW;
							default:
								return o.NONE
						}
					}
					static get quality() {
						return r._quality
					}
					static get smartLoading() {
						return r._smartLoading
					}
					static get replayMode() {
						return r._replayMode
					}
					static get isDevMode() {
						return r.DEFAULT_DEV_MODE || r._runTimeDevMode
					}
					static set isDevMode(t) {
						r._runTimeDevMode = t
					}
					static get isFastSpin() {
						var t, e;
						if (null === (t = r._instance) || void 0 === t ? void 0 : t._apiAdapter) return null !== (e = r._instance._apiAdapter.isFastSpin()) && void 0 !== e && e;
						throw new Error("Error: GameSetting.isFastSpin: GameSetting is not initialized!")
					}
					static get isSoundLoopOn() {
						var t, e;
						if (null === (t = r._instance) || void 0 === t ? void 0 : t._apiAdapter) return null !== (e = r._instance._apiAdapter.isSoundLoopOn()) && void 0 !== e && e;
						throw new Error("Error: GameSetting.isSoundLoopOn: GameSetting is not initialized!")
					}
					static get isSoundEffectsOn() {
						var t, e;
						if (null === (t = r._instance) || void 0 === t ? void 0 : t._apiAdapter) return null !== (e = r._instance._apiAdapter.isSoundEffectsOn()) && void 0 !== e && e;
						throw new Error("Error: GameSetting.isSoundEffectsOn: GameSetting is not initialized!")
					}
					static get isLeftHanded() {
						var t, e;
						if (null === (t = r._instance) || void 0 === t ? void 0 : t._apiAdapter) return null !== (e = r._instance._apiAdapter.isLeftHanded()) && void 0 !== e && e;
						throw new Error("Error: GameSetting.isLeftHanded: GameSetting is not initialized!")
					}
					static get isAutoplayRound() {
						var t, e;
						if (null === (t = r._instance) || void 0 === t ? void 0 : t._apiAdapter) return null !== (e = r._instance._apiAdapter.isAutoplayRound()) && void 0 !== e && e;
						throw new Error("Error: GameSetting.isAutoPlayRound: GameSetting is not initialized!")
					}
					static get isNextAutoplayRound() {
						var t, e;
						if (null === (t = r._instance) || void 0 === t ? void 0 : t._apiAdapter) return null !== (e = r._instance._apiAdapter.isNextAutoplayRound()) && void 0 !== e && e;
						throw new Error("Error: GameSetting.isNextAutoplayRound: GameSetting is not initialized!")
					}
					static getDefaultQualities() {
						if (0 == r.smartLoading) switch (r.quality) {
							case o.HIGH:
								return [n.AssetQualityLevel.HIGH];
							case o.MEDIUM:
								return [n.AssetQualityLevel.MEDIUM];
							case o.LOW:
								return [n.AssetQualityLevel.LOW];
							default:
								return s.UserAgent.isMobile ? [n.AssetQualityLevel.MEDIUM] : [n.AssetQualityLevel.HIGH]
						}
						switch (r.quality) {
							case o.HIGH:
								return [n.AssetQualityLevel.MEDIUM, n.AssetQualityLevel.HIGH];
							case o.MEDIUM:
								return [n.AssetQualityLevel.LOW, n.AssetQualityLevel.MEDIUM];
							case o.LOW:
								return [n.AssetQualityLevel.LOW];
							default:
								return s.UserAgent.isMobile ? [n.AssetQualityLevel.LOW, n.AssetQualityLevel.MEDIUM] : [n.AssetQualityLevel.MEDIUM, n.AssetQualityLevel.HIGH]
						}
					}
				}
				r.DEFAULT_DEV_MODE = !1, e.GameSetting = r
			},
			72361: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SlotApiAdapter = void 0;
				const n = i(11195),
					s = i(30835),
					o = i(23110);
				class r {
					constructor(t) {
						if (r._instance) throw new Error("Error: SlotApiAdapter.constructor() - Instantiation failed: Singleton.");
						r._instance = this, this._slotApi = t, this._eventManager = new n.SlotApiEventManager(this._slotApi)
					}
					getReady() {
						this._eventManager.addPluginEventListener()
					}
					translate(t) {
						return this._slotApi.translations.translate(t)
					}
					formatCurrency(t, e) {
						return this._slotApi.currency.format(t, e)
					}
					formatCurrencyValue(t, e) {
						return this._slotApi.currency.formatValue(t, e)
					}
					get hideCurrency() {
						return this._slotApi.options.hideCurrency
					}
					isFastSpin() {
						return this.getSettings(s.APISetting.FAST_SPIN)
					}
					isSoundLoopOn() {
						return this.getSettings(s.APISetting.MUSIC)
					}
					isSoundEffectsOn() {
						return this.getSettings(s.APISetting.SFX)
					}
					getSettings(t) {
						return this._slotApi.settings.get(t)
					}
					getDevice() {
						return this._slotApi.options.device
					}
					getQuality() {
						return this._slotApi.options.quality
					}
					getSmartLoading() {
						return !0 === this._slotApi.options.smartLoading
					}
					getReplayMode() {
						return null != this._slotApi.options.replay
					}
					isLeftHanded() {
						return this.getSettings(s.APISetting.LEFT_HAND_MODE)
					}
					isAutoplayRound() {
						return o.SlotGame.autoPlay.isAutoplayRound
					}
					isNextAutoplayRound() {
						return o.SlotGame.autoPlay.isAutoplayRound && o.SlotGame.autoPlay.rounds > 0
					}
				}
				e.SlotApiAdapter = r
			},
			11195: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SlotApiEventManager = void 0;
				const n = i(59848),
					s = i(11084),
					o = i(52409),
					r = i(44679),
					a = i(75367),
					l = i(69363),
					h = i(330),
					u = i(32696),
					c = i(72519),
					d = i(57284),
					p = i(78973),
					_ = i(46334),
					m = i(47159),
					g = i(30835),
					f = i(34365),
					S = i(23110),
					y = i(72468),
					v = i(97182),
					T = i(41122),
					E = i(49490);
				e.SlotApiEventManager = class {
					constructor(t) {
						this._slotApi = t, this.initSlotApiEvents(), this.initGameEvents()
					}
					initSlotApiEvents() {
						this._slotApi.events.on(m.SlotApiEvent.INIT, this.onInit), this._slotApi.events.on(m.SlotApiEvent.CONFIG, this.onConfig), this._slotApi.events.on(m.SlotApiEvent.RESIZE, this.onResize), this._slotApi.events.on(m.SlotApiEvent.FAST_SPIN, this.onFastspin), this._slotApi.events.on(m.SlotApiEvent.READY, this.onReady), this._slotApi.events.on(m.SlotApiEvent.STATE, this.onState), this._slotApi.events.on(m.SlotApiEvent.BET, this.onBet), this._slotApi.events.on(m.SlotApiEvent.CURRENCY, this.onCurrency), this._slotApi.events.on(m.SlotApiEvent.BALANCE, this.onBalance), this._slotApi.events.on(m.SlotApiEvent.BET_LEVELS, this.onBetLevels), this._slotApi.events.on(m.SlotApiEvent.FREE_BETS, this.onFreeBets), this._slotApi.events.on(m.SlotApiEvent.GAME, this.onGame), this._slotApi.events.on(m.SlotApiEvent.STOP, this.onStop), this._slotApi.events.on(m.SlotApiEvent.SKIP, this.onKeypadSkip), this._slotApi.events.on(m.SlotApiEvent.MIN_SPIN_TIME, this.onMinSpinTime), this._slotApi.settings.on(g.APISetting.SFX, this.onSoundEffectSetting), this._slotApi.settings.on(g.APISetting.MUSIC, this.onSoundLoopSetting), this._slotApi.settings.on(g.APISetting.LEFT_HAND_MODE, this.onLeftHanded), this._slotApi.events.on(E.APIEvent.ACTION_SPINS_IS_ACTIVE, (t => this.onActionSpins(t)))
					}
					onActionSpins(t) {
						o.EventHandler.enabled = !t
					}
					addPluginEventListener() {
						S.SlotGame.keypad.events.on(v.KeypadPluginEvents.DISPLAY_BET_UPDATE, (t => this.onCurrentBet(t)))
					}
					onInit(t) {
						o.EventHandler.dispatchEvent(new r.GameEvent(h.ServerEvent.INIT_DATA_RECEIVED, t))
					}
					onConfig(t) {
						o.EventHandler.dispatchEvent(new r.GameEvent(p.SystemEvent.CONFIG_LOADED, t))
					}
					onResize(t) {
						o.EventHandler.dispatchEvent(new r.GameEvent(d.StageEvent.CONTAINER_RESIZED, t))
					}
					onSoundEffectSetting(t) {
						o.EventHandler.dispatchEvent(new r.GameEvent(l.SoundEvent.EFFECTS_SETTING, t))
					}
					onSoundLoopSetting(t) {
						o.EventHandler.dispatchEvent(new r.GameEvent(l.SoundEvent.LOOPS_SETTING, t))
					}
					onLeftHanded(t) {
						o.EventHandler.dispatchEvent(new r.GameEvent(d.StageEvent.LEFT_HANDED_SETTING, t))
					}
					onFastspin(t) {
						o.EventHandler.dispatchEvent(new r.GameEvent(u.SpinEvent.FASTSPIN, t))
					}
					onReady() {
						o.EventHandler.dispatchEvent(new r.GameEvent(m.SlotApiEventIntroCommand.API_READY))
					}
					onButtonPosition(t) {
						o.EventHandler.dispatchEvent(new r.GameEvent(m.SlotApiEvent.BUTTON_POSITION, t))
					}
					onState(t) {
						t === T.SlotState.GAMBLE_DONE && o.EventHandler.dispatchEvent(new r.GameEvent(m.SlotApiEvent.GAMBLE_DONE))
					}
					onBet(t) {
						o.EventHandler.dispatchEvent(new r.GameEvent(n.BalanceEvent.BET, t))
					}
					onCurrency(t) {
						o.EventHandler.dispatchEvent(new r.GameEvent(n.BalanceEvent.CURRENCY, t))
					}
					onBalance(t) {
						o.EventHandler.dispatchEvent(new r.GameEvent(n.BalanceEvent.BALANCE, t))
					}
					onBetLevels(t) {
						o.EventHandler.dispatchEvent(new r.GameEvent(n.BalanceEvent.BET_LEVELS, t))
					}
					onFreeBets(t) {
						o.EventHandler.dispatchEvent(new r.GameEvent(n.BalanceEvent.FREE_BETS, t))
					}
					onGame(t) {
						S.SlotGame.jackpot && S.SlotGame.jackpot.isActive ? S.SlotGame.jackpot.addOnSpinCompleteCallback((() => {
							o.EventHandler.dispatchEvent(new r.GameEvent(h.ServerEvent.GAME_DATA_RECEIVED, t))
						})) : o.EventHandler.dispatchEvent(new r.GameEvent(h.ServerEvent.GAME_DATA_RECEIVED, t))
					}
					onStop() {
						o.EventHandler.dispatchEvent(new r.GameEvent(u.SpinEvent.STOP, !0))
					}
					onKeypadSkip() {
						o.EventHandler.dispatchEvent(new r.GameEvent(u.SpinEvent.SKIP))
					}
					onCurrentBet(t) {
						o.EventHandler.dispatchEvent(new r.GameEvent(n.BalanceEvent.CURRENT_BET, t))
					}
					onMinSpinTime(t) {
						let e = t / 1e3;
						a.GameConfig.instance.MIN_STOPPING_TIME && (e = Math.max(0, e - a.GameConfig.instance.MIN_STOPPING_TIME)), c.SpinController.MIN_SPIN_TIME = e, o.EventHandler.dispatchEvent(new r.GameEvent(f.JurisdictionEvent.MINIMUM_STOP_TIME, t))
					}
					initGameEvents() {
						o.EventHandler.addEventListener(this, n.BalanceEvent.ZERO_BET, (t => this.onZeroBet(t.params[0]))), o.EventHandler.addEventListener(this, n.BalanceEvent.PICK_AND_CLICK, (t => this.onPickAndClick(t.params[0]))), o.EventHandler.addEventListener(this, u.SpinEvent.STARTED, (t => this.onSpinStarted())), o.EventHandler.addEventListener(this, u.SpinEvent.STOPPED, (t => this.onSpinStopped())), o.EventHandler.addEventListener(this, u.SpinEvent.WANT_SKIPPABLE, (t => this.onSpinWantSkippable())), o.EventHandler.addEventListener(this, u.SpinEvent.DONE, (t => this.onSpinDone())), o.EventHandler.addEventListener(this, u.SpinEvent.FINISHING, (t => this.onSpinFinishing())), o.EventHandler.addEventListener(this, u.SpinEvent.FINISH, (t => this.onSpinFinish())), o.EventHandler.addEventListener(this, d.StageEvent.WANT_RESIZE, (t => this.onWantResize())), o.EventHandler.addEventListener(this, s.ErrorEvent.ERROR, (t => this.onGameError(t))), o.EventHandler.addEventListener(this, p.SystemEvent.SHOW_DIALOG, (t => this.showDialog(t.params[0])))
					}
					onZeroBet(t) {
						this._slotApi.betHandler.zeroBet(), null == t && (t = -1), S.SlotGame.keypad.setZeroBetSpinCounter(t)
					}
					onPickAndClick(t) {
						this._slotApi.betHandler.pickAndClickBet(t)
					}
					onSpinStarted() {
						this._slotApi.events.trigger(m.SlotApiEvent.STARTED)
					}
					onSpinStopped() {
						this._slotApi.events.trigger(m.SlotApiEvent.STOP)
					}
					onSpinWantSkippable() {
						this._slotApi.events.trigger(m.SlotApiEvent.SKIPPABLE)
					}
					onSpinDone() {
						this._slotApi.events.trigger(m.SlotApiEvent.DONE)
					}
					onSpinFinishing() {
						this._slotApi.events.trigger(m.SlotApiEvent.FINISHING)
					}
					onSpinFinish() {
						this._slotApi.events.trigger(m.SlotApiEvent.FINISH)
					}
					onWantResize() {
						_.Logger.warn("Requesting resize is bad for performance and should be avoided if possible."), y.NolimitApplication.pixiApp.resize()
					}
					onGameError(t) {
						this._slotApi.events.trigger(m.SlotApiEvent.ERROR, {
							code: t.code,
							message: t.errorMessage
						})
					}
					showDialog(t) {}
				}
			},
			47159: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SlotApiEventIntroCommand = e.SlotApiEvent = void 0;
				class i {}
				i.INIT = "init", i.CONFIG = "config", i.INTRO = "intro", i.CUSTOM = "custom", i.RESIZE = "resize", i.TICK = "tick", i.ERROR = "error", i.BET = "bet", i.BET_LEVELS = "betLevels", i.BALANCE = "balance", i.CURRENCY = "currency", i.FREE_BETS = "freeBets", i.AUTO_PLAY = "autoplay", i.FAST_SPIN = "fastspin", i.READY = "ready", i.GAME = "game", i.STARTING = "starting", i.STARTED = "started", i.STOPPABLE = "stoppable", i.STOP = "stop", i.STOPPING = "stopping", i.SKIPPABLE = "skippable", i.SKIP = "skip", i.SKIPPED = "skipped", i.DONE = "done", i.FINISHING = "finishing", i.FINISH = "finish", i.STATE = "state", i.LOADING = "loading", i.AUDIO = "audio", i.UPDATE_FREESPINS_LEFT = "updateFreeSpins", i.CURRENT_BET = "currentBet", i.MIN_SPIN_TIME = "minSpinTime", i.BUTTON_POSITION = "buttonPosition", i.GAMBLE_DONE = "gambleDone", e.SlotApiEvent = i;
				class n {}
				n.SHOW = "show", n.CLOSE = "close", n.API_READY = "apiReady", e.SlotApiEventIntroCommand = n
			},
			72519: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SpinController = void 0;
				const n = i(46334),
					s = i(13006),
					o = i(59848),
					r = i(52409),
					a = i(44679),
					l = i(75367),
					h = i(89768),
					u = i(91812),
					c = i(15904),
					d = i(79752),
					p = i(330),
					_ = i(52475),
					m = i(34785),
					g = i(57992),
					f = i(48918),
					S = i(32696),
					y = i(23110),
					v = i(82748),
					T = i(47159),
					E = i(83673);
				class b {
					constructor() {
						this._zeroBetManager = this.createZeroBetManager(), this._screenManager = this.createScreenManager(), this._pickAndClickManager = this.createPickAndClickManager(), this._isQuickStop = !1, this._isSpinning = !1, this._stopDataReceived = !1, this._stopActionReceived = !1, this._stopDelay = 0, this.addEventListeners()
					}
					createZeroBetManager() {
						return new f.ZeroBetManager
					}
					createScreenManager() {
						return new d.ScreenManager
					}
					createPickAndClickManager() {
						return new h.PickAndClickManager
					}
					addEventListeners() {
						r.EventHandler.addEventListener(this, p.ServerEvent.INIT_DATA_PARSED, (t => this.onGameDataParsed(t.params[0]))), r.EventHandler.addLastEventListener(this, p.ServerEvent.GAME_DATA_PARSED, (t => this.onGameDataParsed(t.params[0]))), r.EventHandler.addEventListener(this, c.ScreenEvent.GAME_READY, (t => this.onGameReady())), r.EventHandler.addLastEventListener(this, c.ScreenEvent.GAME_START, (t => this.onGameStart())), r.EventHandler.addEventListener(this, T.SlotApiEvent.GAMBLE_DONE, (t => this.onGambleDone())), r.EventHandler.addLastEventListener(this, o.BalanceEvent.BET, (t => this.onBet(t.params[0]))), r.EventHandler.addEventListener(this, u.ReelEvent.ALL_REELS_SPIN_STARTED, (t => this.onAllReelsSpinStarted())), r.EventHandler.addEventListener(this, S.SpinEvent.STOP, (t => this.onStop(t.params[0]))), r.EventHandler.addLastEventListener(this, u.ReelEvent.ALL_REELS_SPIN_STOPPED, (t => this.onAllReelsSpinStopped())), r.EventHandler.addEventListener(this, S.SpinEvent.ADD_STOP_DELAY, (t => this.addStopDelay(t.params[0]))), r.EventHandler.addEventListener(this, g.WinPresentationEvent.ALL_PRESENTATIONS_COMPLETED, (t => this.onAllWinPresentationsCompleted())), r.EventHandler.addEventListener(this, c.ScreenEvent.SCREEN_CLOSED, (t => this.tryPlayZeroBet(!1)))
					}
					onGameDataParsed(t) {
						this._mode = t.mode, this._nextMode = t.nextMode, this.parseGameData && this.parseGameData(t), this._isSpinning && (this._stopDataReceived = !0, this._stopActionReceived && !this._isQuickStop && this.tryDelaySpin() || this.tryStop())
					}
					onGameReady() {
						r.EventHandler.dispatchEvent(new a.GameEvent(S.SpinEvent.IDLE))
					}
					onGameStart() {
						this.checkNext(!0)
					}
					onGambleDone() {
						this.checkNext(!1)
					}
					checkNext(t) {
						this.tryPickAndClick(t)
					}
					tryPickAndClick(t) {
						t && this._pickAndClickManager.tryRestoreSelectedPickAndClick() || this._pickAndClickManager.tryPlayPickAndClick() || this.tryPlayScreens(t)
					}
					tryPlayScreens(t) {
						this._screenManager.tryPlayScreen() || this.tryPlayZeroBet(t)
					}
					tryPlayZeroBet(t) {
						this._zeroBetManager.tryPlayZeroBet() || this.tryGamble(t)
					}
					tryGamble(t) {
						if (y.SlotGame.gamblePlugin && y.SlotGame.gamblePlugin.hasGamble()) y.SlotGame.gamblePlugin.startGamble();
						else {
							if (this._nextMode == E.GameMode.GAMBLE) throw new Error("Missing Gamble plugin");
							t || this.finishGameRound()
						}
					}
					finishGameRound() {
						r.EventHandler.dispatchEvent(new a.GameEvent(S.SpinEvent.IDLE)), n.Logger.logDev("Game Round Finished!"), r.EventHandler.dispatchEvent(new a.GameEvent(S.SpinEvent.FINISH))
					}
					onBet(t) {
						this._isQuickStop = !1, this._isSpinning = !0, this._mode = this._nextMode, this._nextMode = null, this._isZeroBet = this._zeroBetManager.isNextZeroBet(), t.type != v.APIBetType.GAMBLE_BET && (r.EventHandler.dispatchEvent(new a.GameEvent(S.SpinEvent.BEFORE_START, this.getReelsGameConfigFromPreviousGameData())), this.startSpin())
					}
					startSpin() {
						r.EventHandler.dispatchEvent(new a.GameEvent(S.SpinEvent.START, {
							isFastSpin: _.GameSetting.isFastSpin,
							activeReels: this.getReelsGameConfigFromPreviousGameData()
						}))
					}
					getReelsGameConfigFromPreviousGameData() {
						return m.ArrayHelper.initArrayWithValues(l.GameConfig.instance.REELS_NUM, (t => !0))
					}
					onAllReelsSpinStarted() {
						r.EventHandler.dispatchEvent(new a.GameEvent(S.SpinEvent.STARTED)), this.addStopDelay(this.getSpinTime()), this.onSpinTimerDone()
					}
					onSpinTimerDone() {
						this.tryDelaySpin() || this.wantStopSpin()
					}
					tryDelaySpin() {
						return this._stopDelay > 0 && (this._spinTimer = s.TweenLite.to(this, this._stopDelay, {
							onComplete: () => this.onSpinTimerDone()
						}), this._stopDelay = 0, !0)
					}
					getSpinTime() {
						const t = _.GameSetting.isFastSpin ? l.GameConfig.instance.REEL_FAST_SPIN_SPIN_TIME : l.GameConfig.instance.REEL_SPIN_TIME;
						return this._isZeroBet ? t : Math.max(t, b.MIN_SPIN_TIME)
					}
					addStopDelay(t) {
						this._stopDelay += t
					}
					onStop(t) {
						this._isSpinning && (t && (this._isQuickStop = !0), this.wantStopSpin())
					}
					wantStopSpin() {
						this._spinTimer && this._spinTimer.isActive() && (this._spinTimer.pause(), this._spinTimer.kill()), this._stopActionReceived = !0, this.tryStop()
					}
					tryStop() {
						this._stopActionReceived && this._stopDataReceived && r.EventHandler.dispatchEvent(new a.GameEvent(u.ReelEvent.ALL_REELS_STOP_SPIN, {
							quickStop: this._isQuickStop,
							fastSpin: _.GameSetting.isFastSpin
						}))
					}
					onAllReelsSpinStopped() {
						this._stopActionReceived = !1, this._stopDataReceived = !1, this._isSpinning = !1, this._stopDelay = 0, r.EventHandler.dispatchEvent(new a.GameEvent(S.SpinEvent.STOPPED))
					}
					onAllWinPresentationsCompleted() {
						n.Logger.logDev("SpinController.onAllWinPresentationCompleted()"), r.EventHandler.dispatchEvent(new a.GameEvent(S.SpinEvent.DONE)), this.checkNext(!1)
					}
					parseGameData(t) {}
				}
				b.MIN_SPIN_TIME = 0, e.SpinController = b
			},
			32696: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SpinEvent = void 0;
				class i {}
				i.RESTORE = "spinEvent_restore", i.BEFORE_START = "spinEvent_beforeStart", i.START = "spinEvent_start", i.STARTED = "spinEvent_started", i.STOP = "spinEvent_stop", i.STOPPED = "spinEvent_stopped", i.WANT_SKIPPABLE = "spinEvent_wantSkippable", i.SKIP = "spinEvent_skip", i.DONE = "spinEvent_done", i.IDLE = "spinEvent_idle", i.FINISHING = "spinEvent_finishing", i.FINISH = "spinEvent_finish", i.FASTSPIN = "spinSetting_fastspin", i.ADD_STOP_DELAY = "spinEvent_addStopDelay", i.INTRO = "SpinEvent_intro", e.SpinEvent = i
			},
			89951: (t, e) => {
				"use strict";
				var i, n, s;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LayerScaleOption = e.ScaleTarget = e.ScaleMethod = void 0, (s = e.ScaleMethod || (e.ScaleMethod = {})).NONE = "none", s.FIT = "fit", s.FILL = "fill", (n = e.ScaleTarget || (e.ScaleTarget = {})).NONE = "none", n.WINDOW = "window", n.STAGE = "stage", (i = e.LayerScaleOption || (e.LayerScaleOption = {})).NONE = "none", i.FIT_STAGE = "fitStage", i.FIT_WINDOW = "fitWINDOW", i.FILL_STAGE = "fillStage", i.FILL_WINDOW = "fillWindow", i.REELS_FIT_WINDOW = "reelsFitWindow", i.REELS_FIT_STAGE = "reelsFitStage"
			},
			66493: (t, e) => {
				"use strict";
				var i;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Orientation = void 0, (i = e.Orientation || (e.Orientation = {})).NONE = "notInitialized", i.LANDSCAPE = "landscape", i.PORTRAIT = "portrait"
			},
			75039: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ScalableLayer = void 0;
				const n = i(75367),
					s = i(56665),
					o = i(89951);
				class r extends PIXI.Container {
					get method() {
						return s.UserAgent.getDeviceDependentValue(this._method)
					}
					get target() {
						return s.UserAgent.getDeviceDependentValue(this._target)
					}
					get frame() {
						return s.UserAgent.getDeviceDependentValue(this._frame)
					}
					get placement() {
						return s.UserAgent.getDeviceDependentValue(this._placement)
					}
					set customOptions(t) {
						this.processCustomOptions(t)
					}
					constructor(t) {
						super(), this.name = t.name;
						const e = t.scaleOption || n.GameConfig.instance.DEFAULT_LAYER_SCALE_OPTION || o.LayerScaleOption.FIT_WINDOW;
						this._scaleOption = this.processOptions(e), this.processCustomOptions(t.customOptions)
					}
					processOptions(t) {
						return t = (0, s.isIDeviceDependentConfig)(t) ? t : {
							desktop: {
								landscape: t
							}
						}, this.setDeviceDependentPreset(t), t
					}
					setDeviceDependentPreset(t) {
						this._method = {
							desktop: {
								landscape: r.getMethodFromPreset()
							}
						}, this._target = {
							desktop: {
								landscape: r.getTargetFromPreset()
							}
						}, this._frame = {
							desktop: {
								landscape: r.getFrameFromPreset()
							}
						}, this._placement = {
							desktop: {
								landscape: r.getPlacementFromPreset()
							}
						};
						for (let e in t) {
							const i = t[e];
							this._method[e] = this._method[e] || {}, this._target[e] = this._target[e] || {}, this._frame[e] = this._frame[e] || {}, this._placement[e] = this._placement[e] || {};
							for (let t in i)
								if (i.hasOwnProperty(t)) {
									const n = i[t];
									this._method[e][t] = r.getMethodFromPreset(n), this._target[e][t] = r.getTargetFromPreset(n), this._frame[e][t] = r.getFrameFromPreset(n), this._placement[e][t] = r.getPlacementFromPreset(n)
								}
						}
					}
					processCustomOptions(t) {
						null != t && (null != t.method && (this._method = (0, s.isIDeviceDependentConfig)(t.method) ? t.method : {
							desktop: {
								landscape: t.method
							}
						}), null != t.target && (this._target = (0, s.isIDeviceDependentConfig)(t.target) ? t.target : {
							desktop: {
								landscape: t.target
							}
						}), null != t.frame && (this._frame = (0, s.isIDeviceDependentConfig)(t.frame) ? t.frame : {
							desktop: {
								landscape: t.frame
							}
						}), null != t.placement && (this._placement = (0, s.isIDeviceDependentConfig)(t.placement) ? t.placement : {
							desktop: {
								landscape: t.placement
							}
						}))
					}
					static getMethodFromPreset(t) {
						return t == o.LayerScaleOption.NONE ? o.ScaleMethod.NONE : t == o.LayerScaleOption.FILL_WINDOW || t == o.LayerScaleOption.FILL_STAGE ? o.ScaleMethod.FILL : o.ScaleMethod.FIT
					}
					static getTargetFromPreset(t) {
						return t == o.LayerScaleOption.NONE ? o.ScaleTarget.NONE : t == o.LayerScaleOption.FILL_STAGE || t == o.LayerScaleOption.FIT_STAGE || t == o.LayerScaleOption.REELS_FIT_STAGE ? o.ScaleTarget.STAGE : o.ScaleTarget.WINDOW
					}
					static getFrameFromPreset(t) {
						return t == o.LayerScaleOption.REELS_FIT_STAGE || t == o.LayerScaleOption.REELS_FIT_WINDOW ? r.getReelAreaFrame() : r.getGameFrame()
					}
					static getPlacementFromPreset(t) {
						return new PIXI.Point(.5, .5)
					}
					static getGameFrame() {
						return {
							x: 0,
							y: 0,
							width: n.GameConfig.instance.GAME_WIDTH,
							height: n.GameConfig.instance.GAME_HEIGHT
						}
					}
					static getReelAreaFrame() {
						return {
							x: n.GameConfig.instance.REEL_AREA_POS_X,
							y: n.GameConfig.instance.REEL_AREA_POS_Y,
							width: n.GameConfig.instance.REEL_AREA_WIDTH,
							height: n.GameConfig.instance.REEL_AREA_HEIGHT
						}
					}
				}
				e.ScalableLayer = r
			},
			85206: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.StageManager = void 0;
				const n = i(52409),
					s = i(44679),
					o = i(75367),
					r = i(52475),
					a = i(57244),
					l = i(57284),
					h = i(89951),
					u = i(66493),
					c = i(75039),
					d = i(46334),
					p = i(72468),
					_ = i(23110);
				class m extends PIXI.Container {
					static get stage() {
						return m._stage
					}
					static set renderer(t) {
						this._renderer = t
					}
					static get renderer() {
						return this._renderer
					}
					static get devicePixelRatio() {
						return m.renderer.resolution
					}
					static get orientation() {
						return this._orientation
					}
					static get resizeData() {
						return m._prevResizeData
					}
					constructor() {
						super(), m.renderer = p.NolimitApplication.pixiApp.renderer, this.createStage()
					}
					createStage() {
						m._stage = this, m._layers = {};
						const t = o.GameConfig.instance.LAYERS;
						for (let e in t) {
							const i = new c.ScalableLayer(t[e]);
							m._stage.addChild(i), m._layers[t[e].name] = i
						}
						p.NolimitApplication.addLayer("StageManager", m._stage)
					}
					addEventListeners() {
						n.EventHandler.addEventListener(this, l.StageEvent.ADD_TO_RENDER_LOOP, (t => this.onAddToRenderLoop(t.params[0]))), n.EventHandler.addFirstEventListener(this, l.StageEvent.LEFT_HANDED_SETTING, (t => this.onLeftHandedSetting(t.params[0])))
					}
					isResizeDataEqual(t, e) {
						return !(!t || !e) && t.orientation == e.orientation && t.width == e.width && t.height == e.height && t.top == e.top && t.bottom == e.bottom && t.left == e.left && t.right == e.right
					}
					onResize() {
						let t = p.NolimitApplication.isLandscape ? 100 : 238;
						t = _.SlotGame.keypad.showing ? t : 0;
						const e = {
							top: 0,
							bottom: p.NolimitApplication.screenBounds.height - t,
							left: 0,
							right: p.NolimitApplication.screenBounds.width,
							width: p.NolimitApplication.screenBounds.width,
							height: p.NolimitApplication.screenBounds.height,
							orientation: p.NolimitApplication.isLandscape ? u.Orientation.LANDSCAPE : u.Orientation.PORTRAIT,
							isLeftHanded: r.GameSetting.isLeftHanded
						};
						this.onResizeInternal(e)
					}
					onResizeInternal(t) {
						this.isResizeDataEqual(m._prevResizeData, t) || (d.Logger.logDev(`StageManager.onResize():ratio = ${window.devicePixelRatio}, l = ${t.left}, r = ${t.right}, t = ${t.top}, b = ${t.bottom}, w = ${t.width}, h = ${t.height}, o = ${t.orientation}.`), m._prevResizeData = t, m._orientation = t.orientation, m.legacyScaling && (m._stage.position.set(p.NolimitApplication.screenBounds.left, p.NolimitApplication.screenBounds.top), m.scaleLayers(t)), n.EventHandler.dispatchEvent(new s.GameEvent(l.StageEvent.STAGE_RESIZED, t)))
					}
					onLeftHandedSetting(t) {
						m._prevResizeData && (m._prevResizeData.isLeftHanded = t, n.EventHandler.dispatchEvent(new s.GameEvent(l.StageEvent.STAGE_RESIZED, m._prevResizeData)))
					}
					static scaleLayers(t) {
						for (let e in m._layers) {
							const i = m.getLayer(e);
							if (i.method == h.ScaleMethod.NONE || i.target == h.ScaleTarget.NONE) continue;
							let n, s = 1;
							n = i.target == h.ScaleTarget.STAGE ? new PIXI.Rectangle(t.left, t.top, t.right - t.left, t.bottom - t.top) : new PIXI.Rectangle(t.left, t.top, t.width, t.height), s = i.method == h.ScaleMethod.FILL ? a.MathHelper.ceilToDecimals(Math.max(n.width / i.frame.width, n.height / i.frame.height), 4) : a.MathHelper.floorToDecimals(Math.min(n.width / i.frame.width, n.height / i.frame.height), 4);
							let o = Math.floor((n.width - i.frame.width * s) * i.placement.x - i.frame.x * s) + t.left,
								r = Math.floor((n.height - i.frame.height * s) * i.placement.y - i.frame.y * s) + t.top;
							i.scale.set(s, s), i.position.set(o, r)
						}
					}
					onAddToRenderLoop(t) {
						this._renderCallbacks.push(t)
					}
					animate() {
						for (let t = 0; t < this._renderCallbacks.length; t++) this._renderCallbacks[t]();
						0 == m.skipFrame() && m.renderer.render(m._stage)
					}
					static getLayer(t) {
						return m._layers[t]
					}
				}
				m._orientation = u.Orientation.NONE, m.skipFrame = () => !1, m._prevResizeData = null, m.legacyScaling = !1, e.StageManager = m
			},
			57284: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.StageEvent = void 0;
				class i {}
				i.ADD_TO_RENDER_LOOP = "stageEvent_addToRenderLoop", i.WANT_RESIZE = "stageEvent_wantResize", i.CONTAINER_RESIZED = "stageEvent_containerResized", i.STAGE_RESIZED = "stageEvent_stageResized", i.LEFT_HANDED_SETTING = "stageEvent_leftHandedSetting", e.StageEvent = i
			},
			78973: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SystemEvent = void 0;
				class i {}
				i.SHOW_DIALOG = "systemEvent_showDialog", i.CONFIG_LOADED = "systemEvent_configLoaded", e.SystemEvent = i
			},
			40745: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Translation = void 0;
				class i {
					constructor(t) {
						if (i._apiAdapter) throw new Error("Error: Translation.constructor() - Instantiation failed: Singleton.");
						i._apiAdapter = t
					}
					static translate(t) {
						return i._apiAdapter.translate(t)
					}
				}
				e.Translation = i
			},
			56665: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.UserAgent = e.isIDeviceDependentConfig = e.isIOrientationDependentConfig = void 0;
				const n = i(75367),
					s = i(80927),
					o = i(85206),
					r = i(70329);
				e.isIOrientationDependentConfig = function(t) {
					return void 0 !== t.landscape
				}, e.isIDeviceDependentConfig = function(t) {
					return void 0 !== t.desktop
				};
				class a {
					constructor(t) {
						if (a._instance) throw new Error("Error: UserAgent.constructor() - Instantiation failed: Singleton.");
						this._apiAdapter = t, this._deviceName = this._apiAdapter.getDevice(), a._instance = this
					}
					static get deviceName() {
						return a._instance._deviceName ? a._instance._deviceName : a.defaultDeviceName
					}
					static get defaultDeviceName() {
						return null != n.GameConfig.instance.DEFAULT_DEVICE_NAME ? n.GameConfig.instance.DEFAULT_DEVICE_NAME : r.Device.DESKTOP
					}
					static get isMobile() {
						return a.deviceName === r.Device.MOBILE
					}
					static get forceCanvas() {
						const t = null != n.GameConfig.instance.FORCE_CANVAS && n.GameConfig.instance.FORCE_CANVAS,
							e = s.NolimitConfig.forceCanvas;
						return t || e
					}
					static getDeviceDependentValue(t) {
						const e = null != t[a.deviceName] ? t[a.deviceName] : t.desktop;
						return a.getOrientationDependentValue(e)
					}
					static getOrientationDependentValue(t) {
						return null != t[o.StageManager.orientation] ? t[o.StageManager.orientation] : t.landscape
					}
				}
				e.UserAgent = a
			},
			34785: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ArrayHelper = void 0, e.ArrayHelper = class {
					static initArrayWithValues(t, e) {
						const i = [];
						for (let n = 0; n < t; n++) i.push(e(n));
						return i
					}
					static getRandomElementFromArray(t) {
						return t[Math.floor(Math.random() * t.length)]
					}
					static arraySum(t) {
						return t.reduce(((t, e) => t + e), 0)
					}
					static reviseIndexInLoopRange(t, e) {
						if (t <= 0) throw new Error("Error: ArrayHelper.getValueInLoopRange(): length must bigger than zero!");
						return e > t - 1 ? e % t : e < 0 ? t - Math.abs(e) % t : e
					}
					static removeFirstMatchElement(t, e) {
						for (let i = 0; i < t.length; i++)
							if (t[i] === e) return void t.splice(i, 1)
					}
					static removeFirstMatchElementWithCondition(t, e) {
						for (let i = 0; i < t.length; i++)
							if (e(t[i])) return void t.splice(i, 1)
					}
					static getFirstElement(t) {
						return t[0]
					}
					static getLastElement(t) {
						return t[t.length - 1]
					}
					static shuffle(t) {
						let e = t.concat();
						for (let t = e.length; t; t--) {
							let i = Math.floor(Math.random() * t);
							[e[t - 1], e[i]] = [e[i], e[t - 1]]
						}
						return e
					}
				}
			},
			56682: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Helper = void 0;
				const n = i(75367),
					s = i(23792),
					o = i(56665),
					r = i(46334);
				class a {
					static getReelSet(t, e) {
						if (n.GameConfig.instance.REEL_SETS[t] && n.GameConfig.instance.REEL_SETS[t].length > 0) {
							const i = n.GameConfig.instance.REEL_SETS[t][e];
							return i.length < 4 && r.Logger.logDev(`Helper.getReelSet() name = ${t}, index = ${e}, the reelset is too short that might break ReelController.randomizeReelSetPosition().`), i
						}
						throw new Error(`Error: Helper.getReelSet(): Reel ${t} does not contain any symbol!`)
					}
					static getSymbolPositions(t, e, i = !1, s) {
						s || (s = o.UserAgent.deviceName);
						const r = [n.GameConfig.instance.REEL_AREA_POS_X, n.GameConfig.instance.REEL_AREA_POS_Y],
							l = a.getSymbolPositionsOnReelArea(t, e, i, s);
						return [r[0] + l[0], r[1] + l[1]]
					}
					static getSymbolPositionsOnReelArea(t, e, i = !1, r) {
						var a;
						r || (r = o.UserAgent.deviceName);
						const l = n.GameConfig.instance.REEL_DISPLAY_POSITIONS[t];
						if (i) try {
							const i = s.Reels.getSymbol(t, e, !1);
							if (i) return [l[0] + i.x, l[1] + i.y]
						} catch (t) {}
						const h = (null === (a = s.Reels.getReel(t)) || void 0 === a ? void 0 : a.symStep) ? s.Reels.getReel(t).symStep : n.GameConfig.instance.SYMBOL_HEIGHT + n.GameConfig.instance.SYMBOL_BOTTOM_PADDING;
						return [l[0], l[1] + h * e + n.GameConfig.instance.SYMBOL_HEIGHT / 2]
					}
					static toDeviceScale(t, e, i = !0) {
						return o.UserAgent.isMobile && (t *= e), i ? Math.round(t) : t
					}
					static shrinkTextWidth(t, e, i) {
						for (; e.width > i;) {
							if ("string" == typeof e.style.fontSize) {
								if (e.style.fontSize.indexOf("em") > -1) throw new Error("Helper.shrinkTextWidth(), I am lazy so I don't want to parse em, please use number or px.");
								e.style.fontSize = parseInt(e.style.fontSize)
							}
							if (e.style.fontSize--, e.style.fontSize <= 10) return void(e.style.fontSize = 10)
						}
					}
					static fitItemInRectangle(t, e, i) {
						const n = e.width / (t.width / t.scale.x),
							s = e.height / (t.height / t.scale.y);
						let o = Math.min(n, s);
						null != i && (o = Math.min(o, i)), t.scale.set(o, o), t instanceof PIXI.Sprite ? (t.x = e.x + e.width / 2 + t.width * (t.anchor.x - .5), t.y = e.y + e.height / 2 + t.height * (t.anchor.y - .5)) : (t.x = e.x + e.width / 2, t.y = e.y + e.height / 2)
					}
					static globalPositionToLayerPosition(t, e) {
						return [Math.floor((t[0] - e.x) / e.scale.x), Math.floor((t[1] - e.y) / e.scale.y)]
					}
					static timeLineKiller(t, e, i = !1) {
						return t ? (i && t.totalProgress(1), t.pause(), t.kill(), t.clear(), e || t) : e || t
					}
					static timeLineNuller(t, e = !1) {
						if (!t) return null;
						let i = t;
						return e && i.totalProgress(1), i ? (i.pause(), i.kill(), i.clear()) : (t.pause(), t.kill()), null
					}
					static createSprite(t) {
						let e = new PIXI.Sprite(t);
						return e.anchor.set(.5, .5), e.alpha = 0, e
					}
					static assignObj(t, e) {
						let i = Object(t);
						for (var n = 1; n < arguments.length; n++) {
							let t = arguments[n];
							if (null != t)
								for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && (i[s] = t[s])
						}
						return i
					}
					static copyLocalPosition(t, e) {
						return t.parent.toLocal(t.parent.position, e)
					}
				}
				e.Helper = a
			},
			57244: (t, e) => {
				"use strict";

				function i(t) {
					return "number" == typeof t
				}
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.MathHelper = e.isNumber = void 0, e.isNumber = i;
				class n {
					static floorToDecimals(t, e) {
						return Math.floor(t * Math.pow(10, e)) / Math.pow(10, e)
					}
					static ceilToDecimals(t, e) {
						return Math.ceil(t * Math.pow(10, e)) / Math.pow(10, e)
					}
					static roundToDecimals(t, e) {
						return Number(t.toFixed(e))
					}
					static randomNumberInRange(t, e, i = 0) {
						let n = t + (e - t) * Math.random();
						return Number(n.toFixed(i))
					}
					static randomIntInRange(t, e) {
						return Math.floor(Math.random() * (e - t + 1) + t)
					}
					static constrain(t, e, i) {
						return Math.max(e, Math.min(t, i))
					}
					static isInRange(t, e, i) {
						return t >= e && t <= i
					}
					static map(t, e, i, n, s) {
						return (t - e) * (s - n) / (i - e) + n
					}
					static angleBetweenPoints(t, e) {
						return Math.atan2(e.y - t.y, e.x - t.x)
					}
					static addPoints(t, e) {
						return this.pointAdd(t, e)
					}
					static subPoints(t, e) {
						return this.pointSub(t, e)
					}
					static multiplyPoints(t, e) {
						return this.pointMul(t, e)
					}
					static dividePoints(t, e) {
						return this.pointDiv(t, e)
					}
					static pointAdd(t, e) {
						return i(e) ? new PIXI.Point(t.x + e, t.y + e) : new PIXI.Point(t.x + e.x, t.y + e.y)
					}
					static pointSub(t, e) {
						return i(e) ? new PIXI.Point(t.x - e, t.y - e) : new PIXI.Point(t.x - e.x, t.y - e.y)
					}
					static pointMul(t, e) {
						return i(e) ? new PIXI.Point(t.x * e, t.y * e) : new PIXI.Point(t.x * e.x, t.y * e.y)
					}
					static pointDiv(t, e) {
						return i(e) ? new PIXI.Point(t.x / e, t.y / e) : new PIXI.Point(t.x / e.x, t.y / e.y)
					}
					static vectorMagnitude(t) {
						return Math.sqrt(t.x * t.x + t.y * t.y)
					}
					static normalizeVector(t) {
						const e = n.vectorMagnitude(t);
						return e > 0 ? n.pointDiv(t, e) : new PIXI.Point
					}
					static pointAlongLine(t, e, i) {
						let n = i;
						return new PIXI.Point((1 - n) * t.x + n * e.x, (1 - n) * t.y + n * e.y)
					}
					static distanceBetweenPoints(t, e) {
						return Math.sqrt((t.x - e.x) * (t.x - e.x) + (t.y - e.y) * (t.y - e.y))
					}
					static randomPosInRect(t, e) {
						let i = new PIXI.Point(n.randomIntInRange(t.x, t.width + t.x), n.randomIntInRange(t.y, t.height + t.y));
						if (e)
							for (; e.contains(i.x, i.y);) i = new PIXI.Point(n.randomIntInRange(t.x, t.width + t.x), n.randomIntInRange(t.y, t.height + t.y));
						return i
					}
					static DistanceByVTA(t, e, i) {
						return t * e + i * Math.pow(e, 2) / 2
					}
					static accCalcByVDT(t, e, i) {
						return 2 * (e - t * i) / Math.pow(i, 2)
					}
					static accCalcByVVD(t, e, i) {
						return (Math.pow(t, 2) - Math.pow(e, 2)) / (2 * i)
					}
					static timeByVVA(t, e, i) {
						return (t - e) / i
					}
					static frameToSeconds(t, e = 30) {
						return t / e
					}
					static secondsToFrame(t, e = 30) {
						return t * e
					}
					static shuffleArray(t) {
						let e = t.concat();
						for (let t = e.length; t; t--) {
							let i = Math.floor(Math.random() * t);
							[e[t - 1], e[i]] = [e[i], e[t - 1]]
						}
						return e
					}
					static normalizedRotation(t) {
						return 2 * Math.PI / t
					}
					static degreeToAngle(t) {
						return this.normalizedRotation(360 / t)
					}
				}
				e.MathHelper = n
			},
			91265: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.WinFieldController = void 0;
				const n = i(52409),
					s = i(15904),
					o = i(330),
					r = i(23110);
				e.WinFieldController = class {
					constructor() {
						this.addEventListeners()
					}
					addEventListeners() {
						n.EventHandler.addEventListener(this, s.ScreenEvent.GAME_RESTORE, (t => this.onRestore())), n.EventHandler.addEventListener(this, o.ServerEvent.INIT_DATA_PARSED, (t => this.onInitDataParsed(t.params[0]))), n.EventHandler.addEventListener(this, o.ServerEvent.GAME_DATA_PARSED, (t => this.onGameDataParsed(t.params[0])))
					}
					onRestore() {
						n.EventHandler.removeEventListener(this, s.ScreenEvent.GAME_RESTORE), this.showWinField()
					}
					onInitDataParsed(t) {
						n.EventHandler.removeEventListener(this, o.ServerEvent.INIT_DATA_PARSED), this.onGameDataParsed(t)
					}
					onGameDataParsed(t) {
						this._data = t, this._shouldShowTotalWin = t.isTotalWin, this._shouldNextShowTotalWin = t.isNextTotalWin, this._totalWin = t.totalWin
					}
					shouldShow() {
						return this._totalWin > 0
					}
					showWinField(t, e = !1, i = !1) {
						if (this.shouldShow()) {
							if (t = null != t ? t : this._totalWin, !e && (i || this._shouldShowTotalWin || this._shouldNextShowTotalWin)) return void r.SlotGame.keypad.setWin(t, !0);
							r.SlotGame.keypad.setWin(t)
						}
					}
				}
			},
			99313: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.WinPresentationController = void 0;
				const n = i(46334),
					s = i(46289),
					o = i(52409),
					r = i(44679),
					a = i(330),
					l = i(32696),
					h = i(57992);
				class u extends s.BaseController {
					constructor(t, e) {
						super(e.tweakEnabled, e.name, e.betWinMode), this._isPlaying = !1, this._isDataDirty = !1, this._indexes = t, this._skippable = !0 === e.skippable, this.addEventListeners()
					}
					addEventListeners() {
						o.EventHandler.addEventListener(this, a.ServerEvent.GAME_DATA_PARSED, (t => this.onGameDataParsed(t.params[0]))), o.EventHandler.addEventListener(this, h.WinPresentationEvent.UPDATE_WIN_PRESENTATION_BET_WINS, (t => this.onUpdateBetWins(t.params[0]))), this.addFeatureEventHandlers && this.addFeatureEventHandlers()
					}
					onGameDataParsed(t) {
						this._gameData = t, this._betWinsData = t.betWins, this.parseFeatureGameData && this.parseFeatureGameData(t), this._isDataDirty = !0
					}
					onUpdateBetWins(t) {
						this._betWinsData = t.concat()
					}
					reset() {
						this._isDataDirty && (this._gameData = null, this._betWinsData = null, this._isDataDirty = !1, this.resetFeature && this.resetFeature())
					}
					play() {
						this.hasWin() ? (n.Logger.logDev(`[WinPresentation]-${this.moduleName}.startWinPresentation(), skippable = ${this._skippable}`), o.EventHandler.dispatchEvent(new r.GameEvent(h.WinPresentationEvent.WIN_PRESENTATION_STARTED, this._indexes, this.moduleName)), this._skippable && o.EventHandler.dispatchEvent(new r.GameEvent(l.SpinEvent.WANT_SKIPPABLE)), this._isPlaying = !0, this.startWinPresentation()) : o.EventHandler.dispatchEvent(new r.GameEvent(h.WinPresentationEvent.WIN_PRESENTATION_COMPLETED, this._indexes, !1))
					}
					abort() {
						this._isPlaying && this._skippable && (n.Logger.logDev(`[WinPresentation]-${this.moduleName}.abort()`), o.EventHandler.dispatchEvent(new r.GameEvent(h.WinPresentationEvent.WIN_PRESENTATION_ABORTED, this.moduleName)), this.abortWinPresentation())
					}
					abortWinPresentation() {
						this.finish(!0)
					}
					finish(t = !1) {
						n.Logger.logDev(`[WinPresentation]-${this.moduleName}.finish()`), this._isPlaying = !1, this.stopWinPresentation(t), o.EventHandler.dispatchEvent(new r.GameEvent(h.WinPresentationEvent.WIN_PRESENTATION_COMPLETED, this._indexes, !0))
					}
				}
				e.WinPresentationController = u
			},
			61734: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.WinPresentationManager = void 0;
				const n = i(53108),
					s = i(52409),
					o = i(44679),
					r = i(28147),
					a = i(15904),
					l = i(52475),
					h = i(32696),
					u = i(34785),
					c = i(57992);
				e.WinPresentationManager = class {
					constructor() {
						this._currentIndexes = [-1, -1], this._winPresentations = [];
						const t = r.GameModuleConfig.instance.WIN_PRESENTATIONS;
						if (t) {
							let e;
							for (let i = 0; i < t.length; i++) {
								e = [];
								for (let n = 0; n < t[i].length; n++) e.push(t[i][n]([i, n]));
								this._winPresentations.push(e)
							}
						}
						const e = r.GameModuleConfig.instance.INDIVIDUAL_WIN_PRESENTATION;
						if (null == e) throw new Error("No IndividualWinPresentationController defined");
						this._individualWin = e(), this.resetLevelStates(), this.addEventListeners()
					}
					addEventListeners() {
						s.EventHandler.addLastEventListener(this, h.SpinEvent.STOPPED, (t => this.onStartWinPresentations())), s.EventHandler.addEventListener(this, a.ScreenEvent.PICK_AND_CLICK_CLOSED, (t => this.onPickAndClickClosed(t.params[0]))), s.EventHandler.addEventListener(this, h.SpinEvent.SKIP, (t => this.onAbort())), s.EventHandler.addEventListener(this, h.SpinEvent.BEFORE_START, (t => this.onReset())), s.EventHandler.addEventListener(this, a.ScreenEvent.SCREEN_START, (t => this.onReset())), s.EventHandler.addEventListener(this, a.ScreenEvent.PICK_AND_CLICK_START, (t => this.onReset())), s.EventHandler.addEventListener(this, a.ScreenEvent.BET_OPTION_CHANGED, (t => this.onReset())), s.EventHandler.addEventListener(this, h.SpinEvent.IDLE, (t => this.onSpinIdle())), s.EventHandler.addEventListener(this, c.WinPresentationEvent.WIN_PRESENTATION_COMPLETED, (t => this.onWinPresentationComplete(t.params[0], t.params[1])))
					}
					onStartWinPresentations() {
						s.EventHandler.dispatchEvent(new o.GameEvent(c.WinPresentationEvent.WIN_PRESENTATIONS_STARTED)), this.playNextPresentation(!0)
					}
					onPickAndClickClosed(t) {
						t ? this.onStartWinPresentations() : s.EventHandler.dispatchEvent(new o.GameEvent(c.WinPresentationEvent.ALL_PRESENTATIONS_COMPLETED))
					}
					onAbort() {
						this._currentIndexes[0] > -1 && this._currentIndexes[1] > -1 && this._winPresentations[this._currentIndexes[0]][this._currentIndexes[1]].abort()
					}
					onReset() {
						for (let t = 0; t < this._winPresentations.length; t++)
							for (let e = 0; e < this._winPresentations[t].length; e++) this._winPresentations[t][e].reset();
						s.EventHandler.dispatchEvent(new o.GameEvent(n.BetLineEvent.HIDE_ALL_BET_LINES)), this._individualWin.abort(), this.resetLevelStates()
					}
					onSpinIdle() {
						l.GameSetting.isNextAutoplayRound || this._individualWin.play()
					}
					onWinPresentationComplete(t, e) {
						if (-1 !== t[0]) {
							if (this._currentIndexes[0] !== t[0] || this._currentIndexes[1] !== t[1]) throw new Error("Error: WinPresentationManager.onWinPresentationComplete():Win Presentation index fault!");
							this.playNextPresentation(e)
						}
					}
					playNextPresentation(t) {
						t ? this.playNextLevelPresentation() : this.playNextPresentationInTheSameLevel()
					}
					playNextLevelPresentation() {
						const t = this._currentIndexes[0];
						t >= 0 && (this._levelCompleteStates[t] = !0), this._currentIndexes[0]++, this._currentIndexes[1] = -1, this._currentIndexes[0] >= this._winPresentations.length ? (this._currentIndexes = [-1, -1], this.resetLevelStates(), s.EventHandler.dispatchEvent(new o.GameEvent(c.WinPresentationEvent.ALL_PRESENTATIONS_COMPLETED))) : this.playNextPresentationInTheSameLevel()
					}
					playNextPresentationInTheSameLevel() {
						this._currentIndexes[1]++, this._currentIndexes[1] >= this._winPresentations[this._currentIndexes[0]].length ? this.playNextLevelPresentation() : this._winPresentations[this._currentIndexes[0]][this._currentIndexes[1]].play()
					}
					resetLevelStates() {
						this._levelCompleteStates = u.ArrayHelper.initArrayWithValues(this._winPresentations.length, (t => !1))
					}
				}
			},
			42226: (t, e) => {
				"use strict";
				var i;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.WinRatioType = void 0, (i = e.WinRatioType || (e.WinRatioType = {})).TINY = "tiny", i.SMALL = "small", i.MEDIUM = "medium", i.LARGE = "large", i.BIG_WIN = "bigWin", i.MEGA_WIN = "megaWin", i.SUPER_MEGA_WIN = "superMegaWin"
			},
			57992: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.WinPresentationEvent = void 0;
				class i {}
				i.WIN_PRESENTATIONS_STARTED = "winPresentationEvent_winPresentationsStarted", i.ALL_PRESENTATIONS_COMPLETED = "winPresentationEvent_allPresentationsCompleted", i.UPDATE_WIN_PRESENTATION_BET_WINS = "winPresentationEvent_updateWinPresentationBetWins", i.WIN_PRESENTATION_STARTED = "winPresentationEvent_winPresentationStarted", i.WIN_PRESENTATION_COMPLETED = "winPresentationEvent_winPresentationCompleted", i.WIN_PRESENTATION_ABORTED = "winPresentationEvent_winPresentationAborted", e.WinPresentationEvent = i
			},
			81084: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.IndividualWinPresentationController = void 0;
				const n = i(46334),
					s = i(13006),
					o = i(52409),
					r = i(44679),
					a = i(75367),
					l = i(57992),
					h = i(99313);
				class u extends h.WinPresentationController {
					constructor(t = "IndividualWin", e, i) {
						super([-1, -1], {
							name: t,
							tweakEnabled: e,
							betWinMode: i
						}), this._currentIndex = -1, this._winSymbols = []
					}
					hasWin() {
						return null != this._betWinsData && this._betWinsData.length > 0
					}
					startWinPresentation() {
						this.playAllNoWinSymbols && this.playAllNoWinSymbols(), this.playNextBetWinPresentation()
					}
					playNextBetWinPresentation() {
						this._isPlaying && (this.resetWinSymbols(!1), this._currentIndex++, this._currentIndex >= this._betWinsData.length && (this._currentIndex = 0), this._currentLineAnimation = new s.TimelineLite, this._currentLineAnimation.add(this.getLineAnimation(this._betWinsData[this._currentIndex]), .1), this._currentLineAnimation.add((() => {
							this.playNextBetWinPresentation()
						})))
					}
					stopWinPresentation(t) {
						this._isPlaying = !1, this._currentLineAnimation && (this._currentLineAnimation.isActive() && (this._currentLineAnimation.pause(), this._currentLineAnimation.kill()), this._currentLineAnimation = null), this._currentIndex = -1, this.resetWinSymbols(!0)
					}
					abort() {
						this._isPlaying && (n.Logger.logDev(`[WinPresentation]-${this.moduleName}.abort()`), o.EventHandler.dispatchEvent(new r.GameEvent(l.WinPresentationEvent.WIN_PRESENTATION_ABORTED, this.moduleName)), this.finish(!0))
					}
					resetWinSymbols(t) {
						if (t)
							for (; this._winSymbols.length > 0;) this._winSymbols.pop().changeState({
								state: a.GameConfig.instance.SYMBOL_STATES.win,
								frames: [-1, -1]
							})
					}
				}
				e.IndividualWinPresentationController = u
			},
			84833: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ZeroBetController = void 0;
				const n = i(59848),
					s = i(52409),
					o = i(44679),
					r = i(330);
				e.ZeroBetController = class {
					get isTriggered() {
						return this._isTriggered
					}
					constructor() {
						this.addEventListeners()
					}
					addEventListeners() {
						s.EventHandler.addEventListener(this, r.ServerEvent.INIT_DATA_PARSED, (t => this.onGameDataParsed(t.params[0]))), s.EventHandler.addEventListener(this, r.ServerEvent.GAME_DATA_PARSED, (t => this.onGameDataParsed(t.params[0])))
					}
					onGameDataParsed(t) {
						this._isTriggered = this.calculateIsTriggered(t), this._zeroBetNumberLeft = this.getZeroBetNumberLeft(t)
					}
					handleZeroBetCounter() {
						this.shouldShowZeroBetCounter() ? (this.shouldSubtractZeroBetCounter() && this._zeroBetNumberLeft--, s.EventHandler.dispatchEvent(new o.GameEvent(n.BalanceEvent.ZERO_BET, this._zeroBetNumberLeft))) : s.EventHandler.dispatchEvent(new o.GameEvent(n.BalanceEvent.ZERO_BET, -1))
					}
				}
			},
			48918: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ZeroBetManager = void 0;
				const n = i(28147);
				e.ZeroBetManager = class {
					get isCurrentZeroBet() {
						return this._isCurrentZeroBet
					}
					constructor() {
						this._isCurrentZeroBet = !1, this._zeroBetControllers = [];
						const t = n.GameModuleConfig.instance.ZERO_BETS;
						if (t)
							for (let e = 0; e < t.length; e++) this._zeroBetControllers.push(t[e]())
					}
					tryPlayZeroBet() {
						return this.isNextZeroBet(!0)
					}
					isNextZeroBet(t = !1) {
						for (let e = 0; e < this._zeroBetControllers.length; e++)
							if (this._zeroBetControllers[e].isTriggered) return t && (this._isCurrentZeroBet = !0, this._zeroBetControllers[e].handleZeroBetCounter()), !0;
						return this._isCurrentZeroBet = !1, !1
					}
				}
			},
			70975: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PerformanceLogger = void 0;
				const n = i(46334),
					s = i(59848),
					o = i(52409),
					r = i(91812),
					a = i(330),
					l = i(52475),
					h = i(32696),
					u = i(57244),
					c = i(45729);
				class d {
					constructor() {
						if (d._instance) throw new Error("Error: PerformanceLogger.constructor() - Instantiation failed: Singleton.");
						d._instance = this, l.GameSetting.isDevMode && this.addEventListeners()
					}
					addEventListeners() {
						o.EventHandler.addEventListener(this, s.BalanceEvent.BET, (t => d.addMark(c.PerformanceMarkName.SPIN_START))), o.EventHandler.addEventListener(this, r.ReelEvent.ALL_REELS_STOP_SPIN, (t => this.onSpinStopping())), o.EventHandler.addEventListener(this, h.SpinEvent.STOPPED, (t => this.onSpinStopped())), o.EventHandler.addEventListener(this, a.ServerEvent.GAME_DATA_RECEIVED, (t => this.onGameDataReceived()))
					}
					static addMark(t, e = "blue") {
						if (!d._instance) return;
						const i = Date.now();
						n.Logger.logDev("%c Performance Mark ", `background-color:${e}; color:white; font-size: 12px; padding: 4px;`, t);
						for (let e of this._marks)
							if (e.name === t) return void(e.time = i);
						this._marks.push({
							name: t,
							time: i
						})
					}
					static getMarkTime(t) {
						for (let e of this._marks)
							if (e.name === t) return e.time;
						return n.Logger.logDev(`Error: PerformanceLogger.getMarkTime() Cannot find mark with name ${t}!`), -1
					}
					static measureMark(t, e, i) {
						if (!d._instance) return;
						const s = this.getMarkTime(e),
							o = this.getMarkTime(i);
						n.Logger.logDev("%c Performance Measure ", "background-color:red; color:white; font-size: 12px; padding: 4px;", `Measure ${t} from Mark ${e} to Mark ${i} is ${u.MathHelper.roundToDecimals((o-s)/1e3,2)} seconds.`)
					}
					static timeStart(t) {
						console.time(t), console.log(`%c Time Start:${t} `, "background-color:grey; color:white; font-size: 12px; padding: 4px;")
					}
					static timeEnd(t) {
						console.timeEnd(t)
					}
					onSpinStopping() {
						d.addMark(c.PerformanceMarkName.SPIN_STOPPING), d.measureMark("SPIN TIME", c.PerformanceMarkName.SPIN_START, c.PerformanceMarkName.SPIN_STOPPING)
					}
					onSpinStopped() {
						d.addMark(c.PerformanceMarkName.SPIN_COMPLETED), d.measureMark("TOTAL SPIN TIME", c.PerformanceMarkName.SPIN_START, c.PerformanceMarkName.SPIN_COMPLETED)
					}
					onGameDataReceived() {
						d.addMark(c.PerformanceMarkName.GAME_DATA_RECEIVED), d.measureMark("SERVER RESPONSE TIME", c.PerformanceMarkName.SPIN_START, c.PerformanceMarkName.GAME_DATA_RECEIVED)
					}
				}
				d._marks = [], e.PerformanceLogger = d
			},
			45729: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PerformanceMarkName = void 0;
				class i {}
				i.SPIN_START = "SPIN START", i.SPIN_STOPPING = "SPIN STOPPING", i.SPIN_ANIMATION_COMPLETED = "SPIN ANIMATION COMPLETED", i.SPIN_STOP_PRESENTATION_COMPLETED = "SPIN STOP PRESENTATION COMPLETED", i.SPIN_COMPLETED = "SPIN COMPLETED", i.GAME_DATA_RECEIVED = "GAME DATA RECEIVED", e.PerformanceMarkName = i
			},
			31801: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GameTweaker = void 0;
				const n = i(73044),
					s = i(13663),
					o = i(52409),
					r = i(88240),
					a = i(85206),
					l = i(71027),
					h = i(25975);
				class u extends n.BaseView {
					constructor(t) {
						super(), this._baseWindowHeight = 0, this._modules = [], this._config = t, this._layer = a.StageManager.getLayer(this._config.layer), this._layer.addChild(this), this.createBackground()
					}
					onResize(t) {
						this.y = -this._layer.y / this._layer.scale.y
					}
					createBackground() {
						this._backgroundContainer = new PIXI.Container, this.addChild(this._backgroundContainer), this.drawBackground()
					}
					initAnimations() {
						this.createCopyButton()
					}
					createCopyButton() {
						const t = {
							idle: r.GameResources.getTextures(this._config.buttonSkinIdle)[0],
							over: r.GameResources.getTextures(this._config.buttonSkinOver)[0],
							down: r.GameResources.getTextures(this._config.buttonSkinDown)[0],
							disabled: r.GameResources.getTextures(this._config.buttonSkinDisabled)[0]
						};
						this._copyButton = new s.TextButton(t, (() => this.onCopyClicked()), this._config.copyAllButtonText, this.getTextStyle()), this._copyButton.x = this._config.baseWindowWidth - this._copyButton.width, this._copyButton.y = this._baseWindowHeight + this._copyButton.height + 4, this.addChild(this._copyButton)
					}
					onCopyClicked() {
						let t = "\r\n";
						for (let e = 0; e < this._modules.length; e++) {
							const i = this._modules[e].getModuleValues();
							t += i.name + "\r\n";
							for (let e = 0; e < i.sliders.length; e++) t += i.sliders[e].name + "\r\n", t += i.sliders[e].value + "\r\n";
							t += "\r\n"
						}
						this.copyText(t)
					}
					copyText(t) {
						const e = document.createElement("DIV");
						e.textContent = t, document.body.appendChild(e), this.selectElementText(e), document.execCommand("copy"), e.remove()
					}
					selectElementText(t) {
						if (window.getSelection) {
							const e = document.createRange();
							e.selectNode(t), window.getSelection().removeAllRanges(), window.getSelection().addRange(e)
						}
					}
					getTextStyle() {
						return {
							fontFamily: "Arial",
							fontSize: 12,
							fill: "#000000",
							wordWrap: !1
						}
					}
					addEventListeners() {
						o.EventHandler.addEventListener(this, l.TweakEvent.ADD_MODULE, (t => this.addModule(t.params[0])))
					}
					addModule(t) {
						const e = new h.TweakModule(t, (t => this.moduleResized(t)));
						e.y = this._modules.length * this._config.moduleHeight + this._modules.length, this.addChild(e), this._modules.push(e), this._baseWindowHeight += this._config.moduleHeight, this.drawBackground()
					}
					moduleResized(t) {
						if (1 == t.expanded) {
							for (let e = t.index; e < this._modules.length; e++) this._modules[e].y += t.height;
							this._baseWindowHeight += t.height
						} else {
							for (let e = t.index; e < this._modules.length; e++) this._modules[e].y -= t.height;
							this._baseWindowHeight -= t.height
						}
						this.drawBackground(), this.updateButtonPosition()
					}
					drawBackground() {
						this._backgroundContainer.removeChildren();
						const t = new PIXI.Graphics;
						t.lineStyle(2, 5469287, 1), t.beginFill(5469287, .4), t.drawRect(1, 1, this._config.baseWindowWidth, this._baseWindowHeight), t.endFill(), this._backgroundContainer.addChild(t)
					}
					updateButtonPosition() {
						this._copyButton.y = this._baseWindowHeight + 4
					}
				}
				e.GameTweaker = u
			},
			71027: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.TweakEvent = void 0;
				class i {}
				i.ADD_MODULE = "tweakEvent_addModule", i.ADD_SLIDER_TO_MODULE = "tweakEvent_addSliderToModule", e.TweakEvent = i
			},
			25975: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.TweakModule = void 0;
				const n = i(22365),
					s = i(52409),
					o = i(71027),
					r = i(85359);
				class a extends PIXI.Container {
					constructor(t, e) {
						super(), this._moduleName = t, this._sliders = [], this._expanded = !1, this._contentContainer = new PIXI.Container, this._contentContainer.visible = !1, this.addChild(this._contentContainer), this._resizeCallback = e, this.createHeadLine(), this.addEventListeners()
					}
					createHeadLine() {
						const t = new r.TweakModuleHeadline(this._moduleName);
						t.interactive = !0, t.on("click", (() => this.onHeadlineClicked())), this.addChild(t)
					}
					onHeadlineClicked() {
						0 == this._expanded ? (this._expanded = !0, this.expand()) : (this._expanded = !1, this.retract())
					}
					expand() {
						this._contentContainer.visible = !0, this.resize()
					}
					retract() {
						this._contentContainer.visible = !1, this.resize()
					}
					resize() {
						const t = {
							expanded: this._expanded,
							index: this.parent.getChildIndex(this),
							height: this._contentContainer.height + a.BOTTOM_PADDING
						};
						this._resizeCallback(t)
					}
					addEventListeners() {
						s.EventHandler.addEventListener(this, o.TweakEvent.ADD_SLIDER_TO_MODULE, (t => this.addSlider(t.params[0], t.params[1])))
					}
					addSlider(t, e) {
						if (this._moduleName != t) return;
						const i = new n.Slider(e.text, e.minValue, e.maxValue, e.startValue, e.onValueChangeCallback);
						i.x = 12, i.y = 65 + 50 * this._sliders.length, this._contentContainer.addChild(i), i.scaleTextToComponentWidth(), this._sliders.push(i)
					}
					getModuleValues() {
						const t = [];
						for (let e = 0; e < this._sliders.length; e++) t.push(this._sliders[e].getSliderValues());
						return {
							name: this._moduleName,
							sliders: t
						}
					}
				}
				a.BOTTOM_PADDING = 12, e.TweakModule = a
			},
			85359: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.TweakModuleHeadline = void 0;
				class i extends PIXI.Container {
					constructor(t) {
						super(), this._headlineTextString = t, this.init()
					}
					init() {
						this.addChild(this.createHeadlineBackground()), this.addChild(this.createHeadlineText())
					}
					createHeadlineBackground() {
						const t = new PIXI.Graphics;
						return t.beginFill(5469287, .5), t.drawRect(1, 1, i.HEADLINE_WIDTH, i.HEADLINE_HEIGHT), t.endFill(), t
					}
					createHeadlineText() {
						const t = new PIXI.Text(this._headlineTextString, this.getHeadlineTextStyle());
						return t.position.x = 3, t.position.y = 1, t
					}
					getHeadlineTextStyle() {
						return {
							fontFamily: "Arial",
							fontSize: 24,
							fill: "#FFFFFF"
						}
					}
				}
				i.HEADLINE_WIDTH = 400, i.HEADLINE_HEIGHT = 30, e.TweakModuleHeadline = i
			},
			69221: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.StillImageBackground = void 0;
				const n = i(17259),
					s = i(75367),
					o = i(88240);
				class r extends n.Background {
					constructor(t) {
						super(t), this._backgroundImages = t.backgroundImages, this._stretch = t.stretch
					}
					initAnimations() {
						super.initAnimations(), this._backgroundSprite = new PIXI.Sprite, this.addChild(this._backgroundSprite)
					}
					onChangeBackground(t) {
						if (!super.onChangeBackground(t)) return !1;
						const e = o.GameResources.getTextures(this._backgroundImages[this._currentMode].image)[0],
							i = null != this._backgroundImages[this._currentMode].offset ? this._backgroundImages[this._currentMode].offset : r._DEFAULT_OFFSET,
							n = null != this._backgroundImages[this._currentMode].scale ? this._backgroundImages[this._currentMode].scale : 1;
						return this._backgroundSprite.texture = e, this._stretch ? (this._backgroundSprite.width = s.GameConfig.instance.GAME_WIDTH, this._backgroundSprite.height = s.GameConfig.instance.GAME_HEIGHT) : this._backgroundSprite.scale.set(n, n), this._backgroundSprite.x = i.x, this._backgroundSprite.y = i.y, !0
					}
				}
				r._DEFAULT_OFFSET = new PIXI.Point(0, 0), e.StillImageBackground = r
			},
			14023: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PolyBetLine = void 0;
				const n = i(64625),
					s = i(75367),
					o = i(85206),
					r = i(56682),
					a = i(13006);
				class l extends n.BetLine {
					constructor(t, e, i, n) {
						super(t, e, i, n)
					}
					draw(t, e, i) {
						s.GameConfig.instance.SYMBOL_WIDTH, s.GameConfig.instance.SYMBOL_HEIGHT;
						const n = [];
						0 === t[2] && n.push([t[0] + i.numberOffsetX, t[1]]);
						for (let t = 0; t < e.length; t++) {
							const i = e[t],
								s = r.Helper.getSymbolPositions(t, i);
							n.push(s)
						}
						1 === t[2] && n.push([t[0] - i.numberOffsetX, t[1]]);
						let a = new PIXI.Graphics,
							l = 0;
						for (let t = 0; t < i.styles.length; t++) this.drawPolyline(a, n, i.styles[t]), l = Math.max(l, i.styles[t].lineWidth);
						this.addChild(a), o.StageManager.getLayer(i.staticLineLayer).addChild(this), this.alpha = 0
					}
					drawPolyline(t, e, i) {
						t.lineStyle(i.lineWidth, i.color, i.alpha), t.moveTo(e[0][0], e[0][1]);
						for (let i = 1; i < e.length; i++) t.lineTo(e[i][0], e[i][1])
					}
					getHighestPointY(t) {
						let e = t[0][1];
						for (let i = 1; i < t.length; i++) e = Math.min(e, t[i][1]);
						return e
					}
					showStatic() {
						this.show()
					}
					showWin() {
						this.show()
					}
					hideAll() {
						this.killTween(), this._alphaTween = a.TweenLite.to(this, .1, {
							alpha: 0
						})
					}
					show() {
						this.killTween(), this._alphaTween = a.TweenLite.to(this, .1, {
							alpha: 1
						})
					}
					killTween() {
						this._alphaTween && this._alphaTween.isActive() && (this._alphaTween.pause(), this._alphaTween.kill())
					}
				}
				e.PolyBetLine = l
			},
			17044: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.IdleAnimationController = void 0;
				const n = i(52409),
					s = i(15904),
					o = i(330),
					r = i(32696),
					a = i(57244),
					l = i(13006);
				e.IdleAnimationController = class {
					constructor(t) {
						this._startTime = 3, this._minInterval = .1, this._maxInterval = 2, this._isPlaying = !1, t && (null != t.startTime && (this._startTime = t.startTime), null != t.minInterval && (this._minInterval = t.minInterval), null != t.maxInterval && (this._maxInterval = t.maxInterval)), this.addEventListeners()
					}
					addEventListeners() {
						n.EventHandler.addEventListener(this, o.ServerEvent.GAME_DATA_PARSED, (t => this.onGameDataParsed(t.params[0]))), n.EventHandler.addEventListener(this, s.ScreenEvent.GAME_START, (t => this.onGameStart()))
					}
					onGameStart() {
						n.EventHandler.addEventListener(this, r.SpinEvent.BEFORE_START, (t => this.onIdleStop())), n.EventHandler.addEventListener(this, s.ScreenEvent.PICK_AND_CLICK_START, (t => this.onIdleStop())), n.EventHandler.addEventListener(this, s.ScreenEvent.SCREEN_START, (t => this.onIdleStop())), n.EventHandler.addEventListener(this, r.SpinEvent.IDLE, (t => this.onIdle())), this.onIdle()
					}
					onIdle() {
						this.hasWin() || (this._isPlaying = !0, this.play(this._startTime, !1))
					}
					play(t, e) {
						this._isPlaying && (e && this.playIdleAnimation(), this._idleTimer = l.TweenLite.to(this, t, {
							onComplete: () => this.play(a.MathHelper.randomNumberInRange(this._minInterval, this._maxInterval), !0)
						}))
					}
					onIdleStop() {
						this._isPlaying = !1, this._idleTimer && (this._idleTimer.pause(), this._idleTimer.kill(), this._idleTimer = null), this.stopIdleAnimation && this.stopIdleAnimation()
					}
				}
			},
			44747: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SymbolIdleAnimationController = void 0;
				const n = i(75367),
					s = i(23792),
					o = i(57244),
					r = i(17044);
				class a extends r.IdleAnimationController {
					constructor(t) {
						super(t), this._hasSymbolIdle = null != n.GameConfig.instance.SYMBOL_STATES.idle
					}
					onGameDataParsed(t) {
						this._betWinsData = t.betWins
					}
					hasWin() {
						return null != this._betWinsData && this._betWinsData.length > 0
					}
					playIdleAnimation() {
						if (!this._hasSymbolIdle) return;
						const t = o.MathHelper.randomNumberInRange(0, n.GameConfig.instance.REELS_NUM - 1),
							e = o.MathHelper.randomNumberInRange(0, n.GameConfig.instance.SYMBOLS_NUM_IN_REEL[2] - 1),
							i = s.Reels.getSymbol(t, e);
						i && this.playSymbolIdleAnimation(i)
					}
					playSymbolIdleAnimation(t) {
						t.changeState({
							state: n.GameConfig.instance.SYMBOL_STATES.idle,
							replay: !1,
							onCompleteCallback: () => {
								t.changeState({
									state: n.GameConfig.instance.SYMBOL_STATES.normal
								})
							}
						})
					}
				}
				e.SymbolIdleAnimationController = a
			},
			5351: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.AvalancheReelController = void 0;
				const n = i(13006),
					s = i(52409),
					o = i(44679),
					r = i(75367),
					a = i(83673),
					l = i(28147),
					h = i(91812),
					u = i(86033),
					c = i(39386),
					d = i(23792),
					p = i(54504),
					_ = i(34785),
					m = i(46334),
					g = i(671),
					f = i(7755);
				class S extends c.ReelController {
					constructor(t) {
						super(t)
					}
					createReelPartAnimator() {
						return this._avalancheReelPartAnimator = l.GameModuleConfig.instance.REEL_PART_ANIMATOR ? l.GameModuleConfig.instance.REEL_PART_ANIMATOR(this._reelId) : new f.AvalancheReelPartAnimator(this._reelId), this._avalancheReelPartAnimator
					}
					parseInitData(t) {
						super.parseInitData(t), this._reelsAfterCollapes = t.reelsAfterCollapse[this._reelId], this._allWinPositions = _.ArrayHelper.initArrayWithValues(this._symNumTotal, (t => this._reelsAfterCollapes[t] === p.ReelSymbolName.EMPTY))
					}
					onGameDataParsed(t) {
						super.onGameDataParsed(t), this._reelsAfterCollapes = t.reelsAfterCollapse[this._reelId].concat(), this._allWinPositions = t.allWinPositions[this._reelId].concat(), this._newSymbols = t.newSymbols[this._reelId] ? t.newSymbols[this._reelId].concat() : [], this._nearWinPositions = t.nearWinPositions
					}
					makeUpStopReelSet(t, e) {
						return e && this.isNextAvalanche() ? this._reelsAfterCollapes.concat() : !e && this.isAvalanche() ? this._newSymbols.concat() : this._stopReelSet.concat()
					}
					moveReelSetPosition() {
						if (0 == this._currentReelSetPosition) throw new Error("AvalancheReelController.moveReelSetPosition():ReelSet position cannot be smaller than 0!");
						this._currentReelSetPosition--
					}
					addAvalancheToTimeline(t, e, i, r) {
						null == r && (r = this._allWinPositions.concat()), r.includes(!1) || (i = !1);
						const a = i ? e + this.getNormalStopDelay(this.reelId) : e,
							l = new n.TimelineLite;
						return l.add((() => this._currentState = u.ReelAnimationState.AVALANCHE)), l.add(this._avalancheReelPartAnimator.getAvalancheAnimation(r, this._allWinPositions, 0, (t => this.removeSymbol(t)))), l.add((() => s.EventHandler.dispatchEvent(new o.GameEvent(g.AvalancheReelEvent.REEL_AVALANCHE_COMPLETE, this.reelId)))), t.add(l, a), a
					}
					startSpinAnimation(t, e) {
						this._isSpinBlurred = !0;
						let i = e;
						const s = new n.TimelineLite;
						if (this.isAvalanche()) {
							if (this._currentState = u.ReelAnimationState.AVALANCHE_START, this._allWinPositions.includes(!0)) {
								i = e + (0 === this.reelId ? 0 : t.fastSpin ? c.ReelController._reelFastStartDelays[this._reelId] : c.ReelController._reelStartDelays[this._reelId]);
								const n = this._allWinPositions.concat();
								s.add((() => this._avalancheReelPartAnimator.getAvalancheAnimation(n, null, i, (t => this.removeSymbol(t)))))
							}
						} else this._currentState = u.ReelAnimationState.ALL_OUT, i = e + (0 === this.reelId ? 0 : t.fastSpin ? c.ReelController._reelFastStartDelays[this._reelId] : c.ReelController._reelStartDelays[this._reelId]), s.add((() => this._avalancheReelPartAnimator.getAllOutAnimation(i, (t => this.removeSymbol(t)))));
						return s.add((() => this.onSpinStartedCompleted())), i
					}
					onSpinStartedCompleted() {
						this._currentState = u.ReelAnimationState.SPIN, s.EventHandler.dispatchEvent(new o.GameEvent(h.ReelEvent.REEL_SPIN_STARTED, this._reelId))
					}
					stopSpin(t, e) {
						if (this._reelPartAnimator.isQuickStop = t.quickStop, this._reelPartAnimator.isFastSpin = t.fastSpin, this.currentState === u.ReelAnimationState.AVALANCHE_NEW || this.currentState === u.ReelAnimationState.ALL_IN) {
							if (null != this._stopTimeline && this._stopTimeline.isActive()) {
								this._stopTimeline.paused(), this._stopTimeline.kill();
								const t = new n.TimelineLite;
								t.add(this._avalancheReelPartAnimator.getQuickStopNewSymbolsInAnimation()), t.add((() => this.onSpinStopAnimationCompleted())), this._stopTimeline = t
							}
							return 0
						}
						if (t.active) {
							this._reelPartAnimator.isQuickStop && (this._addedStopDelay = 0);
							const t = e + this.getFakeStopDelay() + this._addedStopDelay;
							if (this._addedStopDelay = 0, this._reelStopDelayTimer && this._reelStopDelayTimer.isActive()) {
								const e = this._reelStopDelayTimer.totalDuration() - this._reelStopDelayTimer.time();
								if (t >= e) return e;
								this._reelStopDelayTimer.pause(), this._reelStopDelayTimer.kill()
							}
							return this._reelStopDelayTimer = n.TweenLite.to(this, t, {
								onComplete: () => this.clearStopDelay()
							}), t
						}
						return m.Logger.logDev(`ReelController.stopSpin():Inactive reel ${this._reelId} stop spin animation completed!`), s.EventHandler.dispatchEvent(new o.GameEvent(h.ReelEvent.REEL_STOP_SPIN_ANIMATION_COMPLETE, {
							reelId: this._reelId,
							fastSpin: this._reelPartAnimator.isFastSpin,
							quickStop: this._reelPartAnimator.isQuickStop,
							active: !1
						})), e
					}
					getFakeStopDelay() {
						return 0 === this.reelId ? .01 : this._reelPartAnimator.isQuickStop ? this.getQuickStopDelay(this.reelId) : 100
					}
					onStopDelayDone() {
						this._currentReelSet = this.makeUpStopReelSet(0, !1), this._currentReelSetPosition = this._currentReelSet.length;
						const t = new n.TimelineLite;
						if (t.add((() => this.onSpinStopStarted())), this.isAvalanche() ? this._currentState = u.ReelAnimationState.AVALANCHE_NEW : this._currentState = u.ReelAnimationState.ALL_IN, t.add(this._avalancheReelPartAnimator.getNewSymbolsInAnimation(this.getNewSymbols(), this._nearWinPositions[this.reelId])), t.add((() => this.onSpinStopAnimationCompleted())), this._stopTimeline = t, this.reelId < r.GameConfig.instance.REELS_NUM - 1) {
							const t = this.reelId + 1;
							let e = this.getReelStopOffset(t);
							if (d.Reels.getReel(t).shouldPlayNearWinStop()) {
								const t = this._avalancheReelPartAnimator.currentTimeline ? this._avalancheReelPartAnimator.currentTimeline.totalDuration() : 0;
								e = Math.max(0, t + e)
							}
							s.EventHandler.dispatchEvent(new o.GameEvent(h.ReelEvent.REEL_REFRESH_STOP_DELAY, {
								reelId: t,
								delay: e
							}))
						}
					}
					getQuickStopDelay(t) {
						return c.ReelController._reelQuickStopDelays[t]
					}
					getFastSpinStopDelay(t) {
						return this.getQuickStopDelay(t)
					}
					getNearWinStopDelay(t) {
						return c.ReelController._reelNearWinStopDelays[t]
					}
					getNormalStopDelay(t) {
						return c.ReelController._reelStopDelays[t]
					}
					getReelStopOffset(t) {
						return this.isAvalanche() && 0 === this._newSymbols.length ? 0 : this._reelPartAnimator.isQuickStop ? this.getQuickStopDelay(t) : this._nearWinPositions[t][this._nearWinPositions[t].length - 1] ? this.getNearWinStopDelay(t) : this._reelPartAnimator.isFastSpin ? this.getFastSpinStopDelay(t) : this.getNormalStopDelay(t)
					}
					getNewSymbols() {
						const t = [];
						let e = null;
						for (; this._currentReelSetPosition > 0;) {
							const i = this.createNextSymbol(e);
							t.unshift(i), e = i
						}
						return t
					}
					onSpinStopAnimationCompleted() {
						this._isSpinBlurred = !1, this._stopTimeline = null, super.onSpinStopAnimationCompleted()
					}
					isAvalanche() {
						return this._gameMode === a.GameMode.NORMAL_AVALANCHE || this._gameMode === a.GameMode.FREESPIN_AVALANCHE
					}
					isNextAvalanche() {
						return this._nextGameMode === a.GameMode.NORMAL_AVALANCHE || this._nextGameMode === a.GameMode.FREESPIN_AVALANCHE
					}
					shouldPlayNearWinStop() {
						if (this._reelPartAnimator.isQuickStop) return !1;
						const t = (this.isAvalanche() ? this._newSymbols.length : this._stopReelSet.length) - 1;
						return this._nearWinPositions[this.reelId][t]
					}
				}
				e.AvalancheReelController = S
			},
			671: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.AvalancheReelEvent = void 0;
				class i {}
				i.REEL_STOP_SPIN_SYMBOL_ATTENTION_START = "avalancheReelEvent_reelStopSpinSymbolAttentionStart", i.ALL_REELS_AVALANCHE_STARTED = "avalancheReelEvent_allReelsAvalancheStarted", i.REEL_AVALANCHE_COMPLETE = "avalancheReelEvent_reelAvalancheComplete", i.ALL_REELS_AVALANCHE_COMPLETE = "avalancheReelEvent_allReelsAvalancheComplete", e.AvalancheReelEvent = i
			},
			7755: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.AvalancheReelPartAnimator = void 0;
				const n = i(52409),
					s = i(44679),
					o = i(75367),
					r = i(56978),
					a = i(34785),
					l = i(13006),
					h = i(57244),
					u = i(671);
				class c extends r.ReelPartAnimator {
					get isQuickStop() {
						return this._isQuickStop
					}
					set isQuickStop(t) {
						this._isQuickStop = t, this._isQuickStop && (this._stopSymDelay = c._quickStopSymbolDelay[this._reelId], this.stopSpeed = r.ReelPartAnimator._spinQuickStopSpeeds[this._reelId])
					}
					get startSymDelay() {
						return this._startSymDelay
					}
					set startSymDelay(t) {
						this._startSymDelay = t
					}
					get stopSymDelay() {
						return this._stopSymDelay
					}
					set stopSymDelay(t) {
						this._stopSymDelay = t
					}
					get currentTimeline() {
						return this._currentTimeline
					}
					constructor(t) {
						super(t)
					}
					initConfig() {
						if (r.ReelPartAnimator._configInitialized) return;
						const t = o.GameConfig.instance.REEL_SPIN_START_SYMBOL_DELAY ? o.GameConfig.instance.REEL_SPIN_START_SYMBOL_DELAY : 0;
						if ((0, h.isNumber)(t)) this.addTweakModuleSlider({
							text: "Avalanche Spin Out Symbol Delay",
							minValue: 0,
							maxValue: 2,
							startValue: t,
							onValueChangeCallback: (t, e) => c.onSpinStartSymbolDelayChanged(e)
						}), c._startSymbolDelay = a.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => t));
						else if (c._startSymbolDelay = t, c._startSymbolDelay.length != o.GameConfig.instance.REELS_NUM) throw new Error("AvalancheReelPartAnimator.initConfig(): Invalid config REEL_SPIN_START_SYMBOL_DELAY, the length doesn't match the amount of reels!");
						if (o.GameConfig.instance.REEL_FAST_SPIN_START_SYMBOL_DELAY) {
							const t = o.GameConfig.instance.REEL_FAST_SPIN_START_SYMBOL_DELAY;
							if ((0, h.isNumber)(t)) this.addTweakModuleSlider({
								text: "Avalanche Fast Spin Out Symbol Delay",
								minValue: 0,
								maxValue: 2,
								startValue: t,
								onValueChangeCallback: (t, e) => c.onSpinFastStartSymbolDelayChanged(e)
							}), c._fastStartSymbolDelay = a.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => t));
							else if (c._fastStartSymbolDelay = t, c._fastStartSymbolDelay.length != o.GameConfig.instance.REELS_NUM) throw new Error("AvalancheReelPartAnimator.initConfig(): Invalid config REEL_FAST_SPIN_START_SYMBOL_DELAY, the length doesn't match the amount of reels!")
						} else c._fastStartSymbolDelay = c._startSymbolDelay.concat();
						const e = o.GameConfig.instance.REEL_SPIN_STOP_SYMBOL_DELAY ? o.GameConfig.instance.REEL_SPIN_STOP_SYMBOL_DELAY : 0;
						if ((0, h.isNumber)(e)) this.addTweakModuleSlider({
							text: "Avalanche Spin In Symbol Delay",
							minValue: 0,
							maxValue: 2,
							startValue: e,
							onValueChangeCallback: (t, e) => c.onSpinStopSymbolDelayChanged(e)
						}), c._stopSymbolDelay = a.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => e));
						else if (c._stopSymbolDelay = e, c._stopSymbolDelay.length != o.GameConfig.instance.REELS_NUM) throw new Error("AvalancheReelPartAnimator.initConfig(): Invalid config REEL_SPIN_STOP_SYMBOL_DELAY, the length doesn't match the amount of reels!");
						const i = o.GameConfig.instance.REEL_SPIN_QUICK_STOP_SYMBOL_DELAY ? o.GameConfig.instance.REEL_SPIN_QUICK_STOP_SYMBOL_DELAY : 0;
						if ((0, h.isNumber)(i)) this.addTweakModuleSlider({
							text: "Avalanche Quick Spin In Symbol Delay",
							minValue: 0,
							maxValue: 2,
							startValue: i,
							onValueChangeCallback: (t, e) => c.onSpinQuickStopSymbolDelayChanged(e)
						}), c._quickStopSymbolDelay = a.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => i));
						else if (c._quickStopSymbolDelay = i, c._quickStopSymbolDelay.length != o.GameConfig.instance.REELS_NUM) throw new Error("AvalancheReelPartAnimator.initConfig(): Invalid config REEL_SPIN_QUICK_STOP_SYMBOL_DELAY, the length doesn't match the amount of reels!");
						const n = o.GameConfig.instance.REEL_SPIN_NEAR_WIN_STOP_SYMBOL_DELAY ? o.GameConfig.instance.REEL_SPIN_NEAR_WIN_STOP_SYMBOL_DELAY : 0;
						if ((0, h.isNumber)(n)) this.addTweakModuleSlider({
							text: "Avalanche Near Win Spin In Symbol Delay",
							minValue: 0,
							maxValue: 2,
							startValue: n,
							onValueChangeCallback: (t, e) => c.onSpinNearWinSymbolDelayChanged(e)
						}), c._nearWinStopSymbolDelay = a.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => n));
						else if (c._nearWinStopSymbolDelay = n, c._nearWinStopSymbolDelay.length != o.GameConfig.instance.REELS_NUM) throw new Error("AvalancheReelPartAnimator.initConfig(): Invalid config REEL_SPIN_NEAR_WIN_STOP_SYMBOL_DELAY, the length doesn't match the amount of reels!");
						super.initConfig()
					}
					static onSpinStartSymbolDelayChanged(t) {
						c._startSymbolDelay = a.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => t))
					}
					static onSpinFastStartSymbolDelayChanged(t) {
						c._fastStartSymbolDelay = a.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => t))
					}
					static onSpinStopSymbolDelayChanged(t) {
						c._stopSymbolDelay = a.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => t))
					}
					static onSpinQuickStopSymbolDelayChanged(t) {
						c._quickStopSymbolDelay = a.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => t))
					}
					static onSpinNearWinSymbolDelayChanged(t) {
						c._nearWinStopSymbolDelay = a.ArrayHelper.initArrayWithValues(o.GameConfig.instance.REELS_NUM, (() => t))
					}
					initTargetPositions() {
						let t;
						this._targetPositions = [];
						const e = o.GameConfig.instance.SYMBOLS_NUM_IN_REEL[2];
						for (let i = 0; i < e; i++) t = this.symStep * i + this._symHeight / 2, this._targetPositions.push(t)
					}
					initSymbolsPosition() {
						for (let t = 0; t < this._symbolsToAnimate.length; t++) this.symbolsToAnimate[this._symbolsToAnimate.length - 1 - t].y = this._targetPositions[this._targetPositions.length - 1 - t]
					}
					resetStartSpin(t) {
						super.resetStartSpin(t), this._startSymDelay = t ? c._fastStartSymbolDelay[this._reelId] : c._startSymbolDelay[this._reelId], this._stopSymDelay = t ? c._quickStopSymbolDelay[this._reelId] : c._stopSymbolDelay[this._reelId]
					}
					getAvalancheAnimation(t, e, i, n) {
						if (!t.includes(!0)) return new l.TimelineLite;
						const s = new l.TimelineLite,
							o = this._symbolsToAnimate.concat();
						let r = 1;
						for (; t.length > 0 && !(o.length - r < 0);)
							if (t.pop()) {
								const t = o.length - r,
									i = o.splice(t, 1)[0];
								s.add((() => n(i))), null != e && (e.splice(e.length - r, 1), e.unshift(!1))
							} else r++;
						s.add((() => this._symbolsToAnimate = o.concat()));
						for (let t = 0; t < o.length; t++) {
							const e = o.length - 1 - t,
								n = this._targetPositions.length - 1 - t,
								r = o[e];
							if (null == r) throw new Error(`AvalancheReelPartAnimator.getAvalancheAnimation, symbol at index ${e} is null!`);
							i = this.addSymbolInAnimationToTimeline(r, s, i, this._targetPositions[n], 0 === t, !1, !1)
						}
						return s.add((() => this._currentTimeline = null)), this._currentTimeline = s, s
					}
					getAllOutAnimation(t, e) {
						const i = new l.TimelineLite;
						for (; this._symbolsToAnimate.length > 0;) {
							const n = this._symbolsToAnimate.pop();
							if (null == n) throw new Error("AvalancheReelPartAnimator.animateAllOut, symbol is null!");
							t = this.addSymbolOutAnimationToTimeline(n, i, t, e)
						}
						return i.add((() => this._currentTimeline = null)), this._currentTimeline = i, i
					}
					addSymbolOutAnimationToTimeline(t, e, i, n) {
						return t.stackedSymName.isStacked && !t.visible ? (n(t), i) : (i += this.startSymDelay, e.add(t.changeState({
							state: o.GameConfig.instance.SYMBOL_STATES.spin,
							setStack: !0,
							replay: !1,
							fadeInDuration: o.GameConfig.instance.REEL_SPIN_START_SYMBOL_CHANGE_TO_SPIN_STATE_DURATION,
							fadeInDelay: o.GameConfig.instance.REEL_SPIN_START_SYMBOL_CHANGE_TO_SPIN_STATE_DELAY
						}), i), e.add(l.TweenLite.to(t, this.startSpeed, {
							ease: o.GameConfig.instance.REEL_SPIN_START_EASE,
							y: t.y + o.GameConfig.instance.REEL_AREA_HEIGHT,
							onComplete: () => n(t)
						}), i), i)
					}
					getDefaultStopEase() {
						const t = this.isQuickStop ? o.GameConfig.instance.REEL_SPIN_QUICK_STOP_ELASTIC_CONFIG : o.GameConfig.instance.REEL_SPIN_STOP_ELASTIC_CONFIG;
						return l.Elastic.easeOut.config(t[0], t[1])
					}
					getNewSymbolsInAnimation(t, e) {
						if (0 === t.length) return new l.TimelineLite;
						if (t.length + this._symbolsToAnimate.length != this._targetPositions.length) throw new Error("AvalancheReelPartAnimator.getAvalancheNewAnimation(): the amount of symbols doesn't match the positions!");
						const i = new l.TimelineLite;
						let n = 0,
							s = !0;
						for (; t.length > 0;) {
							const o = t.pop();
							this._symbolsToAnimate.unshift(o);
							const r = t.length;
							n = this.addSymbolInAnimationToTimeline(o, i, n, this._targetPositions[r], s, e[r], !0), s = !1
						}
						return i.add((() => this._currentTimeline = null)), this._currentTimeline = i, i
					}
					getQuickStopNewSymbolsInAnimation() {
						const t = new l.TimelineLite;
						let e = 0;
						for (let i = 0; i < this._symbolsToAnimate.length; i++) {
							const n = this._symbolsToAnimate.length - 1 - i,
								s = this._symbolsToAnimate[n];
							e = this.addSymbolInAnimationToTimeline(s, t, e, this._targetPositions[n], !1, !1, !0)
						}
						return t.add((() => this._currentTimeline = null)), this._currentTimeline = t, t
					}
					addSymbolInAnimationToTimeline(t, e, i, n, s, a, u) {
						if (t.stackedSymName.isStacked && !t.visible) return i;
						if (t.y === n) return i;
						const d = h.MathHelper.roundToDecimals((n - t.y) / o.GameConfig.instance.REEL_AREA_HEIGHT, 3);
						i += a && !this.isQuickStop ? c._nearWinStopSymbolDelay[this._reelId] : this.stopSymDelay;
						const p = a && !this.isQuickStop ? r.ReelPartAnimator._nearWinSpinSpeeds[this._reelId] : this.stopSpeed;
						e.add(l.TweenLite.to(t, p * d, {
							ease: this.getDefaultStopEase(),
							y: n,
							onComplete: () => {
								u && this.onSymbolInAttentionPointReached(t)
							}
						}), i);
						const _ = new l.TimelineLite({
							paused: !0
						});
						return _.add(t.changeState({
							state: o.GameConfig.instance.REEL_SPIN_STOP_SYMBOL_STATE ? o.GameConfig.instance.REEL_SPIN_STOP_SYMBOL_STATE() : o.GameConfig.instance.SYMBOL_STATES.normal,
							replay: !1,
							setStack: !0,
							fadeInDuration: o.GameConfig.instance.REEL_SPIN_STOP_SYMBOL_CHANGE_FROM_SPIN_STATE_DURATION * d,
							fadeInDelay: o.GameConfig.instance.REEL_SPIN_STOP_SYMBOL_CHANGE_FROM_SPIN_STATE_DELAY * d
						})), e.add((() => _.play()), i), e.add((() => {}), i + _.totalDuration()), i
					}
					onSymbolInAttentionPointReached(t) {
						n.EventHandler.dispatchEvent(new s.GameEvent(u.AvalancheReelEvent.REEL_STOP_SPIN_SYMBOL_ATTENTION_START, {
							reelId: this._reelId,
							symbols: [t],
							quickStop: this.isQuickStop
						}))
					}
				}
				e.AvalancheReelPartAnimator = c
			},
			63927: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NudgeReelEvent = void 0;
				class i {}
				i.NUDGE_STEP_START = "nudgeReelEvent_nudgeStepStart", i.NUDGE_STEP_COMPLETED = "nudgeReelEvent_nudgeStepCompleted", i.NUDGE_COMPLETED = "nudgeReelEvent_nudgeCompleted", e.NudgeReelEvent = i
			},
			52559: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NudgeSpinReelController = void 0;
				const n = i(46334),
					s = i(13006),
					o = i(52409),
					r = i(44679),
					a = i(75367),
					l = i(86033),
					h = i(7157),
					u = i(63927),
					c = i(57244);
				class d extends h.SpinReelController {
					constructor(t) {
						super(t), this._maxRemovedSymbolLength = 3, this._nudgeAnimator = this._reelPartAnimator, this._removedSymbolPool = [], null == a.GameConfig.instance.STACKED_SYMBOLS && n.Logger.logDev("NudgeSpinReelController.constructor(): GameConfig.STACKED_SYMBOLS has not stacked symbol for nudging!");
						for (let e in a.GameConfig.instance.STACKED_SYMBOLS) {
							if (null != a.GameConfig.instance.STACKED_SYMBOLS[e].reels && a.GameConfig.instance.STACKED_SYMBOLS[e].reels.indexOf(t) < 0) continue;
							const i = (0, c.isNumber)(a.GameConfig.instance.STACKED_SYMBOLS[e].totalNum) ? a.GameConfig.instance.STACKED_SYMBOLS[e].totalNum : a.GameConfig.instance.STACKED_SYMBOLS[e].totalNum[this._reelId];
							this._maxRemovedSymbolLength = Math.max(this._maxRemovedSymbolLength, i + 1)
						}
					}
					onGameDataParsed(t) {
						super.onGameDataParsed(t), this._doNudge = this.parseDoNudge(t), this._extraTopSymbols = null != t.extraSymbolsOnTop && null != t.extraSymbolsOnTop[this._reelId] ? t.extraSymbolsOnTop[this._reelId] : []
					}
					parseDoNudge(t) {
						return null != t.doReelNudge && null != t.doReelNudge[this._reelId] && t.doReelNudge[this._reelId]
					}
					makeUpStackedSymbolTop(t) {
						var e;
						const i = (null === (e = this._extraTopSymbols) || void 0 === e ? void 0 : e.length) > 0 && this._doNudge ? this._extraTopSymbols[0] : t,
							n = null != this._extraTopSymbols && this._doNudge ? this._extraTopSymbols : [];
						return n.length, super.makeUpStackedSymbolTop(i).concat(n)
					}
					nudge(t, e, i, n) {
						if (this._currentState != l.ReelAnimationState.IDLE && this._currentState != l.ReelAnimationState.INACTIVE) throw new Error("NudgeSpinReelController.nudge(): Can not nudge when reel is not idling or inactive.");
						this._spinStateBeforeNudge = this._currentState, this._currentState = l.ReelAnimationState.NUDGE, this._nudgeAnimator.nudgeSteps = t, this._nudgeAnimator.nudgeStepSpeed = e, this._nudgeAnimator.ease = i, this.nudgeInDirection(n)
					}
					abortNudge(t) {
						n.Logger.logDev(`NudgeSpinReelController.abortNudge() at reel ${this._reelId}`), this._currentState == l.ReelAnimationState.NUDGE || null != t ? (null != t && (this._nudgeAnimator.nudgeSteps = t), this._nudgeAnimator.aborted = !0, this._currentTimeline && this._currentTimeline.isActive() && this._currentTimeline.progress(1), this._currentState = this._spinStateBeforeNudge, this._spinStateBeforeNudge = null) : n.Logger.logDev(`NudgeReelController.abortNudge() The reel is not nudging. reelId = ${this._reelId}`)
					}
					nudgeInDirection(t) {
						n.Logger.logDev(`nudge ${this._nudgeAnimator.nudgeSteps} steps left  at reel ${this._reelId}`), null == t && (t = 0);
						const e = new s.TimelineLite;
						return this._currentTimeline = e, 0 === this._nudgeAnimator.nudgeSteps ? (e.add(this._nudgeAnimator.getNudgeCompleteAnimation(t)), void e.add((() => this.onNudgeCompleted()))) : (e.add((() => this.onNudgeStepStart(this._nudgeAnimator.nudgeSteps)), t), this._nudgeAnimator.nudgeSteps > 0 ? (e.add(this._nudgeAnimator.getNudgeDownAnimation(this.createNextNudgeDownSymbol())), void e.add((() => this.onNudgeDownStepCompleted(this.allSymbols.pop())))) : (e.add(this._nudgeAnimator.getNudgeUpAnimation(this.createNextNudgeUpSymbol())), void e.add((() => this.onNudgeUpStepCompleted(this.allSymbols.shift())))))
					}
					onNudgeStepStart(t) {
						o.EventHandler.dispatchEvent(new r.GameEvent(u.NudgeReelEvent.NUDGE_STEP_START, this._reelId, t))
					}
					onNudgeDownStepCompleted(t) {
						this.updateStackedSymbols(this._reelPartAnimator.symbolsToAnimate[this._reelPartAnimator.symbolsToAnimate.length - 1], null, 1, !1), this.removeSymbol(t), this.onNudgeStepCompleted()
					}
					onNudgeUpStepCompleted(t) {
						this.updateStackedSymbols(this._reelPartAnimator.symbolsToAnimate[this._reelPartAnimator.symbolsToAnimate.length - 1], null, 1, !1), super.removeSymbol(t), this.onNudgeStepCompleted()
					}
					onNudgeStepCompleted() {
						n.Logger.logDev(`NudgeSpinReelController.onNudgeStepCompleted at reel ${this._reelId}`), o.EventHandler.dispatchEvent(new r.GameEvent(u.NudgeReelEvent.NUDGE_STEP_COMPLETED, this._reelId, this._nudgeAnimator.nudgeSteps)), this.nudgeInDirection()
					}
					onNudgeCompleted() {
						this._currentTimeline = null, this._currentState = this._spinStateBeforeNudge, this._spinStateBeforeNudge = null, o.EventHandler.dispatchEvent(new r.GameEvent(u.NudgeReelEvent.NUDGE_COMPLETED, this._reelId, this._nudgeAnimator.aborted)), this._nudgeAnimator.aborted = !1
					}
					createNextNudgeDownSymbol() {
						return super.createNextSymbol(this._nudgeAnimator.symbolsToAnimate[0])
					}
					createNextNudgeUpSymbol() {
						this._currentReelSetPosition++;
						const t = this._removedSymbolPool.shift();
						return t.changeState({
							state: a.GameConfig.instance.SYMBOL_STATES.normal
						}), this._reelView.addChild(t), this.updateStackedSymbols(t, this.allSymbols[this.allSymbols.length - 1], 1, !1), t
					}
					removeSymbol(t) {
						this._reelView.removeChild(t), this._removedSymbolPool.unshift(t), this._removedSymbolPool.length > this._maxRemovedSymbolLength && this._reelPartCreator.deleteSymbol(this._removedSymbolPool.pop())
					}
				}
				e.NudgeSpinReelController = d
			},
			21155: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NudgeSpinReelPartAnimator = void 0;
				const n = i(13006),
					s = i(46334),
					o = i(90441);
				class r extends o.SpinReelPartAnimator {
					get nudgeSteps() {
						return this._nudgeSteps
					}
					set nudgeSteps(t) {
						this._nudgeSteps = t
					}
					get nudgeStepSpeed() {
						return this._nudgeStepSpeed
					}
					set nudgeStepSpeed(t) {
						this._nudgeStepSpeed = t
					}
					get ease() {
						return this._ease
					}
					set ease(t) {
						this._ease = t
					}
					get aborted() {
						return this._aborted
					}
					set aborted(t) {
						this._aborted = t
					}
					constructor(t) {
						super(t), this._aborted = !1
					}
					getNudgeCompleteAnimation(t) {
						return this._nudgeTimeline = new n.TimelineLite, this._nudgeTimeline.add((() => this.onNudgeCompleted()), t), this._nudgeTimeline
					}
					getNudgeDownAnimation(t) {
						return this._symbolsToAnimate.unshift(t), this.resetSymbolsPosition(), this._nudgeTimeline = new n.TimelineLite, this._aborted ? (s.Logger.logDev(`NudgeSpinReelPartAnimator nudgeDown after abort. at reel ${this._reelId}`), this._nudgeTimeline.add((() => this.yPos = this.symStep))) : (s.Logger.logDev(`NudgeSpinReelPartAnimator nudgeDown  at reel ${this._reelId}`), this._nudgeTimeline.add(n.TweenLite.to(this, this._nudgeStepSpeed, {
							ease: this.ease,
							yPos: this.symStep
						}))), this._nudgeTimeline.add((() => this.onNudgeDownStepCompleted())), this._nudgeTimeline
					}
					onNudgeDownStepCompleted() {
						s.Logger.logDev(`NudgeSpinReelPartAnimator.onNudgeDownStepCompleted, abort: ${this._aborted}  at reel ${this._reelId}`), this._nudgeSteps--, this._nudgeTimeline = null
					}
					onNudgeCompleted() {
						s.Logger.logDev(`NudgeSpinReelPartAnimator.onNudgeCompleted  at reel ${this._reelId}`)
					}
					getNudgeUpAnimation(t) {
						return this._symbolsToAnimate.push(t), this.resetSymbolsPositionBeforeNudgeUp(), this._nudgeTimeline = new n.TimelineLite, this._aborted ? (s.Logger.logDev(`NudgeSpinReelPartAnimator nudgeUp after abort.  at reel ${this._reelId}`), this._nudgeTimeline.add((() => this.yPos = 0))) : (s.Logger.logDev(`NudgeSpinReelPartAnimator nudgeUp. at reel ${this._reelId}`), this._nudgeTimeline.add(n.TweenLite.to(this, this._nudgeStepSpeed, {
							ease: this.ease,
							yPos: 0
						}))), this._nudgeTimeline.add((() => this.onNudgeUpStepCompleted())), this._nudgeTimeline
					}
					resetSymbolsPositionBeforeNudgeUp() {
						this.yPos = this.symStep
					}
					onNudgeUpStepCompleted() {
						s.Logger.logDev(`NudgeSpinReelPartAnimator.onNudgeUpStepCompleted, abort: ${this._aborted}  at reel ${this._reelId}`), this._nudgeSteps++, this._nudgeTimeline = null
					}
				}
				e.NudgeSpinReelPartAnimator = r
			},
			93035: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SpinParsedGameData = void 0;
				const n = i(13182);
				class s extends n.ParsedGameData {
					get nearWinReels() {
						return this._nearWinReels
					}
					get nearWinBigWinReels() {
						return this._nearWinBigWinReels
					}
					constructor(t, e) {
						super(t, e), this._nearWinReels = e.parseNearWinReels(t), this._nearWinBigWinReels = e.parseNearWinBigWinReels(t)
					}
				}
				e.SpinParsedGameData = s
			},
			7157: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SpinReelController = void 0;
				const n = i(46334),
					s = i(13006),
					o = i(52409),
					r = i(44679),
					a = i(75367),
					l = i(28147),
					h = i(91812),
					u = i(86033),
					c = i(39386),
					d = i(55058),
					p = i(34785),
					_ = i(56682),
					m = i(57244),
					g = i(52601),
					f = i(90441);
				class S extends c.ReelController {
					get currentSpinStepLeftTime() {
						return this._spinReelPartAnimator.currentStepLeftTime
					}
					constructor(t) {
						super(t), this._stopCounter = 0
					}
					initValues() {
						super.initValues(), this._symNumTop = a.GameConfig.instance.SYMBOLS_NUM_IN_REEL[0] + a.GameConfig.instance.SYMBOLS_NUM_IN_REEL[1], this._attentionSymbols = [], this._isNextSpinFullStacked = null != a.GameConfig.instance.FULL_STACKED_REELS && a.GameConfig.instance.FULL_STACKED_REELS[this._reelId]
					}
					createReelPartAnimator() {
						return this._spinReelPartAnimator = l.GameModuleConfig.instance.REEL_PART_ANIMATOR ? l.GameModuleConfig.instance.REEL_PART_ANIMATOR(this._reelId) : new f.SpinReelPartAnimator(this._reelId), this._spinReelPartAnimator
					}
					addEventListeners() {
						super.addEventListeners(), o.EventHandler.addEventListener(this, g.SpinReelEvent.REEL_SET_CURRENT_REEL_SET, (t => this.setCurrentReelSet(t.params[0]))), o.EventHandler.addEventListener(this, g.SpinReelEvent.ADD_SLOW_ATTENTION_SPIN_SYMBOL_TO_REEL, (t => this.onAddSpinningAttentionSymbol(t.params[0]))), o.EventHandler.addEventListener(this, g.SpinReelEvent.REMOVE_SLOW_ATTENTION_SPIN_SYMBOL_FROM_REEL, (t => this.onRemoveSpinningAttentionSymbol(t.params[0], t.params[1]))), o.EventHandler.addEventListener(this, g.SpinReelEvent.SET_REEL_NEXT_SPIN_FULL_STACKED, (t => this.onSetReelNextSpinFullStack(t.params[0], t.params[1]))), o.EventHandler.addEventListener(this, g.SpinReelEvent.REEL_SET_SPIN_SPEED, (t => this.setReelSpinSpeed(t.params[0]))), o.EventHandler.addEventListener(this, g.SpinReelEvent.REEL_TRY_NEAR_WIN, (t => this.tryPlayNearWin(t.params[0])))
					}
					parseInitData(t) {
						super.parseInitData(t), this._nextFullReelSet = _.Helper.getReelSet(t.nextReelSetName, this._reelId), this._currentFullReelSet = _.Helper.getReelSet(t.initReelSet, this._reelId)
					}
					onGameDataParsed(t) {
						super.onGameDataParsed(t), this._nextFullReelSet = _.Helper.getReelSet(t.nextReelSetName, this._reelId), this._nearWinReels = t.nearWinReels.concat(), this._nearWinBigWinReels = t.nearWinBigWinReels.concat()
					}
					makeUpStopReelSet(t, e) {
						const i = this.randomizeReelSetPosition(this._nextFullReelSet),
							n = this.makeUpStackedSymbolTop(this._stopReelSet[0]),
							s = this.makeUpStackedSymbolBottom(this._stopReelSet[this._stopReelSet.length - 1], t, e),
							o = this.makeUpStopReelSetRandomBottomFillUp(t - s.length, e);
						return this._nextFullReelSet.slice(0, i + 1).concat(n).concat(this._stopReelSet).concat(s).concat(o)
					}
					randomizeReelSetPosition(t) {
						let e;
						do {
							e = m.MathHelper.randomNumberInRange(0, t.length - 1)
						} while (e < 3);
						const i = d.StateReelSymbol.parseStackedSymbolName(t[e], this._reelId);
						return i.isStacked && (e += i.totalNum - 1 - i.index), e
					}
					makeUpStackedSymbolTop(t) {
						let e = [];
						const i = d.StateReelSymbol.parseStackedSymbolName(t, this._reelId);
						if (i.isStacked && i.index > 0)
							for (let t = 0; t < i.index; t++) e.push(`${i.symName}*${t}`);
						return e
					}
					makeUpStackedSymbolBottom(t, e, i) {
						let n = [];
						const s = d.StateReelSymbol.parseStackedSymbolName(t, this._reelId);
						if (s.isStacked && s.index < s.totalNum - 1) {
							let t = i ? Math.min(s.totalNum, s.index + e + 1) : s.totalNum;
							for (let e = s.index + 1; e < t; e++) n.push(`${s.symName}*${e}`)
						}
						return n
					}
					makeUpStopReelSetRandomBottomFillUp(t, e) {
						if (t <= 0) return this._addedExtraStoppingFullStackedSymbolNum = -t, 1 === this._reelId && n.Logger.logDev(`makeUpStopReelSetRandomBottomFillUp 1 _addedExtraStoppingFullStackedSymbolNum = ${this._addedExtraStoppingFullStackedSymbolNum}`), [];
						if (this._isFullStacked) {
							const i = [];
							let s = t;
							do {
								const t = this._currentFullReelSet[m.MathHelper.randomNumberInRange(0, this._currentFullReelSet.length - 1)],
									n = d.StateReelSymbol.parseStackedSymbolName(t, this._reelId);
								if (!n.isStacked) throw new Error("ReelController.makeUpStopReelSetRandomBottomFillUp(): When reel is full stacked, the nextReelSet should only contain stacked symbols!");
								for (let t = 0; t < n.totalNum; t++)
									if (i.push(`${n.symName}*${t}`), s--, e && 0 === s) return i
							} while (s > 0);
							return i.length > t && (this._addedExtraStoppingFullStackedSymbolNum += i.length - t, n.Logger.logDev(`makeUpStopReelSetRandomBottomFillUp 2 _addedExtraStoppingFullStackedSymbolNum = ${this._addedExtraStoppingFullStackedSymbolNum}`)), i
						}
						return p.ArrayHelper.initArrayWithValues(t, (t => this.getRandomSymbolFromReelSet(this._currentFullReelSet)))
					}
					isSpecialSymbol(t) {
						return super.isSpecialSymbol(t) || this.isSlowAttentionSymbol(t)
					}
					isSlowAttentionSymbol(t) {
						for (let e of this._attentionSymbols)
							if (e.symName === t) return !0;
						return !1
					}
					moveReelSetPosition() {
						if (0 == this._currentReelSetPosition) {
							if (null == this._currentFullReelSet) throw new Error("ReelController.createNextSymbol():This is a bug that Ning is trying to reproduce!");
							this._currentReelSet = this._currentFullReelSet.concat()
						}
						this._currentReelSetPosition--, this._currentReelSetPosition = p.ArrayHelper.reviseIndexInLoopRange(this._currentReelSet.length, this._currentReelSetPosition)
					}
					createNextSymbol(t, e) {
						return this._stopCounter > 0 && this._stopCounter--, super.createNextSymbol(t, e)
					}
					setStartSpinData(t) {
						super.setStartSpinData(t), this._addedExtraStoppingFullStackedSymbolNum = 0, this._currentFullReelSet = this._nextFullReelSet.concat(), this._isFullStacked = this._isNextSpinFullStacked
					}
					startSpinAnimation(t, e) {
						this._isSpinBlurred = !0;
						const i = e + (0 === this.reelId ? 0 : t.fastSpin ? c.ReelController._reelFastStartDelays[this._reelId] : c.ReelController._reelStartDelays[this._reelId]);
						this._currentState = u.ReelAnimationState.START_SPIN;
						const n = new s.TimelineLite;
						return n.add(this._spinReelPartAnimator.getStartSpinAnimate(i, this.createNextSymbol())), n.add((() => this.onSpinStartedCompleted())), i
					}
					tryStartSlowSpinAttention() {
						for (let t of this._attentionSymbols) {
							if (this._symNumTop + t.startPosition < 0) throw new Error("ReelController.tryStartSlowSpinAttention(), the start position is out of reel's range!");
							const e = this.allSymbols[this._symNumTop + t.startPosition];
							if (t.symName === e.symName) return this._spinReelPartAnimator.setupTweenSpinSpeedQueue(t.spinSpeed, t.steps), e.changeState({
								state: t.symbolState ? t.symbolState : a.GameConfig.instance.SYMBOL_STATES.normal,
								replay: !1,
								fadeInDuration: t.spinSpeed / 2,
								fadeInDelay: 0
							}), void this._reelView.addChild(e)
						}
					}
					onSpinStartedCompleted() {
						this.updateStackedSymbols(this.allSymbols[this.allSymbols.length - 1], null, 1, !1), this.removeSymbol(this.allSymbols.pop()), this.tryStartSlowSpinAttention(), this._currentState = u.ReelAnimationState.SPIN, this.spinSpinAnimation(), o.EventHandler.dispatchEvent(new r.GameEvent(h.ReelEvent.REEL_SPIN_STARTED, this._reelId))
					}
					onSpinStepCompleted() {
						switch (this.updateStackedSymbols(this.allSymbols[this.allSymbols.length - 2], null, 1, !1), this.removeSymbol(this.allSymbols.pop()), this.tryStartSlowSpinAttention(), this._currentState) {
							case u.ReelAnimationState.SPIN:
								return void this.spinSpinAnimation();
							case u.ReelAnimationState.STOP_SPIN:
								if (this._stopCounter > 1) return void this.spinSpinAnimation();
								const t = new s.TimelineLite;
								return t.add([() => this._isSpinBlurred = !1, this._spinReelPartAnimator.getStopSpinAnimation(this.createNextSymbol()), () => this.onSpinStopStarted()]), void t.add((() => this.onSpinStopAnimationCompleted()));
							default:
								throw new Error("SpinReelController.onSpinStepCompleted()")
						}
					}
					spinSpinAnimation() {
						const t = new s.TimelineLite;
						t.add(this._spinReelPartAnimator.getSpinAnimation(this.createNextSymbol())), t.add((() => this.onSpinStepCompleted()))
					}
					getSpinStopOffset() {
						if (this._currentState === u.ReelAnimationState.INACTIVE || this._currentState === u.ReelAnimationState.IDLE) return 0;
						let t = 0,
							e = this._stopReelSet[this._stopReelSet.length - 1],
							i = d.StateReelSymbol.parseStackedSymbolName(e, this._reelId);
						return i.isStacked && i.index < i.totalNum - 1 && (t = i.totalNum - 1 - i.index), Math.max(0, t - a.GameConfig.instance.SYMBOLS_NUM_IN_REEL[4])
					}
					getQuickStopDelay(t) {
						return c.ReelController._reelQuickStopDelays[t]
					}
					getFastSpinStopDelay(t) {
						return this.getQuickStopDelay(t)
					}
					getNearWinStopDelay(t) {
						return c.ReelController._reelNearWinStopDelays[t]
					}
					getNormalStopDelay(t) {
						return c.ReelController._reelStopDelays[t]
					}
					getStopDelayDelta(t) {
						return t.quickStop ? this.getQuickStopDelay(this.reelId) : this.hasNearWin() ? this.getNearWinStopDelay(this.reelId) : t.fastSpin ? this.getFastSpinStopDelay(this.reelId) : this.getNormalStopDelay(this.reelId)
					}
					calculateStopTime(t) {
						return this._spinReelPartAnimator.getStopTime(this._symNumTotal + t - 1, this.hasNearWin())
					}
					stopSpin(t, e) {
						if (this._reelPartAnimator.isQuickStop = t.quickStop, this._reelPartAnimator.isFastSpin = t.fastSpin, this._spinStopOffset = t.spinStopOffset, this.currentState === u.ReelAnimationState.STOP_SPIN) return this._spinReelPartAnimator.getStopTime(this._stopCounter - 1, !1) + this.currentSpinStepLeftTime;
						if (t.active) {
							const i = this._spinReelPartAnimator.getStopTime(this._symNumTotal + this._spinStopOffset - 1, this.hasNearWin());
							this._reelPartAnimator.isQuickStop && (this._addedStopDelay = 0);
							const n = Math.max(0, e + this.getStopDelayDelta(t) + this._addedStopDelay - i);
							if (this._addedStopDelay = 0, this._reelStopDelayTimer && this._reelStopDelayTimer.isActive()) {
								const t = this._reelStopDelayTimer.totalDuration() - this._reelStopDelayTimer.time();
								if (n >= t) return t + i;
								this._reelStopDelayTimer.pause(), this._reelStopDelayTimer.kill()
							}
							return this._reelStopDelayTimer = s.TweenLite.to(this, n, {
								onComplete: () => this.clearStopDelay()
							}), n + i + this.currentSpinStepLeftTime
						}
						return n.Logger.logDev(`ReelController.stopSpin():Inactive reel ${this._reelId} stop spin animation completed!`), o.EventHandler.dispatchEvent(new r.GameEvent(h.ReelEvent.REEL_STOP_SPIN_ANIMATION_COMPLETE, {
							reelId: this._reelId,
							fastSpin: this._reelPartAnimator.isFastSpin,
							quickStop: this._reelPartAnimator.isQuickStop,
							active: !1
						})), e
					}
					onStopDelayDone() {
						let t = 0;
						const e = this.handleUnfinishedSpinningStackedSymbols();
						this._currentReelSet = this.makeUpStopReelSet(a.GameConfig.instance.SYMBOLS_NUM_IN_REEL[4] + this._spinStopOffset - e.length, !1).concat(e), this._currentReelSetPosition = this._currentReelSet.length, this._addedExtraStoppingFullStackedSymbolNum > 0 && (t += this._addedExtraStoppingFullStackedSymbolNum * this._spinReelPartAnimator.spinSpeed, this._spinStopOffset += this._addedExtraStoppingFullStackedSymbolNum), this._stopCounter = this._symNumTotal + this._spinStopOffset, this._currentState = u.ReelAnimationState.STOP_SPIN, !this._reelPartAnimator.isQuickStop && this._reelId < a.GameConfig.instance.REELS_NUM - 1 && (t += this.checkSlowMotionStopDelay()), t += this.currentSpinStepLeftTime, t > 0 && o.EventHandler.dispatchEvent(new r.GameEvent(h.ReelEvent.REEL_ADD_STOP_DELAY, {
							reelId: this._reelId + 1,
							delay: t
						}))
					}
					checkSlowMotionStopDelay() {
						if (0 === this._attentionSymbols.length) return 0;
						let t = 0,
							e = 0,
							i = 0,
							n = 0;
						for (let s = 0; s < this._stopCounter - 1; s++) {
							let o = 0;
							this._spinReelPartAnimator.spinSpeedsQueue && this._spinReelPartAnimator.spinSpeedsQueue[s] && (o = this._spinReelPartAnimator.spinSpeedsQueue[s] - this._spinReelPartAnimator.spinSpeed);
							for (let t = 0; t < this._attentionSymbols.length; t++) {
								const o = this._attentionSymbols[t];
								if (this._currentReelSet[this._currentReelSet.length - 1 - s] === o.symName) {
									n = this._symNumTop + o.startPosition, e = o.steps, i = o.spinSpeed;
									break
								}
							}
							n > 0 ? n-- : e > 0 && (e--, o = i - this._spinReelPartAnimator.spinSpeed), t += o
						}
						return e > 0 && (t += i - this._spinReelPartAnimator.stopSpeed), t
					}
					handleUnfinishedSpinningStackedSymbols() {
						if (null == a.GameConfig.instance.STACKED_SYMBOLS) return [];
						const t = this.allSymbols[0].stackedSymName;
						return t.isStacked && 0 !== t.index ? p.ArrayHelper.initArrayWithValues(t.index, (e => `${t.symName}*${e}`)) : []
					}
					onSpinStopAnimationCompleted() {
						this.removeSymbol(this.allSymbols.pop()), this.updateStackedSymbols(this.allSymbols[this.allSymbols.length - 1], null, 1, !1), super.onSpinStopAnimationCompleted(), !this._reelPartAnimator.isQuickStop && this.reelId < a.GameConfig.instance.REELS_NUM - 1 && o.EventHandler.dispatchEvent(new r.GameEvent(g.SpinReelEvent.REEL_TRY_NEAR_WIN, this.reelId + 1))
					}
					setCurrentReelSet(t) {
						this._currentFullReelSet = _.Helper.getReelSet(t.reelSetName, this._reelId);
						const e = this.makeUpStackedSymbolTop(this.allSymbols[0].symName),
							i = null == t.reelSetPosition ? this.randomizeReelSetPosition(this._currentFullReelSet) : t.reelSetPosition;
						this._currentReelSet = this._currentFullReelSet.slice(0, i + 1).concat(e), this._currentReelSetPosition = this._currentReelSet.length
					}
					onAddSpinningAttentionSymbol(t) {
						t.reelId == this._reelId && (this._attentionSymbols.forEach((e => {
							if (e.symName === t.symName) return e.startPosition = t.startPosition, e.steps = t.steps, void(e.spinSpeed = t.spinSpeed)
						})), this._attentionSymbols.push(t))
					}
					onRemoveSpinningAttentionSymbol(t, e) {
						t == this._reelId && p.ArrayHelper.removeFirstMatchElementWithCondition(this._attentionSymbols, (t => t.symName === e))
					}
					onSetReelNextSpinFullStack(t, e) {
						t == this._reelId && (this._isNextSpinFullStacked = e)
					}
					setReelSpinSpeed(t) {
						t.reelId == this._reelId && (this._reelPartAnimator.isQuickStop || s.TweenLite.to(this._reelPartAnimator, t.fadeInTime, {
							spinSpeed: t.spinSpeed
						}))
					}
					tryPlayNearWin(t) {
						t === this.reelId && this.hasNearWin() && this.currentState === u.ReelAnimationState.SPIN && this.playNearWin(t)
					}
					playNearWin(t) {
						this._spinReelPartAnimator.playNearWin(), this._isNearWin = !0, o.EventHandler.dispatchEvent(new r.GameEvent(g.SpinReelEvent.REEL_ON_NEAR_WIN, this._reelId))
					}
					hasNearWin(t) {
						return t = null != t ? t : this.reelId, null != this._nearWinReels && this._nearWinReels[t] || null != this._nearWinBigWinReels && this._nearWinBigWinReels[t]
					}
					findSymbol(t, e = !0) {
						return super.findSymbol(t + this._symNumTop, e)
					}
				}
				e.SpinReelController = S
			},
			52601: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SpinReelEvent = void 0;
				class i {}
				i.REEL_STOP_SPIN_BOUNCE_STARTED = "spinReelEvent_reelStopSpinBounceStarted", i.REEL_SET_SPIN_SPEED = "spinReelEvent_reelSetSpinSpeed", i.REEL_SET_CURRENT_REEL_SET = "spinReelEvent_setCurrentReelSet", i.ADD_SLOW_ATTENTION_SPIN_SYMBOL_TO_REEL = "spinReelEvent_addSlowAttentionSpinSymbolToReel", i.REMOVE_SLOW_ATTENTION_SPIN_SYMBOL_FROM_REEL = "spinReelEvent_removeSlowAttentionSpinSymbolFromReel", i.SET_REEL_NEXT_SPIN_FULL_STACKED = "spinReelEvent_setReelNextSpinFullStacked", i.REEL_TRY_NEAR_WIN = "reelEvent_reelTryNearWin", i.REEL_ON_NEAR_WIN = "reelEvent_reelOnNearWin", e.SpinReelEvent = i
			},
			90441: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SpinReelPartAnimator = void 0;
				const n = i(13006),
					s = i(52409),
					o = i(44679),
					r = i(75367),
					a = i(56978),
					l = i(34785),
					h = i(57244),
					u = i(52601);
				class c extends a.ReelPartAnimator {
					get isQuickStop() {
						return this._isQuickStop
					}
					set isQuickStop(t) {
						this._isQuickStop = t, this._isQuickStop && (this._spinSpeedsQueue && this._spinSpeedsQueue.length > 0 && (this._spinSpeedsQueue.length = 0), this.stopSpeed = a.ReelPartAnimator._spinQuickStopSpeeds[this._reelId])
					}
					get preYPos() {
						return this._preYPos
					}
					get yPos() {
						return this._yPos
					}
					set yPos(t) {
						if (t === this._yPos) return;
						this._preYPos = this._yPos, this._yPos = t;
						const e = h.MathHelper.floorToDecimals(t, 2);
						for (let t = 0; t < this._symbolsToAnimate.length; t++) this._symbolsToAnimate[t].y = h.MathHelper.floorToDecimals(this._targetPositions[t] + e, 2)
					}
					get currentSpeed() {
						return this._currentSpeed
					}
					get spinSpeedsQueue() {
						return this._spinSpeedsQueue
					}
					get currentStepLeftTime() {
						return null != this._currentTween && this._currentTween.isActive() ? this._currentSpeed * (1 - this._currentTween.progress()) : 0
					}
					constructor(t) {
						super(t), this._currentSpeed = 0
					}
					initTargetPositions() {
						let t;
						this._targetPositions = [];
						const e = l.ArrayHelper.arraySum(r.GameConfig.instance.SYMBOLS_NUM_IN_REEL) + 1,
							i = r.GameConfig.instance.SYMBOLS_NUM_IN_REEL[0] + r.GameConfig.instance.SYMBOLS_NUM_IN_REEL[1] + 1;
						for (let n = 0; n < e; n++) t = this.symStep * (n - i) + this._symHeight / 2, this._targetPositions.push(t)
					}
					initSymbolsPosition() {
						this._yPos = 0, this._preYPos = 0, this.yPos = this.symStep
					}
					getStartSpinAnimate(t, e) {
						this._symbolsToAnimate.unshift(e), this.resetSymbolsPosition();
						const i = this.calculateStartSpinSpeed();
						this._currentTween = n.TweenLite.to(this, i, {
							ease: r.GameConfig.instance.REEL_SPIN_START_EASE,
							yPos: this.symStep
						});
						const s = new n.TimelineLite;
						return s.add([this._currentTween, () => {
							this._currentSpeed = i, this.fadeInBlurSymbols()
						}], t), s
					}
					calculateStartSpinSpeed() {
						return this.startSpeed
					}
					fadeInBlurSymbols() {
						for (let t = 0; t < this._symbolsToAnimate.length; t++) this._symbolsToAnimate[t].changeState({
							state: r.GameConfig.instance.SYMBOL_STATES.spin,
							replay: !1,
							fadeInDuration: r.GameConfig.instance.REEL_SPIN_START_SYMBOL_CHANGE_TO_SPIN_STATE_DURATION,
							fadeInDelay: r.GameConfig.instance.REEL_SPIN_START_SYMBOL_CHANGE_TO_SPIN_STATE_DELAY
						})
					}
					resetSymbolsPosition() {
						this.yPos = 0, this._preYPos = 0
					}
					getSpinAnimation(t) {
						this._symbolsToAnimate.unshift(t), this.resetSymbolsPosition();
						const e = this.calculateSpinSpeed();
						this._currentTween = n.TweenLite.to(this, e, {
							ease: n.Linear.easeNone,
							yPos: this.symStep
						});
						const i = new n.TimelineLite;
						return i.add([this._currentTween, () => this._currentSpeed = e]), i
					}
					calculateSpinSpeed() {
						return !this.isQuickStop && this._spinSpeedsQueue && this._spinSpeedsQueue.length > 0 ? this._spinSpeedsQueue.shift() : this.spinSpeed
					}
					setupTweenSpinSpeedQueue(t, e) {
						this._spinSpeedsQueue = l.ArrayHelper.initArrayWithValues(e, (e => t))
					}
					getStopTime(t, e) {
						return (!this.isQuickStop && e ? c._nearWinSpinSpeeds[this._reelId] : this.spinSpeed) * t + this.stopSpeed
					}
					getSpinStopEase() {
						const t = r.GameConfig.instance.REEL_SPIN_STOP_ELASTIC_CONFIG;
						return n.Elastic.easeOut.config(t[0], t[1])
					}
					getSpinQuickStopEase() {
						const t = r.GameConfig.instance.REEL_SPIN_QUICK_STOP_ELASTIC_CONFIG;
						return n.Elastic.easeOut.config(t[0], t[1])
					}
					getStopSpinAnimation(t) {
						this._symbolsToAnimate.unshift(t), this.resetSymbolsPosition(), this._bouncingTargetReached = !1;
						const e = this.calculationStopSpinSpeed();
						this._currentTween = n.TweenLite.to(this, e, {
							ease: this.isQuickStop ? this.getSpinQuickStopEase() : this.getSpinStopEase(),
							yPos: this.symStep,
							onUpdate: () => this.onBouncingUpdate()
						});
						const i = new n.TimelineLite;
						return i.add([this._currentTween, () => {
							this._currentSpeed = e, this.fadeOutSymbolBlur()
						}]), i.add((() => this.onSpinStopCompleted())), i
					}
					calculationStopSpinSpeed() {
						return !this.isQuickStop && this._spinSpeedsQueue && this._spinSpeedsQueue.length > 0 ? this._spinSpeedsQueue.shift() : this.stopSpeed
					}
					onBouncingUpdate() {
						this._bouncingTargetReached || this._yPos < this._preYPos && this.onBouncingTargetReached()
					}
					onBouncingTargetReached() {
						this._bouncingTargetReached = !0, s.EventHandler.dispatchEvent(new o.GameEvent(u.SpinReelEvent.REEL_STOP_SPIN_BOUNCE_STARTED, {
							reelId: this._reelId,
							quickStop: this.isQuickStop,
							fastSpin: this.isFastSpin
						}))
					}
					fadeOutSymbolBlur() {
						for (let t = 0; t < this._symbolsToAnimate.length; t++) this._symbolsToAnimate[t].changeState({
							state: r.GameConfig.instance.REEL_SPIN_STOP_SYMBOL_STATE ? r.GameConfig.instance.REEL_SPIN_STOP_SYMBOL_STATE() : r.GameConfig.instance.SYMBOL_STATES.normal,
							replay: !1,
							fadeInDuration: r.GameConfig.instance.REEL_SPIN_STOP_SYMBOL_CHANGE_FROM_SPIN_STATE_DURATION,
							fadeInDelay: r.GameConfig.instance.REEL_SPIN_STOP_SYMBOL_CHANGE_FROM_SPIN_STATE_DELAY
						})
					}
					onSpinStopCompleted() {
						this._currentSpeed = 0, this._currentTween = null, this._spinSpeedsQueue && this._spinSpeedsQueue.length > 0 && (this._spinSpeedsQueue.length = 0), this._bouncingTargetReached || this.onBouncingTargetReached()
					}
					playNearWin(t) {
						this.spinSpeed = null != t ? t : c._nearWinSpinSpeeds[this._reelId]
					}
				}
				e.SpinReelPartAnimator = c
			},
			83857: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SpinServerDataParser = void 0;
				const n = i(75367),
					s = i(17206),
					o = i(34785);
				class r extends s.ServerDataParser {
					constructor() {
						super()
					}
					parseNearWinReels(t) {
						return null == t.nearWinReels ? o.ArrayHelper.initArrayWithValues(n.GameConfig.instance.REELS_NUM, (() => !1)) : t.nearWinReels.concat()
					}
					parseNearWinBigWinReels(t) {
						return null == t.nearWinBigWinReels ? o.ArrayHelper.initArrayWithValues(n.GameConfig.instance.REELS_NUM, (() => !1)) : t.nearWinBigWinReels.concat()
					}
				}
				e.SpinServerDataParser = r
			},
			49775: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.FreespinOutroController = void 0;
				const n = i(83673),
					s = i(92323),
					o = i(23110);
				class r extends s.ScreenController {
					constructor(t, e) {
						super("FreespinOutro", t, e)
					}
					calculateIsTriggered(t) {
						return t.mode === n.GameMode.FREESPIN && 0 === t.freespinsLeft
					}
					show() {
						return super.show(), o.SlotGame.keypad.setZeroBetSpinCounter(-1), !0
					}
					close() {
						super.close()
					}
				}
				e.FreespinOutroController = r
			},
			42352: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.StepCountUpBigWinController = void 0;
				const n = i(13006),
					s = i(52409),
					o = i(44679),
					r = i(75367),
					a = i(32696),
					l = i(99313);
				class h extends l.WinPresentationController {
					constructor(t, e, i = {
						name: "StepCountUpBigWin",
						skippable: !0,
						tweakEnabled: !0
					}) {
						super(t, i), this._winLevel = -1, this._currentLevel = -1, this._winRatios = r.GameConfig.instance.WIN_RATIOS.bigWin, this._skipLastLevelCountUpIfSmall = !0 === e.skipLastLevelCountUpIfSmall, this._skippableOnEachLevel = !0 === e.skippableOnEachLevel
					}
					parseFeatureGameData(t) {
						if (t && t.isBigWin) {
							for (let e = this._winRatios.length - 1; e >= 0; e--)
								if (t.currentWinRatio > this._winRatios[e].ratio) return void(this._winLevel = e);
							this._winLevel = 0
						} else this._winLevel = -1
					}
					hasWin() {
						return null != this._gameData && this._gameData.isBigWin
					}
					startWinPresentation() {
						this.playBigWinLevelAnimation(0), this.playSymbolsAnimation && this.playSymbolsAnimation(), this.playBigWinSound && this.playBigWinSound()
					}
					playBigWinLevelAnimation(t) {
						if (this._currentLevel = t, this._skipLastLevelCountUpIfSmall && t === this._winLevel && this.isLevelWinTooSmall(t) || !(t <= this._winLevel)) this.finish();
						else {
							this._skippableOnEachLevel && s.EventHandler.dispatchEvent(new o.GameEvent(a.SpinEvent.WANT_SKIPPABLE));
							const e = this.getBigWinLevelAnimation(t);
							this._currentTimeline = new n.TimelineLite({
								paused: !0
							}), this._currentTimeline.add([e, this.playBigWinCountUp(t, e.totalDuration()), () => {
								this.playBigWinLevelSound && this.playBigWinLevelSound(t)
							}]), this._currentTimeline.add((() => {
								this.playBigWinLevelAnimation(t + 1)
							})), this._currentTimeline.play()
						}
					}
					isLevelWinTooSmall(t) {
						if (0 === t) return !1;
						const e = this._gameData.playedBetValue * r.GameConfig.instance.WIN_RATIOS.bigWin[t].ratio;
						return this._gameData.singleWin - e <= .1 * e
					}
					playBigWinCountUp(t, e) {
						const i = this._gameData.totalWin - this._gameData.singleWin,
							s = 0 === t ? 0 : this._gameData.playedBetValue * r.GameConfig.instance.WIN_RATIOS.bigWin[t].ratio,
							o = t === this._winLevel ? this._gameData.singleWin : this._gameData.playedBetValue * r.GameConfig.instance.WIN_RATIOS.bigWin[t + 1].ratio,
							a = new n.TimelineLite;
						return a.add([this.playCountUp(s, o, e, i), () => {
							this.playBigWinCountUpSound && this.playBigWinCountUpSound(t)
						}]), a
					}
					abort() {
						this._isPlaying && this._skippable && this._skippableOnEachLevel ? this.abortCurrentLevel(this._currentLevel) : super.abort()
					}
					abortCurrentLevel(t) {
						this._currentTimeline && this._currentTimeline.isActive() && this._currentTimeline.progress(1)
					}
					stopWinPresentation(t) {
						if (this._currentTimeline && this._currentTimeline.isActive() && (this._currentTimeline.pause(), this._currentTimeline.kill()), this._currentTimeline = null, this.playSymbolsAnimation) {
							if (null == this.stopSymbolsAnimation) throw new Error("StepCountUpBigWinController.stopWinPresentation():stopSymbolsAnimation() must be implemented when there is sound playing.");
							this.stopSymbolsAnimation()
						}
						if (this.playBigWinSound || this.playBigWinLevelSound || this.playBigWinCountUpSound) {
							if (null == this.stopAllSounds) throw new Error("StepCountUpBigWinController.stopWinPresentation():stopAllSounds() must be implemented when there is sound playing.");
							this.stopAllSounds()
						}
						this.playEndingAnimation && this.playEndingAnimation(t)
					}
					resetFeature() {
						this._winLevel = -1, this._currentLevel = -1
					}
				}
				e.StepCountUpBigWinController = h
			},
			68744: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BitmapWinCountUp = void 0;
				const n = i(73044),
					s = i(86069),
					o = i(13006),
					r = i(75367);
				class a extends n.BaseView {
					constructor(t) {
						super(), this._style = t
					}
					initAnimations() {
						this._countUp = new s.BitmapCountUp({
							style: this._style,
							evenWidth: this.isFontEvenWidth()
						}), this._countUp.shrinkSize = !0, this._countUp.maxTextWidth = .9 * r.GameConfig.instance.REEL_AREA_WIDTH, this._countUp.visible = !1, this._countUpContainer = new PIXI.Sprite, this._countUpContainer.anchor.set(.5, .5), this._countUpContainer.addChild(this._countUp), this.addChild(this._countUpContainer)
					}
					abort(t, e, ...i) {
						const n = new o.TimelineLite;
						return e && n.add(this.getAbortAnimation(t, ...i)), n.add(this.getEndingAnimation(t, ...i)), n
					}
					isFontEvenWidth() {
						return !0
					}
				}
				e.BitmapWinCountUp = a
			},
			75129: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BetLineWinIndividualWPController = void 0;
				const n = i(53108),
					s = i(52409),
					o = i(44679),
					r = i(75367),
					a = i(23792),
					l = i(81084),
					h = i(13006);
				class u extends l.IndividualWinPresentationController {
					constructor(t, e = "BetLineIndividualWin", i) {
						super(e, i, 1), this._config = t
					}
					getLineAnimation(t) {
						const e = new h.TimelineLite;
						e.add((() => {
							s.EventHandler.dispatchEvent(new o.GameEvent(n.BetLineEvent.HIDE_ALL_BET_LINES)), s.EventHandler.dispatchEvent(new o.GameEvent(n.BetLineEvent.SHOW_WIN_BET_LINE, t.betLineIndex + 1))
						}));
						for (let i = 0; i < t.nrOfSymbols; i++) {
							const n = a.Reels.getSymbol(i, t.betLine[i]);
							n && (this.addSymbolWinAnimationToTimeline(t, e, this._config.symbolTimeOffsetCalculator(e.totalDuration(), i, t.betLine[i]), n, i, t.betLine[i]), -1 === this._winSymbols.indexOf(n) && this._winSymbols.push(n))
						}
						return e
					}
					addSymbolWinAnimationToTimeline(t, e, i, n, s, o) {
						e.add([() => this.sortSymbolDepthToTop(n), n.changeState({
							state: r.GameConfig.instance.SYMBOL_STATES.win,
							setStack: !0,
							fadeInDuration: .4
						})], i)
					}
					sortSymbolDepthToTop(t) {
						t && t.parent && t.parent.addChild(t)
					}
				}
				e.BetLineWinIndividualWPController = u
			},
			14571: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.InitialWinPresentationController = void 0;
				const n = i(13006),
					s = i(75367),
					o = i(99313);
				class r extends o.WinPresentationController {
					constructor(t, e = {
						name: "InitialWin",
						hasWinCountUp: !0,
						skippable: !0,
						tweakEnabled: !0
					}) {
						super(t, e), this._config = e, this._winSymbols = []
					}
					hasWin() {
						return null != this._betWinsData && this._betWinsData.length > 0
					}
					startWinPresentation() {
						const t = new n.TimelineLite({
							paused: !0,
							onComplete: () => this.finish()
						});
						this.playAllNoWinSymbols && this.playAllNoWinSymbols(t), this.addWinAnimationsToTimeline(t), this._config.hasWinCountUp && this.addWinCountUpToTimeline && this.addWinCountUpToTimeline(t), this._timeline = t, this._timeline.play()
					}
					stopWinPresentation(t) {
						for (this._timeline && (this._timeline.isActive() && (this._timeline.pause(), this._timeline.kill()), this._timeline = null); this._winSymbols.length > 0;) this._winSymbols.pop().changeState({
							state: s.GameConfig.instance.SYMBOL_STATES.win,
							frames: [-1, -1]
						})
					}
				}
				e.InitialWinPresentationController = r
			},
			95968: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SequentiallyBetLineInitialWPController = void 0;
				const n = i(53108),
					s = i(52409),
					o = i(44679),
					r = i(75367),
					a = i(35213);
				class l extends a.SequentiallyInitialWPController {
					constructor(t, e = {
						name: "SequentiallyBetLineInitialWin",
						hasWinCountUp: !0,
						skippable: !0,
						tweakEnabled: !0,
						betWinMode: 1,
						shouldPlayBetLine: !0
					}) {
						super(t, e), this._betLineWinConfig = e
					}
					addSingleBetWinAnimationToTimeline(t, e, i) {
						const n = t.nrOfSymbols;
						let s, o = 0;
						for (let r = 0; r < n; r++) {
							if (s = this.findSymbol(r, t.betLine[r]), !s) throw new Error(`Error: SequentiallyBetLineInitialWPController.playBetWinPresentation(): Cannot find symbol at reel ${r} symbol ${t.betLine[r]}`);
							o += this.addSymbolWinAnimationToTimeline(t, e, i + o, s, r, t.betLine[r]), -1 === this._winSymbols.indexOf(s) && this._winSymbols.push(s)
						}
						return this._betLineWinConfig.shouldPlayBetLine && e.add((() => this.playBetLine(t.betLineIndex + 1)), i), this.getNextBetWinAnimationTimeOffset(o)
					}
					addSymbolWinAnimationToTimeline(t, e, i, n, s, o) {
						const a = n.changeState({
							state: r.GameConfig.instance.SYMBOL_STATES.win,
							setStack: !0,
							fadeInDuration: .1
						});
						return e.add([() => this.sortSymbolDepthToTop(n), a], i), this.getNextSymbolAnimationTimeOffset(a.totalDuration())
					}
					sortSymbolDepthToTop(t) {
						t && t.parent && t.parent.addChild(t)
					}
					playBetLine(t) {
						s.EventHandler.dispatchEvent(new o.GameEvent(n.BetLineEvent.SHOW_WIN_BET_LINE, t))
					}
					getNextBetWinAnimationTimeOffset(t) {
						return t
					}
					getNextSymbolAnimationTimeOffset(t) {
						return t
					}
				}
				e.SequentiallyBetLineInitialWPController = l
			},
			35213: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SequentiallyInitialWPController = void 0;
				const n = i(23792),
					s = i(23110),
					o = i(14571);
				class r extends o.InitialWinPresentationController {
					constructor(t, e = {
						name: "SequentiallyInitialWin",
						hasWinCountUp: !0,
						skippable: !0,
						tweakEnabled: !0
					}) {
						super(t, e)
					}
					addWinAnimationsToTimeline(t) {
						let e = 0;
						for (let i = 0; i < this._betWinsData.length; i++) e += this.addSingleBetWinAnimationToTimeline(this._betWinsData[i], t, e)
					}
					addWinCountUpToTimeline(t) {
						this._gameData.singleWin, this._gameData.totalWin;
						const e = this.getWinCountUpDuration(t),
							i = this.getWinCountUpDelay(t);
						t.add((() => s.SlotGame.winFieldController.showWinField()), i + e)
					}
					getWinCountUpDuration(t) {
						return this._gameData.currentWinRatio <= 1 ? 0 : t.totalDuration()
					}
					getWinCountUpDelay(t) {
						return 0
					}
					findSymbol(t, e) {
						return n.Reels.getSymbol(t, e)
					}
				}
				e.SequentiallyInitialWPController = r
			},
			35829: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NoWinSymbolsWinPresentationController = void 0;
				const n = i(52409),
					s = i(75367),
					o = i(23792),
					r = i(55058),
					a = i(32696),
					l = i(34785),
					h = i(99313);
				class u extends h.WinPresentationController {
					constructor(t, e, i = {
						name: "NoWinSymbol",
						skippable: !1
					}) {
						super(t, i), this._noWinSymbols = [], this._reelsNum = s.GameConfig.instance.REELS_NUM, this._symbolsNum = s.GameConfig.instance.SYMBOLS_NUM_IN_REEL[2], this._noWinConfig = e
					}
					addFeatureEventHandlers() {
						n.EventHandler.addEventListener(this, a.SpinEvent.BEFORE_START, (t => this.onBeforeSpinStart()))
					}
					onBeforeSpinStart() {
						for (; this._noWinSymbols.length > 0;) this._noWinSymbols.pop().changeState({
							state: s.GameConfig.instance.SYMBOL_STATES.normal,
							fadeInDuration: .5
						})
					}
					parseFeatureGameData(t) {
						if (this.hasWin()) switch (this._symbolWinStates = l.ArrayHelper.initArrayWithValues(this._reelsNum, (() => l.ArrayHelper.initArrayWithValues(this._symbolsNum, (() => !1)))), s.GameConfig.instance.BET_WIN_MODE) {
							case 1:
								this.getBetLineSymbolWinStates();
								break;
							case 2:
								this.getBetWaySymbolWinStates()
						}
					}
					getBetWaySymbolWinStates() {
						this._betWinsData.forEach((t => {
							const e = t;
							for (let t = 0; t < e.reelWinPositions.length; t++)
								for (let i = 0; i < e.reelWinPositions[t].length; i++) e.reelWinPositions[t][i] && (this._symbolWinStates[t][i] = !0, this.updateStackedSymbolWinStates(t, i))
						}))
					}
					getBetLineSymbolWinStates() {
						this._betWinsData.forEach((t => {
							const e = t;
							for (let t = 0; t < e.nrOfSymbols; t++) {
								const i = e.betLine[t];
								this._symbolWinStates[t][i] = !0, this.updateStackedSymbolWinStates(t, i)
							}
						}))
					}
					updateStackedSymbolWinStates(t, e) {
						if (null == s.GameConfig.instance.STACKED_SYMBOLS) return;
						const i = r.StateReelSymbol.parseStackedSymbolName(this._gameData.reels[t][e + s.GameConfig.instance.SYMBOLS_NUM_IN_REEL[1]], t);
						if (i.isStacked)
							for (let n = 0; n < i.totalNum; n++) this._symbolWinStates[t][Math.min(s.GameConfig.instance.SYMBOLS_NUM_IN_REEL[2] - 1, Math.max(0, n - i.index + e))] = !0
					}
					hasWin() {
						return null != this._betWinsData && this._betWinsData.length > 0
					}
					startWinPresentation() {
						this.finish()
					}
					stopWinPresentation(t) {
						if (t) return;
						let e;
						for (let t = 0; t < this._symbolWinStates.length; t++)
							for (let i = 0; i < this._symbolWinStates[t].length; i++) this._symbolWinStates[t][i] || (e = o.Reels.getSymbol(t, i), null != e && (e.changeState({
								state: s.GameConfig.instance.SYMBOL_STATES.noWin,
								fadeInDuration: this._noWinConfig.noWinStateFadeInDuration
							}), this._noWinSymbols.push(e)))
					}
				}
				e.NoWinSymbolsWinPresentationController = u
			},
			43635: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NudgeStackedSymbolWPController = void 0;
				const n = i(46334),
					s = i(13006),
					o = i(52409),
					r = i(75367),
					a = i(23792),
					l = i(34785),
					h = i(99313),
					u = i(63927);
				class c extends h.WinPresentationController {
					constructor(t, e, i = {
						name: "NudgeStackedSymbol",
						skippable: !0,
						tweakEnabled: !0
					}) {
						super(t, i), this._nudgeAborted = !1, this._nudgeConfig = e, null == this._nudgeConfig.endingDelay && (this._nudgeConfig.endingDelay = 0), this.resetFeature()
					}
					addFeatureEventHandlers() {
						o.EventHandler.addEventListener(this, u.NudgeReelEvent.NUDGE_STEP_START, (t => this.onNudgeStepStart(t.params[0], t.params[1]))), o.EventHandler.addEventListener(this, u.NudgeReelEvent.NUDGE_STEP_COMPLETED, (t => this.onNudgeStepCompeted(t.params[0], t.params[1]))), o.EventHandler.addEventListener(this, u.NudgeReelEvent.NUDGE_COMPLETED, (t => this.onNudgeCompleted(t.params[0], t.params[1])))
					}
					parseFeatureGameData(t) {
						this._nudgeData = t, this._noWinNudge = this.isNoWinNudge(t)
					}
					isNoWinNudge(t) {
						return !(null != this._betWinsData && this._betWinsData.length > 0)
					}
					hasWin() {
						return n.Logger.logDev(`server data doReelNudge: ${this._nudgeData.doReelNudge.toString()}`), this._nudgeData.doReelNudge.indexOf(!0) > -1
					}
					startWinPresentation() {
						let t = 0;
						this._nudgeData.doReelNudge.forEach(((e, i) => {
							e && (this.doReelNudge(i, t), t += this.getReelNoWinNudge(i) ? this.getNoWinNudgeSpeed() : this.getNextReelNudgeDelayDelta(i))
						}))
					}
					getNextReelNudgeDelayDelta(t) {
						return Math.abs(this._steps[t]) * this._nudgeConfig.nudgeStepSpeed
					}
					getNoWinNudgeSpeed() {
						return .001
					}
					doReelNudge(t, e) {
						this._nudgeState[t] = !0;
						let i = -1,
							n = -1;
						const o = this.getNudgeRange(t);
						for (let e = o[0]; e < o[1]; e++) {
							const s = a.Reels.getSymbol(t, e, !1);
							if (s.symName.indexOf(this._nudgeConfig.stackedSymbolKeyword) > -1) {
								i = e, n = s.stackedSymName.index;
								break
							}
						}
						if (-1 === i) throw new Error(`NudgeStackedSymbolWPController.doReelNudge():There is no symbol contains ${this._nudgeConfig.stackedSymbolKeyword} in a nudging reel. reelId = ${t}`);
						this._nudgeSymbolId[t] = i, this._steps[t] = o[0] + n - i;
						const r = this._nudgeConfig.nudgeEase ? this._nudgeConfig.nudgeEase : s.Elastic.easeIn.config(1, 1);
						a.Reels.getReel(t).nudge(this._steps[t], this.getReelNoWinNudge(t) ? this.getNoWinNudgeSpeed() : this._nudgeConfig.nudgeStepSpeed, r, e)
					}
					getReelNoWinNudge(t) {
						return this._noWinNudge
					}
					getNudgeRange(t) {
						return [0, r.GameConfig.instance.SYMBOLS_NUM_IN_REEL[2]]
					}
					onNudgeStepStart(t, e) {
						this._nudgeState[t] && (this.getReelNoWinNudge(t) || this.playNudgeStepStart && this.playNudgeStepStart(t, e))
					}
					onNudgeStepCompeted(t, e) {
						if (!this._nudgeState[t]) return;
						const i = this._steps[t];
						i > 0 ? this._nudgedSteps[t]++ : i < 0 && this._nudgedSteps[t]--, this.playOnNudgeStepComplete && this.playOnNudgeStepComplete(t, e)
					}
					onNudgeCompleted(t, e) {
						this._nudgeState[t] && (this._nudgeState[t] = !1, this.playOnReelNudgeComplete && this.playOnReelNudgeComplete(t, e), this._nudgeState.indexOf(!0) > -1 || this.playOnAllNudgeComplete(e))
					}
					playOnAllNudgeComplete(t) {
						this._finishTimeline = new s.TimelineLite, this._finishTimeline.add((() => this.finish()), this._noWinNudge || t ? 0 : this._nudgeConfig.endingDelay), this._finishTimeline.play()
					}
					abortWinPresentation() {
						let t = !1;
						this._nudgeState.forEach(((e, i) => {
							e && (this._nudgeAborted = !0, Math.abs(this._steps[i]) - Math.abs(this._nudgedSteps[i]) > 0 && (t = !0), this.abortNudgingReel(i))
						})), this._nudgeAborted && t && this.playNudgeAbortSound && this.playNudgeAbortSound()
					}
					stopWinPresentation(t) {
						this._finishTimeline && (this._finishTimeline.paused(), this._finishTimeline.kill(), this._finishTimeline = null)
					}
					abortNudgingReel(t) {
						a.Reels.getReel(t).abortNudge()
					}
					resetFeature() {
						this._nudgeData = null, this._nudgeAborted = !1, this._noWinNudge = !1, this._steps = l.ArrayHelper.initArrayWithValues(r.GameConfig.instance.REELS_NUM, (() => 0)), this._nudgedSteps = l.ArrayHelper.initArrayWithValues(r.GameConfig.instance.REELS_NUM, (() => 0)), this._nudgeState = l.ArrayHelper.initArrayWithValues(r.GameConfig.instance.REELS_NUM, (() => !1)), this._nudgeSymbolId = l.ArrayHelper.initArrayWithValues(r.GameConfig.instance.REELS_NUM, (() => -1))
					}
				}
				e.NudgeStackedSymbolWPController = c
			},
			47206: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.FreespinZeroBetController = void 0;
				const n = i(83673),
					s = i(84833);
				class o extends s.ZeroBetController {
					constructor() {
						super()
					}
					getZeroBetNumberLeft(t) {
						return t.freespinsLeft
					}
					shouldSubtractZeroBetCounter() {
						return !0
					}
					shouldShowZeroBetCounter() {
						return !0
					}
					calculateIsTriggered(t) {
						return t.nextMode === n.GameMode.FREESPIN
					}
				}
				e.FreespinZeroBetController = o
			},
			45247: function(t, e, i) {
				var n, s, o, r = t.exports && void 0 !== i.g ? i.g : this || window;
				(r._gsQueue || (r._gsQueue = [])).push((function() {
						"use strict";
						r._gsDefine("easing.CustomEase", ["easing.Ease"], (function(t) {
							var e = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
								i = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
								n = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/gi,
								s = /[cLlsS]/g,
								o = "CustomEase only accepts Cubic Bezier data.",
								r = function(t, e, i, n, s, o, a, l, h, u, c) {
									var d, p = (t + i) / 2,
										_ = (e + n) / 2,
										m = (i + s) / 2,
										g = (n + o) / 2,
										f = (s + a) / 2,
										S = (o + l) / 2,
										y = (p + m) / 2,
										v = (_ + g) / 2,
										T = (m + f) / 2,
										E = (g + S) / 2,
										b = (y + T) / 2,
										A = (v + E) / 2,
										P = a - t,
										I = l - e,
										w = Math.abs((i - a) * I - (n - l) * P),
										L = Math.abs((s - a) * I - (o - l) * P);
									return u || (u = [{
										x: t,
										y: e
									}, {
										x: a,
										y: l
									}], c = 1), u.splice(c || u.length - 1, 0, {
										x: b,
										y: A
									}), (w + L) * (w + L) > h * (P * P + I * I) && (d = u.length, r(t, e, p, _, y, v, b, A, h, u, c), r(b, A, T, E, f, S, a, l, h, u, c + 1 + (u.length - d))), u
								},
								a = function(t) {
									var e = this.lookup[t * this.l | 0] || this.lookup[this.l - 1];
									return e.nx < t && (e = e.n), e.y + (t - e.x) / e.cx * e.cy
								},
								l = function(e, i, n) {
									this._calcEnd = !0, this.id = e, e && (t.map[e] = this), this.getRatio = a, this.setData(i, n)
								},
								h = l.prototype = new t;
							return h.constructor = l, h.setData = function(t, a) {
								var l, h, u, c, d, p, _, m, g, f, S = (t = t || "0,0,1,1").match(e),
									y = 1,
									v = [];
								if (f = (a = a || {}).precision || 1, this.data = t, this.lookup = [], this.points = v, this.fast = f <= 1, (s.test(t) || -1 !== t.indexOf("M") && -1 === t.indexOf("C")) && (S = function(t) {
										var e, s, r, a, l, h, u, c, d, p, _, m = (t + "").replace(n, (function(t) {
												var e = +t;
												return e < 1e-4 && e > -1e-4 ? 0 : e
											})).match(i) || [],
											g = [],
											f = 0,
											S = 0,
											y = m.length,
											v = 2;
										for (e = 0; e < y; e++)
											if (d = a, isNaN(m[e]) ? l = (a = m[e].toUpperCase()) !== m[e] : e--, s = +m[e + 1], r = +m[e + 2], l && (s += f, r += S), e || (u = s, c = r), "M" === a) h && h.length < 8 && (g.length -= 1, v = 0), f = u = s, S = c = r, h = [s, r], v = 2, g.push(h), e += 2, a = "L";
											else if ("C" === a) h || (h = [0, 0]), h[v++] = s, h[v++] = r, l || (f = S = 0), h[v++] = f + 1 * m[e + 3], h[v++] = S + 1 * m[e + 4], h[v++] = f += 1 * m[e + 5], h[v++] = S += 1 * m[e + 6], e += 6;
										else if ("S" === a) "C" === d || "S" === d ? (p = f - h[v - 4], _ = S - h[v - 3], h[v++] = f + p, h[v++] = S + _) : (h[v++] = f, h[v++] = S), h[v++] = s, h[v++] = r, l || (f = S = 0), h[v++] = f += 1 * m[e + 3], h[v++] = S += 1 * m[e + 4], e += 4;
										else {
											if ("L" !== a && "Z" !== a) throw o;
											"Z" === a && (s = u, r = c, h.closed = !0), ("L" === a || Math.abs(f - s) > .5 || Math.abs(S - r) > .5) && (h[v++] = f + (s - f) / 3, h[v++] = S + (r - S) / 3, h[v++] = f + 2 * (s - f) / 3, h[v++] = S + 2 * (r - S) / 3, h[v++] = s, h[v++] = r, "L" === a && (e += 2)), f = s, S = r
										}
										return g[0]
									}(t)), 4 === (l = S.length)) S.unshift(0, 0), S.push(1, 1), l = 8;
								else if ((l - 2) % 6) throw o;
								for (0 == +S[0] && 1 == +S[l - 2] || function(t, e, i) {
										i || 0 === i || (i = Math.max(+t[t.length - 1], +t[1]));
										var n, s = -1 * +t[0],
											o = -i,
											r = t.length,
											a = 1 / (+t[r - 2] + s),
											l = -e || (Math.abs(+t[r - 1] - +t[1]) < .01 * (+t[r - 2] - +t[0]) ? function(t) {
												var e, i = t.length,
													n = 999999999999;
												for (e = 1; e < i; e += 6) + t[e] < n && (n = +t[e]);
												return n
											}(t) + o : +t[r - 1] + o);
										for (l = l ? 1 / l : -a, n = 0; n < r; n += 2) t[n] = (+t[n] + s) * a, t[n + 1] = (+t[n + 1] + o) * l
									}(S, a.height, a.originY), this.rawBezier = S, c = 2; c < l; c += 6) h = {
									x: +S[c - 2],
									y: +S[c - 1]
								}, u = {
									x: +S[c + 4],
									y: +S[c + 5]
								}, v.push(h, u), r(h.x, h.y, +S[c], +S[c + 1], +S[c + 2], +S[c + 3], u.x, u.y, 1 / (2e5 * f), v, v.length - 1);
								for (l = v.length, c = 0; c < l; c++) _ = v[c], m = v[c - 1] || _, _.x > m.x || m.y !== _.y && m.x === _.x || _ === m ? (m.cx = _.x - m.x, m.cy = _.y - m.y, m.n = _, m.nx = _.x, this.fast && c > 1 && Math.abs(m.cy / m.cx - v[c - 2].cy / v[c - 2].cx) > 2 && (this.fast = !1), m.cx < y && (m.cx ? y = m.cx : (m.cx = .001, c === l - 1 && (m.x -= .001, y = Math.min(y, .001), this.fast = !1)))) : (v.splice(c--, 1), l--);
								if (l = 1 / y + 1 | 0, this.l = l, d = 1 / l, p = 0, _ = v[0], this.fast) {
									for (c = 0; c < l; c++) g = c * d, _.nx < g && (_ = v[++p]), h = _.y + (g - _.x) / _.cx * _.cy, this.lookup[c] = {
										x: g,
										cx: d,
										y: h,
										cy: 0,
										nx: 9
									}, c && (this.lookup[c - 1].cy = h - this.lookup[c - 1].y);
									this.lookup[l - 1].cy = v[v.length - 1].y - h
								} else {
									for (c = 0; c < l; c++) _.nx < c * d && (_ = v[++p]), this.lookup[c] = _;
									p < v.length - 1 && (this.lookup[c - 1] = v[v.length - 2])
								}
								return this._calcEnd = 1 !== v[v.length - 1].y || 0 !== v[0].y, this
							}, h.getRatio = a, h.getSVGData = function(t) {
								return l.getSVGData(this, t)
							}, l.create = function(t, e, i) {
								return new l(t, e, i)
							}, l.version = "0.2.2", l.bezierToPoints = r, l.get = function(e) {
								return t.map[e]
							}, l.getSVGData = function(e, i) {
								var n, s, o, r, a, l, h, u, c, d, p = 1e3,
									_ = (i = i || {}).width || 100,
									m = i.height || 100,
									g = i.x || 0,
									f = (i.y || 0) + m,
									S = i.path;
								if (i.invert && (m = -m, f = 0), (e = e.getRatio ? e : t.map[e] || console.log("No ease found: ", e)).rawBezier) {
									for (n = [], h = e.rawBezier.length, o = 0; o < h; o += 2) n.push(((g + e.rawBezier[o] * _) * p | 0) / p + "," + ((f + e.rawBezier[o + 1] * -m) * p | 0) / p);
									n[0] = "M" + n[0], n[1] = "C" + n[1]
								} else
									for (n = ["M" + g + "," + f], r = 1 / (h = Math.max(5, 200 * (i.precision || 1))), u = 5 / (h += 2), c = ((g + r * _) * p | 0) / p, s = ((d = ((f + e.getRatio(r) * -m) * p | 0) / p) - f) / (c - g), o = 2; o < h; o++) a = ((g + o * r * _) * p | 0) / p, l = ((f + e.getRatio(o * r) * -m) * p | 0) / p, (Math.abs((l - d) / (a - c) - s) > u || o === h - 1) && (n.push(c + "," + d), s = (l - d) / (a - c)), c = a, d = l;
								return S && ("string" == typeof S ? document.querySelector(S) : S).setAttribute("d", n.join(" ")), n.join(" ")
							}, l
						}), !0)
					})), r._gsDefine && r._gsQueue.pop()(),
					function(a) {
						"use strict";
						var l = function() {
							return (r.GreenSockGlobals || r).CustomEase
						};
						t.exports ? (i(23684), t.exports = l()) : (s = [i(23684)], void 0 === (o = "function" == typeof(n = l) ? n.apply(e, s) : n) || (t.exports = o))
					}()
			},
			34720: function(t, e, i) {
				var n, s, o, r = t.exports && void 0 !== i.g ? i.g : this || window;
				(r._gsQueue || (r._gsQueue = [])).push((function() {
						"use strict";
						r._gsDefine("easing.CustomWiggle", ["easing.CustomEase", "easing.Ease"], (function(t, e) {
							var i, n = {
									easeOut: new t("", "M0,1,C0.7,1,0.6,0,1,0"),
									easeInOut: new t("", "M0,0,C0.104,0,0.242,1,0.444,1,0.644,1,0.608,0,1,0"),
									anticipate: new t("", "M0,0,C0,0.222,0.024,0.386,0.06,0.402,0.181,0.455,0.647,0.646,0.7,0.67,0.9,0.76,1,0.846,1,1"),
									uniform: new t("", "M0,0,C0,0.95,0.01,1,0.01,1,0.01,1,1,1,1,1,1,1,1,0.01,1,0")
								},
								s = new t,
								o = function(i, n) {
									return (i = i.getRatio ? i : e.map[i] || new t("", i)).rawBezier || !n ? i : {
										getRatio: function(t) {
											return 1 - i.getRatio(t)
										}
									}
								},
								r = function(e, i) {
									this.vars = i || {}, t.call(this, e), this.update(this.vars)
								};
							return r.prototype = i = new t, i.constructor = r, i.update = function(t) {
								var e, i, r, a, l, h, u, c, d, p = 0 | ((t = t || this.vars).wiggles || 10),
									_ = 1 / p,
									m = _ / 2,
									g = "anticipate" === t.type,
									f = n[t.type] || n.easeOut,
									S = s;
								if (g && (S = f, f = n.easeOut), t.timingEase && (S = o(t.timingEase)), t.amplitudeEase && (f = o(t.amplitudeEase, !0)), c = [0, 0, (h = S.getRatio(m)) / 4, 0, h / 2, u = g ? -f.getRatio(m) : f.getRatio(m), h, u], "random" === t.type) {
									for (c.length = 4, e = S.getRatio(_), i = 2 * Math.random() - 1, d = 2; d < p; d++) m = e, u = i, e = S.getRatio(_ * d), i = 2 * Math.random() - 1, r = Math.atan2(i - c[c.length - 3], e - c[c.length - 4]), a = Math.cos(r) * _, l = Math.sin(r) * _, c.push(m - a, u - l, m, u, m + a, u + l);
									c.push(e, 0, 1, 0)
								} else {
									for (d = 1; d < p; d++) c.push(S.getRatio(m + _ / 2), u), m += _, u = (u > 0 ? -1 : 1) * f.getRatio(d * _), h = S.getRatio(m), c.push(S.getRatio(m - _ / 2), u, h, u);
									c.push(S.getRatio(m + _ / 4), u, S.getRatio(m + _ / 4), 0, 1, 0)
								}
								for (d = c.length; --d > -1;) c[d] = (1e3 * c[d] | 0) / 1e3;
								c[2] = "C" + c[2], this.setData("M" + c.join(","))
							}, r.create = function(t, e) {
								return new r(t, e)
							}, r.version = "0.2.1", r.eases = n, r
						}), !0)
					})), r._gsDefine && r._gsQueue.pop()(),
					function(a) {
						"use strict";
						var l = function() {
							return (r.GreenSockGlobals || r).CustomWiggle
						};
						t.exports ? (i(45247), i(23684), t.exports = l()) : (s = [i(23684), i(45247)], void 0 === (o = "function" == typeof(n = l) ? n.apply(e, s) : n) || (t.exports = o))
					}()
			},
			5266: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SkinLoader = void 0;
				const n = i(61e3),
					s = i(72468);
				class o {
					constructor() {
						this._animationAssets = new Map, this._introAssets = new Map, this._imgAssets = new Map, this._guideAssets = new Map, this._introLoadCallbacks = [], this._introLoadStarted = !1, this._isIntroLoaded = !1, this._isLoaded = !1, this._defaultImgUrl = "/node_modules/@nolimitcity/slot-keypad/resources/default/icons/", this._defaultGuideUrl = "/node_modules/@nolimitcity/slot-keypad/resources/default/gui_guide_images/", this._loader = new n.ImgLoader(s.NolimitApplication.resourcePath), this._introLoader = new n.ImgLoader(s.NolimitApplication.resourcePath), this._introAssets.set(o.NOLIMIT_BONUS_PRICE_TAG, this.makeImgUrl("keypad_icons/" + o.NOLIMIT_BONUS_PRICE_TAG)), this._imgAssets.set(o.X_BET_ANIMATION, this._defaultImgUrl + "keypad_icons/" + o.X_BET_ANIMATION), this._imgAssets.set(o.AUTO_PLAY_ON, this.makeImgUrl("keypad_icons/" + o.AUTO_PLAY_ON)), this._imgAssets.set(o.AUTO_PLAY_OFF, this.makeImgUrl("keypad_icons/" + o.AUTO_PLAY_OFF)), this._imgAssets.set(o.BACK, this.makeImgUrl("keypad_icons/" + o.BACK)), this._imgAssets.set(o.BET_LEVELS_BUTTON, this.makeImgUrl("keypad_icons/" + o.BET_LEVELS_BUTTON)), this._imgAssets.set(o.DEMO_ICON, this.makeImgUrl("keypad_icons/" + o.DEMO_ICON)), this._imgAssets.set(o.FAST_SPIN, this.makeImgUrl("keypad_icons/" + o.FAST_SPIN)), this._imgAssets.set(o.MENU, this.makeImgUrl("keypad_icons/" + o.MENU)), this._imgAssets.set(o.RING_LOADER, this.makeImgUrl("keypad_icons/" + o.RING_LOADER)), this._imgAssets.set(o.SOUND_ON, this.makeImgUrl("keypad_icons/" + o.SOUND_ON)), this._imgAssets.set(o.SOUND_OFF, this.makeImgUrl("keypad_icons/" + o.SOUND_OFF)), this._imgAssets.set(o.X_BET_BUTTON, this.makeImgUrl("keypad_icons/" + o.X_BET_BUTTON)), this._imgAssets.set(o.X_BET_BUTTON_BUBBLE, this.makeImgUrl("keypad_icons/" + o.X_BET_BUTTON_BUBBLE)), this._imgAssets.set(o.NOLIMIT_BONUS_BTN, this.makeImgUrl("keypad_icons/" + o.NOLIMIT_BONUS_BTN)), this._imgAssets.set(o.BET_UP, this.makeImgUrl("keypad_icons/" + o.BET_UP)), this._imgAssets.set(o.BET_DOWN, this.makeImgUrl("keypad_icons/" + o.BET_DOWN)), this._imgAssets.set(o.BONUS_ARROW, this.makeImgUrl("keypad_icons/" + o.BONUS_ARROW)), this._imgAssets.set(o.BONUS_ARROW_STROKE, this.makeImgUrl("keypad_icons/" + o.BONUS_ARROW_STROKE)), this._imgAssets.set(o.CONFIRM_POP_UP, this.makeImgUrl("keypad_icons/" + o.CONFIRM_POP_UP)), this._imgAssets.set(o.CONFIRM_POP_UP_WARNING, this.makeImgUrl("keypad_icons/" + o.CONFIRM_POP_UP_WARNING)), this._imgAssets.set(o.EXIT_LOBBY, this.makeImgUrl("menu_icons/" + o.EXIT_LOBBY)), this._imgAssets.set(o.HISTORY, this.makeImgUrl("menu_icons/" + o.HISTORY)), this._imgAssets.set(o.INFO, this.makeImgUrl("menu_icons/" + o.INFO)), this._imgAssets.set(o.SETTINGS, this.makeImgUrl("menu_icons/" + o.SETTINGS)), this._imgAssets.set(o.MENU_CLOSE, this.makeImgUrl("menu_icons/" + o.MENU_CLOSE)), this._imgAssets.set(o.SPIN_BUTTON_PLATE, this.makeImgUrl("spinbutton/" + o.SPIN_BUTTON_PLATE)), this._imgAssets.set(o.SPIN_ARROW, this.makeImgUrl("spinbutton/" + o.SPIN_ARROW)), this._imgAssets.set(o.SPIN_PLAY, this.makeImgUrl("spinbutton/" + o.SPIN_PLAY)), this._imgAssets.set(o.SPIN_SKIP, this.makeImgUrl("spinbutton/" + o.SPIN_SKIP)), this._imgAssets.set(o.SPIN_STOP, this.makeImgUrl("spinbutton/" + o.SPIN_STOP)), this._imgAssets.set(o.COLLECT_ICON, this.makeImgUrl("spinbutton/" + o.COLLECT_ICON)), this._imgAssets.set(o.BOOST_ICON, this.makeImgUrl("spinbutton/" + o.BOOST_ICON)), this._imgAssets.set(o.PROMO_BUTTON, this.makeImgUrl(o.PROMO_BUTTON)), this._imgAssets.set(o.LABEL_PLATE_22, this.makeImgUrl(o.LABEL_PLATE_22)), this._imgAssets.set(o.BUTTON_PLATE_20, this.makeImgUrl(o.BUTTON_PLATE_20)), this._imgAssets.set(o.BUTTON_STROKE_20, this.makeImgUrl(o.BUTTON_STROKE_20)), this._guideAssets.set(o.GUIDE_AUTO_PLAY_STOP_YELLOW, this.makeGuideUrl(o.GUIDE_AUTO_PLAY_STOP_YELLOW)), this._guideAssets.set(o.GUIDE_BOOSTED_BET, this.makeGuideUrl(o.GUIDE_BOOSTED_BET)), this._guideAssets.set(o.GUIDE_COLLECT_AND_SPIN, this.makeGuideUrl(o.GUIDE_COLLECT_AND_SPIN)), this._guideAssets.set(o.GUIDE_SPIN_BUTTON, this.makeGuideUrl(o.GUIDE_SPIN_BUTTON)), this._guideAssets.set(o.GUIDE_SPIN_BUTTON_X, this.makeGuideUrl(o.GUIDE_SPIN_BUTTON_X)), this._guideAssets.set(o.GUIDE_REPLAY, this.makeGuideUrl(o.GUIDE_REPLAY)), this._guideAssets.set(o.GUIDE_CHECKBOX, this.makeGuideUrl(o.GUIDE_CHECKBOX))
					}
					makeImgUrl(t) {
						return this._defaultImgUrl + t + "@2x.png"
					}
					makeGuideUrl(t) {
						return this._defaultGuideUrl + t + ".png"
					}
					overrideAssetByName(t, e) {
						this._isLoaded ? console.warn("You need to override skin assets before loading.") : this._imgAssets.has(t) ? this._imgAssets.set(t, e) : console.warn("Trying to override source for non existing icon")
					}
					loadIntroAssets() {
						return this._isIntroLoaded ? Promise.resolve(!0) : this._introLoadStarted ? new Promise(((t, e) => {
							this._introLoadCallbacks.push((() => {
								t(!0)
							}))
						})) : (this._introLoadStarted = !0, this._introAssets.forEach(((t, e) => {
							this._introLoader.add(e, t)
						})), this._introLoader.load().then((t => {
							this._isIntroLoaded = t;
							for (let t of this._introLoadCallbacks) t();
							return t
						})))
					}
					load() {
						return this._imgAssets.forEach(((t, e) => {
							this._loader.add(e, t)
						})), this._loader.load().then((t => (this._isLoaded = t, t)))
					}
					getSkinTexture(t) {
						return n.ImgLoader.getImgTexture(t)
					}
					static getTexture(t) {
						return n.ImgLoader.getImgTexture(t)
					}
					getSkinData() {
						const t = {};
						return this._imgAssets.forEach(((e, i) => {
							t[i] = e
						})), this._guideAssets.forEach(((e, i) => {
							t[i] = e
						})), t
					}
				}
				o.NOLIMIT_BONUS_PRICE_TAG = "introSplashxBet", o.AUTO_PLAY_ON = "autoPlayStop", o.AUTO_PLAY_OFF = "autoPlay", o.BACK = "back", o.BET_LEVELS_BUTTON = "bet", o.DEMO_ICON = "diamond", o.FAST_SPIN = "fastSpin", o.MENU = "menu", o.RING_LOADER = "ringLoader", o.SOUND_ON = "soundOn", o.SOUND_OFF = "soundOff", o.X_BET_BUTTON = "xBetButton", o.X_BET_BUTTON_BUBBLE = "xBetButtonBubble", o.X_BET_ANIMATION = "xBetAttention.json", o.BET_DOWN = "minus", o.BET_UP = "plus", o.BONUS_ARROW = "bonusArrow", o.BONUS_ARROW_STROKE = "bonusArrowStroke", o.NOLIMIT_BONUS_BTN = "nolimitBonusBtn", o.NOLIMIT_BOOSTER_BTN = "nolimitBonusBtn", o.CONFIRM_POP_UP = "popUpBackground", o.CONFIRM_POP_UP_WARNING = "warning", o.EXIT_LOBBY = "exitToLobby", o.HISTORY = "history", o.INFO = "info", o.SETTINGS = "settings", o.MENU_CLOSE = "menuClose", o.SPIN_BUTTON_PLATE = "spinBg", o.SPIN_ARROW = "spinArrow", o.SPIN_PLAY = "spinArrow", o.SPIN_SKIP = "spinX", o.SPIN_STOP = "spinX", o.COLLECT_ICON = "collectIcon", o.BOOST_ICON = "boostIcon", o.PROMO_BUTTON = "nolimitPromotions", o.LABEL_PLATE_22 = "labelPlate22", o.BUTTON_PLATE_20 = "buttonPlate20", o.BUTTON_STROKE_20 = "buttonStroke20", o.GUIDE_AUTO_PLAY_STOP_YELLOW = "autoPlayStopYellow", o.GUIDE_BOOSTED_BET = "boostedBet", o.GUIDE_COLLECT_AND_SPIN = "collectAndSpin", o.GUIDE_SPIN_BUTTON = "spinButton", o.GUIDE_SPIN_BUTTON_X = "spinButtonX", o.GUIDE_REPLAY = "replay", o.GUIDE_CHECKBOX = "checkBox", e.SkinLoader = o
			},
			22088: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SlotKeypad = e.SettingsExtEventIDs = e.SettingPageIDs = e.KeypadValueIDs = e.KeypadButtonIDs = void 0;
				const n = i(94183),
					s = i(97182),
					o = i(88297),
					r = i(81029),
					a = i(16211),
					l = i(64118),
					h = i(3307),
					u = i(30706),
					c = i(72468),
					d = i(91980),
					p = i(42855),
					_ = i(13006),
					m = i(15507),
					g = i(1676),
					f = i(64232),
					S = i(17106),
					y = i(9886),
					v = i(49490),
					T = i(41122),
					E = i(82748),
					b = i(61190),
					A = i(30835),
					P = i(50108),
					I = i(12355),
					w = i(5117),
					L = i(70742),
					C = i(70329),
					x = i(46334),
					B = i(39267),
					O = i(46419),
					N = i(20486),
					M = i(5266),
					R = i(79275),
					D = i(63635),
					k = i(56254),
					F = i(68518);
				var G, U, W, H;
				! function(t) {
					t.FAST_SPIN = "FAST_SPIN", t.PROMO_BUTTON = "PROMO_BUTTON", t.DEMO = "DEMO", t.SOUND = "SOUND", t.AUTO_PLAY = "autoplay", t.SPIN = "spin", t.FULLSCREEN_SPIN = "FULLSCREEN_SPIN", t.MENU = "menu", t.NOLIMIT_BONUS_MENU = "nolimitBonusMenu", t.BET_LEVEL = "bet-level", t.EXIT_REPLAY = "exitReplay", t.LIMIT_CAP = "limitCap"
				}(G = e.KeypadButtonIDs || (e.KeypadButtonIDs = {})), (H = e.KeypadValueIDs || (e.KeypadValueIDs = {})).BET = "BET", H.WIN = "WIN", H.BALANCE = "BALANCE", H.FREE_BETS_TOTAL_WIN = "FREE_BETS_TOTAL_WIN", H.TOTAL_COST = "TOTAL_COST",
					function(t) {
						t.GAME_MENU = "gameMenuPage", t.INFO = "infoPage", t.SETTINGS = "settingsPage", t.BET_LEVEL = "betLevelPage", t.AUTOPLAY = "autoplayPage", t.HISTORY = "historyPage"
					}(U = e.SettingPageIDs || (e.SettingPageIDs = {})),
					function(t) {
						t.SOUND_MASTER = "soundMaster", t.FAST_SPIN = "fastSpin", t.AUTOPLAY = "autoplay", t.OPEN_SETTINGS_SECTION = "openSettingsSection"
					}(W = e.SettingsExtEventIDs || (e.SettingsExtEventIDs = {}));
				class V {
					get showing() {
						return this._view && this._view.visible
					}
					constructor(t) {
						this.name = "SlotKeypad", this._balancePrecision = 2, this._hasOpenConfirmDialog = !1, this._disableSpinButtonOnGamble = !1, this.gameConfig = t, this.skinLoader = new M.SkinLoader, V.skinLoader = this.skinLoader, V._instance = this
					}
					fetchPlugins() {
						for (let t of d.NolimitLauncher.plugins)(0, r.isSoundPlugin)(t) && (V.sound = t), (0, h.isAutoPlayPlugin)(t) && (V.autoplay = t), (0, l.isApiPlugin)(t) && (V.apiPlugIn = t, V.apiPlugIn.events.on(v.APIEvent.INIT, (t => this.onInitData()))), (0, a.isPromotionPlugin)(t) && (V.promoPlugin = t);
						return null == V.sound ? Promise.reject(new Error("SlotKeypad is missing SoundPlugin")) : null == V.apiPlugIn ? Promise.reject(new Error("SlotKeypad is missing  ApiPlugin")) : null == V.autoplay ? Promise.reject(new Error("SlotKeypad is missing  AutoPlayPlugin")) : Promise.resolve()
					}
					destroy() {
						this.events.shutdown(), V.sound = void 0, V.autoplay = void 0, V.apiPlugIn = void 0, V.promoPlugin = void 0, V.NO_DECIMALS_CUTOFF_POINT = void 0, V.svgLoader = void 0, V.skinLoader = void 0, V.VERSION = void 0
					}
					init() {
						return new Promise(((t, e) => {
							this.fetchPlugins().catch((t => Promise.reject(t))), this.events = V.apiPlugIn.eventSystemFactory.create(), V.self = this, this.skinLoader.loadIntroAssets().then((() => {
								t(this)
							}))
						}))
					}
					getReady() {
						const t = new P.FontLoader(c.NolimitApplication.resourcePath);
						return t.add(w.OpenSans.ITALIC_600), t.add(w.OpenSans.NORMAL_300), t.add(w.OpenSans.NORMAL_400), t.add(w.OpenSans.NORMAL_700), Promise.all([this.skinLoader.load(), t.load()]).then((t => (V.apiPlugIn.settings.set(A.APISetting.DEVICE_HAS_ROUNDED_CORNERS, V.apiPlugIn.options.device == C.Device.MOBILE), this._view = new p.KeypadView(this), V.apiPlugIn.options.demo && V.apiPlugIn.options.token ? (this._demoView = new L.DemoView(this, V.apiPlugIn), this._demoView.load().then((t => {
							this._view.betPanel.demoButton.enable(!0)
						}))) : this.disableDemoButton(), this._betLevelsView = new m.BetLevelsDialogView(this, V.apiPlugIn), this._autoPlaySettingsView = new g.AutoPlayView(this, V.apiPlugIn), this._gameMenuView = new f.GameMenuDialogView(this, V.apiPlugIn), this.addEventListeners(), this._gameMenuView.preLoadHtmlPages().then((t => this)))))
					}
					getReadyToStart() {
						return new Promise(((t, e) => {
							var i;
							if (new URLSearchParams(window.parent.location.search).get("showGameInfoContainer")) {
								const t = document.createElement("div");
								t.id = "openPaytable", null === (i = document.activeElement) || void 0 === i || i.append(t), t.addEventListener("click", (() => {
									var e;
									const i = new n.GuiButton("menu");
									this.buttonClick(i), null === (e = document.activeElement) || void 0 === e || e.removeChild(t)
								}))
							}
							if (this._view.betPanel.fastSpinButton.toggled = V.apiPlugIn.settings.get(A.APISetting.FAST_SPIN, !1), this._view.betPanel.promoButton.enable(!0), this._view.betPanel.betLevelButton.enable(!0), this._view.betPanel.spinButton.enable(!0), this._view.betPanel.nolimitBonusMenu.enable(!0), this._view.betPanel.fastSpinButton.enable(!0), this._view.betPanel.autoplayButton.enable(!0), this._view.betPanel.menuButton.enable(!0), this._view.betPanel.limitCapButton.enable(!0), this._view.betPanel.soundButton.enable(!0), V.promoPlugin && V.promoPlugin.hasPromotions() || B.SlotKeypadUtils.disableElement(this._view.betPanel.promoButton), !1 === V.apiPlugIn.options.autoplay && (B.SlotKeypadUtils.disableElement(this._view.betPanel.autoplayButton), this._view.betPanel.onResize()), V.apiPlugIn.gameClientConfiguration.isSet ? this.applyGameClientConfiguration() : V.apiPlugIn.events.on(v.APIEvent.GAME_CLIENT_CONFIGURATION_APPLIED, (() => this.applyGameClientConfiguration())), V.apiPlugIn.settings.set(A.APISetting.LEFT_HAND_MODE, !1), V.apiPlugIn.betLevel.hasCapWinLimitToggle()) {
								const t = V.apiPlugIn.betLevel.getButtonLabels();
								this._view.betPanel.limitCapButton.addBylines(t.onLabel, t.offLabel), this._view.betPanel.limitCapButton.toggled = V.apiPlugIn.betLevel.isCapWinLimitToggled(), V.apiPlugIn.events.on(v.APIEvent.BET_GAME_MODE_CHANGED, (() => {
									this._view.betPanel.limitCapButton.toggled = V.apiPlugIn.betLevel.isCapWinLimitToggled();
									const t = V.apiPlugIn.betFeatureController.getActiveBetFeature();
									null != t && 0 == t.isBetLevelAndCostValid() && V.apiPlugIn.betFeatureController.setActiveBetFeature(), this.updateBet()
								}))
							} else B.SlotKeypadUtils.disableElement(this._view.betPanel.limitCapButton);
							t(this)
						}))
					}
					start() {
						return new Promise(((t, e) => {
							this._view.onOrientationChanged(), this._view.onResize(), this._view.alpha = 0, c.NolimitApplication.addLayer("Keypad", this._view), V.apiPlugIn.options.device == C.Device.DESKTOP && !V.apiPlugIn.isReplay && V.apiPlugIn.gameClientConfiguration.spacebarSpinAllowed && (this._keyboardInput = new O.KeyboardInput(V.apiPlugIn, this)), _.TweenLite.to(this._view, .2, {
								alpha: 1,
								ease: _.Linear.easeNone,
								onComplete: () => {
									t(this)
								}
							})
						}))
					}
					static getGuiGuideData(t) {
						const e = [],
							i = [],
							n = V.apiPlugIn.betFeatureController.getAllowedFeatures();
						for (let t of n) {
							const n = {
								name: t.name,
								maxBet: V.apiPlugIn.currency.format(t.getMaxBet()),
								price: t.price,
								image: t.displayConfig.imageUrl,
								description: t.displayConfig.description
							};
							"FREESPIN" === t.type ? e.push(n) : i.push(n)
						}
						return t.hasNolimitBonus = e.length > 0, t.bonusFeatures = e, t.hasNolimitBooster = i.length > 0, t.boosterFeatures = i, t.skin = V.skinLoader.getSkinData(), t
					}
					getKeypadGuide() {
						const t = new I.TemplateLoader(V.apiPlugIn.resources.getStaticRoot());
						return t.add({
							name: "gui-guide",
							url: "node_modules/@nolimitcity/slot-keypad/resources/default/templates/gui-guide.mustache"
						}), t.load().then((t => {
							for (let e of t)
								if ("gui-guide" == e.name && e.loadedData) return e.loadedData;
							throw new Error("SlotKeypad could not load gui-guide")
						}))
					}
					getIntroPages() {
						return new Promise(((t, e) => {
							const i = new P.FontLoader(c.NolimitApplication.resourcePath);
							return i.add(w.OpenSans.NORMAL_600), i.add(w.OpenSans.NORMAL_800), Promise.all([i.load(), this.skinLoader.loadIntroAssets(), V.apiPlugIn.betFeatureController.hasInit()]).then((() => {
								const e = [],
									i = V.apiPlugIn.betFeatureController.getAllowedFeatures();
								let n = 0,
									s = 0;
								for (let t of i) "FREESPIN" === t.type ? n += 1 : s += 1;
								n > 0 && e.push(new D.NolimitBonusIntroPage), s > 0 && e.push(new F.NolimitBoosterIntroPage), t(e)
							}))
						}))
					}
					applyGameClientConfiguration() {
						V.apiPlugIn.gameClientConfiguration.fastSpinEnabled || (V.apiPlugIn.settings.set(A.APISetting.FAST_SPIN, !1), B.SlotKeypadUtils.disableElement(this._view.betPanel.fastSpinButton)), V.apiPlugIn.gameClientConfiguration.autoPlaySettings.autoplayAllowed || B.SlotKeypadUtils.disableElement(this._view.betPanel.autoplayButton), V.apiPlugIn.betFeatureController.getAllowedFeatures().length <= 0 && B.SlotKeypadUtils.disableElement(this._view.betPanel.nolimitBonusMenu), this._view.betPanel.onResize()
					}
					setupMaxInactivityTimerForJurisdiction() {
						V.apiPlugIn.gameClientConfiguration.maxInactivityInMinutes && V.apiPlugIn.gameClientConfiguration.maxInactivityInMinutes > 0 && this.createJurisdictionMaxInactivityInterval()
					}
					isMaxInactivityForJurisdictionApplied() {
						return !!(V.apiPlugIn.gameClientConfiguration.maxInactivityInMinutes && V.apiPlugIn.gameClientConfiguration.maxInactivityInMinutes > 0)
					}
					createJurisdictionMaxInactivityInterval() {
						if (this.isMaxInactivityForJurisdictionApplied()) {
							const t = new Date;
							let e = this._currentEndDate = new Date(t.getTime() + 6e4 * V.apiPlugIn.gameClientConfiguration.maxInactivityInMinutes);
							x.Logger.logDev("SlotKeypad - Inactivity, setting up max inactivity timer for jurisdiction: " + V.apiPlugIn.gameClientConfiguration.jurisdictionName), x.Logger.logDev("SlotKeypad - Inactivity Time in Minutes: " + V.apiPlugIn.gameClientConfiguration.maxInactivityInMinutes), x.Logger.logDev("SlotKeypad - Inactivity Start Date: " + t), x.Logger.logDev("SLotKeypad - Inactivity End Date: " + e), clearInterval(this._maxInactivityInterval);
							let i = this._maxInactivityInterval = setInterval((function() {
								let t = new Date,
									n = e - t,
									s = Math.round(n % 864e5 % 36e5 / 6e4);
								x.Logger.logDev("SlotKeypad - Inactivity, minute countdown: " + s), s <= 0 && (clearInterval(i), x.Logger.logDev("SlotKeypad - Inactivity, time limit met, showing dialog at time: " + t), "mobile" === V.apiPlugIn.options.device ? V.apiPlugIn.dialog.showGameDialog({
									message: V.apiPlugIn.translations.translate("You have reached the maximum inactivity time and you have to restart the game to continue playing."),
									okButtonLabel: "OK",
									onOkClick: () => {
										V.apiPlugIn.externalApi.trigger(b.APIExternalApiEvent.EXIT).or(history.back.bind(history))
									}
								}) : V.apiPlugIn.dialog.showNoCloseGameDialog({
									message: V.apiPlugIn.translations.translate("You have reached the maximum inactivity time and you have to restart the game to continue playing.")
								}))
							}), 59e3)
						}
					}
					forceCheckInactivity() {
						if (this._currentEndDate && this._maxInactivityInterval) {
							let t = new Date,
								e = this._currentEndDate - t,
								i = Math.round(e % 864e5 % 36e5 / 6e4);
							x.Logger.logDev("SlotKeypad - Inactivity, force check on page visibility, time left on inactivity: " + i), i <= 0 && (clearInterval(this._maxInactivityInterval), x.Logger.logDev("SlotKeypad - Inactivity, time limit met, showing dialog at time: " + t), "mobile" === V.apiPlugIn.options.device ? V.apiPlugIn.dialog.showGameDialog({
								message: V.apiPlugIn.translations.translate("You have reached the maximum inactivity time and you have to restart the game to continue playing."),
								okButtonLabel: "OK",
								onOkClick: () => {
									V.apiPlugIn.externalApi.trigger(b.APIExternalApiEvent.EXIT).or(history.back.bind(history))
								}
							}) : V.apiPlugIn.dialog.showNoCloseGameDialog({
								message: V.apiPlugIn.translations.translate("You have reached the maximum inactivity time and you have to restart the game to continue playing.")
							}))
						}
					}
					disableDemoButton() {
						B.SlotKeypadUtils.disableElement(this._view.betPanel.demoButton)
					}
					addEventListeners() {
						V.apiPlugIn.events.on(v.APIEvent.CURRENCY, (t => B.SlotKeypadUtils.doFontHack(t))), V.apiPlugIn.events.on(v.APIEvent.REFRESH, ((...t) => this.onRefresh(t))), V.apiPlugIn.events.on(v.APIEvent.BET, (t => this.onBet(t))), V.apiPlugIn.events.on(v.APIEvent.ACTION_SPINS_ROUND_COMPLETE, (() => this.updateBalance())), V.apiPlugIn.events.on(v.APIEvent.STATE, (t => this.onState(t))), V.apiPlugIn.events.on(v.APIEvent.FAST_SPIN, (t => this.onFastSpin(t))), V.apiPlugIn.events.on(v.APIEvent.AUTO_PLAY, (() => this.onAutoPlay())), V.apiPlugIn.events.on(v.APIEvent.SELECTED_FEATURE_BET_CHANGED, (() => this.updateBet())), V.apiPlugIn.events.on(v.APIEvent.CURRENT_BET, (() => this.updateBet())), V.apiPlugIn.events.on(v.APIEvent.HALT, (() => this.onHalt())), V.apiPlugIn.events.on(v.APIEvent.PAUSE, (() => this.onPause(!0))), V.apiPlugIn.events.on(v.APIEvent.RESUME, (() => this.onPause(!1))), V.apiPlugIn.events.on(v.APIEvent.FREEZE, (() => this.onFreeze(!0))), V.apiPlugIn.events.on(v.APIEvent.UNFREEZE, (() => this.onFreeze(!1))), V.apiPlugIn.events.on(v.APIEvent.HIDDEN, (t => this.onHidden(t))), V.apiPlugIn.events.on(v.APIEvent.GAME, (t => this.onGameData(t))), V.apiPlugIn.events.on("redirectingToBonusInGame", (t => this.onPlayBonusInGame(t))), V.apiPlugIn.events.on("redirectingToBonusInGameComplete", (t => this.onPlayBonusInGameComplete(t))), V.apiPlugIn.settings.on(v.APIEvent.MUSIC, (t => this.onMusic(t))), V.apiPlugIn.settings.on(v.APIEvent.SFX, (t => this.onSfx(t))), V.apiPlugIn.events.on(v.APIEvent.SETTING_PAGE_CHANGE, (t => this.onSettingPageChange(t))), c.NolimitApplication.events.on(c.NolimitApplication.DIALOG_OPENED, (() => this.dialogOpened())), c.NolimitApplication.events.on(c.NolimitApplication.DIALOG_CLOSING, (() => this.dialogClosing())), c.NolimitApplication.apiPlugin.events.on(v.APIEvent.DIALOG, (t => this.onApiDialog(t))), c.NolimitApplication.apiPlugin.events.on(v.APIEvent.GUI_REFRESH, (t => this.onGuiRefresh(t))), V.apiPlugIn.freeBets.events.on(V.apiPlugIn.freeBets.FREE_BETS_START, (() => this.onFreeBetsStart())), V.apiPlugIn.freeBets.events.on(V.apiPlugIn.freeBets.FREE_BETS_START_FROM_ACTION_SPINS, (() => this.hideAllKeypadStuff())), V.apiPlugIn.freeBets.events.on(V.apiPlugIn.freeBets.FREE_BETS_END, (() => this.onFreeBetsEnd())), V.apiPlugIn.freeBets.events.on(V.apiPlugIn.freeBets.FREE_BETS_UPDATE, (() => this.onFreeBetsUpdate())), V.apiPlugIn.freeFeatureBet.events.on(V.apiPlugIn.freeFeatureBet.FREE_FEATURE_BET_START, (() => this.onFreeFeatureBetStart())), V.apiPlugIn.freeFeatureBet.events.on(V.apiPlugIn.freeFeatureBet.FREE_FEATURE_BET_END, (() => this.onFreeFeatureBetEnd()))
					}
					onGuiRefresh(t) {
						V.apiPlugIn.slotStates.checkState(T.SlotState.READY) && (this.updateBet(), this.updateBalance(), this.updateSoundButton(), V.apiPlugIn.freeBets.hasFreeBets() && this.updateFreeBetsTotalWin(), null != (null == t ? void 0 : t.hideBalance) && (this._view.betPanel.balance.visible = !0 !== t.hideBalance))
					}
					hideAllKeypadStuff() {
						this._view.visible = !1
					}
					onFreeFeatureBetStart() {
						this._view.betPanel.promoButton.enable(!1), this._view.betPanel.promoButton.visible = !1, this._view.betPanel.nolimitBonusMenu.enable(!1), this._view.betPanel.nolimitBonusMenu.setVisible(!1), this.setSpinButtonBetState(), this._view.betPanel.autoplayButton.spinsCounterLabel.setColor(S.SlotKeypadViewSettings.FREE_FEATURE_BET_COLOR), this._view.betPanel.betLevelButton.enable(!1), this._view.betPanel.betLevelButton.hide(), this.updateBet()
					}
					onFreeFeatureBetEnd() {
						this._view.betPanel.promoButton.enable(!0), this._view.betPanel.promoButton.visible = !0, this._view.betPanel.nolimitBonusMenu.enable(!0), this._view.betPanel.nolimitBonusMenu.setVisible(!0), this.setSpinButtonBetState(), this._view.betPanel.bet.setLabel(V.apiPlugIn.translations.translate("BET")), this._view.betPanel.bet.setColor(y.GuiUtils.getColorFromARGB(S.SlotKeypadViewSettings.NORMAL_COLOR)), this._view.betPanel.autoplayButton.enable(!0), this._view.betPanel.autoplayButton.spinsCounterLabel.setColor(S.SlotKeypadViewSettings.NORMAL_COLOR), this._view.betPanel.betLevelButton.show(), this._view.betPanel.betLevelButton.enable(!0), this.updateBet(), this._view.betPanel.onResize()
					}
					onFreeBetsUpdate() {
						this._view.betPanel.bet.setLabel(V.apiPlugIn.freeBets.getBetHeader()), this._view.betPanel.bet.setColor(y.GuiUtils.getColorFromARGB(S.SlotKeypadViewSettings.FREE_BETS_COLOR)), this.updateFreeBetsTotalWin(!0)
					}
					onFreeBetsStart() {
						this._view.betPanel.promoButton.enable(!1), this._view.betPanel.promoButton.visible = !1, this._view.betPanel.nolimitBonusMenu.enable(!1), this._view.betPanel.nolimitBonusMenu.setVisible(!1), this.setSpinButtonBetState(), this._view.betPanel.autoplayButton.spinsCounterLabel.setColor(S.SlotKeypadViewSettings.FREE_BETS_COLOR), this._view.betPanel.betLevelButton.enable(!1), this._view.betPanel.betLevelButton.hide(), this.updateBet(), this.updateFreeBetsTotalWin()
					}
					updateFreeBetsTotalWin(t = !1) {
						let e = V.apiPlugIn.freeBets.getFormattedWin();
						const i = V.apiPlugIn.freeBets.getCurrentWinnings();
						null != e && t && (e = V.apiPlugIn.currency.format(i - this._currentRoundBalance)), null != e && i - this._currentRoundBalance > 0 ? (this._view.betPanel.freeBetsTotalWin.visible = !0, this._view.betPanel.freeBetsTotalWin.setValue(e), this._view.betPanel.onResize()) : (this._view.betPanel.freeBetsTotalWin.visible = !1, this._view.betPanel.freeBetsTotalWin.setValue(""), this._view.betPanel.onResize())
					}
					onFreeBetsEnd() {
						this._view.betPanel.promoButton.enable(!0), this._view.betPanel.promoButton.visible = !0, this._view.betPanel.nolimitBonusMenu.enable(!0), this._view.betPanel.nolimitBonusMenu.setVisible(!0), this.setSpinButtonBetState(), this._view.betPanel.bet.setLabel(V.apiPlugIn.translations.translate("BET")), this._view.betPanel.bet.setColor(y.GuiUtils.getColorFromARGB(S.SlotKeypadViewSettings.NORMAL_COLOR)), this._view.betPanel.autoplayButton.spinsCounterLabel.setColor(S.SlotKeypadViewSettings.NORMAL_COLOR), this._view.betPanel.betLevelButton.show(), this._view.betPanel.betLevelButton.enable(!0), this._view.betPanel.freeBetsTotalWin.visible = !1, this._view.betPanel.freeBetsTotalWin.setValue("-1"), this.updateBet(), this._view.betPanel.onResize()
					}
					onApiDialog(t) {}
					onAutoPlay() {
						!this._view.betPanel.autoplayButton.toggled && V.autoplay.isAutoplayRound && this.reportBackSettingChange("autoplay", !0), this._view.betPanel.autoplayButton.toggled = V.autoplay.isAutoplayRound, this._view.betPanel.autoplayButton.setCount(V.autoplay.rounds), V.autoplay.rounds <= 0 && this.reportBackSettingChange("autoplay", !1), this.setSpinButtonBetState(), V.autoplay.rounds <= 0 && this.reportBackSettingChange("autoplay", !1);
						const t = V.apiPlugIn.slotStates.getState();
						V.autoplay.isAutoplayRound || t == T.SlotState.READY || t == T.SlotState.FINISH || (this._view.betPanel.autoplayButton.enable(!1), this.reportBackSettingChange("autoplay", !1)), this._view.setStateVisibility()
					}
					onFastSpin(t) {
						this._view.betPanel.fastSpinButton.toggled = t
					}
					clickSpin() {
						this._hasOpenConfirmDialog || this._view.betPanel.spinButton.clickButton()
					}
					buttonClick(t) {
						if (x.Logger.logDev(`SlotKeypad.buttonClicked[${t.name}]`), !this.interactionEnabled) return;
						const e = this.cancelAutoPlay(t);
						let i = !0;
						switch (t.name) {
							case G.AUTO_PLAY:
								e || this._autoPlaySettingsView.isOpen || (V.apiPlugIn.freeBets.hasFreeBets() ? V.autoplay.playFreeRoundsAutoplay() : (this._autoPlaySettingsView.open(), this.reportBackSettingPageChange(U.AUTOPLAY, !0)));
								break;
							case G.BET_LEVEL:
								this._betLevelsView.open(), this.reportBackSettingPageChange(U.BET_LEVEL, !0);
								break;
							case G.FULLSCREEN_SPIN:
								this.clickSpin(), i = !1;
								break;
							case G.SPIN:
								this.onSpinButtonClicked(), i = !1;
								break;
							case G.MENU:
								this._gameMenuView.open(), this.reportBackSettingPageChange(U.GAME_MENU, !0);
								break;
							case G.LIMIT_CAP:
								this.toggleLimitCap();
								break;
							case G.FAST_SPIN:
								this.toggleFastSpin();
								break;
							case G.SOUND:
								V.sound.toggleQuickMute();
								break;
							case G.NOLIMIT_BONUS_MENU:
								this.toggleNolimitBonusMenu();
								break;
							case G.PROMO_BUTTON:
								V.promoPlugin.open();
								break;
							case G.DEMO:
								this._demoView.open();
								break;
							case G.EXIT_REPLAY:
								this.exitReplay()
						}
						i && V.playButtonSound(t.name), this.onAnyInteraction()
					}
					static playButtonSound(t = "", e = R.KeypadSound.CLICK) {
						var i;
						let n = !0;
						(null === (i = V._instance.gameConfig) || void 0 === i ? void 0 : i.playKeypadButtonSound) && (n = V._instance.gameConfig.playKeypadButtonSound(t)), n && V.sound.playKeypadEffect(e)
					}
					onAnyInteraction() {
						this.setupMaxInactivityTimerForJurisdiction()
					}
					cancelAutoPlay(t) {
						if (V.autoplay.isAutoplayRound) {
							const e = [G.AUTO_PLAY, G.MENU, G.BET_LEVEL, G.PROMO_BUTTON];
							for (let i of e)
								if (i == t.name) return V.autoplay.cancelAutoPlay(), this.reportBackSettingChange(W.AUTOPLAY, !1), !0
						}
						return !1
					}
					static formatCurrencyWithDecimalCutoff(t) {
						"string" == typeof t && (t = parseFloat(t));
						const e = t < V.NO_DECIMALS_CUTOFF_POINT || t % 1 != 0 ? 2 : 0;
						return V.apiPlugIn.currency.format(t, {
							minimumPrecision: e
						})
					}
					static formatCurrencyValueWithDecimalCutoff(t) {
						"string" == typeof t && (t = parseFloat(t));
						const e = t < V.NO_DECIMALS_CUTOFF_POINT || t % 1 != 0 ? 2 : 0;
						return V.apiPlugIn.currency.formatValue(t, {
							minimumPrecision: e
						})
					}
					updateBet() {
						let t = V.apiPlugIn.betLevel.getLevel();
						V.apiPlugIn.freeBets.hasFreeBets() && (t = V.apiPlugIn.freeBets.getBet(), this._view.betPanel.bet.setLabel(V.apiPlugIn.freeBets.getBetHeader()), this._view.betPanel.bet.setColor(y.GuiUtils.getColorFromARGB(S.SlotKeypadViewSettings.FREE_BETS_COLOR))), V.apiPlugIn.freeFeatureBet.hasFreeFeatureBet() && (t = V.apiPlugIn.freeFeatureBet.getBet(), this._view.betPanel.bet.setLabel(V.apiPlugIn.freeFeatureBet.getBetHeader()), this._view.betPanel.bet.setColor(y.GuiUtils.getColorFromARGB(S.SlotKeypadViewSettings.FREE_FEATURE_BET_COLOR))), this.updateBetFeatureState(), this._view.betPanel.bet.setValue(V.formatCurrencyWithDecimalCutoff(t)), this._view.betPanel.nolimitBonusMenu.updateBetLevel(t), this.events.trigger(s.KeypadPluginEvents.DISPLAY_BET_UPDATE, t)
					}
					updateBetFeatureState() {
						const t = V.apiPlugIn.betFeatureController.getActiveBetFeature();
						if (null != t) {
							const e = t.getTotalCost(),
								i = V.formatCurrencyWithDecimalCutoff(e);
							this._view.betPanel.totalCost.setValue(i), this._view.betPanel.spinButton.setTotalCost(i), this._view.betPanel.totalCost.visible || (this.setSpinButtonBetState(), this._view.betPanel.autoplayButton.customToggledColorSet = new k.PointerStateColorSet(S.SlotKeypadViewSettings.BOOSTED_BET_COLOR), this._view.betPanel.totalCost.visible = !0, this._view.betPanel.onResize())
						} else this._view.betPanel.spinButton.setTotalCost(), this._view.betPanel.totalCost.visible && (this.setSpinButtonBetState(), this._view.betPanel.autoplayButton.customToggledColorSet = void 0, this._view.betPanel.totalCost.visible = !1, this._view.betPanel.onResize())
					}
					updateBalance() {
						V.apiPlugIn.balance.getAmount();
						const t = V.apiPlugIn.balance.getFormattedBalance(this._balancePrecision);
						this._view.betPanel.balance.setValue(t), V.apiPlugIn.externalApi.trigger("balance", V.apiPlugIn.balance.toString())
					}
					increaseBetLevel() {
						const t = V.apiPlugIn.betLevel.getLevel();
						V.apiPlugIn.betLevel.increase(), this.updateBet(), this.events.trigger(s.KeypadPluginEvents.USER_BET_UPDATE, {
							from: t,
							to: V.apiPlugIn.betLevel.getLevel()
						})
					}
					decreaseBetLevel() {
						const t = V.apiPlugIn.betLevel.getLevel();
						V.apiPlugIn.betLevel.decrease(), this.updateBet(), this.events.trigger(s.KeypadPluginEvents.USER_BET_UPDATE, {
							from: t,
							to: V.apiPlugIn.betLevel.getLevel()
						})
					}
					newBetLevelSelected(t) {
						const e = V.apiPlugIn.betLevel.getLevel();
						V.apiPlugIn.betLevel.setLevel(t);
						const i = V.apiPlugIn.betFeatureController.getActiveBetFeature();
						null != i && 0 == i.isBetLevelAndCostValid() && V.apiPlugIn.betFeatureController.setActiveBetFeature(), this.updateBet(), this.events.trigger(s.KeypadPluginEvents.USER_BET_UPDATE, {
							from: e,
							to: V.apiPlugIn.betLevel.getLevel()
						})
					}
					updateAutoplaySettings(t) {
						V.autoplay.updateData(t)
					}
					reportBackSettingPageChange(t, e) {
						V.apiPlugIn.events.trigger(v.APIEvent.SETTING_PAGE_CHANGE, {
							name: t,
							value: e
						})
					}
					reportBackSettingChange(t, e) {
						V.apiPlugIn.events.trigger(v.APIEvent.SETTING_CHANGE, {
							name: t,
							value: e
						})
					}
					onSettingPageChange(t) {
						t && t.page && t.section ? this.openGameSection(t.page, t.section, t.close || !1) : t && t.page && t.section
					}
					openGameSection(t, e, i = !1) {
						if (i && this.reportBackSettingPageChange(t, !1), "gameMenu" === t)
							if (i && this._gameMenuView.isOpen) this._gameMenuView.close();
							else switch (e) {
								case "history":
								case "settings":
								default:
									break;
								case "paytable":
									this._gameMenuView.openAndGoTo(N.SettingSectionIDs.PAYTABLE);
									break;
								case "rules":
									this._gameMenuView.openAndGoTo(N.SettingSectionIDs.RULES);
									break;
								case "guide":
									this._gameMenuView.openAndGoTo(N.SettingSectionIDs.GUIDE)
							}
						"autoplayMenu" === t && this._autoPlaySettingsView, "betLevelMenu" === t && this._betLevelsView, this.reportBackSettingPageChange(t, !0)
					}
					onBet(t) {
						t.type == E.APIBetType.GAMBLE_BET ? !0 !== t.playerInteraction.gambleCollected && this._view.betPanel.hideWin() : t.type !== E.APIBetType.ZERO_BET && this._view.betPanel.hideWin(), 0 == V.apiPlugIn.freeFeatureBet.hasFreeFeatureBet() && this.updateBalance()
					}
					setSpinButtonBetState() {
						null != V.apiPlugIn.betFeatureController.getActiveBetFeature() ? this._view.betPanel.spinButton.betState = u.BetState.BOOSTED_BET : V.autoplay.isAutoplayRound ? this._view.betPanel.spinButton.betState = u.BetState.AUTOPLAY : this._view.betPanel.zeroBetCounter.visible ? this._view.betPanel.spinButton.betState = u.BetState.ZERO_BET : this._view.betPanel.spinButton.betState = V.apiPlugIn.freeBets.hasFreeBets() ? u.BetState.FREE_BETS : u.BetState.NORMAL
					}
					onState(t) {
						switch (this._view.betPanel.demoButton.enable(!1), t) {
							case T.SlotState.RESTORE:
								this.updateBalance(), this.updateBet(), this.setSpinButtonBetState(), this._view.setStateVisibility();
								break;
							case T.SlotState.READY:
								this._currentRoundBalance = 0, this._view.betPanel.interactionEnabled = !0, this.setupMaxInactivityTimerForJurisdiction(), this.updateBalance(), this.updateBet(), this.setSpinButtonBetState(), this._view.betPanel.spinButton.spinState = o.SpinButtonState.SPIN, this._view.setStateVisibility(), this._view.betPanel.demoButton.enable(!0), this.reportBackSettingChange(v.APIEvent.AUDIO_MASTER_MUTED, !V.sound.isQuickMute());
								break;
							case T.SlotState.STARTING:
								this.updateFreeBetsTotalWin(!0), this._view.setStateVisibility(), this._view.betPanel.spinButton.enable(!1), this._view.betPanel.nolimitBonusMenu.enable(!1), this._view.betPanel.promoButton.enable(!1), this._view.betPanel.menuButton.enable(!1), this._view.betPanel.limitCapButton.enable(!1), this._view.betPanel.fullscreenSpinButton.enable(!1), this._view.betPanel.betLevelButton.enable(!1), this._view.betPanel.autoplayButton.enable(this._view.betPanel.autoplayButton.toggled);
								break;
							case T.SlotState.STOPPABLE:
								V.apiPlugIn.gameClientConfiguration.fastSpinEnabled && (this._view.betPanel.spinButton.enable(!0), this._view.betPanel.fullscreenSpinButton.enable(!0), this._view.betPanel.spinButton.spinState = o.SpinButtonState.STOP);
								break;
							case T.SlotState.STOPPING:
								this._view.betPanel.spinButton.enable(!1), this._view.betPanel.fullscreenSpinButton.enable(!1);
								break;
							case T.SlotState.SKIPPABLE:
								this._view.betPanel.spinButton.enable(!0), this._view.betPanel.fullscreenSpinButton.enable(!0), this._view.betPanel.spinButton.spinState = o.SpinButtonState.ABORT;
								break;
							case T.SlotState.SKIPPED:
							case T.SlotState.DONE:
								this._view.betPanel.spinButton.enable(!1), this._view.betPanel.fullscreenSpinButton.enable(!1);
								break;
							case T.SlotState.FINISHING:
								break;
							case T.SlotState.FINISH:
								this._currentRoundBalance = 0, this.updateBalance(), this._view.betPanel.nolimitBonusMenu.enable(!0), this._view.betPanel.spinButton.enable(!0), this._view.betPanel.fullscreenSpinButton.enable(!1), this._view.betPanel.autoplayButton.enable(!0), this._view.betPanel.betLevelButton.enable(!0), this._view.betPanel.menuButton.enable(!0), this._view.betPanel.limitCapButton.enable(!0), this._view.betPanel.promoButton.enable(!0), this._view.setStateVisibility();
								break;
							case T.SlotState.SCREEN:
								this._view.betPanel.interactionEnabled = !1, this._view.setStateVisibility(0);
								break;
							case T.SlotState.DIALOG:
								this._view.betPanel.interactionEnabled = !1, this._view.setStateVisibility(.2, !0);
								break;
							case T.SlotState.GAMBLE:
								this.setSpinButtonBetState(), this._disableSpinButtonOnGamble ? this._view.betPanel.spinButton.enable(!1) : (this._view.betPanel.spinButton.spinState = o.SpinButtonState.GAMBLE, this._view.betPanel.spinButton.enable(!0)), this._view.betPanel.promoButton.enable(!1), this._view.betPanel.menuButton.enable(!1), this._view.betPanel.limitCapButton.enable(!1), this._view.betPanel.fullscreenSpinButton.enable(!1), this._view.betPanel.betLevelButton.enable(!1), this._view.betPanel.autoplayButton.enable(this._view.betPanel.autoplayButton.toggled), this._view.betPanel.nolimitBonusMenu.enable(!1), this._view.setStateVisibility(), this._view.betPanel.nolimitBonusMenu.hideForGamble();
								break;
							case T.SlotState.GAMBLING:
								this._view.betPanel.spinButton.enable(!1);
								break;
							case T.SlotState.GAMBLE_COLLECT:
								this._view.betPanel.spinButton.enable(!1), this._view.betPanel.promoButton.enable(!1), this._view.betPanel.menuButton.enable(!1), this._view.betPanel.limitCapButton.enable(!1), this._view.betPanel.fullscreenSpinButton.enable(!1), this._view.betPanel.betLevelButton.enable(!1), this._view.betPanel.autoplayButton.enable(this._view.betPanel.autoplayButton.toggled);
								break;
							case T.SlotState.GAMBLE_DONE:
								this._view.betPanel.demoButton.enable(!0), this._view.betPanel.nolimitBonusMenu.showForGamble()
						}
					}
					onPlayBonusInGame(t) {
						this._disableSpinButtonOnGamble = !0, this._view.betPanel.interactionEnabled = !0
					}
					onPlayBonusInGameComplete(t) {
						this._view.betPanel.interactionEnabled = !1, this._disableSpinButtonOnGamble = !1
					}
					onSpinButtonClicked() {
						switch (V.apiPlugIn.slotStates.getState()) {
							case T.SlotState.READY:
								V.apiPlugIn.betHandler.bet(), this._view.betPanel.spinButton.playClickedAnimation();
								break;
							case T.SlotState.STARTING:
								break;
							case T.SlotState.STOPPABLE:
								V.apiPlugIn.events.trigger(v.APIEvent.STOP), this._view.betPanel.fullscreenSpinButton.playClickedAnimation();
								break;
							case T.SlotState.STOPPING:
								break;
							case T.SlotState.SKIPPABLE:
								V.apiPlugIn.events.trigger(v.APIEvent.SKIP), this._view.betPanel.fullscreenSpinButton.playClickedAnimation();
								break;
							case T.SlotState.SKIPPED:
								break;
							case T.SlotState.GAMBLE:
								V.apiPlugIn.betHandler.bet(), this._view.betPanel.spinButton.playClickedAnimation();
							case T.SlotState.DONE:
							case T.SlotState.FINISHING:
							case T.SlotState.SCREEN:
						}
					}
					dialogOpened() {}
					dialogClosing() {
						this._view.setStateVisibility(.18, !1, !0)
					}
					setWinLegacy(t, e, i, n) {
						this.showWin(t, e, i, n)
					}
					setWin(t, e, i, n) {
						this.showWin(t, e, i, n), this.updateBalance()
					}
					showWin(t, e, i, n) {
						this._currentRoundBalance = t;
						const s = V.apiPlugIn.currency.format(t);
						if (null == i && (i = V.apiPlugIn.gameClientConfiguration.belowStakeWinRestriction && t <= this._playedBetValue), t <= 0) this._view.betPanel.hideWin(n ? 0 : .5).add((() => {
							this._view.betPanel.win.setLabel(e ? V.apiPlugIn.translations.translate("TOTAL WIN") : V.apiPlugIn.translations.translate("WIN")), this._view.betPanel.win.setValue(s)
						}));
						else {
							let t;
							t = i ? "" : e ? V.apiPlugIn.translations.translate("TOTAL WIN") : V.apiPlugIn.translations.translate("WIN"), this._view.betPanel.win.setLabel(t), this._view.betPanel.win.setValue(s), this._view.betPanel.showWin()
						}
					}
					hide(t = 0) {
						return this._view.hide(t)
					}
					show(t = 0) {
						return this._view.visible = !0, this._view.show(t)
					}
					setZeroBetSpinCounter(t) {
						t < 0 ? (this._view.betPanel.zeroBetCounter.hide(), this._view.betPanel.zeroBetCounter.setCount(t), this.setSpinButtonBetState(), this._view.betPanel.autoplayButton.showSpinCounterLabel(), this._view.onResize()) : (this._view.betPanel.zeroBetCounter.setCount(t), this._view.betPanel.zeroBetCounter.show(), this.setSpinButtonBetState(), this._view.betPanel.autoplayButton.hideSpinCounterLabel(), this._view.onResize())
					}
					getBalanceBarHeight() {
						return 35
					}
					getSpinButtonCenter() {
						return this._view.betPanel.spinButtonCenter.clone()
					}
					disableQuickStop() {
						V.apiPlugIn.slotStates.checkState(T.SlotState.STOPPABLE) && (this._view.betPanel.spinButton.enable(!1), this._view.betPanel.fullscreenSpinButton.enable(!1))
					}
					get interactionEnabled() {
						var t, e;
						return null === (e = null === (t = this._view) || void 0 === t ? void 0 : t.betPanel) || void 0 === e ? void 0 : e.interactionEnabled
					}
					toggleVisibility(t) {
						this._view.visible = t
					}
					onRefresh(...t) {
						V.apiPlugIn.slotStates.checkState(T.SlotState.READY, T.SlotState.SCREEN, T.SlotState.DIALOG) && (this.updateBalance(), this.updateBet()), this._betLevelsView.onRefresh()
					}
					exitToLobby() {
						V.apiPlugIn.externalApi.trigger(b.APIExternalApiEvent.EXIT).or(history.back.bind(history))
					}
					exitReplay() {
						V.apiPlugIn.externalApi.trigger(b.APIExternalApiEvent.EXIT_REPLAY)
					}
					toggleBoolSetting(t) {
						const e = !V.apiPlugIn.settings.get(t, !1);
						return V.apiPlugIn.settings.set(A.APISetting.FAST_SPIN, e), e
					}
					openNolimitBonusMenu() {
						this._view.betPanel.nolimitBonusMenu.open(), this._view.betPanel.tempHideWin()
					}
					closeNolimitBonusMenu() {
						this._view.betPanel.nolimitBonusMenu.close(), this._view.betPanel.releaseTempHideWin()
					}
					toggleNolimitBonusMenu() {
						this._view.betPanel.nolimitBonusMenu.isOpen ? this.closeNolimitBonusMenu() : this.openNolimitBonusMenu()
					}
					toggleLimitCap() {
						V.apiPlugIn.betLevel.toggleCapWinLimit()
					}
					toggleFastSpin() {
						const t = this.toggleBoolSetting(A.APISetting.FAST_SPIN);
						V.apiPlugIn.events.trigger(v.APIEvent.FAST_SPIN, t), this.reportBackSettingChange("fastSpin", t)
					}
					onMusic(t) {
						this.updateSoundButton()
					}
					onSfx(t) {
						this.updateSoundButton()
					}
					updateSoundButton() {
						V.sound.loading ? (this._view.betPanel.soundButton.toggled = !1, this._view.betPanel.soundButton.enable(!1), this._view.betPanel.soundButton.startLoadingAnimation(), this.reportBackSettingChange(v.APIEvent.AUDIO_MASTER_MUTED, V.sound.isQuickMute())) : (this._view.betPanel.soundButton.stopLoadingAnimation(), this._view.betPanel.soundButton.toggled = !V.sound.isQuickMute(), this._view.betPanel.soundButton.enable(!0), this.reportBackSettingChange(v.APIEvent.AUDIO_MASTER_MUTED, !V.sound.isQuickMute()))
					}
					onHidden(t) {
						t || this.forceCheckInactivity(), this.updateSoundButton()
					}
					onGameData(t) {
						this._playedBetValue = t.playedBetValue
					}
					onInitData() {
						const t = V.apiPlugIn.freeBets.hasFreeBets() ? V.apiPlugIn.freeBets.getBet() : V.apiPlugIn.betLevel.getLevel();
						this._playedBetValue = parseFloat(t)
					}
					onFreeze(t) {
						t ? this._view.setStateVisibility(.2, !0) : this._view.setStateVisibility()
					}
					onPause(t) {
						this.updateSoundButton(), t && this._view.setStateVisibility(.2, !0)
					}
					onHalt() {
						this._view.halt()
					}
					static showConfirmFeatureBetPopUp(t) {
						return this._instance._hasOpenConfirmDialog = !0, V.apiPlugIn.events.trigger("modal", "open"), this._instance._view.betPanel.betFeatureConfirmPopUp.open(t).then((t => (this._instance._hasOpenConfirmDialog = !1, V.apiPlugIn.events.trigger("modal", "close"), t)))
					}
				}
				V.NO_DECIMALS_CUTOFF_POINT = 10, V.VERSION = i(2087).rE, e.SlotKeypad = V
			},
			17106: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SlotKeypadViewSettings = void 0;
				const n = i(56254);
				class s {
					static set instance(t) {
						this._instance = t
					}
					static get instance() {
						return null == this._instance && (this._instance = new s), this._instance
					}
					constructor() {
						this.activePointerStateColors = new n.PointerStateColorSet(4294966272, 4294966272, 4294966272, 872414208), this.freeBetsPointerStateColors = new n.PointerStateColorSet(4286512896, 4286512896, 4286512896, 863960832), this.boostedBetsPointerStateColors = new n.PointerStateColorSet(4294967295, 4294967295, 4294967295, 872415231), this.normalNonEmphasisPointerStateColors = new n.PointerStateColorSet(4294967295, 4294967295, 4294967295, 872415231), this.normalPointerStateColors = new n.PointerStateColorSet(4294967295, 4294967295, 4294967295, 872415231), this.normalBackPlatePointerStateColors = new n.PointerStateColorSet(2566914048, 3137339392, 2281701376, 2566914048)
					}
				}
				s.NORMAL_COLOR = 4294967295, s.AUTOPLAY_COLOR = 4294966272, s.FREE_BETS_COLOR = 4286512896, s.FREE_FEATURE_BET_COLOR = 4286512896, s.BOOSTED_BET_COLOR = 4293797459, e.SlotKeypadViewSettings = s
			},
			24186: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.KeypadDefault = void 0;
				class i {}
				i.DEFAULT_LARGE_BUTTON_SIZE = new PIXI.Rectangle(0, 0, 128, 70), i.DEFAULT_SMALL_BUTTON_SIZE = new PIXI.Rectangle(0, 0, 110, 60), i.DEFAULT_BET_LEVELS_ROW_MAX = 5, i.SCREEN_EDGE_MARGIN_TOP_LANDSCAPE = 40, i.SCREEN_EDGE_MARGIN_TOP = 40, i.SCREEN_EDGE_MARGIN_LEFT = 20, i.PAGE_LEFT_PADDING = 20, i.PAGE_HEADER_BOTTOM_MARGIN = 20, e.KeypadDefault = i
			},
			49078: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.KeypadTextStyles = void 0;
				const n = i(5117),
					s = i(77616),
					o = i(17106),
					r = i(9886),
					a = i(78229);
				class l {}
				l.DEFAULT_PORTRAIT_TEXT_SIZE = 20, l.DEFAULT_LANDSCAPE_TEXT_SIZE = 20, l.DEFAULT_DROP_SHADOW = {
					dropShadow: !0,
					dropShadowColor: 0,
					dropShadowAngle: 1.5707,
					dropShadowBlur: 4,
					dropShadowDistance: 2
				}, l.KEYPAD_STANDARD_LABEL = Object.assign(Object.assign(a.GuiDefaults.DEFAULT_LABEL_STYLE.clone(), l.DEFAULT_DROP_SHADOW), {
					fontWeight: s.FontWeight.NORMAL
				}), l.KEYPAD_STANDARD_VALUE = Object.assign(a.GuiDefaults.DEFAULT_LABEL_VALUE_STYLE.clone(), l.DEFAULT_DROP_SHADOW), l.FREE_BETS_WIN_LABEL = Object.assign(l.KEYPAD_STANDARD_LABEL.clone(), {
					fill: r.GuiUtils.getColorFromARGB(o.SlotKeypadViewSettings.FREE_BETS_COLOR)
				}), l.FREE_BETS_WIN_VALUE = Object.assign(l.KEYPAD_STANDARD_VALUE.clone(), {
					fill: r.GuiUtils.getColorFromARGB(o.SlotKeypadViewSettings.FREE_BETS_COLOR)
				}), l.TOTAL_COST_LABEL = Object.assign(l.KEYPAD_STANDARD_LABEL.clone(), {
					fill: r.GuiUtils.getColorFromARGB(o.SlotKeypadViewSettings.AUTOPLAY_COLOR)
				}), l.TOTAL_COST_VALUE = Object.assign(l.KEYPAD_STANDARD_VALUE.clone(), {
					fill: r.GuiUtils.getColorFromARGB(o.SlotKeypadViewSettings.AUTOPLAY_COLOR)
				}), l.WIN_LABEL = l.KEYPAD_STANDARD_LABEL.clone(), l.WIN_VALUE = Object.assign(l.KEYPAD_STANDARD_VALUE.clone(), {
					fontSize: 34,
					fill: r.GuiUtils.getColorFromARGB(o.SlotKeypadViewSettings.AUTOPLAY_COLOR)
				}), l.DEFAULT_RADIO_BUTTON_LABEL = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: n.OpenSans.FAMILY,
					fontSize: 40,
					fontStyle: s.FontStyle.NORMAL,
					fontWeight: s.FontWeight.NORMAL
				}), l.DEFAULT_LABEL_STYLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: n.OpenSans.FAMILY,
					fontSize: 20,
					fontStyle: s.FontStyle.NORMAL,
					fontWeight: s.FontWeight.LIGHT
				}), l.AUTO_PLAY_COUNTER_LABEL_STYLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: n.OpenSans.FAMILY,
					fontSize: 25,
					fontStyle: s.FontStyle.NORMAL,
					fontWeight: s.FontWeight.LIGHT
				}), l.SPIN_BUTTON_FREE_BETS_NUMBER = new PIXI.TextStyle({
					fill: r.GuiUtils.getColorFromARGB(o.SlotKeypadViewSettings.FREE_BETS_COLOR),
					fontFamily: n.OpenSans.FAMILY,
					fontSize: 25,
					fontStyle: s.FontStyle.NORMAL,
					fontWeight: s.FontWeight.LIGHT
				}), l.DEFAULT_DIALOG_HEADER = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: n.OpenSans.FAMILY,
					fontSize: 48,
					fontStyle: s.FontStyle.ITALIC,
					fontWeight: s.FontWeight.SEMI_BOLD,
					padding: 10
				}), l.DEFAULT_DIALOG_HEADER_EMPHASIS = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: n.OpenSans.FAMILY,
					fontSize: 40,
					fontStyle: s.FontStyle.NORMAL,
					fontWeight: s.FontWeight.BOLD
				}), l.BRAND_TEXT_THIN = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: n.OpenSans.FAMILY,
					fontSize: 17,
					fontStyle: s.FontStyle.NORMAL,
					fontWeight: s.FontWeight.LIGHT
				}), l.BRAND_TEXT_THICK = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: n.OpenSans.FAMILY,
					fontSize: 20,
					fontStyle: s.FontStyle.NORMAL,
					fontWeight: s.FontWeight.BOLD
				}), l.CLOCK = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: n.OpenSans.FAMILY,
					fontSize: 14,
					fontStyle: s.FontStyle.NORMAL,
					fontWeight: s.FontWeight.LIGHT
				}), l.GAME_NAME = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: n.OpenSans.FAMILY,
					fontSize: 14,
					fontStyle: s.FontStyle.NORMAL,
					fontWeight: s.FontWeight.LIGHT
				}), l.FREE_BETS_DIALOG_HEADER = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: n.OpenSans.FAMILY,
					fontSize: 30,
					fontWeight: s.FontWeight.NORMAL
				}), l.FREE_BETS_DIALOG_MESSAGE = new PIXI.TextStyle({
					fill: r.GuiUtils.getColorFromARGB(o.SlotKeypadViewSettings.FREE_BETS_COLOR),
					fontFamily: n.OpenSans.FAMILY,
					fontSize: 20,
					fontWeight: s.FontWeight.NORMAL,
					wordWrap: !0,
					wordWrapWidth: 660,
					align: "center"
				}), l.FREE_BETS_DIALOG_VALUE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: n.OpenSans.FAMILY,
					fontSize: 20,
					fontWeight: s.FontWeight.NORMAL
				}), e.KeypadTextStyles = l
			},
			46419: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.KeyboardInput = void 0;
				const n = i(30835),
					s = i(22088);
				e.KeyboardInput = class {
					constructor(t, e) {
						this._boundEvents = !1, this.onKeyUp = t => {
							var e;
							if (" " === t.key) {
								if (s.SlotKeypad.autoplay.isAutoplayRound || (null === (e = s.SlotKeypad.promoPlugin) || void 0 === e ? void 0 : e.isActionSpinRound)) return;
								this._keypad.clickSpin()
							}
						}, this._api = t, this._keypad = e, this._api.settings.default(n.APISetting.USE_SPACE_TO_SPIN, !0), this._api.settings.on(n.APISetting.USE_SPACE_TO_SPIN, (() => this.update())), this.update()
					}
					update() {
						const t = this._api.settings.get(n.APISetting.USE_SPACE_TO_SPIN);
						t && !this._boundEvents && this.bindEvents(), !t && this._boundEvents && this.unbindEvents()
					}
					bindEvents() {
						window.addEventListener("keyup", this.onKeyUp), this._boundEvents = !0
					}
					unbindEvents() {
						window.removeEventListener("keyup", this.onKeyUp), this._boundEvents = !1
					}
				}
			},
			63635: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NolimitBonusIntroPage = void 0;
				const n = i(58295),
					s = i(17106),
					o = i(61e3),
					r = i(68714),
					a = i(38801),
					l = i(5117),
					h = i(77616),
					u = i(5266),
					c = i(13006),
					d = i(22088),
					p = i(78229),
					_ = i(83901),
					m = i(55462),
					g = i(37107);
				class f extends n.SlideShowPage {
					constructor() {
						super(void 0, void 0, s.SlotKeypadViewSettings.BOOSTED_BET_COLOR);
						const t = this.createHeader("Nolimit Bonus", m.GuiDefaultTextures.NOLIMIT_BONUS_ICON, f.HEADER_STYLE);
						this.addChild(t);
						let e = d.SlotKeypad.apiPlugIn.betFeatureController.getAllowedFeatures().reverse();
						for (let t = e.length - 1; t >= 0; t--) "FREESPIN" !== e[t].type && e.splice(t, 1);
						const i = e.length > 1 ? 0 : 23,
							n = this.createTickets(e);
						n.position.set(20, i), this.addChild(n);
						const o = Math.min(1, e.length - 1),
							a = new r.Label(d.SlotKeypad.apiPlugIn.translations.translate(["Buy your way into the most exciting feature of the game!", "Buy your way into the most exciting features of the game!"][o]), p.GuiDefaults.INTRO_PAGE_TEXT);
						a.anchor.x = 1, a.anchor.y = .5, a.position.x = -10, a.position.y = 35, this.addChild(a)
					}
					createHeader(t, e, i) {
						const n = new PIXI.Container,
							s = new PIXI.Sprite(o.ImgLoader.getImgTexture(e)),
							l = new r.Label(t, i),
							h = 65 / s.height;
						return s.scale.set(h, h), n.addChild(s, l), a.GuiLayout.align([s, l], 24, a.Align.TOP, a.Direction.HORIZONTAL), n.pivot.set(.5 * n.width, .5 * n.height), n.position.set(0, -139), n
					}
					createTickets(t) {
						const e = new PIXI.Container,
							i = [];
						for (let e of t) i.push(this.createTicket(e));
						let n = 0,
							s = 0,
							o = 0,
							r = 0,
							a = 0;
						i.length > 1 && (n = .25 / (i.length - 1), o = -n * (i.length - 1) * .5, s = -.05, r = 23 / (i.length - 1), a = 78 / (i.length - 1));
						const l = [];
						for (let t = 0; t < i.length; t++) {
							const h = i[t],
								u = new c.TimelineLite,
								d = n * t + o + s;
							u.add(new c.TweenLite(h, .5, {
								x: r * t,
								y: a * t,
								rotation: d,
								ease: c.Elastic.easeOut.config(1, .75)
							}));
							const p = h.getChildByName("priceTag");
							p && (u.add(new c.TweenLite(p, .5, {
								rotation: -d,
								ease: c.Elastic.easeOut.config(1, .75)
							}), 0), p.rotation = -h.rotation), l.push(u), e.addChild(h)
						}
						return this._fanAnimation = new c.TimelineLite({
							paused: !0
						}), this._fanAnimation.add(l, 0), e
					}
					createTicket(t) {
						const e = new PIXI.Container,
							i = new g.NolimitBonusFeatureTicket(t.name),
							n = this.makePriceTag(t.price);
						return n.name = "priceTag", n.position.set(200, 10), e.addChild(i), e.pivot.set(-33, .5 * e.height), e.addChild(n), e
					}
					makePriceTag(t) {
						const e = new PIXI.Container,
							i = new _.NLCStaticText("x " + t, f.PRICE_TAG_STYLE);
						i.anchor.set(.5, .5), i.position.set(0, 0);
						const n = new PIXI.Sprite(o.ImgLoader.getImgTexture(u.SkinLoader.NOLIMIT_BONUS_PRICE_TAG));
						return n.anchor.set(.5, .4), e.addChild(n, i), e
					}
					enable(t) {
						super.enable(t), this._fanAnimation && (t ? this._fanAnimation.play(0) : this._fanAnimation.pause(0))
					}
				}
				f.HEADER_STYLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: l.OpenSans.FAMILY,
					fontSize: 50,
					fontStyle: h.FontStyle.NORMAL,
					fontWeight: h.FontWeight.SEMI_BOLD,
					dropShadow: !0,
					dropShadowAngle: -1,
					dropShadowDistance: -3,
					dropShadowColor: "#b62449",
					padding: 50
				}), f.PRICE_TAG_STYLE = new PIXI.TextStyle({
					fontFamily: l.OpenSans.FAMILY,
					fontSize: 20,
					fontStyle: h.FontStyle.NORMAL,
					fontWeight: h.FontWeight.EXTRA_BOLD,
					dropShadow: !0,
					dropShadowAngle: 1.57,
					dropShadowColor: "#ef9720",
					dropShadowDistance: 2,
					fill: "#f4f2f3",
					padding: 3,
					stroke: "#FFAA05",
					strokeThickness: 2,
					lineJoin: "round"
				}), e.NolimitBonusIntroPage = f
			},
			68518: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NolimitBoosterIntroPage = void 0;
				const n = i(58295),
					s = i(17106),
					o = i(61e3),
					r = i(68714),
					a = i(38801),
					l = i(5117),
					h = i(77616),
					u = i(5266),
					c = i(13006),
					d = i(22088),
					p = i(78229),
					_ = i(83901),
					m = i(55462),
					g = i(37107);
				class f extends n.SlideShowPage {
					constructor() {
						super(void 0, void 0, s.SlotKeypadViewSettings.BOOSTED_BET_COLOR);
						const t = this.createHeader("Nolimit Booster", m.GuiDefaultTextures.NOLIMIT_BOOSTER_ICON, f.HEADER_STYLE);
						this.addChild(t);
						let e = d.SlotKeypad.apiPlugIn.betFeatureController.getAllowedFeatures().reverse();
						for (let t = e.length - 1; t >= 0; t--) "FREESPIN" === e[t].type && e.splice(t, 1);
						const i = e.length > 1 ? 0 : 23,
							n = this.createTickets(e);
						n.position.set(20, i), this.addChild(n);
						const o = Math.min(1, e.length - 1),
							a = new r.Label(d.SlotKeypad.apiPlugIn.translations.translate(["Buy a specific game feature in the Nolimit Booster tool.", "Buy a specific game feature in the Nolimit Booster tool."][o]), p.GuiDefaults.INTRO_PAGE_TEXT);
						a.anchor.x = 1, a.anchor.y = .5, a.position.x = -10, a.position.y = 35, this.addChild(a)
					}
					createHeader(t, e, i) {
						const n = new PIXI.Container,
							s = new PIXI.Sprite(o.ImgLoader.getImgTexture(e)),
							l = new r.Label(t, i),
							h = 65 / s.height;
						return s.scale.set(h, h), n.addChild(s, l), a.GuiLayout.align([s, l], 24, a.Align.TOP, a.Direction.HORIZONTAL), n.pivot.set(.5 * n.width, .5 * n.height), n.position.set(0, -139), n
					}
					createTickets(t) {
						const e = new PIXI.Container,
							i = [];
						for (let e of t) i.push(this.createTicket(e));
						let n = 0,
							s = 0,
							o = 0,
							r = 0,
							a = 0;
						i.length > 1 && (n = .25 / (i.length - 1), o = -n * (i.length - 1) * .5, s = -.05, r = 23 / (i.length - 1), a = 78 / (i.length - 1));
						const l = [];
						for (let t = 0; t < i.length; t++) {
							const h = i[t],
								u = new c.TimelineLite,
								d = n * t + o + s;
							u.add(new c.TweenLite(h, .5, {
								x: r * t,
								y: a * t,
								rotation: d,
								ease: c.Elastic.easeOut.config(1, .75)
							}));
							const p = h.getChildByName("priceTag");
							p && (u.add(new c.TweenLite(p, .5, {
								rotation: -d,
								ease: c.Elastic.easeOut.config(1, .75)
							}), 0), p.rotation = -h.rotation), l.push(u), e.addChild(h)
						}
						return this._fanAnimation = new c.TimelineLite({
							paused: !0
						}), this._fanAnimation.add(l, 0), e
					}
					createTicket(t) {
						const e = new PIXI.Container,
							i = new g.NolimitBonusFeatureTicket(t.name),
							n = this.makePriceTag(t.price);
						return n.name = "priceTag", n.position.set(200, 10), e.addChild(i), e.pivot.set(-33, .5 * e.height), e.addChild(n), e
					}
					makePriceTag(t) {
						const e = new PIXI.Container,
							i = new _.NLCStaticText("x " + t, f.PRICE_TAG_STYLE);
						i.anchor.set(.5, .5), i.position.set(0, 0);
						const n = new PIXI.Sprite(o.ImgLoader.getImgTexture(u.SkinLoader.NOLIMIT_BONUS_PRICE_TAG));
						return n.anchor.set(.5, .4), e.addChild(n, i), e
					}
					enable(t) {
						super.enable(t), this._fanAnimation && (t ? this._fanAnimation.play(0) : this._fanAnimation.pause(0))
					}
				}
				f.HEADER_STYLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: l.OpenSans.FAMILY,
					fontSize: 50,
					fontStyle: h.FontStyle.NORMAL,
					fontWeight: h.FontWeight.SEMI_BOLD,
					dropShadow: !0,
					dropShadowAngle: -1,
					dropShadowDistance: -3,
					dropShadowColor: "#b62449",
					padding: 50
				}), f.PRICE_TAG_STYLE = new PIXI.TextStyle({
					fontFamily: l.OpenSans.FAMILY,
					fontSize: 20,
					fontStyle: h.FontStyle.NORMAL,
					fontWeight: h.FontWeight.EXTRA_BOLD,
					dropShadow: !0,
					dropShadowAngle: 1.57,
					dropShadowColor: "#ef9720",
					dropShadowDistance: 2,
					fill: "#f4f2f3",
					padding: 3,
					stroke: "#FFAA05",
					strokeThickness: 2,
					lineJoin: "round"
				}), e.NolimitBoosterIntroPage = f
			},
			55855: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.AnimationUtils = void 0;
				const n = i(13006);
				e.AnimationUtils = class {
					static hideObject(t = .5, e = !0) {
						return new n.TimelineLite
					}
					static elementVisibilityAnimation(t, e, i, s, o = !0) {
						const r = new n.TimelineLite;
						return null != s && r.add((() => {
							t.alpha = s
						})), i ? (r.add((() => {
							t.visible = !0
						})), r.add(new n.TweenLite(t, e, {
							alpha: 1,
							ease: n.Linear.easeNone
						}))) : (r.add(new n.TweenLite(t, e, {
							alpha: 0,
							ease: n.Linear.easeNone
						})), o && r.add((() => {
							t.visible = !1
						}))), r
					}
				}
			},
			39267: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SlotKeypadUtils = void 0;
				const n = i(49078);
				e.SlotKeypadUtils = class {
					static disableElement(t) {
						t.parent && t.parent.removeChild(t)
					}
					static doFontHack(t) {
						const e = [
							[n.KeypadTextStyles.DEFAULT_RADIO_BUTTON_LABEL, "DEFAULT_RADIO_BUTTON_LABEL"],
							[n.KeypadTextStyles.DEFAULT_LABEL_STYLE, "DEFAULT_LABEL_STYLE"],
							[n.KeypadTextStyles.AUTO_PLAY_COUNTER_LABEL_STYLE, "AUTO_PLAY_COUNTER_LABEL_STYLE"],
							[n.KeypadTextStyles.SPIN_BUTTON_FREE_BETS_NUMBER, "SPIN_BUTTON_FREE_BETS_NUMBER"],
							[n.KeypadTextStyles.DEFAULT_DIALOG_HEADER, "DEFAULT_DIALOG_HEADER"],
							[n.KeypadTextStyles.DEFAULT_DIALOG_HEADER_EMPHASIS, "DEFAULT_DIALOG_HEADER_EMPHASIS"],
							[n.KeypadTextStyles.BRAND_TEXT_THIN, "BRAND_TEXT_THIN"],
							[n.KeypadTextStyles.BRAND_TEXT_THICK, "BRAND_TEXT_THICK"],
							[n.KeypadTextStyles.CLOCK, "CLOCK"],
							[n.KeypadTextStyles.GAME_NAME, "GAME_NAME"],
							[n.KeypadTextStyles.FREE_BETS_DIALOG_HEADER, "FREE_BETS_DIALOG_HEADER"],
							[n.KeypadTextStyles.FREE_BETS_DIALOG_MESSAGE, "FREE_BETS_DIALOG_MESSAGE"],
							[n.KeypadTextStyles.FREE_BETS_DIALOG_VALUE, "FREE_BETS_DIALOG_VALUE"]
						];
						if (null != t.symbol) {
							const i = document.createElement("div");
							i.classList.add("currencyFontLoadHack"), i.style.position = "absolute", i.style.zIndex = "-1000";
							const n = document.querySelector(".nolimit.container");
							if (null == n) return;
							n.append(i);
							let s = 0;
							for (let n of e) {
								let e = "";
								if ("string" == typeof n[0].fontFamily) e = n[0].fontFamily;
								else
									for (let t of n[0].fontFamily) e += t + ",";
								const o = document.createElement("p");
								o.style.position = "absolute", o.style.top = s + "px", o.style.fontFamily = e, o.style.fontWeight = n[0].fontWeight.toString(), o.style.fontSize = "20px", o.style.color = "#FFFFFF", o.innerText = t.symbol, s += 20, i.append(o)
							}
						}
					}
				}
			},
			56348: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BetPanelView = void 0;
				const n = i(22088),
					s = i(10280),
					o = i(66515),
					r = i(17106),
					a = i(46980),
					l = i(68554),
					h = i(85136),
					u = i(89601),
					c = i(56717),
					d = i(75345),
					p = i(72468),
					_ = i(60223),
					m = i(13006),
					g = i(30835),
					f = i(77920),
					S = i(32862),
					y = i(38801),
					v = i(79555),
					T = i(49078),
					E = i(5266),
					b = i(61952),
					A = i(79970),
					P = i(50898),
					I = i(65221);
				class w extends PIXI.Container {
					get interactionEnabled() {
						return this._interactionEnabled
					}
					set interactionEnabled(t) {
						this._interactionEnabled = t
					}
					get betFeatureConfirmPopUp() {
						return this._betFeatureConfirmPopUp
					}
					get totalCost() {
						return this._totalCost
					}
					get permanentContainer() {
						return this._permanentContainer
					}
					get freeBetsTotalWin() {
						return this._freeBetsTotalWin
					}
					get staticContainer() {
						return this._staticContainer
					}
					get dynamicContainer() {
						return this._dynamicContainer
					}
					get demoButton() {
						return this._demoButton
					}
					get soundButton() {
						return this._soundButton
					}
					get promoButton() {
						return this._promoButton
					}
					get zeroBetCounter() {
						return this._zeroBetCounter
					}
					get fullscreenSpinButton() {
						return this._fullscreenSpinButton
					}
					get betLevelButton() {
						return this._betLevelButton
					}
					get nolimitBonusMenu() {
						return this._nolimitBonusMenu
					}
					get limitCapButton() {
						return this._limitCapButton
					}
					get menuButton() {
						return this._menuButton
					}
					get spinButton() {
						return this._spinButton
					}
					get spinSettingsGroup() {
						return this._spinSettingsGroup
					}
					get fastSpinButton() {
						return this._fastSpinButton
					}
					get autoplayButton() {
						return this._autoplayButton
					}
					get bet() {
						return this._bet
					}
					get balance() {
						return this._balance
					}
					get win() {
						return this._win
					}
					constructor(t) {
						super(), this.backgroundGradientMaxAlpha = .6, this.spinButtonCenter = new PIXI.Point, this._interactionEnabled = !0, this._controller = t, this.name = "SlotKeypadView", this.initAnimations(), this.hideWin(0), n.SlotKeypad.apiPlugIn.settings.on(g.APISetting.LEFT_HAND_MODE, (() => this.onResize()))
					}
					onResize() {
						const t = p.NolimitApplication.screenBounds;
						this._backgroundGradient.position.set(t.left, t.bottom), this._backgroundGradient.width = t.width, this._backgroundGradient.height = 40, this._fullscreenSpinButton.position.set(t.left, t.top), this._fullscreenSpinButton.width = t.width, this._fullscreenSpinButton.height = t.height, this._spinSettingsGroup.resize();
						const e = !0 === n.SlotKeypad.apiPlugIn.settings.get(g.APISetting.DEVICE_HAS_ROUNDED_CORNERS) ? 50 : 0,
							i = 10;
						let s = new PIXI.Point(t.center, t.bottom - 234),
							o = t.bottom - 124,
							r = new PIXI.Point;
						if (p.NolimitApplication.isLandscape) this._win.position.set(t.center, t.bottom - 3), this._balance.position.set(t.right - i - e, t.bottom - 3), this._bet.position.set(t.left + i + e, t.bottom - 3), this._soundButton.position.set(t.left + i, o), this._betLevelButton.position.set(this._soundButton.x + this._soundButton.width + 20, o), this._menuButton.position.set(t.left + i, this._soundButton.y - this._soundButton.height - 20), this._promoButton.position.set(t.left + i, this._menuButton.y - this._promoButton.height - 30), s = new PIXI.Point(t.right - i - 100, t.bottom - 234), this._spinSettingsGroup.position.set(Math.floor(s.x - .5 * this._spinSettingsGroup.getWidth()), o), n.SlotKeypad.apiPlugIn.settings.get(g.APISetting.LEFT_HAND_MODE) && (s = new PIXI.Point(t.left + i + 100, t.bottom - 238)), null != this._nolimitBonusMenu.parent ? this._limitCapButton.position.set(Math.floor(s.x - .5 * this._limitCapButton.width), s.y - this._limitCapButton.height - 265) : this._limitCapButton.position.set(Math.floor(s.x - .5 * this._limitCapButton.width), s.y - this._limitCapButton.height - 95), r.set(43, 50);
						else {
							const n = s.y - 1 + 90;
							this._bet.position.set(t.left + i + e, t.bottom - 3), this._balance.position.set(t.right - i - e, t.bottom - 3), this._rightSeparator.position.set(t.right - i, n), this._win.position.set(t.right - i, n - 3), this._spinSettingsGroup.position.set(Math.floor(t.center - .5 * this._spinSettingsGroup.getWidth()), o), this._soundButton.position.set(t.left + i, o), this._betLevelButton.position.set(this._soundButton.x + this._soundButton.width + 20, o), this._promoButton.position.set(t.left + i, this._betLevelButton.y - this._promoButton.height - 30), this._menuButton.position.set(t.right - this._menuButton.width - i, o), this._nolimitBrandLabel.position.set(t.center, t.bottom - 3), this._limitCapButton.position.set(this._menuButton.x - this._limitCapButton.width - i, this._menuButton.y - 20), r.set(0, 50)
						}
						if (this._freeBetsTotalWin.visible) {
							this._freeBetsTotalWin.position.set(t.left + i + e, this._bet.y - this._freeBetsTotalWin.height - 3);
							const n = [this._soundButton, this._betLevelButton, this._promoButton];
							p.NolimitApplication.isLandscape && n.push(this._menuButton), y.GuiLayout.offset(n, 0, -this._freeBetsTotalWin.height)
						}
						if (this._totalCost.visible) {
							this._totalCost.position.set(t.left + i + e, this._bet.y - this._totalCost.height - 3);
							const n = [this._soundButton, this._betLevelButton, this._promoButton];
							p.NolimitApplication.isLandscape && n.push(this._menuButton), y.GuiLayout.offset(n, 0, -this._totalCost.height)
						}
						this._demoButton.position.set(t.right - this._demoButton.width - i, t.top + 40), this._spinButton.position.set(s.x - 100, s.y - 90), this._zeroBetCounter.position.set(s.x - .5 * this._zeroBetCounter.width + r.x, s.y - .5 * this._zeroBetCounter.height + r.y), this.spinButtonCenter = s.clone(), this._nolimitBonusMenu.onResize(), this._betFeatureConfirmPopUp.resize()
					}
					onOrientationChanged() {
						p.NolimitApplication.isLandscape ? (this._bet.setAnchor(0, 1), this._freeBetsTotalWin.setAnchor(0, 1), this._totalCost.setAnchor(0, 1), this._win.setAnchor(.5, 1), this._balance.setAnchor(1, 1), this._nolimitBrandLabel.pivot.set(.5 * this._nolimitBrandLabel.width, this._nolimitBrandLabel.height), this._staticContainer.removeChild(this._rightSeparator), this._staticContainer.removeChild(this._nolimitBrandLabel)) : (this._bet.setAnchor(0, 1), this._freeBetsTotalWin.setAnchor(0, 1), this._totalCost.setAnchor(0, 1), this._win.setAnchor(1, 1), this._balance.setAnchor(1, 1), this._rightSeparator.lineStyle(1, 16777215, .6), this._rightSeparator.lineTo(-150, 0), this._staticContainer.addChild(this._rightSeparator), this._staticContainer.addChild(this._nolimitBrandLabel)), this._nolimitBonusMenu.onOrientationChanged()
					}
					createPermanentContainer() {
						const t = new PIXI.Container;
						return t.name = "PermanentContainer", this._balance = new l.LabeledValue(n.KeypadValueIDs.BALANCE, n.SlotKeypad.apiPlugIn.translations.translate("BALANCE"), -1, T.KeypadTextStyles.KEYPAD_STANDARD_LABEL, T.KeypadTextStyles.KEYPAD_STANDARD_VALUE), this._bet = new l.LabeledValue(n.KeypadValueIDs.BET, n.SlotKeypad.apiPlugIn.translations.translate("BET"), -1, T.KeypadTextStyles.KEYPAD_STANDARD_LABEL, T.KeypadTextStyles.KEYPAD_STANDARD_VALUE), this._totalCost = new l.LabeledValue(n.KeypadValueIDs.TOTAL_COST, n.SlotKeypad.apiPlugIn.translations.translate("TOTAL COST"), -1, T.KeypadTextStyles.TOTAL_COST_LABEL, T.KeypadTextStyles.TOTAL_COST_VALUE), this._totalCost.visible = !1, this._betFeatureConfirmPopUp = new I.ConfirmBetPopUpView, t.addChild(this._betFeatureConfirmPopUp), t.addChild(this._bet), t.addChild(this._balance), t.addChild(this._totalCost), t
					}
					createStaticContainer() {
						const t = new PIXI.Container;
						return t.name = "StaticContainer", this._rightSeparator = new PIXI.Graphics, this._rightSeparator.name = "_rightSeparator", this._nolimitBrandLabel = new c.NolimitBrandLabel, this._win = new f.WinLabel(n.KeypadValueIDs.WIN, n.SlotKeypad.apiPlugIn.translations.translate("WIN"), -1, T.KeypadTextStyles.WIN_LABEL, T.KeypadTextStyles.WIN_VALUE), this._zeroBetCounter = new _.ZeroBetCounter, this._fullscreenSpinButton = new d.FullscreenSpinButton(n.KeypadButtonIDs.FULLSCREEN_SPIN), this._fullscreenSpinButton.alpha = 0, this._fullscreenSpinButton.addClickCallback((() => this._controller.buttonClick(this._fullscreenSpinButton))), this._soundButton = new b.SoundButton(n.KeypadButtonIDs.SOUND), this._soundButton.addClickCallback((() => this._controller.buttonClick(this._soundButton))), this._soundButton.toggled = !n.SlotKeypad.sound.isQuickMute(), this._freeBetsTotalWin = new l.LabeledValue(n.KeypadValueIDs.FREE_BETS_TOTAL_WIN, n.SlotKeypad.apiPlugIn.translations.translate("TOTAL WIN"), -1, T.KeypadTextStyles.FREE_BETS_WIN_LABEL, T.KeypadTextStyles.FREE_BETS_WIN_VALUE), this._freeBetsTotalWin.visible = !1, t.addChild(this._freeBetsTotalWin), t.addChild(this._win), t.addChild(this._zeroBetCounter), t.addChild(this._fullscreenSpinButton), t.addChild(this._soundButton), t
					}
					createDynamicContainer() {
						const t = new PIXI.Container;
						t.name = "DynamicContainer", this._spinButton = new s.SpinButton, this._spinButton.addClickCallback((() => this._controller.buttonClick(this._spinButton)));
						let e, i, l = r.SlotKeypadViewSettings.instance.normalNonEmphasisPointerStateColors.clone();
						return r.SlotKeypadViewSettings.instance.activePointerStateColors.clone(), this._nolimitBonusMenu = new P.NolimitBonusMenu(this._controller, this._behindAllButtonsContainer), e = new a.PointerStateIconSet(new h.Icon(E.SkinLoader.getTexture(E.SkinLoader.BET_LEVELS_BUTTON))), this._betLevelButton = new v.BetLevelButton(n.KeypadButtonIDs.BET_LEVEL, e, l), this._betLevelButton.addClickCallback((() => this._controller.buttonClick(this._betLevelButton))), this._betLevelButton.toggled = !1, e = new a.PointerStateIconSet(new h.Icon(E.SkinLoader.getTexture(E.SkinLoader.MENU_CLOSE))), i = new a.PointerStateIconSet(new h.Icon(E.SkinLoader.getTexture(E.SkinLoader.MENU))), this._menuButton = new o.IconToggleButton(n.KeypadButtonIDs.MENU, e, l, i), this._menuButton.addClickCallback((() => this._controller.buttonClick(this._menuButton))), this._menuButton.toggled = !1, e = new a.PointerStateIconSet(new h.Icon(E.SkinLoader.getTexture(E.SkinLoader.PROMO_BUTTON))), i = new a.PointerStateIconSet(new h.Icon(E.SkinLoader.getTexture(E.SkinLoader.PROMO_BUTTON))), this._promoButton = new o.IconToggleButton(n.KeypadButtonIDs.PROMO_BUTTON, e, l, i), this._promoButton.pivot.x = 60, this._promoButton.addClickCallback((() => this._controller.buttonClick(this._promoButton))), e = new a.PointerStateIconSet(new h.Icon(E.SkinLoader.getTexture(E.SkinLoader.DEMO_ICON))), i = new a.PointerStateIconSet(new h.Icon(E.SkinLoader.getTexture(E.SkinLoader.DEMO_ICON))), this._demoButton = new o.IconToggleButton(n.KeypadButtonIDs.DEMO, e, l, i), this._demoButton.addClickCallback((() => this._controller.buttonClick(this._demoButton))), this._limitCapButton = new A.LimitCapButton(n.KeypadButtonIDs.LIMIT_CAP), this._limitCapButton.addClickCallback((() => this._controller.buttonClick(this._limitCapButton))), t.addChild(this._spinButton), t.addChild(this._betLevelButton), t.addChild(this._menuButton), t.addChild(this._promoButton), t.addChild(this._demoButton), t.addChild(this._nolimitBonusMenu), t.addChild(this._limitCapButton), t
					}
					createSpinSettingsGroup() {
						let t, e, i = r.SlotKeypadViewSettings.instance.normalNonEmphasisPointerStateColors.clone(),
							s = r.SlotKeypadViewSettings.instance.activePointerStateColors.clone();
						return t = new a.PointerStateIconSet(new h.Icon(E.SkinLoader.getTexture(E.SkinLoader.FAST_SPIN))), this._fastSpinButton = new o.IconToggleButton(n.KeypadButtonIDs.FAST_SPIN, t, s, void 0, i), this._fastSpinButton.addClickCallback((() => this._controller.buttonClick(this._fastSpinButton))), this._fastSpinButton.toggled = !1, t = new a.PointerStateIconSet(new h.Icon(E.SkinLoader.getTexture(E.SkinLoader.AUTO_PLAY_ON))), e = new a.PointerStateIconSet(new h.Icon(E.SkinLoader.getTexture(E.SkinLoader.AUTO_PLAY_OFF))), this._autoplayButton = new u.AutoplayButton(n.KeypadButtonIDs.AUTO_PLAY, t, s, e, i), this._autoplayButton.addClickCallback((() => this._controller.buttonClick(this._autoplayButton))), this._autoplayButton.toggled = !1, new S.SpinSettingsGroup(this._fastSpinButton, this._autoplayButton)
					}
					initAnimations() {
						this._behindAllButtonsContainer = new PIXI.Container;
						const t = PIXI.BaseTexture.from("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAEACAYAAACOKzdSAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAGRJREFUeNrs2bsNACAMQ0GD2H9mNoAuIuJSW+HFpuAzkowcauZS648OIN9ZAkMjBmNykqCxYPJBFnz4dQqQIDEIC4MNgwEkSGdaNxQ+yIKgocALJyfbjYmhjMFP8TuQBR22AAMAFikEyMCk4fEAAAAASUVORK5CYII=");
						this._backgroundGradient = new PIXI.Sprite(new PIXI.Texture(t)), this._backgroundGradient.anchor.set(0, 1), this._backgroundGradient.name = "BackgroundGradient", this._backgroundGradient.alpha = this.backgroundGradientMaxAlpha, this._behindAllButtonsContainer.addChild(this._backgroundGradient), this._permanentContainer = this.createPermanentContainer(), this._staticContainer = this.createStaticContainer(), this._dynamicContainer = this.createDynamicContainer(), this._spinSettingsGroup = this.createSpinSettingsGroup(), this.addChild(this._behindAllButtonsContainer), this.addChild(this._staticContainer), this.addChild(this._dynamicContainer), this.addChild(this._spinSettingsGroup), this.addChild(this._permanentContainer)
					}
					tempHideWin() {
						this.win.visible = !1, this._rightSeparator.visible = !1
					}
					releaseTempHideWin() {
						this.win.visible = !0, this._rightSeparator.visible = !0
					}
					hideWin(t = .5) {
						const e = new m.TimelineLite;
						return e.add([new m.TweenLite(this._win, t, {
							alpha: 0
						}), new m.TweenLite(this._rightSeparator, t, {
							alpha: 0
						})], .1), e
					}
					showWin(t = .1) {
						const e = new m.TimelineLite;
						return e.add([() => {
							this.releaseTempHideWin()
						}, new m.TweenLite(this._win, t, {
							alpha: 1
						}), new m.TweenLite(this._rightSeparator, t, {
							alpha: 1
						})]), e
					}
				}
				e.BetPanelView = w
			},
			79275: (t, e) => {
				"use strict";
				var i;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.KeypadSound = void 0, (i = e.KeypadSound || (e.KeypadSound = {})).NONE = "", i.CLICK = "click", i.DISABLED = "disabled", i.FAST_SPIN_OFF = "fast-spin-off", i.FAST_SPIN_ON = "fast-spin-on", i.SPIN_START = "spin-start", i.SPIN_STOP = "spin-stop"
			},
			42855: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.KeypadView = void 0;
				const n = i(22088),
					s = i(56348),
					o = i(13006),
					r = i(55855),
					a = i(41122),
					l = i(11479);
				class h extends PIXI.Container {
					get betPanel() {
						return this._betPanel
					}
					constructor(t) {
						super(), this._controller = t, this.initAnimations(), n.SlotKeypad.apiPlugIn.clock.events.on(n.SlotKeypad.apiPlugIn.clock.UPDATE, (() => this.onClockHandler(n.SlotKeypad.apiPlugIn.clock.UPDATE))), n.SlotKeypad.apiPlugIn.clock.events.on(n.SlotKeypad.apiPlugIn.clock.SETTING_UPDATE, (() => this.onClockHandler(n.SlotKeypad.apiPlugIn.clock.SETTING_UPDATE))), this.onClockHandler(n.SlotKeypad.apiPlugIn.clock.SETTING_UPDATE)
					}
					onResize() {
						this._betPanel.onResize()
					}
					onOrientationChanged() {
						this._betPanel.onOrientationChanged()
					}
					initAnimations() {
						this.setupTopBar(), this._betPanel = new s.BetPanelView(this._controller), this.addChild(this._betPanel)
					}
					hide(t) {
						return this.setStateVisibility(t, !0)
					}
					show(t) {
						return this.setStateVisibility(t)
					}
					halt() {
						this.createStateVisibilityAnimation(.1, !1, !1, !1)
					}
					setStateVisibility(t = .2, e = !1, i = !1) {
						const s = n.SlotKeypad.apiPlugIn.slotStates.checkState(a.SlotState.READY, a.SlotState.FINISH, a.SlotState.GAMBLE) && !n.SlotKeypad.apiPlugIn.slotStates.checkState(a.SlotState.PAUSED),
							o = n.SlotKeypad.apiPlugIn.slotStates.checkState(a.SlotState.DIALOG, a.SlotState.SCREEN, a.SlotState.PAUSED);
						let r = s && !n.SlotKeypad.autoplay.isAutoplayRound && !n.SlotKeypad.apiPlugIn.isReplay,
							l = (s || n.SlotKeypad.autoplay.isAutoplayRound) && !n.SlotKeypad.apiPlugIn.isReplay && !e,
							h = !o && !e;
						return o && i && (r = !0, l = !0, h = !0), 0 == r && this.betPanel.nolimitBonusMenu.isOpen && this._controller.closeNolimitBonusMenu(), this.createStateVisibilityAnimation(t, h, r, l)
					}
					createStateVisibilityAnimation(t, e, i, n) {
						return null != this._stateVisibilityAnimation && (this._stateVisibilityAnimation.kill(), this._stateVisibilityAnimation = void 0), this._stateVisibilityAnimation = new o.TimelineLite, this._stateVisibilityAnimation.add([r.AnimationUtils.elementVisibilityAnimation(this.betPanel.staticContainer, t, e), r.AnimationUtils.elementVisibilityAnimation(this.betPanel.fastSpinButton, t, e), r.AnimationUtils.elementVisibilityAnimation(this.betPanel.dynamicContainer, t, i), r.AnimationUtils.elementVisibilityAnimation(this.betPanel.autoplayButton, t, n)]), this.betPanel.permanentContainer.interactiveChildren = i, this._stateVisibilityAnimation
					}
					onClockHandler(t) {
						t == n.SlotKeypad.apiPlugIn.clock.UPDATE && this._clock.update(n.SlotKeypad.apiPlugIn.clock.formattedTime), t == n.SlotKeypad.apiPlugIn.clock.SETTING_UPDATE && (n.SlotKeypad.apiPlugIn.clock.shouldShow ? (this._clock.update(n.SlotKeypad.apiPlugIn.clock.formattedTime), this._clock.show()) : this._clock.hide())
					}
					setupTopBar() {
						const t = document.querySelector(".nolimit.container"),
							e = document.createElement("div");
						e.classList.add("top-bar-left");
						const i = document.createElement("div");
						i.classList.add("top-bar-right"), this._clock = new l.HtmlTopLabel("clock", !0), this._playForFun = new l.HtmlTopLabel(".nolimit.container .fun"), this._gameName = new l.HtmlTopLabel(".nolimit.container #game-name-version"), this._netPosition = new l.HtmlTopLabel(".nolimit.container #net-position"), e.append(this._clock.element), e.append(this._playForFun.element), i.append(this._gameName.element), i.append(this._netPosition.element), t.append(e), t.append(i)
					}
				}
				e.KeypadView = h
			},
			79555: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BetLevelButton = void 0;
				const n = i(66515);
				class s extends n.IconToggleButton {
					constructor(t, e, i, n, s) {
						super(t, e, i, n, s), this._buttonSlaves = [], this.onSlaveClick = t => {
							this.worldVisible && this.interactive && this.onClick(t)
						}
					}
					addButtonSlave(t) {
						t.on("pointertap", this.onSlaveClick), this._buttonSlaves.push(t)
					}
					enable(t) {
						super.enable(t);
						for (let e of this._buttonSlaves) e.interactive = t, e.buttonMode = t, e.hitArea = e.getLocalBounds()
					}
				}
				e.BetLevelButton = s
			},
			83181: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.MiniBetSelector = void 0;
				const n = i(27763),
					s = i(68714),
					o = i(22088),
					r = i(77616),
					a = i(5117),
					l = i(55462),
					h = i(5266);
				class u extends PIXI.Container {
					get betWidget() {
						return this._betWidget
					}
					constructor(t) {
						super(), this._controller = t, this.name = "MiniBetSelector", this._backgroundPlate = new PIXI.NineSlicePlane(h.SkinLoader.getTexture(l.GuiDefaultTextures.PLATE_BASE_20), 20, 20, 20, 20), this._backgroundPlate.alpha = 1, this._backgroundPlate.tint = 15607379, this._backgroundStroke = new PIXI.NineSlicePlane(h.SkinLoader.getTexture(l.GuiDefaultTextures.PLATE_STROKE_20), 20, 20, 20, 20), this._backgroundStroke.alpha = 1, this._backgroundStroke.tint = 10165059, this._backgroundStroke2 = new PIXI.NineSlicePlane(h.SkinLoader.getTexture(l.GuiDefaultTextures.PLATE_STROKE_20), 20, 20, 20, 20), this._backgroundStroke2.alpha = 1, this._backgroundStroke2.tint = 10165059, this.setBackgroundSize(206, 164);
						const e = new PIXI.Sprite(h.SkinLoader.getTexture(h.SkinLoader.NOLIMIT_BONUS_BTN));
						e.scale.set(.4, .4), e.anchor.set(1, 0), e.position.set(200, 6), this.titleLabel = new s.Label(o.SlotKeypad.apiPlugIn.translations.translate("BET"), u.BET_PANEL_BET_LABEL), this.titleLabel.anchor.set(.5, 0), this.titleLabel.position.set(Math.floor(.5 * this.size.x), 12), this.costLabel = new s.Label("-1", u.BET_PANEL_BET_STYLE), this.costLabel.anchor.set(.5, .5), this.costLabel.position.set(Math.floor(.5 * this.size.x), 65), this._betWidget = new n.PlusMinusWidget("up", "down", (t => {
							"up" == t.name ? this._controller.increaseBetLevel() : "down" == t.name && this._controller.decreaseBetLevel()
						})), this._betWidget.position.set(107, 118), this._betWidget.enableUpButton(!0), this._betWidget.enableDownButton(!0), this.addChild(this._backgroundPlate), this.addChild(this._backgroundStroke), this.addChild(this._backgroundStroke2), this.addChild(e), this.addChild(this.titleLabel), this.addChild(this.costLabel), this.addChild(this._betWidget), this.interactive = !0, this.interactiveChildren = !0
					}
					setBackgroundSize(t, e) {
						this.size = new PIXI.Point(t, e), this._backgroundPlate.width = this.size.x, this._backgroundPlate.height = this.size.y, this._backgroundStroke.width = this.size.x, this._backgroundStroke.height = this.size.y, this._backgroundStroke2.width = this.size.x, this._backgroundStroke2.height = this.size.y - 3
					}
					updateBetLevel(t) {
						this.setBetLevel(t), this.betWidget.enableDownButton(!o.SlotKeypad.apiPlugIn.betLevel.isFirst()), this.betWidget.enableUpButton(!o.SlotKeypad.apiPlugIn.betLevel.isLast()), this.lastBetLevel = t
					}
					setBetLevel(t) {
						if (this.costLabel.text = o.SlotKeypad.formatCurrencyWithDecimalCutoff(t), this.costLabel.scale.set(1, 1), this.costLabel.width >= 185) {
							const t = 185 / this.costLabel.width;
							this.costLabel.scale.set(t, t)
						}
					}
				}
				u.BET_PANEL_BET_LABEL = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: a.OpenSans.FAMILY,
					fontSize: 20,
					fontStyle: r.FontStyle.NORMAL,
					fontWeight: r.FontWeight.NORMAL
				}), u.BET_PANEL_BET_STYLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: a.OpenSans.FAMILY,
					fontSize: 22,
					fontStyle: r.FontStyle.NORMAL,
					fontWeight: r.FontWeight.LIGHT
				}), e.MiniBetSelector = u
			},
			50898: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NolimitBonusMenu = void 0;
				const n = i(22088),
					s = i(78229),
					o = i(5266),
					r = i(55462),
					a = i(68714),
					l = i(5117),
					h = i(77616),
					u = i(72468),
					c = i(85136),
					d = i(14615),
					p = i(46980),
					_ = i(17106),
					m = i(83181),
					g = i(49490),
					f = i(65508),
					S = i(26733),
					y = i(38801);
				class v extends PIXI.Container {
					constructor(t, e) {
						super(), this.isOpen = !1, this.boxSize = new PIXI.Point, this.onMiniTicketClick = t => {
							this._interactionEnabled && ("open" == t ? (this._controller.openNolimitBonusMenu(), n.SlotKeypad.playButtonSound("MiniTicket")) : (this.setFeature(), n.SlotKeypad.playButtonSound("RemoveSelectedFeature")))
						}, this.onOpenClick = t => {
							this._interactionEnabled && this._controller.openNolimitBonusMenu()
						}, this.onCloseClick = t => {
							this._interactionEnabled && (this._controller.closeNolimitBonusMenu(), null == t && n.SlotKeypad.playButtonSound("NLBonusMenu_" + this.closeButton.name))
						}, this.onFeatureBtnClick = t => {
							this._interactionEnabled && (n.SlotKeypad.playButtonSound("NLBonusMenu_" + t.name), this.setFeature(t.name))
						}, this.updateState = () => {
							const t = n.SlotKeypad.apiPlugIn.betFeatureController.getActiveBetFeature();
							if (this.isOpen)
								for (let e of this.buttons)(null == t ? void 0 : t.name) == e.name ? e.toggled = !0 : e.toggled = !1;
							else this.selectVisibleButtonWhenClosed()
						}, this._controller = t, this._clickerParent = e, this.name = "NolimitBonusMenu", this._miniBetSelector = new m.MiniBetSelector(this._controller);
						let i = _.SlotKeypadViewSettings.instance.normalNonEmphasisPointerStateColors.clone(),
							s = new p.PointerStateIconSet(new c.Icon(o.SkinLoader.getTexture(o.SkinLoader.NOLIMIT_BONUS_BTN)));
						this._nolimitBonusButton = new d.IconButton(n.KeypadButtonIDs.NOLIMIT_BONUS_MENU, s, i), this._nolimitBonusButton.addClickCallback((() => this._controller.buttonClick(this._nolimitBonusButton))), this._nolimitBonusButton.enable(!0), this._nolimitBonusButton.pivot.set(.5 * this._nolimitBonusButton.width, .5 * this._nolimitBonusButton.height), this._miniTicketContainer = new PIXI.Container, this._fullscreenClick = new PIXI.Sprite(PIXI.Texture.EMPTY), this._fullscreenClick.name = "clickOutSide", this._fullscreenClick.interactive = !0, this._fullscreenClick.buttonMode = !0, this._fullscreenClick.on("pointerup", this.onCloseClick), this.popUpMenu = new PIXI.Container, this.popUpMenu.name = "popUpMenu";
						let a = n.SlotKeypad.apiPlugIn.betFeatureController.getAllowedFeatures();
						this.buttons = [], this.bonusButtons = [], this.boosterButtons = [], this._miniTickets = new Map;
						for (let t = 0; t < a.length; t++) {
							const e = a[t],
								i = this.createBetFeatureBtn(e);
							this.buttons.push(i), "FREESPIN" === e.type ? this.bonusButtons.push(i) : this.boosterButtons.push(i);
							const n = new f.SelectedBuyFeatureButton(e.name, this.onMiniTicketClick);
							n.pivot.set(.5 * n.width, .5 * n.height), n.enable(!0), this._miniTickets.set(e.name, n)
						}
						this.contentContainer = this.createContent(), this._backgroundPlate = new PIXI.NineSlicePlane(o.SkinLoader.getTexture(r.GuiDefaultTextures.PLATE_BASE_20), 20, 20, 20, 20), this._backgroundPlate.alpha = 1, this._backgroundPlate.tint = 15607379, this._backgroundPlate.width = 350, this._backgroundPlate.height = 200, this._backgroundPlate.position.set(0, 0), this._shadowPlate = new PIXI.NineSlicePlane(o.SkinLoader.getTexture(r.GuiDefaultTextures.PLATE_BASE_20_BLUR_40), 60, 60, 60, 60), this._shadowPlate.alpha = 1, this._shadowPlate.tint = 0, this._shadowPlate.width = 350, this._shadowPlate.height = 200, this._shadowPlate.position.set(0, 0), this._backgroundStroke = new PIXI.NineSlicePlane(o.SkinLoader.getTexture(r.GuiDefaultTextures.PLATE_STROKE_20), 20, 20, 20, 20), this._backgroundStroke.alpha = 1, this._backgroundStroke.tint = 10165059, this._backgroundStroke.width = 350, this._backgroundStroke.height = 200, this._backgroundStroke.position.set(0, 0), this._backgroundStroke.interactive = !0;
						const l = new c.Icon(o.SkinLoader.getTexture(r.GuiDefaultTextures.NOLIMIT_BONUS_CLOSE_BUTTON));
						this.closeButton = new d.IconButton("close", new p.PointerStateIconSet(l, l, l, l), i), this.closeButton.enable(!0), this.closeButton.addClickCallback(this.onCloseClick), this.closeButton.scale.set(.5, .5), this.arrow = new PIXI.Container;
						const h = new PIXI.Sprite(o.SkinLoader.getTexture(o.SkinLoader.BONUS_ARROW)),
							u = new PIXI.Sprite(o.SkinLoader.getTexture(o.SkinLoader.BONUS_ARROW_STROKE));
						h.tint = 15607379, u.tint = 10165059, this.arrow.addChild(h, u), this.arrow.pivot.set(.5 * this.arrow.width, 1), this.popUpMenu.addChild(this._shadowPlate, this._backgroundPlate, this._backgroundStroke, this.arrow, this.contentContainer, this.closeButton), n.SlotKeypad.apiPlugIn.events.on(g.APIEvent.SELECTED_FEATURE_BET_CHANGED, this.updateState), this.addChild(this._nolimitBonusButton, this._miniTicketContainer)
					}
					createHeader(t, e) {
						const i = new PIXI.Container,
							n = new PIXI.TextStyle({
								fill: "#ffffff",
								fontFamily: l.OpenSans.FAMILY,
								fontSize: 50,
								fontStyle: h.FontStyle.NORMAL,
								fontWeight: h.FontWeight.SEMI_BOLD,
								dropShadow: !0,
								dropShadowAngle: -1,
								dropShadowDistance: -3,
								dropShadowColor: "#b62449",
								padding: 50
							}),
							s = new PIXI.Sprite(e),
							o = new a.Label(t, n);
						return o.position.set(s.width + 10, 0), i.addChild(s, o), i.pivot.set(.5 * i.width, 0), i
					}
					enable(t) {
						this._interactionEnabled = t, this._nolimitBonusButton.enable(t)
					}
					setVisible(t) {
						this._nolimitBonusButton.visible = t
					}
					hideForGamble() {
						this._prevButtonVisibility = this._nolimitBonusButton.visible, this._prevMiniTicketVisibility = this._miniTicketContainer.visible, this.setVisible(!1), this._miniTicketContainer.visible = !1
					}
					showForGamble() {
						this.setVisible(this._prevButtonVisibility || !0), this._miniTicketContainer.visible = this._prevMiniTicketVisibility
					}
					setFeature(t) {
						const e = n.SlotKeypad.apiPlugIn.betFeatureController.getActiveBetFeature();
						null != t && (null == e ? void 0 : e.name) != t ? n.SlotKeypad.apiPlugIn.betFeatureController.shouldShowWarningPopUp(t) ? n.SlotKeypad.showConfirmFeatureBetPopUp(t).then((e => {
							e.confirmed ? (n.SlotKeypad.apiPlugIn.betFeatureController.setActiveBetFeature(t), e.dontShowNextTime && n.SlotKeypad.apiPlugIn.betFeatureController.dontShowWarningNextTime(t)) : n.SlotKeypad.apiPlugIn.betFeatureController.setActiveBetFeature()
						})) : n.SlotKeypad.apiPlugIn.betFeatureController.setActiveBetFeature(t) : n.SlotKeypad.apiPlugIn.betFeatureController.setActiveBetFeature()
					}
					createBetFeatureBtn(t) {
						s.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE.clone().fontSize = 20;
						const e = new S.BuyFeatureButton(t);
						return e.addClickCallback((() => this.onFeatureBtnClick(e))), e.toggled = !1, e.enable(!0), e
					}
					createContent() {
						const t = new PIXI.Container,
							e = new PIXI.Container,
							i = new PIXI.Container;
						if (this.bonusButtons.length > 0) {
							const i = new PIXI.Container;
							i.addChild(...this.bonusButtons), v.gridLayout(this.bonusButtons, 11, 20), this.bonusHeader = this.createHeader("Nolimit Bonus", o.SkinLoader.getTexture(r.GuiDefaultTextures.NOLIMIT_BONUS_ICON)), e.addChild(this.bonusHeader, i), this.bonusHeader.scale.set(.5, .5), this.bonusHeader.position.set(.5 * i.width, 0), i.position.set(0, this.bonusHeader.height + 10), t.addChild(e)
						}
						if (this.boosterButtons.length > 0) {
							const e = new PIXI.Container;
							e.addChild(...this.boosterButtons), v.gridLayout(this.boosterButtons, 11, 20), this.boosterHeader = this.createHeader("Nolimit Booster", o.SkinLoader.getTexture(r.GuiDefaultTextures.NOLIMIT_BOOSTER_ICON)), i.addChild(this.boosterHeader, e), this.boosterHeader.scale.set(.5, .5), this.boosterHeader.position.set(.5 * e.width, 0), e.position.set(0, this.boosterHeader.height + 10), t.addChild(i)
						}
						return this.bonusButtons.length > 0 && this.boosterButtons.length > 0 && y.GuiLayout.align([e, i], 20, y.Align.LEFT, y.Direction.VERTICAL), this.bonusHeader && this.bonusHeader.position.set(Math.floor(.5 * t.width), 0), this.boosterHeader && this.boosterHeader.position.set(Math.floor(.5 * t.width), 0), t
					}
					calculateSize() {
						this.popUpMenu.scale.set(1, 1), this.boxSize = new PIXI.Point(this.contentContainer.width + 30, this.contentContainer.height + 35), this.boxSize.x = Math.max(this.boxSize.x, 280), this._shadowPlate.width = this.boxSize.x, this._shadowPlate.height = this.boxSize.y, this._shadowPlate.position.y = 10, this._backgroundPlate.width = this.boxSize.x, this._backgroundPlate.height = this.boxSize.y, this._backgroundStroke.width = this.boxSize.x, this._backgroundStroke.height = this.boxSize.y;
						const t = Math.floor(.5 * (this.boxSize.x - this.contentContainer.width));
						this.contentContainer.position.set(t, 15), this.closeButton.position.set(Math.floor(this.boxSize.x - this.closeButton.width + 10), -10), this.onResize()
					}
					onOrientationChanged() {}
					onResize() {
						this.popUpMenu.scale.set(1, 1), this._fullscreenClick.width = u.NolimitApplication.screenBounds.width, this._fullscreenClick.height = u.NolimitApplication.screenBounds.height, this._fullscreenClick.position.set(u.NolimitApplication.screenBounds.left, u.NolimitApplication.screenBounds.top);
						const t = n.SlotKeypad.self.getSpinButtonCenter();
						let e = new PIXI.Point;
						u.NolimitApplication.isLandscape ? (e.set(t.x, t.y - 160), this._nolimitBonusButton.position.set(e.x, e.y), this._miniTicketContainer.position.set(e.x + 5, e.y + 20), this.setPivotByAnchorPoint(this._miniBetSelector, .5, .5), this._miniBetSelector.position.set(e.x, e.y - 20), this.arrow.angle = -90, this.arrow.position.set(e.x - 130, e.y), this.popUpMenu.pivot.set(this.boxSize.x, .5 * this.boxSize.y), this.buttons.length < 4 ? this.popUpMenu.position.set(this.arrow.x + 2, this.arrow.y) : this.popUpMenu.position.set(this.arrow.x + 2, 350)) : (e.set(t.x + 160, t.y), this._nolimitBonusButton.position.set(e.x, e.y - 24), this._miniTicketContainer.position.set(e.x + 40, e.y - 32), this.setPivotByAnchorPoint(this._miniBetSelector, .5, .5), this._miniBetSelector.position.set(e.x + 60, e.y), this.arrow.angle = 0, this.arrow.position.set(e.x, e.y - 110), this.popUpMenu.pivot.set(.5 * this.boxSize.x, this.boxSize.y), this.popUpMenu.position.set(360, this.arrow.y + 2)), this.floorPoint(this.popUpMenu.pivot), this.floorPoint(this.popUpMenu.position), this.floorPoint(this.arrow.pivot), this.floorPoint(this.arrow.position);
						let i = new PIXI.Point(1, 1);
						if (u.NolimitApplication.isLandscape) {
							const t = u.NolimitApplication.screenBounds.right - this.arrow.x;
							i = new PIXI.Point(Math.min(1, (u.NolimitApplication.screenBounds.width - t) / this.popUpMenu.width), Math.min(1, (u.NolimitApplication.screenBounds.height - 30) / this.popUpMenu.height))
						} else {
							const t = u.NolimitApplication.screenBounds.bottom - this.arrow.y;
							i = new PIXI.Point(Math.min(1, u.NolimitApplication.screenBounds.width / this.popUpMenu.width), Math.min(1, (u.NolimitApplication.screenBounds.height - t) / this.popUpMenu.height))
						}
						const s = Math.min(i.x, i.y);
						if (this.popUpMenu.scale.set(s, s), !u.NolimitApplication.isLandscape) {
							const t = Math.max(360, this.arrow.x + 50 - .5 * this.popUpMenu.width);
							this.popUpMenu.position.set(t, this.arrow.y + 2)
						}
					}
					static gridLayout(t, e, i) {
						let n = 0,
							s = 0;
						for (let e of t) {
							const t = e.getBounds();
							n = t.width > n ? t.width : n, s = t.height > s ? t.height : s
						}
						let o = 3;
						4 == t.length && (o = 2);
						for (let r = 0; r < t.length; r++) {
							const a = t[r];
							a.x = Math.floor(r % o) * n, a.y = Math.floor(r / o) * s, a.x > 0 && (a.x += e * Math.floor(r % o)), a.y > 0 && (a.y += i * Math.floor(r / o))
						}
					}
					open() {
						this.isOpen = !0, this.setFeature(), this.updateState(), this.updateBetLevel(n.SlotKeypad.apiPlugIn.betLevel.getLevel()), this.calculateSize(), this._clickerParent.addChild(this._fullscreenClick), this.addChild(this.popUpMenu), this.addChild(this.arrow), this.addChild(this._miniBetSelector), this._nolimitBonusButton.visible = !1, this._miniTicketContainer.removeChildren(), this.onResize()
					}
					close() {
						this._clickerParent.removeChild(this._fullscreenClick), this.removeChild(this.popUpMenu), this.removeChild(this.arrow), this.removeChild(this._miniBetSelector), this.selectVisibleButtonWhenClosed(), this.isOpen = !1
					}
					selectVisibleButtonWhenClosed() {
						const t = n.SlotKeypad.apiPlugIn.betFeatureController.getActiveBetFeature();
						t && this._miniTickets.has(t.name) ? (this._miniTicketContainer.addChild(this._miniTickets.get(t.name)), this._miniTicketContainer.visible = !0, this._nolimitBonusButton.visible = !1) : (this._miniTicketContainer.removeChildren(), this._miniTicketContainer.visible = !1, this._nolimitBonusButton.visible = !0)
					}
					updateBetLevel(t) {
						if (this.isOpen) {
							const e = parseFloat(t),
								i = n.SlotKeypad.apiPlugIn.betFeatureController.getActiveBetFeature();
							for (let t of this.buttons) t.updateCostAndValidate(e) ? t.enable(!0) : (t.enable(!1), t.featureData.name == (null == i ? void 0 : i.name) && this.setFeature());
							this._miniBetSelector.updateBetLevel(t)
						}
					}
					setPivotByAnchorPoint(t, e, i) {
						t.pivot.set(t.width * e, t.height * i)
					}
					floorPoint(t) {
						t.x = Math.floor(t.x), t.y = Math.floor(t.y)
					}
				}
				e.NolimitBonusMenu = v
			},
			56717: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NolimitBrandLabel = void 0;
				const n = i(68714),
					s = i(49078),
					o = i(38801);
				class r extends PIXI.Container {
					constructor() {
						super();
						const t = [];
						t.push(new n.Label("NOLIMIT CITY", s.KeypadTextStyles.BRAND_TEXT_THICK)), o.GuiLayout.align(t);
						for (let e of t) e.alpha = .3, this.addChild(e)
					}
				}
				e.NolimitBrandLabel = r
			},
			32862: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SpinSettingsGroup = void 0;
				const n = i(38801);
				class s extends PIXI.Container {
					get autoPlayButton() {
						return this._autoPlayButton
					}
					get fastSpinButton() {
						return this._fastSpinButton
					}
					getWidth() {
						const t = this._autoPlayButton.visible,
							e = this._fastSpinButton.visible;
						this._autoPlayButton.visible = !0, this._fastSpinButton.visible = !0;
						const i = this.width;
						return this._autoPlayButton.visible = t, this._fastSpinButton.visible = e, i
					}
					constructor(t, e) {
						super(), this._autoPlayButton = e, this._fastSpinButton = t, this.addChild(this._autoPlayButton), this.addChild(this._fastSpinButton), this.resize()
					}
					resize() {
						n.GuiLayout.align(this.children, 40)
					}
				}
				e.SpinSettingsGroup = s
			},
			77920: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.WinLabel = void 0;
				const n = i(68554),
					s = i(72468);
				class o extends n.LabeledValue {
					constructor(t, e, i, n, s) {
						super(t, e, i, n, s), this.setAlignment(), this.setPivot()
					}
					setAlignment() {
						s.NolimitApplication.isLandscape ? (this._label.position.set(0, this._value.height - this._label.height - 4), this._value.position.set(this._label.width + this._margin, 0)) : this._label.width > this._value.width ? (this._label.position.set(0, 0), this._value.position.set(this._label.width - this._value.width, this._label.height)) : (this._label.position.set(this._value.width - this._label.width, 0), this._value.position.set(0, this._label.height))
					}
					setPivot() {
						this.pivot.set(this.width * this._anchorPoint.x, this.height * this._anchorPoint.y)
					}
				}
				e.WinLabel = o
			},
			60223: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ZeroBetCounter = void 0;
				const n = i(68714),
					s = i(5266),
					o = i(78229);
				class r extends PIXI.Container {
					constructor() {
						super(), this.name = "ZeroBetCounter", this._backPlate = new PIXI.NineSlicePlane(s.SkinLoader.getTexture(s.SkinLoader.SPIN_BUTTON_PLATE), 40, 40, 40, 40), this._backPlate.width = 110, this._backPlate.height = 95, this._label = new n.Label("99", o.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE), this._label.anchor.set(.5, .5), this._label.position.set(.5 * this._backPlate.width, .5 * this._backPlate.height), this.addChild(this._backPlate), this.addChild(this._label), this.hide()
					}
					setCount(t) {
						this._label.text = "" + t
					}
					show() {
						this.visible = !0
					}
					hide() {
						this.visible = !1
					}
				}
				e.ZeroBetCounter = r
			},
			7597: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BonusBuyPopUpContent = void 0;
				const n = i(68714),
					s = i(22088),
					o = i(5117),
					r = i(77616),
					a = i(5266);
				class l extends PIXI.Container {
					constructor(t) {
						super(), this.featureName = t.name, this.featureImage = new PIXI.Sprite(a.SkinLoader.getTexture(a.SkinLoader.CONFIRM_POP_UP_WARNING)), this.featureImage.anchor.set(.5, 0), this.bet = s.SlotKeypad.apiPlugIn.betLevel.getLevel(), this.price = t.getTotalCost(), this.priceString = s.SlotKeypad.formatCurrencyWithDecimalCutoff(this.price), this.priceLabel = new n.Label(this.priceString, l.POP_UP_FORMATTED_PRICE), this.priceLabel.anchor.set(.5, 0), this.priceLabel.visible = !1, this.textLabel = new n.Label(s.SlotKeypad.apiPlugIn.translations.translate("The total cost for the activated feature will be charged from your balance for each spin."), l.POP_UP_CHARGE_FROM_WALLET_TEXT), this.textLabel.anchor.set(.5, 0), this.featureImage.position.set(0, 0), this.priceLabel.position.set(0, 220), this.textLabel.position.set(0, 260), this.addChild(this.featureImage, this.priceLabel, this.textLabel)
					}
				}
				l.POP_UP_FORMATTED_PRICE = new PIXI.TextStyle({
					fill: "#000000",
					fontFamily: o.OpenSans.FAMILY,
					fontSize: 30,
					fontStyle: r.FontStyle.NORMAL,
					fontWeight: r.FontWeight.BOLD
				}), l.POP_UP_CHARGE_FROM_WALLET_TEXT = new PIXI.TextStyle({
					fill: "#686868",
					fontFamily: o.OpenSans.FAMILY,
					fontSize: 30,
					fontStyle: r.FontStyle.NORMAL,
					fontWeight: r.FontWeight.LIGHT,
					padding: 25,
					breakWords: !0,
					wordWrap: !0,
					wordWrapWidth: 540
				}), e.BonusBuyPopUpContent = l
			},
			65221: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ConfirmBetPopUpView = void 0;
				const n = i(67566),
					s = i(5266),
					o = i(22088),
					r = i(17106),
					a = i(78229),
					l = i(72468),
					h = i(38801),
					u = i(7597),
					c = i(56254),
					d = i(5117),
					p = i(77616),
					_ = i(92986);
				class m extends PIXI.Container {
					get isOpen() {
						return this.visible
					}
					constructor() {
						super(), this.init()
					}
					resize() {
						this.position.set(l.NolimitApplication.screenBounds.left, l.NolimitApplication.screenBounds.top), this._background.width = l.NolimitApplication.screenBounds.width, this._background.height = l.NolimitApplication.screenBounds.height;
						const t = l.NolimitApplication.isLandscape ? 0 : l.NolimitApplication.screenBounds.height - this._popUpPlate.height;
						this._popUpPlate.position.set(.5 * l.NolimitApplication.screenBounds.width, .5 * t)
					}
					buttonClicked(t) {
						o.SlotKeypad.playButtonSound(t.name), this._buttonClickCallback && this._buttonClickCallback(t.name)
					}
					open(t) {
						return new Promise(((e, i) => {
							const n = o.SlotKeypad.apiPlugIn.betFeatureController.getFeatureData(t);
							if (!n) throw new Error("Feature does not exist");
							let s = new u.BonusBuyPopUpContent(n);
							n.displayConfig.replacePopUpContent && (s = n.displayConfig.replacePopUpContent(s)), this._contentContainer.addChild(s), this.show(), this._buttonClickCallback = t => {
								const i = {
									confirmed: !1,
									dontShowNextTime: this.checkBox.toggled
								};
								"ok" == t && (i.confirmed = !0), this.close(), e(i)
							}
						}))
					}
					close() {
						this._contentContainer.removeChildren(), this.hide()
					}
					init() {
						this._background = new PIXI.Sprite(PIXI.Texture.WHITE), this._background.tint = 0, this._background.alpha = .6, this._background.interactive = !0, this._background.name = "_background", this._popUpPlate = new PIXI.NineSlicePlane(s.SkinLoader.getTexture(s.SkinLoader.CONFIRM_POP_UP), 64, 64, 64, 64), this._popUpPlate.width = 640, this._popUpPlate.height = 700, this._popUpPlate.pivot.set(.5 * this._popUpPlate.width, 0), this._popUpPlate.name = "_popUpPlate", this.mainContainer = new PIXI.Container, this.mainContainer.position.set(50, 30), this.mainWidth = 540;
						const t = this.createButtons();
						t.position.set(0, 490), this._contentContainer = new PIXI.Container, this._contentContainer.name = "content", this._contentContainer.position.set(.5 * this.mainWidth, 50), this.mainContainer.addChild(t, this._contentContainer), this._popUpPlate.addChild(this.mainContainer), this.addChild(this._background, this._popUpPlate), this.close()
					}
					createButtons() {
						const t = new PIXI.Container;
						let e = r.SlotKeypadViewSettings.instance.normalNonEmphasisPointerStateColors.clone(),
							i = new c.PointerStateColorSet(4278190080, 4278190080, 4278190080, 855638016),
							s = m.GAME_FEATURE_OK_TEXT;
						this._cancelButton = new n.LabelButton("cancel", o.SlotKeypad.apiPlugIn.translations.translate("CANCEL"), s, i, e), this._cancelButton.resizeButtonToLabelWithMargin(10, 10, 10, 10), this._cancelButton.enable(!0), this._cancelButton.addClickCallback((() => {
							this.buttonClicked(this._cancelButton)
						})), this._okButton = new n.LabelButton("ok", o.SlotKeypad.apiPlugIn.translations.translate("OK"), s, i, e), this._okButton.resizeButtonToLabelWithMargin(10, 10, 10, 10), this._okButton.enable(!0), this._okButton.addClickCallback((() => {
							this.buttonClicked(this._okButton)
						}));
						const l = Math.max(this._cancelButton.width, this._okButton.width);
						this._cancelButton.setSize(l, this._cancelButton.height), this._okButton.setSize(l, this._okButton.height), this._okButton.pivot.set(0, 0), this._cancelButton.pivot.set(0, 0);
						const u = a.GuiDefaults.DEFAULT_CHECKBOX_BUTTON_LABEL.clone();
						u.padding = 20, u.fill = "#000000", this.checkBox = new _.CheckBoxButton("dontShow", o.SlotKeypad.apiPlugIn.translations.translate("Don't show again"), u, i, i), this.checkBox.toggled = !1, this.checkBox.enable(!0), this.checkBox.addClickCallback((() => {
							this.checkBox.toggled = !this.checkBox.toggled
						})), this.checkBox.position.set(Math.floor(.5 * (this.mainWidth - this.checkBox.width)), 0);
						const d = new PIXI.Container;
						return d.addChild(this._cancelButton, this._okButton), h.GuiLayout.align([this._cancelButton, this._okButton], 30, h.Align.LEFT, h.Direction.HORIZONTAL), d.position.set(.5 * (this.mainWidth - d.width), 50), t.addChild(this.checkBox, d), t
					}
					show() {
						this.resize(), this.checkBox.toggled = !1, this.visible = !0, this._background.alpha = .6
					}
					hide() {
						this.visible = !1
					}
				}
				m.GAME_FEATURE_OK_TEXT = new PIXI.TextStyle({
					fill: "#000000",
					fontFamily: d.OpenSans.FAMILY,
					fontSize: 38,
					fontStyle: p.FontStyle.ITALIC,
					fontWeight: p.FontWeight.EXTRA_BOLD,
					padding: 59
				}), e.ConfirmBetPopUpView = m
			},
			27763: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PlusMinusWidget = void 0;
				const n = i(56254),
					s = i(46980),
					o = i(85136),
					r = i(66515),
					a = i(5266);
				class l extends PIXI.Container {
					constructor(t, e, i) {
						super();
						const l = new n.PointerStateColorSet(4294967295),
							h = new s.PointerStateIconSet(new o.Icon(a.SkinLoader.getTexture(a.SkinLoader.BET_UP)));
						this._upButton = new r.IconToggleButton(t, h, l), this._upButton.addClickCallback((() => i(this._upButton))), this._upButton.toggled = !1, this._upButton.pivot.set(38, 35), this._upButton.position.set(46, 0), this._upButton.scale.set(.8, .8);
						const u = new PIXI.Sprite(PIXI.Texture.WHITE);
						u.width = 2, u.height = 44, u.anchor.set(.5, .5), u.alpha = .5, u.roundPixels = !0;
						const c = new s.PointerStateIconSet(new o.Icon(a.SkinLoader.getTexture(a.SkinLoader.BET_DOWN)));
						this._downButton = new r.IconToggleButton(e, c, l), this._downButton.addClickCallback((() => i(this._downButton))), this._downButton.toggled = !1, this._downButton.pivot.set(38, 35), this._downButton.position.set(-50, 0), this._downButton.scale.set(.8, .8), this.addChild(this._upButton, u, this._downButton)
					}
					enableUpButton(t) {
						this._upButton.enable(t), this._upButton.alpha = t ? 1 : .4
					}
					enableDownButton(t) {
						this._downButton.enable(t), this._downButton.alpha = t ? 1 : .4
					}
				}
				e.PlusMinusWidget = l
			},
			89601: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.AutoplayButton = void 0;
				const n = i(66515),
					s = i(68714),
					o = i(49078),
					r = i(5266);
				class a extends n.IconToggleButton {
					get spinsCounterLabel() {
						return this._spinsCounterLabel
					}
					get width() {
						return this._icon.width
					}
					get height() {
						return this._icon.height
					}
					constructor(t, e, i, n, a) {
						super(t, e, i, n, a), this._spinsCounterLabel = new s.Label("-1", o.KeypadTextStyles.AUTO_PLAY_COUNTER_LABEL_STYLE), this._spinsCounterBackPlate = new PIXI.NineSlicePlane(r.SkinLoader.getTexture(r.SkinLoader.LABEL_PLATE_22), 22, 22, 22, 22), this._spinsCounterBackPlate.tint = 0, this._spinsCounterBackPlate.alpha = .4, this._spinsCounterLabel.addBackPlate(this._spinsCounterBackPlate, (() => this.updateSpinsCounterBackPlate())), this._spinsCounterLabel.anchor.set(.5, .5)
					}
					updateSpinsCounterBackPlate() {
						const t = new s.Margin(0, 0);
						this._spinsCounterBackPlate.width = 80, this._spinsCounterBackPlate.height = 46, this._spinsCounterBackPlate.pivot.set(.5 * this._spinsCounterBackPlate.width + t.left, .5 * this._spinsCounterBackPlate.height + t.top)
					}
					getIconColorSet() {
						return null != this.customToggledColorSet && this.toggled ? this.customToggledColorSet : this._colorSets.getItem(this.toggleState)
					}
					setCount(t) {
						t > 0 ? (this._spinsCounterLabel.text = "" + t, this.addSubComponent(this._spinsCounterLabel, {
							x: .5,
							y: 0
						}, {
							x: 0,
							y: -43
						})) : this.removeChild(this._spinsCounterLabel)
					}
					hideSpinCounterLabel() {
						this._spinsCounterLabel.visible = !1
					}
					showSpinCounterLabel() {
						this._spinsCounterLabel.visible = !0
					}
				}
				e.AutoplayButton = a
			},
			75345: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.FullscreenSpinButton = void 0;
				const n = i(94183),
					s = i(13006);
				class o extends n.GuiButton {
					constructor(t) {
						super(t);
						const e = new PIXI.Graphics;
						e.beginFill(16777215, 1), e.drawRect(0, 0, 100, 100), e.endFill(), this.addChild(e)
					}
					playClickedAnimation() {
						const t = new s.TimelineLite;
						return t.add(new s.TweenLite(this, .1, {
							alpha: .1,
							ease: s.Linear.easeNone
						})), t.add(new s.TweenLite(this, .2, {
							alpha: 0,
							ease: s.Power2.easeOut
						})), t
					}
				}
				e.FullscreenSpinButton = o
			},
			10280: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SpinButton = void 0;
				const n = i(94183),
					s = i(22088),
					o = i(33169),
					r = i(46980),
					a = i(85136),
					l = i(17106),
					h = i(30706),
					u = i(88297),
					c = i(16875),
					d = i(9886),
					p = i(13006),
					_ = i(79275),
					m = i(5266),
					g = i(78229),
					f = i(68714),
					S = i(77616),
					y = i(61e3),
					v = i(55462);
				class T extends n.GuiButton {
					get betState() {
						return this._betState
					}
					set betState(t) {
						this._betState = t, this.update()
					}
					get spinState() {
						return this._spinState
					}
					set spinState(t) {
						this._spinState = t, this.update()
					}
					constructor() {
						super(s.KeypadButtonIDs.SPIN), this._betState = h.BetState.NORMAL, this._spinState = u.SpinButtonState.SPIN, this._backPlateColors = l.SlotKeypadViewSettings.instance.normalBackPlatePointerStateColors.clone(), this._outlineColor = new c.BetStateColorSet(l.SlotKeypadViewSettings.NORMAL_COLOR, l.SlotKeypadViewSettings.NORMAL_COLOR, l.SlotKeypadViewSettings.NORMAL_COLOR, l.SlotKeypadViewSettings.FREE_BETS_COLOR, l.SlotKeypadViewSettings.BOOSTED_BET_COLOR), this._icons = new u.SpinButtonStateSet(new r.PointerStateIconSet(new a.Icon(m.SkinLoader.getTexture(m.SkinLoader.SPIN_ARROW))), new r.PointerStateIconSet(new a.Icon(m.SkinLoader.getTexture(m.SkinLoader.SPIN_STOP))), new r.PointerStateIconSet(new a.Icon(m.SkinLoader.getTexture(m.SkinLoader.SPIN_SKIP))), new r.PointerStateIconSet(new a.Icon(m.SkinLoader.getTexture(m.SkinLoader.SPIN_PLAY))), new r.PointerStateIconSet(new a.Icon(m.SkinLoader.getTexture(m.SkinLoader.SPIN_ARROW))), new r.PointerStateIconSet(new a.Icon(m.SkinLoader.getTexture(m.SkinLoader.SPIN_ARROW)))), this._gambleIcon = new a.Icon(m.SkinLoader.getTexture(m.SkinLoader.COLLECT_ICON)), this._boostIcon = new a.Icon(m.SkinLoader.getTexture(m.SkinLoader.BOOST_ICON));
						const t = l.SlotKeypadViewSettings.instance.normalPointerStateColors.clone();
						this._boostedColors = l.SlotKeypadViewSettings.instance.boostedBetsPointerStateColors.clone(), this._colorSets = new u.SpinButtonStateSet(t, t, t, t, t, this._boostedColors), this._soundSet = new u.SpinButtonStateSet(_.KeypadSound.SPIN_START, _.KeypadSound.SPIN_STOP, _.KeypadSound.SPIN_STOP, _.KeypadSound.NONE, _.KeypadSound.SPIN_START, _.KeypadSound.SPIN_START), this._backPlate = new PIXI.NineSlicePlane(m.SkinLoader.getTexture(m.SkinLoader.SPIN_BUTTON_PLATE), 40, 40, 40, 40), this._backPlate.width = 200, this._backPlate.height = 180, this.addChild(this._backPlate), this._totalCostContainer = new PIXI.Container;
						const e = g.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE.clone();
						e.fontSize = 22, e.fill = "#FFFC00", e.fontWeight = S.FontWeight.BOLD, this._totalCostLabel = new f.Label("-1", e), this._totalCostLabel.anchor.set(.5, 1), this._totalCostLabel.position.set(100, 180), this._totalCostBackplate = new PIXI.NineSlicePlane(y.ImgLoader.getImgTexture(v.GuiDefaultTextures.NOLIMIT_BONUS_BET_BACKPLATE), 36, 36, 36, 36), this._totalCostContainer.visible = !1, this._totalCostContainer.addChild(this._totalCostBackplate, this._totalCostLabel), this.addChild(this._totalCostContainer), this.addClickCallback((() => this.playSound())), this.update()
					}
					drawBackPlate(t, e) {
						this._backPlate.tint = d.GuiUtils.getColorFromARGB(e)
					}
					playClickedAnimation() {
						const t = new p.TimelineLite;
						return t.set(this._icon, {
							rotation: 0
						}), t.set(this._icon.scale, {
							x: 1,
							y: 1
						}), this._spinState == u.SpinButtonState.SPIN || this._spinState == u.SpinButtonState.GAMBLE || this._spinState == u.SpinButtonState.BOOST ? t.add(new p.TweenLite(this._icon, .25, {
							rotation: 2 * Math.PI
						})) : (t.add(new p.TweenLite(this._icon.scale, .05, {
							x: .95,
							y: .95,
							ease: p.Linear.easeNone
						})), t.add(new p.TweenLite(this._icon.scale, .05, {
							x: 1,
							y: 1
						}))), t
					}
					setIcon() {
						if (this._betState == h.BetState.ZERO_BET) return this._icon && (this._icon.visible = !1), void(this._backPlate.visible = !1);
						const t = this._icons.getItem(this._spinState),
							e = this._colorSets.getItem(this._spinState),
							i = t.getItem(this.pointerState);
						let n = e.getItem(this.pointerState);
						this.betState == h.BetState.BOOSTED_BET && (n = this._boostedColors.getItem(this.pointerState)), i.setColor(n), i != this._icon && (this.addChild(i), this.removeChild(this._icon), this._icon = i), this._backPlate.visible = !0, this._icon.visible = !0, this._icon.anchor.set(.5, .5), this._icon.position.set(.5 * this._backPlate.width, .5 * this._backPlate.height), this.setGambleIconViability(n), this.setBoostIconViability(n)
					}
					setGambleIconViability(t) {
						this._spinState == u.SpinButtonState.GAMBLE ? (this._gambleIcon.visible = !0, this._gambleIcon.anchor.set(.5, .6), this._gambleIcon.position.set(.5 * this._backPlate.width, .5 * this._backPlate.height), this._gambleIcon.setColor(t), this.addChild(this._gambleIcon)) : this.removeChild(this._gambleIcon)
					}
					setBoostIconViability(t) {
						this._spinState == u.SpinButtonState.BOOST ? (this._boostIcon.visible = !0, this._boostIcon.anchor.set(.5, .6), this._boostIcon.position.set(.5 * this._backPlate.width, .5 * this._backPlate.height), this._boostIcon.setColor(t), this.addChild(this._boostIcon)) : this.removeChild(this._boostIcon)
					}
					onPointerStateUpdate(t) {
						this.update()
					}
					updateTotalCostSize() {
						this._totalCostBackplate.width = this._totalCostLabel.width + 50, this._totalCostBackplate.height = this._totalCostLabel.height + 32, this._totalCostBackplate.position.set(this._totalCostLabel.x, this._totalCostLabel.y - .5 * this._totalCostLabel.height + 5), this._totalCostBackplate.pivot.set(.5 * this._totalCostBackplate.width, .5 * this._totalCostBackplate.height)
					}
					setTotalCost(t) {
						null != t ? (this._totalCostLabel.text = t, this.updateTotalCostSize(), this._totalCostContainer.visible = !0) : (this._totalCostLabel.text = "", this._totalCostContainer.visible = !1)
					}
					update() {
						this.drawBackPlate(this._backPlateColors.getItem(this.pointerState), this._outlineColor.getItem(this._betState)), this.setIcon()
					}
					playSound() {
						const t = this._soundSet.getItem(this.spinState) || _.KeypadSound.NONE;
						s.SlotKeypad.playButtonSound(this.name + "_" + this.spinState, t)
					}
					clickButton() {
						this.pointerState != o.PointerState.DISABLED && this.onClick()
					}
				}
				e.SpinButton = T
			},
			30706: (t, e) => {
				"use strict";
				var i;
				Object.defineProperty(e, "__esModule", {
						value: !0
					}), e.BetStateSet = e.BetState = void 0,
					function(t) {
						t[t.NORMAL = 0] = "NORMAL", t[t.AUTOPLAY = 1] = "AUTOPLAY", t[t.ZERO_BET = 2] = "ZERO_BET", t[t.FREE_BETS = 3] = "FREE_BETS", t[t.BOOSTED_BET = 4] = "BOOSTED_BET", t[t.HIDDEN = 5] = "HIDDEN"
					}(i = e.BetState || (e.BetState = {}));
				class n {
					constructor(t, e, n, s, o, r) {
						this[i.NORMAL] = t, this[i.AUTOPLAY] = e, this[i.ZERO_BET] = n, this[i.FREE_BETS] = s, this[i.BOOSTED_BET] = o, this[i.HIDDEN] = r
					}
					getItem(t) {
						return this[t]
					}
					clone() {
						return new n(this[i.NORMAL], this[i.AUTOPLAY], this[i.ZERO_BET], this[i.FREE_BETS], this[i.BOOSTED_BET], this[i.HIDDEN])
					}
				}
				e.BetStateSet = n, i.NORMAL, i.AUTOPLAY, i.ZERO_BET, i.FREE_BETS, i.BOOSTED_BET, i.HIDDEN
			},
			88297: (t, e) => {
				"use strict";
				var i;
				Object.defineProperty(e, "__esModule", {
						value: !0
					}), e.SpinButtonStateSet = e.SpinButtonState = void 0,
					function(t) {
						t.SPIN = "SPIN", t.STOP = "STOP", t.ABORT = "ABORT", t.COUNT = "COUNT", t.GAMBLE = "GAMBLE", t.BOOST = "BOOST"
					}(i = e.SpinButtonState || (e.SpinButtonState = {}));
				class n {
					constructor(t, e, n, s, o, r) {
						this[i.SPIN] = t, this[i.STOP] = e, this[i.ABORT] = n, this[i.COUNT] = s, this[i.GAMBLE] = o, this[i.BOOST] = r
					}
					getItem(t) {
						return this[t]
					}
					clone() {
						return new n(this[i.SPIN], this[i.STOP], this[i.ABORT], this[i.COUNT], this[i.GAMBLE], this[i.BOOST])
					}
				}
				e.SpinButtonStateSet = n, i.SPIN, i.STOP, i.ABORT, i.COUNT, i.GAMBLE, i.BOOST
			},
			16875: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BetStateColorSet = void 0;
				const n = i(30706);
				class s extends n.BetStateSet {
					constructor(t, e, i, n, s) {
						super(t, e, i, n, s)
					}
					getItem(t) {
						return null != this[t] ? this[t] : this[n.BetState.NORMAL]
					}
					clone() {
						return super.clone()
					}
				}
				e.BetStateColorSet = s
			},
			1676: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.AutoPlayView = void 0;
				const n = i(22088),
					s = i(38801),
					o = i(62145),
					r = i(17194),
					a = i(75754),
					l = i(37950),
					h = i(24186),
					u = i(72468),
					c = i(49490);
				class d extends o.DialogView {
					constructor(t, e) {
						super(t, e, "AutoPlaySettings", !0)
					}
					init() {
						super.init(), this._settingsPage = new a.AutoPlaySettingsPage(this, n.SlotKeypad.apiPlugIn.translations.translate("Autoplay settings")), this._settingsPage.name = "AutoPlaySettingsPage", this._roundsPage = new r.AutoPlayRoundsPage(this, n.SlotKeypad.apiPlugIn.translations.translate("Number of Rounds")), this._roundsPage.name = "NumberOfRoundsPage", this._sectionDivider = new PIXI.Graphics, this._content = new PIXI.Container, this._content.addChild(this._settingsPage), this._content.addChild(this._sectionDivider), this._content.addChild(this._roundsPage), this.addChild(this._content)
					}
					drawSectionDivider(t, e) {
						this._sectionDivider.clear(), this._sectionDivider.lineStyle(1, 16777215, .6);
						const i = h.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT;
						this._sectionDivider.moveTo(i, 0), this._sectionDivider.lineTo(t.width - 2 * i, 0)
					}
					onResize() {
						if (super.onResize(), !this.shouldResize()) return;
						const t = (0, l.cloneScreenBounds)(u.NolimitApplication.screenBounds);
						t.bottom -= this.bottomMargin, this.drawSectionDivider(t, u.NolimitApplication.isLandscape), this._settingsPage.onResize(t), this._roundsPage.onResize(t), s.GuiLayout.align([this._settingsPage, this._sectionDivider, this._roundsPage], 10, s.Align.LEFT, s.Direction.VERTICAL), this._content.position.set(t.left, t.top)
					}
					onInteraction(t, e) {
						let i = !1,
							s = !0;
						const o = t.split("_")[0];
						"maxSingleWin" == o && (this.autoPlaySettingsData.maxSingleWin = e, s = !1), "StopWhenBalanceIsLower" == o && (this.autoPlaySettingsData.minBalancePercent == e ? this.autoPlaySettingsData.minBalancePercent = void 0 : this.autoPlaySettingsData.minBalancePercent = e), "StopWhenBalanceIsHigher" == o && (this.autoPlaySettingsData.maxBalancePercent == e ? this.autoPlaySettingsData.maxBalancePercent = void 0 : this.autoPlaySettingsData.maxBalancePercent = e), "AutoPlayRoundsButton" == o && (this.autoPlaySettingsData.rounds = parseInt(e), i = !0), this._controller.updateAutoplaySettings(this.autoPlaySettingsData), this._settingsPage.updateValues(n.SlotKeypad.autoplay.settings), this._roundsPage.updateButtons(n.SlotKeypad.apiPlugIn.gameClientConfiguration.autoPlaySettings.autoplayRounds), s && !i && n.SlotKeypad.playButtonSound(o), i && this.close(!0)
					}
					open() {
						super.open(), this.autoPlaySettingsData = n.SlotKeypad.autoplay.settings, this._settingsPage.updateValues(n.SlotKeypad.autoplay.settings), this._roundsPage.updateButtons(n.SlotKeypad.apiPlugIn.gameClientConfiguration.autoPlaySettings.autoplayRounds), this.onResize(), this._settingsPage.updateDomElement(!0)
					}
					close(t = !1) {
						this._settingsPage.updateDomElement(!1), this.reportBackSettingPageClosed(), super.close()
					}
					reportBackSettingPageClosed() {
						n.SlotKeypad.apiPlugIn.events.trigger(c.APIEvent.SETTING_PAGE_CHANGE, {
							name: "gameMenu",
							value: !1
						})
					}
				}
				e.AutoPlayView = d
			},
			15507: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BetLevelsDialogView = void 0;
				const n = i(22088),
					s = i(18386),
					o = i(62145),
					r = i(72468),
					a = i(37950);
				class l extends o.DialogView {
					constructor(t, e) {
						super(t, e, "BetLevels", !0)
					}
					init() {
						super.init(), this.makePage()
					}
					makePage() {
						this._page && (this.removeChild(this._page), this._page.destroy());
						const t = this.api.options.hideCurrency ? "" : this.api.currency.getSymbol();
						this._page = new s.BetLevelsPage(this, n.SlotKeypad.apiPlugIn.translations.translate("BET"), "" + t), this.addChild(this._page)
					}
					onResize() {
						if (super.onResize(), !this.shouldResize()) return;
						const t = (0, a.cloneScreenBounds)(r.NolimitApplication.screenBounds);
						t.bottom -= this.bottomMargin, t.height -= this.bottomMargin, this._page.onResize(t), this._page.position.set(t.left, t.top)
					}
					onInteraction(t, e) {
						this._controller.newBetLevelSelected(t), this.close()
					}
					onRefresh() {
						this.isOpen && this._page.updateButtons()
					}
					open() {
						super.open(), this.makePage(), this._page.updateButtons(), this.onResize()
					}
					close() {
						super.close()
					}
				}
				e.BetLevelsDialogView = l
			},
			70742: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.DemoView = void 0;
				const n = i(62145),
					s = i(22088),
					o = i(37950),
					r = i(72468),
					a = i(30093),
					l = i(41122);
				class h extends n.DialogView {
					constructor(t, e) {
						super(t, e, "Demo", !0), this.storedOutcomes = [], this.outcomeQueue = [], this._client = e.communication.outcome.connect(e.options), e.log("Outcome ws connect"), this._client.on("error", (t => {
							e.warn("Outcome ws error", t), this._controller.disableDemoButton()
						})), this._client.on("close", (() => {
							e.log("Outcome ws close")
						})), this._client.on("message", (t => {
							e.log("Outcome ws message", t), this.storedOutcomes = t
						}))
					}
					load() {
						return this.api.resources.loadJson("outcome.json").then((t => {
							this.outcomeJson = t
						}))
					}
					init() {
						super.init(), this._page = new a.DemoPage(this, s.SlotKeypad.apiPlugIn.translations.translate("DEMO"), ""), this.addChild(this._page)
					}
					tryToSpin() {
						const t = this.api.slotStates.checkState(l.SlotState.READY);
						this.storedOutcomes.length > 0 && t && this._controller.clickSpin()
					}
					onInteraction(t, e) {
						t == h.GO_BUTTON ? this.outcomeQueue.length > 0 && (this.sendOutcomesToServer(this.outcomeQueue), this.clearQueue(), this.close()) : t == h.CLEAR_OUTCOME_SETTER_BUTTON ? this._client.clear() : t == h.CLEAR_BUTTON ? (this.clearQueue(), this._page.updateButtons()) : this.addToQueue(this.outcomeJson.demo[e]), s.SlotKeypad.playButtonSound(t)
					}
					sendOutcomesToServer(t) {
						for (let e of t)
							for (let t of e.outcomes) "string" == typeof t ? this._client.addFlag(t) : this._client.addReels(t)
					}
					addToQueue(t) {
						this.outcomeQueue.push(t), this._page.updateQueue()
					}
					clearQueue() {
						this.outcomeQueue = [], this._page.updateQueue()
					}
					onResize() {
						if (super.onResize(), !this.shouldResize()) return;
						const t = (0, o.cloneScreenBounds)(r.NolimitApplication.screenBounds);
						t.bottom -= this.bottomMargin, t.height -= this.bottomMargin, this._page.onResize(t), this._page.position.set(t.left, t.top)
					}
					open() {
						super.open(), this._page.updateButtons(), this._page.updateQueue(), this.onResize()
					}
					close() {
						super.close()
					}
				}
				h.GO_BUTTON = "GO_BUTTON", h.CLEAR_BUTTON = "CLEAR_BUTTON", h.CLEAR_OUTCOME_SETTER_BUTTON = "CLEAR_OUTCOME_SETTER_BUTTON", e.DemoView = h
			},
			62145: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.DialogView = void 0;
				const n = i(22088),
					s = i(37950),
					o = i(72468),
					r = i(17106),
					a = i(66515),
					l = i(46980),
					h = i(85136),
					u = i(24186),
					c = i(39267),
					d = i(5266);
				class p extends PIXI.Container {
					get isOpen() {
						return this._isOpen
					}
					constructor(t, e, i, n = !1) {
						super(), this._init = !1, this._isOpen = !1, this.bottomMargin = 0, this.name = i, this.api = e, this._controller = t, this._shouldHaveCloseButton = n, this.bottomMargin = this._controller.getBalanceBarHeight()
					}
					onInteraction(t, e) {}
					init() {
						this._backPlate = new PIXI.Graphics, this._backPlate.name = "backplate", this.addChild(this._backPlate);
						const t = r.SlotKeypadViewSettings.instance.normalPointerStateColors.clone(),
							e = new l.PointerStateIconSet(new h.Icon(d.SkinLoader.getTexture(d.SkinLoader.MENU_CLOSE)));
						this.closeButton = new a.IconToggleButton("CLOSE", e, t, e), this.closeButton.addClickCallback((() => this.close())), this.closeButton.enable(!0), this.addChild(this.closeButton), this._shouldHaveCloseButton || c.SlotKeypadUtils.disableElement(this.closeButton), this._bottomSeparator = new PIXI.Graphics, this._bottomSeparator.name = "_bottomSeparator", this.addChild(this._bottomSeparator)
					}
					drawBackPlate(t) {
						this._backPlate.clear(), this._backPlate.beginFill(0, .1), this._backPlate.drawRect(0, 0, t.width, t.height), this._backPlate.position.set(t.left, t.top)
					}
					drawBottomSeparator(t) {
						this._bottomSeparator.clear(), this._bottomSeparator.lineStyle(2, 16777215, .6), this._bottomSeparator.moveTo(0, 0), this._bottomSeparator.lineTo(t.width, 0), this._bottomSeparator.position.set(t.left, t.bottom + 1)
					}
					close() {
						n.SlotKeypad.playButtonSound("DialogClosed"), o.NolimitApplication.removeDialog(this), this._isOpen = !1
					}
					open() {
						this._init || (this.init(), this._init = !0), this._isOpen = !0, o.NolimitApplication.addDialog(this, !0)
					}
					shouldResize() {
						return this._init && this._isOpen
					}
					onResize() {
						if (this.shouldResize()) {
							const t = (0, s.cloneScreenBounds)(o.NolimitApplication.screenBounds);
							t.bottom -= this.bottomMargin, this.closeButton.position.set(t.right - this.closeButton.width - u.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT, t.top - 11 + (o.NolimitApplication.isLandscape ? u.KeypadDefault.SCREEN_EDGE_MARGIN_TOP_LANDSCAPE : u.KeypadDefault.SCREEN_EDGE_MARGIN_TOP)), this.drawBackPlate(t), this.drawBottomSeparator(t)
						}
					}
				}
				e.DialogView = p
			},
			64232: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GameMenuDialogView = e.MenuButtonIDs = void 0;
				const n = i(62145),
					s = i(22088),
					o = i(72468),
					r = i(37950),
					a = i(23246),
					l = i(20486),
					h = i(40069),
					u = i(48550),
					c = i(49490);
				var d;
				! function(t) {
					t.EXIT_TO_LOBBY = "EXIT_TO_LOBBY", t.HISTORY = "HISTORY", t.INFO = "INFO", t.SETTINGS = "SETTINGS", t.CLOSE = "CLOSE"
				}(d = e.MenuButtonIDs || (e.MenuButtonIDs = {}));
				class p extends n.DialogView {
					openAndGoTo(t) {
						this._isOpen || (t === l.SettingSectionIDs.GUIDE || t === l.SettingSectionIDs.RULES || t === l.SettingSectionIDs.PAYTABLE) && (this.open(), this._infoPage.goToSection(t))
					}
					constructor(t, e) {
						super(t, e, "GameMenu", !1), this._htmlScreenContainer = p.getScreensContainer(), this._screenSystem = s.SlotKeypad.apiPlugIn.screenSystem.create(this._htmlScreenContainer), this.init(), this._init = !0
					}
					init() {
						super.init(), this._menuBar = new u.GameMenuNavigationBar(this), this.addChild(this._menuBar), this._gameSettingsPage = new h.GameSettingsPage(d.SETTINGS, this, s.SlotKeypad.apiPlugIn.translations.translate("Game settings")), this._infoPage = new l.InfoPage(this._htmlScreenContainer, this._screenSystem, d.INFO, this), this._historyPage = new a.HistoryPage(this._htmlScreenContainer, this._screenSystem, d.HISTORY, this, s.SlotKeypad.apiPlugIn.translations.translate("Game history"))
					}
					preLoadHtmlPages() {
						const t = [];
						return t.push(this._historyPage.load()), t.push(this._infoPage.load()), Promise.all(t)
					}
					onResize() {
						if (super.onResize(), !this.shouldResize()) return;
						const t = (0, r.cloneScreenBounds)(o.NolimitApplication.screenBounds);
						t.bottom -= this.bottomMargin, t.height -= this.bottomMargin, this._menuBar.onResize(t), o.NolimitApplication.isLandscape ? (t.right -= this._menuBar.width, t.width -= this._menuBar.width) : (t.bottom -= this._menuBar.height, t.height -= this._menuBar.height), this._gameSettingsPage.position.set(t.left, t.top), this._gameSettingsPage.onResize(t), this._historyPage.position.set(t.left, t.top), this._historyPage.onResize(t), this._infoPage.position.set(t.left, t.top), this._infoPage.onResize(t)
					}
					onInteraction(t, e) {
						let i = !0;
						switch (t) {
							case d.EXIT_TO_LOBBY:
								this._controller.exitToLobby();
								break;
							case d.HISTORY:
								this.setActivePage(this._historyPage), this.reportBackSettingPageChange(s.SettingPageIDs.HISTORY, !0);
								break;
							case d.INFO:
								this.setActivePage(this._infoPage), this.reportBackSettingPageChange(s.SettingPageIDs.INFO, !0);
								break;
							case d.SETTINGS:
								this.setActivePage(this._gameSettingsPage), this.reportBackSettingPageChange(s.SettingPageIDs.SETTINGS, !0);
								break;
							case d.CLOSE:
								this.close(), i = !1
						}
						1 == i && s.SlotKeypad.playButtonSound(t), this.updateButtons()
					}
					open() {
						super.open(), this.onResize(), this.setActivePage(this._infoPage), this.updateButtons()
					}
					close() {
						this.setActivePage(null), this.reportBackSettingPageClosed(), super.close()
					}
					reportBackSettingPageChange(t, e) {
						s.SlotKeypad.apiPlugIn.externalApi.trigger(c.APIEvent.SETTING_PAGE_CHANGE, {
							name: t,
							value: e
						})
					}
					reportBackSettingPageClosed() {
						s.SlotKeypad.apiPlugIn.externalApi.trigger(c.APIEvent.SETTING_PAGE_CHANGE, {
							name: "gameMenu",
							value: !1
						})
					}
					setActivePage(t) {
						if (null == t) return this._activePage.deactivate(), void(this._htmlScreenContainer.style.display = "none");
						t != this._activePage ? (this._activePage && (this.removeChild(this._activePage), this._activePage.deactivate()), t.activate(), this.addChild(t), this._activePage = t) : "HISTORY" !== this._activePage.name && this._activePage.activate()
					}
					updateButtons() {
						this._menuBar.updateButtons(this._activePage.name)
					}
					static getScreensContainer() {
						let t = document.querySelector(".nolimit.container.screensFrameContainer");
						if (null == t) {
							const e = document.querySelector(".nolimit.container");
							null == e ? s.SlotKeypad.apiPlugIn.error.trigger("Can't find container element: .nolimit.container") : (t = document.createElement("div"), t.classList.add("screensFrameContainer"), t.style.display = "none", t.style.position = "absolute", t.style.width = "100%", t.style.height = "100%", t.style.top = "0px", t.style.left = "0pxe", e.appendChild(t))
						}
						return t
					}
				}
				e.GameMenuDialogView = p
			},
			48550: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GameMenuNavigationBar = void 0;
				const n = i(17106),
					s = i(22088),
					o = i(39267),
					r = i(64232),
					a = i(46980),
					l = i(85136),
					h = i(66515),
					u = i(70329),
					c = i(38801),
					d = i(72468),
					p = i(5266);
				class _ extends PIXI.Container {
					constructor(t) {
						super(), this.name = "GameMenuNavigationBar", this._parentView = t, this.createMenuBar()
					}
					drawMenuBackPlate(t) {
						this._backPlate.clear(), this._backPlate.beginFill(0, .2), d.NolimitApplication.isLandscape ? (this._backPlate.drawRect(2, 0, 109, t.height), this._backPlate.endFill(), this._backPlate.lineStyle(2, 16777215, .6), this._backPlate.moveTo(1, 0), this._backPlate.lineTo(1, t.height)) : (this._backPlate.drawRect(0, 2, t.width, 109), this._backPlate.endFill(), this._backPlate.lineStyle(2, 16777215, .6), this._backPlate.moveTo(0, 1), this._backPlate.lineTo(t.width, 1))
					}
					drawSeparators() {
						this._exitSeparator.clear(), this._exitSeparator.lineStyle(.6, 16777215), this._closeButtonSeparator.clear(), this._closeButtonSeparator.lineStyle(.6, 16777215), d.NolimitApplication.isLandscape ? (this._exitSeparator.lineTo(70, 0), this._closeButtonSeparator.lineTo(70, 0)) : (this._exitSeparator.lineTo(0, 70), this._closeButtonSeparator.lineTo(0, 70))
					}
					onResize(t) {
						this.drawMenuBackPlate(t), this.drawSeparators(), d.NolimitApplication.isLandscape ? (c.GuiLayout.align(this._navigationSection.children, 30, c.Align.CENTER, c.Direction.VERTICAL), c.GuiLayout.align(this._exitLobbySection.children, 21, c.Align.CENTER, c.Direction.VERTICAL), c.GuiLayout.align(this._closeButtonSection.children, 6, c.Align.CENTER, c.Direction.VERTICAL), this._exitLobbySection.pivot.set(.5 * this._exitLobbySection.width, 0), this._closeButtonSection.pivot.set(.5 * this._closeButtonSection.width, this._closeButtonSection.height), this._navigationSection.pivot.set(.5 * this._navigationSection.width, this._navigationSection.height), this._exitLobbySection.position.y = 40, this._closeButtonSection.position.y = t.height - 5, this._navigationSection.position.y = this._closeButtonSection.y - this._closeButtonSection.height - 40, this._exitLobbySection.position.x = .5 * this._backPlate.width, this._closeButtonSection.position.x = .5 * this._backPlate.width, this._navigationSection.position.x = .5 * this._backPlate.width, this.pivot.set(this.width, 0), this.position.set(t.right, t.top)) : (c.GuiLayout.align(this._navigationSection.children, 30, c.Align.CENTER, c.Direction.HORIZONTAL), c.GuiLayout.align(this._exitLobbySection.children, 21, c.Align.CENTER, c.Direction.HORIZONTAL), c.GuiLayout.align(this._closeButtonSection.children, 6, c.Align.CENTER, c.Direction.HORIZONTAL), this._exitLobbySection.pivot.set(0, .5 * this._exitLobbySection.height), this._closeButtonSection.pivot.set(this._closeButtonSection.width, .5 * this._closeButtonSection.height), this._navigationSection.pivot.set(this._navigationSection.width, .5 * this._navigationSection.height), this._exitLobbySection.position.x = 20, this._closeButtonSection.position.x = t.width - 5, this._navigationSection.position.x = this._closeButtonSection.x - this._closeButtonSection.width - 40, this._exitLobbySection.position.y = .5 * this._backPlate.height, this._closeButtonSection.position.y = .5 * this._backPlate.height, this._navigationSection.position.y = .5 * this._backPlate.height, this.pivot.set(0, this.height), this.position.set(t.left, t.bottom))
					}
					onOrientationChanged() {}
					createMenuBar() {
						this._backPlate = new PIXI.Graphics, this._backPlate.beginFill(16711680, .6), this._backPlate.drawRect(0, 2, 109, 109), this._backPlate.endFill(), this._backPlate.lineStyle(2, 16777215, .6), this._backPlate.moveTo(0, 1), this._backPlate.lineTo(109, 1), this._buttons = [];
						let t, e = n.SlotKeypadViewSettings.instance.activePointerStateColors.clone(),
							i = n.SlotKeypadViewSettings.instance.normalNonEmphasisPointerStateColors.clone();
						t = new a.PointerStateIconSet(new l.Icon(p.SkinLoader.getTexture(p.SkinLoader.EXIT_LOBBY))), this._exitLobbyButton = new h.IconToggleButton(r.MenuButtonIDs.EXIT_TO_LOBBY, t, e, void 0, i), this._exitLobbyButton.addClickCallback((() => this._parentView.onInteraction(this._exitLobbyButton.name, this._exitLobbyButton.name))), t = new a.PointerStateIconSet(new l.Icon(p.SkinLoader.getTexture(p.SkinLoader.HISTORY))), this._historyButton = new h.IconToggleButton(r.MenuButtonIDs.HISTORY, t, e, void 0, i), this._historyButton.addClickCallback((() => this._parentView.onInteraction(this._historyButton.name, this._historyButton.name))), t = new a.PointerStateIconSet(new l.Icon(p.SkinLoader.getTexture(p.SkinLoader.INFO))), this._infoButton = new h.IconToggleButton(r.MenuButtonIDs.INFO, t, e, void 0, i), this._infoButton.addClickCallback((() => this._parentView.onInteraction(this._infoButton.name, this._infoButton.name))), t = new a.PointerStateIconSet(new l.Icon(p.SkinLoader.getTexture(p.SkinLoader.SETTINGS))), this._settingButton = new h.IconToggleButton(r.MenuButtonIDs.SETTINGS, t, e, void 0, i), this._settingButton.addClickCallback((() => this._parentView.onInteraction(this._settingButton.name, this._settingButton.name))), t = new a.PointerStateIconSet(new l.Icon(p.SkinLoader.getTexture(p.SkinLoader.MENU_CLOSE))), this._closeButton = new h.IconToggleButton(r.MenuButtonIDs.CLOSE, t, e, void 0, i), this._closeButton.addClickCallback((() => this._parentView.onInteraction(this._closeButton.name, this._closeButton.name))), this._buttons.push(this._exitLobbyButton), this._buttons.push(this._historyButton), this._buttons.push(this._infoButton), this._buttons.push(this._settingButton), this._buttons.push(this._closeButton), this._exitLobbySection = new PIXI.Container, this._exitSeparator = new PIXI.Graphics, this._exitLobbySection.addChild(this._exitLobbyButton), this._exitLobbySection.addChild(this._exitSeparator), this._navigationSection = new PIXI.Container, this._navigationSection.addChild(this._historyButton), this._navigationSection.addChild(this._infoButton), this._navigationSection.addChild(this._settingButton), this._closeButtonSection = new PIXI.Container, this._closeButtonSeparator = new PIXI.Graphics, this._closeButtonSection.addChild(this._closeButtonSeparator), this._closeButtonSection.addChild(this._closeButton), this.addChild(this._backPlate), this.addChild(this._exitLobbySection), this.addChild(this._navigationSection), this.addChild(this._closeButtonSection);
						for (let t of this._buttons) t.enable(!0);
						s.SlotKeypad.apiPlugIn.options.device === u.Device.DESKTOP ? s.SlotKeypad.apiPlugIn.options.showExitButtonDesktop || o.SlotKeypadUtils.disableElement(this._exitLobbySection) : s.SlotKeypad.apiPlugIn.options.hideExitButton && o.SlotKeypadUtils.disableElement(this._exitLobbySection)
					}
					updateButtons(t) {
						for (let e of this._buttons) e.toggled = t === e.name
					}
				}
				e.GameMenuNavigationBar = _
			},
			80370: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PageHeader = void 0;
				const n = i(49078),
					s = i(17106),
					o = i(68714),
					r = i(38801);
				class a extends PIXI.Container {
					constructor(t, e) {
						super(), this._headerWhite = new o.Label(t, n.KeypadTextStyles.DEFAULT_DIALOG_HEADER), this._headerYellow = new o.Label(e, n.KeypadTextStyles.DEFAULT_DIALOG_HEADER), this._headerYellow.setColor(s.SlotKeypadViewSettings.AUTOPLAY_COLOR), this._separator = new PIXI.Graphics, this._textContainer = new PIXI.Container, this._textContainer.addChild(this._headerWhite, this._headerYellow), r.GuiLayout.align([this._headerWhite, this._headerYellow], 10, r.Align.TOP, r.Direction.HORIZONTAL), this.addChild(this._textContainer, this._separator)
					}
					resize(t) {
						this._separator.clear(), this._separator.lineStyle(1, 16777215, .5), this._separator.moveTo(0, 0), this._separator.lineTo(t - 11, 0), this._separator.position.set(0, 89), this._textContainer.width > t - 80 && this._textContainer.scale.set((t - 80) / this._textContainer.width)
					}
				}
				e.PageHeader = a
			},
			17194: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.AutoPlayRoundsPage = void 0;
				const n = i(39767),
					s = i(17106),
					o = i(24186),
					r = i(38801),
					a = i(22088),
					l = i(67566),
					h = i(78229);
				class u extends n.BasePage {
					constructor(t, e) {
						super("autoplayRounds", t, e)
					}
					createContent() {
						const t = super.createContent();
						return this._buttonContainer = new PIXI.Container, this._buttonContainer.name = "buttons", this._buttons = [], t.addChild(this._buttonContainer), t
					}
					createButton(t) {
						let e = s.SlotKeypadViewSettings.instance.normalNonEmphasisPointerStateColors.clone(),
							i = s.SlotKeypadViewSettings.instance.activePointerStateColors.clone(),
							n = h.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE.clone();
						const r = new l.LabelButton("AutoPlayRoundsButton_" + t.toString(), t.toString(), n, i, e);
						return r.value = t, r.addClickCallback((() => this._parentView.onInteraction(r.name, r.value))), r.setSize(o.KeypadDefault.DEFAULT_SMALL_BUTTON_SIZE.width, o.KeypadDefault.DEFAULT_SMALL_BUTTON_SIZE.height), r.enable(!1), r.toggled = !1, this._buttons.push(r), this._buttonContainer.addChild(r), r
					}
					onResize(t) {
						this.header.position.set(o.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT, 0), this.content.position.set(0, this.header.y + this.header.height + 10), this.onResizeContent(t)
					}
					onResizeContent(t) {
						const e = t.width - 2 * o.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT,
							i = o.KeypadDefault.DEFAULT_SMALL_BUTTON_SIZE.width + 15;
						let n = Math.floor(e / i);
						i * (n + 1) - 15 <= e && (n += 1);
						const s = n,
							a = Math.ceil(this._buttons.length / s),
							l = this._buttons.concat();
						for (let t = 0; t < a; t++) {
							const e = l.length < s ? l : l.splice(0, s);
							r.GuiLayout.align(e, 15, r.Align.TOP, r.Direction.HORIZONTAL), r.GuiLayout.offset(e, o.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT, (o.KeypadDefault.DEFAULT_SMALL_BUTTON_SIZE.height + 15) * t)
						}
					}
					updateButtons(t) {
						let e = !0;
						a.SlotKeypad.apiPlugIn.gameClientConfiguration.autoPlaySettings.autoplayRequiresStopLossLimit && (e = null != a.SlotKeypad.autoplay.settings.minBalancePercent);
						for (let i = 0; i < t.length; i++) {
							const n = t[i];
							this._buttons[i] ? (this._buttons[i].value = n.toString(), this._buttons[i].name = "AutoPlayRoundsButton_" + n.toString(), this._buttons[i].label.text = n.toString()) : this.createButton(n), this._buttons[i].enable(e)
						}
						const i = this._buttons.splice(t.length);
						for (let t of i) this._buttonContainer.removeChild(t)
					}
				}
				e.AutoPlayRoundsPage = u
			},
			75754: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.AutoPlaySettingsPage = void 0;
				const n = i(38801),
					s = i(39767),
					o = i(68714),
					r = i(59936),
					a = i(17106),
					l = i(24186),
					h = i(9886),
					u = i(22088),
					c = i(78229),
					d = i(67566);
				class p extends s.BasePage {
					constructor(t, e) {
						super("autoplaySettings", t, e), this._addLimitMustBeSet = !1
					}
					updateDomElement(t) {
						t ? this._stopWhenExceedInput.addDom() : this._stopWhenExceedInput.removeDom()
					}
					createContent() {
						const t = super.createContent(),
							e = u.SlotKeypad.apiPlugIn.translations.translate("Stop when single win exceeds");
						this._stopWhenExceedWin = this.createStopWhenExceedWin(e), this._stopWhenExceedWin.name = "stopWhenExceedContainer", this._stopWhenBalanceIsLowerButtons = [];
						const i = u.SlotKeypad.apiPlugIn.translations.translate("Stop before the balance is lower than"),
							s = u.SlotKeypad.apiPlugIn.gameClientConfiguration.autoPlaySettings.autoplayRequiresStopLossLimit ? h.GuiUtils.getColorFromARGB(a.SlotKeypadViewSettings.AUTOPLAY_COLOR) : h.GuiUtils.getColorFromARGB(a.SlotKeypadViewSettings.NORMAL_COLOR),
							o = this.createStopWhenBalance(i, "StopWhenBalanceIsLower", ["0%", "50%", "75%"], [0, .5, .75], this._stopWhenBalanceIsLowerButtons, s, !0);
						this._stopWhenBalanceIsLower = o.container, this._calculatedMinBalance = o.calculatedValueLabel, this._stopWhenBalanceIsLower.name = "stopWhenBalanceIsLower", this._stopWhenBalanceIsHigherButtons = [];
						const r = u.SlotKeypad.apiPlugIn.translations.translate("Stop when the balance is higher than"),
							l = this.createStopWhenBalance(r, "StopWhenBalanceIsHigher", ["150%", "200%", "500%"], [1.5, 2, 5], this._stopWhenBalanceIsHigherButtons);
						return this._stopWhenBalanceIsHigher = l.container, this._calculatedMaxBalance = l.calculatedValueLabel, this._stopWhenBalanceIsHigher.name = "stopWhenBalanceIsHigher", t.addChild(this._stopWhenExceedWin, this._stopWhenBalanceIsLower, this._stopWhenBalanceIsHigher), n.GuiLayout.align([this._stopWhenExceedWin, this._stopWhenBalanceIsLower, this._stopWhenBalanceIsHigher], 20, n.Align.LEFT, n.Direction.VERTICAL), t
					}
					onResizeContent(t) {
						if (super.onResizeContent(t), this._stopWhenBalanceIsLower.width + this._stopWhenBalanceIsHigher.width + 20 + 2 * l.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT < t.width) {
							n.GuiLayout.align([this._stopWhenExceedWin, this._stopWhenBalanceIsLower], 20, n.Align.LEFT, n.Direction.VERTICAL);
							const t = this._stopWhenBalanceIsLower.y + 20;
							n.GuiLayout.align([this._stopWhenBalanceIsLower, this._stopWhenBalanceIsHigher], 40, n.Align.TOP, n.Direction.HORIZONTAL), n.GuiLayout.offset([this._stopWhenBalanceIsLower, this._stopWhenBalanceIsHigher], 0, t), n.GuiLayout.offset([this._stopWhenExceedWin, this._stopWhenBalanceIsLower, this._stopWhenBalanceIsHigher], l.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT, 20)
						} else n.GuiLayout.align([this._stopWhenExceedWin, this._stopWhenBalanceIsLower, this._stopWhenBalanceIsHigher], 20, n.Align.LEFT, n.Direction.VERTICAL), n.GuiLayout.offset([this._stopWhenExceedWin, this._stopWhenBalanceIsLower, this._stopWhenBalanceIsHigher], l.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT, 20)
					}
					createLossLimitMustBeSet(t) {
						const e = new PIXI.Container;
						let i = c.GuiDefaults.DEFAULT_LABEL_STYLE.clone();
						i.fontSize = 16;
						const s = new o.Label(t, i);
						return e.addChild(s), n.GuiLayout.align([s], 10, 0, n.Direction.VERTICAL), e
					}
					createStopWhenExceedWin(t) {
						const e = this._parentView.api.options.hideCurrency ? "" : this._parentView.api.currency.getSymbol(),
							i = new PIXI.Container,
							s = new o.Label(t),
							a = new PIXI.Container,
							l = new r.TextInput("maxSingleWin", ((t, e) => this._parentView.onInteraction(t, e)), 330, c.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE);
						l.setDomParent(u.SlotKeypad.apiPlugIn.getGameElement());
						const h = new o.Label(e, c.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE);
						return n.GuiLayout.align([l, h], 10, .5), a.addChild(l, h), this._stopWhenExceedInput = l, i.addChild(s, a), n.GuiLayout.align([s, a], 10, 0, n.Direction.VERTICAL), i
					}
					createStopWhenBalance(t, e, i, s, r, d = a.SlotKeypadViewSettings.NORMAL_COLOR, p = !1) {
						const _ = new PIXI.Container;
						let m = c.GuiDefaults.DEFAULT_LABEL_STYLE.clone();
						m.fill = h.GuiUtils.getColorFromARGB(d);
						const g = new o.Label(t, m),
							f = this.createButtons(l.KeypadDefault.DEFAULT_SMALL_BUTTON_SIZE, e, i, s, r);
						m = c.GuiDefaults.DEFAULT_LABEL_STYLE.clone(), m.fill = h.GuiUtils.getColorFromARGB(a.SlotKeypadViewSettings.AUTOPLAY_COLOR);
						const S = new o.Label("-1 CUR", m);
						if (u.SlotKeypad.apiPlugIn.gameClientConfiguration.autoPlaySettings.autoplayRequiresStopLossLimit && p) {
							const t = u.SlotKeypad.apiPlugIn.translations.translate("Loss limit needs to be set to activate autoplay.");
							this._lossLimitMustBeSet = this.createLossLimitMustBeSet(t), this._lossLimitMustBeSet.name = "lossLimitMustBeSet"
						}
						return n.GuiLayout.align(f.children, 15), n.GuiLayout.align(u.SlotKeypad.apiPlugIn.gameClientConfiguration.autoPlaySettings.autoplayRequiresStopLossLimit && p ? [g, f, S, this._lossLimitMustBeSet] : [g, f, S], 10, n.Align.LEFT, n.Direction.VERTICAL), _.addChild(g), _.addChild(f), u.SlotKeypad.apiPlugIn.gameClientConfiguration.autoPlaySettings.autoplayRequiresStopLossLimit && p && (_.addChild(this._lossLimitMustBeSet), n.GuiLayout.modifyMargin(this._lossLimitMustBeSet, -15, n.Direction.VERTICAL, f), this._addLimitMustBeSet = p, this._buttons = f), _.addChild(S), {
							container: _,
							calculatedValueLabel: S
						}
					}
					createButtons(t, e, i, n, s) {
						const o = new PIXI.Container;
						let r = a.SlotKeypadViewSettings.instance.normalNonEmphasisPointerStateColors.clone(),
							l = a.SlotKeypadViewSettings.instance.activePointerStateColors.clone(),
							h = c.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE.clone();
						for (let a = 0; a < n.length; a++) {
							const u = n[a],
								c = i[a],
								p = new d.LabelButton(e + "_" + c, c, h, l, r);
							p.value = u, p.addClickCallback((() => this._parentView.onInteraction(p.name, p.value))), p.setSize(t.width, t.height), p.enable(!0), p.toggled = !1, s.push(p), o.addChild(p)
						}
						return o
					}
					updateValues(t) {
						t.maxSingleWin ? this._stopWhenExceedInput.setElementValue(t.maxSingleWin) : this._stopWhenExceedInput.setElementValue(-1);
						for (let e of this._stopWhenBalanceIsLowerButtons) e.toggled = e.value == t.minBalancePercent, t.minBalancePercentText ? (this._calculatedMinBalance.text = t.minBalancePercentText, this._calculatedMinBalance.alpha = 1, u.SlotKeypad.apiPlugIn.gameClientConfiguration.autoPlaySettings.autoplayRequiresStopLossLimit && (this._lossLimitMustBeSet.alpha = 0)) : (this._calculatedMinBalance.text = "-1 CUR", u.SlotKeypad.apiPlugIn.gameClientConfiguration.autoPlaySettings.autoplayRequiresStopLossLimit && (this._lossLimitMustBeSet.alpha = 1), this._calculatedMinBalance.alpha = 0);
						for (let e of this._stopWhenBalanceIsHigherButtons) e.toggled = e.value == t.maxBalancePercent, t.maxBalancePercentText ? (this._calculatedMaxBalance.text = t.maxBalancePercentText, this._calculatedMaxBalance.alpha = 1) : (this._calculatedMaxBalance.text = "-1 CUR", this._calculatedMaxBalance.alpha = 0)
					}
				}
				e.AutoPlaySettingsPage = p
			},
			39767: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BasePage = void 0;
				const n = i(24186),
					s = i(72468),
					o = i(80370),
					r = i(39267);
				class a extends PIXI.Container {
					constructor(t, e, i = "", n = "", s = 600) {
						super(), this.name = t, this._parentView = e, this.header = new o.PageHeader(i, n), this.content = this.createContent(), this.content.name = "content", this.addChild(this.header), this.addChild(this.content)
					}
					removeHeader() {
						r.SlotKeypadUtils.disableElement(this.header)
					}
					onResize(t) {
						const e = s.NolimitApplication.isLandscape ? n.KeypadDefault.SCREEN_EDGE_MARGIN_TOP_LANDSCAPE : n.KeypadDefault.SCREEN_EDGE_MARGIN_TOP;
						this.header.position.set(n.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT, e), this.header.resize(t.width - 2 * n.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT), this.onResizeContent(t)
					}
					getHeaderBottom() {
						return this.header.parent != this ? 0 : this.header.y + this.header.height
					}
					activate() {}
					deactivate() {}
					onResizeContent(t) {
						const e = this.getHeaderBottom();
						this.content.position.set(0, e + 0)
					}
					createContent() {
						return new PIXI.Container
					}
				}
				e.BasePage = a
			},
			18386: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BetLevelsPage = void 0;
				const n = i(39767),
					s = i(38801),
					o = i(17106),
					r = i(24186),
					a = i(22088),
					l = i(67566),
					h = i(78229);
				class u extends n.BasePage {
					constructor(t, e, i) {
						super("Betlevels", t, e, i)
					}
					createContent() {
						const t = super.createContent();
						return this._buttonContainer = new PIXI.Container, this._buttonContainer.name = "buttons", this._buttons = this.createButtons(this._buttonContainer), t.addChild(this._buttonContainer), t
					}
					createButtons(t) {
						const e = this._parentView.api.betLevel.getAvailableLevels(),
							i = this._parentView.api.betLevel.getUnavailableLevels(),
							n = e.concat(i),
							r = [];
						let u = o.SlotKeypadViewSettings.instance.normalNonEmphasisPointerStateColors.clone(),
							c = o.SlotKeypadViewSettings.instance.activePointerStateColors.clone(),
							d = h.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE.clone();
						for (let e of n) {
							const i = a.SlotKeypad.formatCurrencyValueWithDecimalCutoff(e);
							d.fontSize = 40;
							const n = new l.LabelButton(e, i, d, c, u);
							n.addClickCallback((() => this._parentView.onInteraction(n.name, n.value))), n.enable(!0), n.resizeButtonToLabelWithMargin(10, 15, 10, 15), r.push(n), t.addChild(n)
						}
						this._largestButtonSize = s.GuiLayout.getLargestSize(r);
						for (let t of r) t.setSize(this._largestButtonSize.x, this._largestButtonSize.y);
						return r
					}
					onResize(t) {
						super.onResize(t);
						const e = 15;
						let i = Math.floor(t.width / (this._largestButtonSize.x + e));
						const n = Math.min(i, r.KeypadDefault.DEFAULT_BET_LEVELS_ROW_MAX),
							o = Math.ceil(this._buttons.length / n),
							a = this._buttons.concat();
						for (let t = 0; t < o; t++) {
							const i = a.length < n,
								o = i ? a : a.splice(0, n);
							if (s.GuiLayout.align(o, e, s.Align.TOP, s.Direction.HORIZONTAL), i) {
								const i = this._largestButtonSize.x * o.length + e * (o.length - 1),
									r = .5 * (this._largestButtonSize.x * n + e * (n - 1) - i);
								s.GuiLayout.offset(o, r, (this._largestButtonSize.y + e) * t)
							} else s.GuiLayout.offset(o, 0, (this._largestButtonSize.y + e) * t)
						}
						this.content.position.x = .5 * (t.width - this.content.width), this.content.position.y += 20
					}
					updateButtons() {
						const t = this._parentView.api.betLevel.getUnavailableLevels(),
							e = this._parentView.api.betLevel.getLevel();
						for (let i of this._buttons) i.toggled = i.name == e, t.indexOf(i.name) >= 0 ? i.enable(!1) : i.enable(!0)
					}
				}
				e.BetLevelsPage = u
			},
			30093: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.DemoPage = void 0;
				const n = i(39767),
					s = i(17106),
					o = i(38801),
					r = i(70742),
					a = i(68714),
					l = i(67566),
					h = i(78229);
				class u extends n.BasePage {
					constructor(t, e, i) {
						super("Demo", t, e, i)
					}
					createContent() {
						const t = super.createContent();
						this._buttonContainer = new PIXI.Container, this._buttonContainer.name = "buttons", this._buttons = this.createButtons(this._buttonContainer), this._outcomeQueueContainer = new PIXI.Container;
						let e = s.SlotKeypadViewSettings.instance.normalNonEmphasisPointerStateColors.clone(),
							i = s.SlotKeypadViewSettings.instance.activePointerStateColors.clone(),
							n = h.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE.clone();
						return this._goButton = new l.LabelButton(r.DemoView.GO_BUTTON, "ADD TO OS", n, i, e), this._goButton.addClickCallback((() => this._parentView.onInteraction(this._goButton.name, void 0))), this._goButton.resizeButtonToLabelWithMargin(20, 30, 20, 30), this._goButton.enable(!1), this._clearOutcomeSetterButton = new l.LabelButton(r.DemoView.CLEAR_OUTCOME_SETTER_BUTTON, "CLEAR OS", n, i, e), this._clearOutcomeSetterButton.addClickCallback((() => this._parentView.onInteraction(this._clearOutcomeSetterButton.name, void 0))), this._clearOutcomeSetterButton.resizeButtonToLabelWithMargin(20, 30, 20, 30), this._clearOutcomeSetterButton.enable(!0), this._mainButtonContainer = new PIXI.Container, this._mainButtonContainer.addChild(this._goButton, this._clearOutcomeSetterButton), o.GuiLayout.align([this._goButton, this._clearOutcomeSetterButton], 10), this._mainButtonContainer.pivot.set(.5 * this._mainButtonContainer.width, 0), n = h.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE.clone(), n.fontSize = 14, this._clearButton = new l.LabelButton(r.DemoView.CLEAR_BUTTON, "CLEAR", n, i, e), this._clearButton.addClickCallback((() => this._parentView.onInteraction(this._clearButton.name, void 0))), this._clearButton.resizeButtonToLabelWithMargin(10, 15, 10, 15), this._clearButton.enable(!0), n = h.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE.clone(), n.fontSize = 12, this._queueLabel = new a.Label("Queue:"), this._queue = new a.Label("..."), this._queueLabel.position.set(0, 0), this._clearButton.position.set(this._queueLabel.width + 10, .5 * -Math.abs(this._queueLabel.height - this._clearButton.height)), this._queue.position.set(10, this._queueLabel.y + this._queueLabel.height + 10), this._outcomeQueueContainer.addChild(this._queueLabel), this._outcomeQueueContainer.addChild(this._clearButton), this._outcomeQueueContainer.addChild(this._queue), t.addChild(this._buttonContainer), this.addChild(this._outcomeQueueContainer), this.addChild(this._mainButtonContainer), t
					}
					createButtons(t) {
						const e = [];
						let i = s.SlotKeypadViewSettings.instance.normalNonEmphasisPointerStateColors.clone(),
							n = s.SlotKeypadViewSettings.instance.activePointerStateColors.clone(),
							r = h.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE.clone();
						r.fontSize = 20;
						const a = this._parentView.outcomeJson;
						for (let s = 0; s < a.demo.length; s++) {
							let o = a.demo[s];
							const h = new l.LabelButton(o.name, o.name, r, n, i);
							h.value = s, h.addClickCallback((() => this._parentView.onInteraction(h.name, h.value))), h.resizeButtonToLabelWithMargin(10, 15, 10, 15), h.enable(!0), e.push(h), t.addChild(h)
						}
						this._largestButtonSize = o.GuiLayout.getLargestSize(e);
						for (let t of e) t.setSize(this._largestButtonSize.x, this._largestButtonSize.y);
						return e
					}
					onResize(t) {
						super.onResize(t);
						const e = 15,
							i = Math.floor(t.width / (this._largestButtonSize.x + e)),
							n = Math.ceil(this._buttons.length / i),
							s = this._buttons.concat();
						for (let t = 0; t < n; t++) {
							const n = s.length < i,
								r = n ? s : s.splice(0, i);
							if (o.GuiLayout.align(r, e, o.Align.TOP, o.Direction.HORIZONTAL), n) {
								const n = this._largestButtonSize.x * r.length + e * (r.length - 1),
									s = .5 * (this._largestButtonSize.x * i + e * (i - 1) - n);
								o.GuiLayout.offset(r, s, (this._largestButtonSize.y + e) * t + 20)
							} else o.GuiLayout.offset(r, 0, (this._largestButtonSize.y + e) * t + 20)
						}
						this.content.position.x = .5 * (t.width - this.content.width), this._outcomeQueueContainer.position.set(10, this.content.y + this.content.height + 50), this._mainButtonContainer.position.set(.5 * t.width, t.height - 40 - this._mainButtonContainer.height)
					}
					updateButtons() {
						for (let t of this._buttons) t.toggled = !1;
						this._clearOutcomeSetterButton.toggled = !1, this._goButton.toggled = !1, this._clearButton.toggled = !1
					}
					updateQueue() {
						let t = "";
						const e = this._parentView.outcomeQueue;
						for (let i of e) t += i.name + "\n";
						this._queue.text = t, this._goButton.enable(e.length > 0)
					}
				}
				e.DemoPage = u
			},
			40069: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GameSettingsPage = void 0;
				const n = i(39767),
					s = i(38801),
					o = i(22088),
					r = i(24186),
					a = i(30835),
					l = i(11877),
					h = i(83236),
					u = i(70329);
				class c extends n.BasePage {
					constructor(t, e, i) {
						super(t, e, i)
					}
					createContent() {
						const t = new l.GUIScrollContainer(720, 720, !1);
						this._buttons = [], this._soundSettingsContainer = this.createButtonGroup([{
							id: a.APISetting.MUSIC,
							label: "Music"
						}, {
							id: a.APISetting.SFX,
							label: "Sound effects"
						}]), o.SlotKeypad.apiPlugIn.options.device == u.Device.DESKTOP && o.SlotKeypad.apiPlugIn.gameClientConfiguration.spacebarSpinAllowed ? this._generalSettingsContainer = this.createButtonGroup([{
							id: a.APISetting.CLOCK,
							label: "Show clock"
						}, {
							id: a.APISetting.USE_SPACE_TO_SPIN,
							label: "Use spacebar to spin"
						}]) : this._generalSettingsContainer = this.createButtonGroup([{
							id: a.APISetting.CLOCK,
							label: "Show clock"
						}]), this._separator = new PIXI.Graphics;
						const e = new PIXI.Container;
						return e.addChild(this._soundSettingsContainer, this._separator, this._generalSettingsContainer), t.addContent(e), t
					}
					drawSeparator(t, e) {
						this._separator.clear(), this._separator.lineStyle(1, 16777215, .6), e ? (this._separator.moveTo(0, 0), this._separator.lineTo(0, t)) : (this._separator.moveTo(0, 0), this._separator.lineTo(t, 0))
					}
					onResize(t) {
						super.onResize(t), this.drawSeparator(t.width - 2 * r.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT, !1), s.GuiLayout.align([this._soundSettingsContainer, this._separator, this._generalSettingsContainer], 30, s.Align.LEFT, s.Direction.VERTICAL), s.GuiLayout.offset([this._soundSettingsContainer, this._separator, this._generalSettingsContainer], r.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT, 20), this.content.resize(t.width, t.height - this.content.position.y)
					}
					buttonClickCallback(t) {
						const e = !o.SlotKeypad.apiPlugIn.settings.get(t.name, !1);
						o.SlotKeypad.apiPlugIn.settings.set(t.name, e), t.toggled = e
					}
					createButtonGroup(t, e = 0) {
						const i = new PIXI.Container;
						for (let e of t) {
							const t = new h.RadioButton(e.id, o.SlotKeypad.apiPlugIn.translations.translate(e.label));
							t.addClickCallback((() => this.buttonClickCallback(t))), t.enable(!0), t.toggled = o.SlotKeypad.apiPlugIn.settings.get(t.name, !1), i.addChild(t), this._buttons.push(t)
						}
						if (this.layoutButtonGroup(i), e > 0) {
							const t = new PIXI.Graphics;
							t.beginFill(0, 1), t.drawRect(0, 0, e, 2), i.addChild(t)
						}
						return i
					}
					layoutButtonGroup(t) {
						s.GuiLayout.align(t.children, 50, s.Align.LEFT, s.Direction.VERTICAL), s.GuiLayout.offset(t.children, 10, 0)
					}
					activate() {
						for (let t of this._buttons) t.toggled = o.SlotKeypad.apiPlugIn.settings.get(t.name, !1), t.name == a.APISetting.CLOCK && (t.enable(o.SlotKeypad.apiPlugIn.gameClientConfiguration.clockSettings.allowSetting), o.SlotKeypad.apiPlugIn.gameClientConfiguration.clockSettings.allowSetting || (this._generalSettingsContainer.removeChild(t), this.layoutButtonGroup(this._generalSettingsContainer)))
					}
				}
				e.GameSettingsPage = c
			},
			23246: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.HistoryPage = void 0;
				const n = i(22088),
					s = i(41169),
					o = i(63886),
					r = i(64232),
					a = i(12355),
					l = i(85418);
				class h extends o.HtmlBasePage {
					constructor(t, e, i, n, s) {
						super(t, e, i, n, s)
					}
					load() {
						const t = new a.TemplateLoader(n.SlotKeypad.apiPlugIn.resources.getStaticRoot());
						return t.add({
							name: r.MenuButtonIDs.HISTORY,
							url: "node_modules/@nolimitcity/slot-keypad/resources/default/templates/history.mustache"
						}), t.load().then((t => this.addLoadedScreenTemplates(t))).then((() => this.init()))
					}
					activate() {
						super.activate(), this.update(), this.screen.show()
					}
					deactivate() {
						this.screen.hide(), this.calendarController.resetView(), super.deactivate()
					}
					init() {
						super.init(), s.Settings.defaultLocale = n.SlotKeypad.apiPlugIn.options.language, this.calendarController = new l.CalendarController(this.screen)
					}
					static makeElement(t, e) {
						const i = document.createElement(t);
						return e && (i.innerHTML = e), i
					}
					static scrollTo(t, e, i) {
						if (i <= 0) return;
						const n = (e - t.scrollTop) / i * 10;
						setTimeout((function() {
							t.scrollTop = t.scrollTop + n, t.scrollTop !== e && h.scrollTo(t, e, i - 10)
						}), 10)
					}
					onResize(t) {
						this.calendarController.resize(t), super.onResize(t)
					}
					update() {
						this.calendarController.update()
					}
				}
				e.HistoryPage = h
			},
			63886: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.HtmlBasePage = void 0;
				const n = i(37950),
					s = i(39767),
					o = i(72468),
					r = i(22088);
				class a extends s.BasePage {
					get screen() {
						if (null != this._screen) return this._screen;
						const t = this._screenSystem.get(this.name);
						if (null == t) throw new Error(`Missing screen: ${this.name}`);
						return this._screen = t, this._screen
					}
					constructor(t, e, i, n, s) {
						super(i, n, s), this._active = !1, this._parentDiv = t, this._screenSystem = e
					}
					activate() {
						this._active = !0, this._parentDiv.style.display = "block", this.resizeHtml(this._htmlBounds)
					}
					deactivate() {
						this._active = !1, this._parentDiv.style.display = "none"
					}
					onResize(t) {
						super.onResize(t), this._htmlBounds = (0, n.cloneScreenBounds)(t), this._htmlBounds.height -= this.content.y, this._htmlBounds.top = this.content.y, this.resizeHtml(this._htmlBounds)
					}
					resizeHtml(t) {
						this._active && (this._screen && (this.screen.element.style.fontSize = 20 * o.NolimitApplication.globalScale + "px"), this._parentDiv.style.width = t.width * o.NolimitApplication.globalScale + "px", this._parentDiv.style.height = t.height * o.NolimitApplication.globalScale + "px", this._parentDiv.style.top = t.top * o.NolimitApplication.globalScale + "px")
					}
					init() {}
					load() {
						return Promise.resolve()
					}
					addLoadedScreenTemplates(t) {
						const e = [];
						for (let i of t)
							if (i.loadedData) {
								let t = r.SlotKeypad.apiPlugIn.translations.render(i.loadedData);
								t = t.replace(/<html /i, `<html data-device="${r.SlotKeypad.apiPlugIn.options.device}" data-agent="${navigator.userAgent}" `), e.push(this._screenSystem.add(i.name, t).then((t => t.classList.add("screen"))))
							} return Promise.all(e)
					}
				}
				e.HtmlBasePage = a
			},
			20486: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.InfoPage = e.SettingSectionIDs = void 0;
				const n = i(63886),
					s = i(22088),
					o = i(58676),
					r = i(34018),
					a = i(91980),
					l = i(12355),
					h = i(64232),
					u = i(97182),
					c = i(64118);
				var d;
				! function(t) {
					t.GUIDE = "guide", t.RULES = "rules", t.PAYTABLE = "paytable"
				}(d = e.SettingSectionIDs || (e.SettingSectionIDs = {}));
				class p extends n.HtmlBasePage {
					constructor(t, e, i, n, s) {
						super(t, e, i, n, s), this.removeHeader()
					}
					goToSection(t) {
						let e;
						switch (t) {
							case d.GUIDE:
								e = this.screen.find(".gui-guide")[0];
								break;
							case d.RULES:
								e = this.screen.find(".rules")[0];
								break;
							case d.PAYTABLE:
								e = this.screen.find(".paytable")[0]
						}
						e.scrollIntoView()
					}
					activate() {
						super.activate(), s.SlotKeypad.apiPlugIn.payoutMultiplier.updateScreen(this.screen), s.SlotKeypad.apiPlugIn.gameClientConfiguration.updateScreen(this.screen), s.SlotKeypad.apiPlugIn.maximumWinCap.updateScreen(this.screen), s.SlotKeypad.apiPlugIn.rtp.updateScreen(this.screen), s.SlotKeypad.apiPlugIn.gameInfo.updateScreen(this.screen), this.updateGamble(), this.updateBoost(), this.updateBetFeatures(), this.updateBetRules(), this.screen.show()
					}
					deactivate() {
						super.deactivate(), this.screen.hide()
					}
					load() {
						const t = new l.TemplateLoader(s.SlotKeypad.apiPlugIn.resources.getStaticRoot());
						return t.add({
							name: h.MenuButtonIDs.INFO,
							url: "node_modules/@nolimitcity/slot-keypad/resources/default/templates/game-info.mustache"
						}), t.load().then((t => this.addLoadedScreenTemplates(t))).then((() => this.assembleInfoPage()))
					}
					assembleInfoPage() {
						const t = [];
						let e = this.prepareDataForHTMLInfo();
						for (let i of a.NolimitLauncher.plugins) null != i.getGameRules && ((0, o.isGamePlugin)(i) ? t.push(i.getGameRules().then((t => this.addHtmlToInfoSection(t, "rules", e, "game")))) : (0, r.isGamblePlugin)(i) ? t.push(i.getGameRules().then((t => this.addHtmlToInfoSection(t, "rules", e, "gamble")))) : (0, c.isApiPlugin)(i) ? t.push(i.getGameRules().then((t => this.addHtmlToInfoSection(t, "rules", e, "common")))) : t.push(i.getGameRules().then((t => this.addHtmlToInfoSection(t, "rules", e))))), i.getKeypadGuide && ((0, u.isKeypadPlugin)(i) && (e = s.SlotKeypad.getGuiGuideData(e)), t.push(i.getKeypadGuide().then((t => this.addHtmlToInfoSection(t, "gui-guide", e))))), (0, o.isGamePlugin)(i) && t.push(i.getPaytable().then((t => this.addHtmlToInfoSection(t, "paytable", e))));
						return Promise.all(t)
					}
					updateBoost() {
						const t = s.SlotKeypad.apiPlugIn.betFeatureController.getAllowedFeatures();
						let e = !1;
						for (let i of t)
							if ("BOOSTED_BET" == i.type) {
								e = !0;
								break
							} e || this.screen.find(".boostedBet").forEach((t => t.style.display = "none"))
					}
					updateGamble() {
						for (let t of a.NolimitLauncher.plugins)
							if ((0, r.isGamblePlugin)(t)) return;
						this.screen.find(".gamble").forEach((t => t.style.display = "none"))
					}
					updateBetFeatures() {
						const t = s.SlotKeypad.apiPlugIn.betFeatureController.getAllowedFeatures(),
							e = [],
							i = [];
						for (let n of t) "FREESPIN" == n.type ? e.push(n) : i.push(n);
						const n = this.screen.find("tr.noLimitBonus")[0];
						if (null != n)
							for (let t of e) {
								const e = n.querySelector("th #" + t.name);
								null != e && (e.innerHTML = s.SlotKeypad.apiPlugIn.translations.render('<p id="{{name}}">{{#tr}}Bonus can be activated for {{price}} times the base bet, maximum possible base bet is {{maxBet}}.{{/tr}}</p>', {
									name: t.name,
									maxBet: s.SlotKeypad.apiPlugIn.currency.format(t.getMaxBet()),
									price: t.price
								}))
							}
						const o = this.screen.find("tr.noLimitBooster")[0];
						if (null != o)
							for (let t of i) {
								const e = o.querySelector("th #" + t.name);
								null != e && (e.innerHTML = s.SlotKeypad.apiPlugIn.translations.render('<p id="{{name}}">{{#tr}}Booster can be activated for {{price}} times the base bet, maximum possible base bet is {{maxBet}}.{{/tr}}</p>', {
									name: t.name,
									maxBet: s.SlotKeypad.apiPlugIn.currency.format(t.getMaxBet()),
									price: t.price
								}))
							}
					}
					updateBetRules() {
						if (s.SlotKeypad.apiPlugIn.gameClientConfiguration.showMinBet) {
							const t = s.SlotKeypad.apiPlugIn.betLevel.getBetLevels()[0],
								e = s.SlotKeypad.apiPlugIn.currency.format(t);
							this.screen.find(".rules #common .minBet .value").forEach((t => t.innerText = e))
						} else this.screen.find(".rules #common .minBet").forEach((t => t.style.display = "none"));
						if (s.SlotKeypad.apiPlugIn.gameClientConfiguration.showMaxBet) {
							let t = +s.SlotKeypad.apiPlugIn.betLevel.getBetLevels()[s.SlotKeypad.apiPlugIn.betLevel.getBetLevels().length - 1];
							for (let e of s.SlotKeypad.apiPlugIn.betFeatureController.getAllowedFeatures()) t = Math.max(t, e.getMaxCost());
							const e = s.SlotKeypad.apiPlugIn.currency.format(t);
							this.screen.find(".rules #common .maxBet .value").forEach((t => t.innerText = e))
						} else this.screen.find(".rules #common .maxBet").forEach((t => t.style.display = "none"));
						if (s.SlotKeypad.apiPlugIn.gameClientConfiguration.showMaxBetLevelInGameRules) {
							const t = s.SlotKeypad.apiPlugIn.betLevel.getBetLevels()[s.SlotKeypad.apiPlugIn.betLevel.getBetLevels().length - 1],
								e = s.SlotKeypad.apiPlugIn.currency.format(t);
							this.screen.find(".rules #common .maxBetLevel .value").forEach((t => t.innerText = e))
						} else this.screen.find(".rules #common .maxBetLevel").forEach((t => t.style.display = "none"))
					}
					addHtmlToInfoSection(t, e, i, n = void 0) {
						return new Promise(((o, r) => {
							const a = this.screen.find("#" + e)[0];
							if (a)
								if (null != n) {
									const e = this.screen.find("#" + n)[0];
									e && (e.innerHTML = s.SlotKeypad.apiPlugIn.translations.render(t, i))
								} else {
									let e = document.createElement("div");
									a.append(e), e.innerHTML = s.SlotKeypad.apiPlugIn.translations.render(t, i)
								} o()
						}))
					}
					prepareDataForHTMLInfo() {
						const t = s.SlotKeypad.apiPlugIn.gameClientConfiguration;
						return {
							dx1: !!(s.SlotKeypad.apiPlugIn.options && s.SlotKeypad.apiPlugIn.options.game && s.SlotKeypad.apiPlugIn.options.game.indexOf("DX1") > -1),
							fastSpinEnabled: t.fastSpinEnabled,
							replaceSlotsInGameRules: t.replaceSlotsInGameRules,
							showGameVersionInGuiGuide: t.showGameVersionInGuiGuide,
							gameVersion: t.gameVersion,
							showGameClientBuiltDate: t.showGameClientBuiltDate,
							gameVersionDate: t.gameVersionDate,
							showServerVersion: t.showServerVersion,
							serverVersion: t.serverVersion,
							showNearMissGfx: t.showNearMissGfx,
							showBaseGameHighestWinInRules: t.showBaseGameHighestWinInRules,
							replaceWincapInfo: t.replaceWincapInfo,
							showOnlyMaxRTPForRange: t.showOnlyMaxRTPForRange,
							showLowProbabilityGfx: t.showLowProbabilityGfx,
							gambleFiftyFiftyAllowed: t.gambleFiftyFiftyAllowed,
							canShowVolatilityInCommonRules: t.showVolatilityInGameRules
						}
					}
				}
				e.InfoPage = p
			},
			85418: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.CalendarController = e.GameHistorySortType = e.GameHistorySortHeader = void 0;
				const n = i(41169),
					s = i(22088),
					o = i(23246),
					r = i(72468);
				var a, l;
				! function(t) {
					t.TIME = "TIME", t.BET = "BET", t.WIN = "WIN"
				}(a = e.GameHistorySortHeader || (e.GameHistorySortHeader = {})),
				function(t) {
					t.ASC = "ASC", t.DESC = "DESC"
				}(l = e.GameHistorySortType || (e.GameHistorySortType = {})), e.CalendarController = class {
					constructor(t) {
						this.onDaySelectNew = t => {
							const e = t.target,
								i = this.menuDiv.querySelector(".history");
							o.HistoryPage.scrollTo(i, 0, 50), setTimeout((() => {
								this.backToSearchBtn.classList.add("animate"), this.calendarContainer.classList.add("animate"), this.resultContainer.classList.add("animate")
							}), 100);
							const n = e.dataset.date;
							this.clearResult(), this.currentSort = {
								date: n,
								head: a.TIME,
								type: l.DESC,
								page: 1
							}, this.loadPage(this.currentSort)
						}, this.screen = t, this.selectedMonth = n.DateTime.local(), this.menuDiv = this.screen.find("#gameHistoryContainer")[0], this.calendarContainer = this.menuDiv.querySelector(".calendar-container"), this.calendarTimeContainer = this.menuDiv.querySelector(".calendar-time-container"), this.calendarTimeContainer.style.display = "none", this.calendarTime = this.calendarTimeContainer.querySelector(".calendar-time"), this.monthHeader = this.calendarContainer.querySelector(".month .header"), this.calendarDays = this.calendarContainer.querySelector(".days"), this.prevMonthBtn = this.calendarContainer.querySelector(".month .prev"), this.nextMonthBtn = this.calendarContainer.querySelector(".month .next"), this.prevMonthBtn.addEventListener("click", (t => this.changeMonth(t))), this.nextMonthBtn.addEventListener("click", (t => this.changeMonth(t))), this.loadingCalendarIcon = this.calendarContainer.querySelector(".loading"), this.backToSearchBtn = this.menuDiv.querySelector(".back-to-search-btn"), this.resultContainer = this.menuDiv.querySelector(".result-container"), this.resultInfo = this.resultContainer.querySelector(".result-info"), this.resultInfoDate = this.resultInfo.querySelector(".date"), this.resultDiv = this.resultContainer.querySelector(".result"), this.resultHead = this.resultContainer.querySelector(".result table thead"), this.resultBody = this.resultContainer.querySelector(".result table tbody"), this.sortTimeBtn = this.resultContainer.querySelector(".result table thead .sort .sortTime"), this.sortTimeBtn.addEventListener("click", (() => {
							this.onSort(a.TIME)
						})), this.sortWinBtn = this.resultContainer.querySelector(".result table thead .sort .sortWin"), this.sortWinBtn.addEventListener("click", (() => {
							this.onSort(a.WIN)
						})), this.amounts = this.resultInfo.querySelectorAll("tr.amount th"), this.loadMoreBtn = this.resultContainer.querySelector(".result .loadMore"), this.loadMoreBtn.addEventListener("click", (() => {
							this.currentSort.page += 1, this.loadPage(this.currentSort)
						})), this.loadingIcon = this.resultContainer.querySelector(".result .loading"), this.backToSearchBtn = this.screen.find(".back-to-search-btn")[0], this.backToSearchBtn.addEventListener("click", (() => {
							this.resetView()
						}))
					}
					goBackToCalendarView() {
						this.backToSearchBtn.classList.remove("animate"), this.calendarContainer.classList.remove("animate"), this.resultContainer.classList.remove("animate"), this.clearResult()
					}
					resetView() {
						const t = this.screen.find(".history")[0];
						o.HistoryPage.scrollTo(t, 0, 50), setTimeout((() => {
							this.goBackToCalendarView()
						}), 100)
					}
					onSort(t) {
						t != this.currentSort.head && (this.clearResult(), this.currentSort.head = t, this.currentSort.page = 1, this.loadPage(this.currentSort))
					}
					changeMonth(t) {
						const e = t.target;
						e.classList.contains("disabled") || (e.classList.contains("prev") ? this.selectedMonth = this.selectedMonth.minus({
							month: 1
						}) : e.classList.contains("next") && (this.selectedMonth = this.selectedMonth.plus({
							month: 1
						})), this.update())
					}
					update(t = this.selectedMonth) {
						try {
							this.monthHeader.textContent = t.toLocaleString({
								month: "long",
								year: "numeric"
							}).toUpperCase()
						} catch (e) {
							this.monthHeader.textContent = t.toLocaleString({
								month: "long",
								year: "numeric"
							}, {
								locale: "en"
							}).toUpperCase()
						}
						this.prevMonthBtn.classList.add("disabled"), this.nextMonthBtn.classList.add("disabled");
						const e = n.DateTime.local(),
							i = e.minus({
								year: 1
							});
						this.calendarDays.innerHTML = "", this.loadingCalendarIcon.style.display = "inline-block", s.SlotKeypad.apiPlugIn.communication.history.daysNoHour(t.year, t.month).then((n => {
							this.generateCalendarDays(t, n), this.loadingCalendarIcon.style.display = "none", i.hasSame(t, "year") && i.hasSame(t, "month") ? this.prevMonthBtn.classList.add("disabled") : this.prevMonthBtn.classList.remove("disabled"), e.hasSame(t, "year") && e.hasSame(t, "month") ? this.nextMonthBtn.classList.add("disabled") : this.nextMonthBtn.classList.remove("disabled")
						})).catch(console.error)
					}
					generateCalendarDays(t, e) {
						const i = n.DateTime.local(),
							s = t.startOf("month");
						for (let t = 2 - s.weekday; t <= s.daysInMonth; t++) {
							const n = document.createElement("li");
							if (t > 0) {
								n.textContent = t.toString();
								const o = s.plus({
										days: t - 1
									}),
									r = o.toISODate();
								e[r] && (n.classList.add("played"), n.addEventListener("click", this.onDaySelectNew), n.dataset.date = r, n.dataset.hours = e[r].join(",")), i.hasSame(o, "day") && n.classList.add("today")
							}
							this.calendarDays.appendChild(n)
						}
					}
					clearResult() {
						this.totalBet = 0, this.totalWin = 0, this.resultBody.innerHTML = ""
					}
					loadPage(t) {
						this.loadingIcon.style.display = "inline-block", this.loadMoreBtn.style.display = "none", t.head == a.TIME ? (this.sortTimeBtn.querySelector(".down").style.display = "inline", this.sortTimeBtn.querySelector(".right").style.display = "none", this.sortWinBtn.querySelector(".down").style.display = "none", this.sortWinBtn.querySelector(".right").style.display = "inline") : (this.sortTimeBtn.querySelector(".down").style.display = "none", this.sortTimeBtn.querySelector(".right").style.display = "inline", this.sortWinBtn.querySelector(".down").style.display = "inline", this.sortWinBtn.querySelector(".right").style.display = "none"), s.SlotKeypad.apiPlugIn.communication.history.roundsPaginated(t.date, t.head, t.type, t.page).then((e => {
							this.addRoundsToResult(t, e), e.length < 100 ? this.loadMoreBtn.style.display = "none" : this.loadMoreBtn.style.display = "inline-block", this.loadingIcon.style.display = "none"
						})).catch(console.error)
					}
					addRoundsToResult(t, e) {
						for (let t of e) this.resultBody.appendChild(this.generateRoundTableRow(t));
						const i = 100 * t.page - 100 + e.length;
						this.resultInfoDate.textContent = `${t.date} (${s.SlotKeypad.apiPlugIn.translations.translate("Round")} 1-${i})`;
						const n = this.totalWin - this.totalBet;
						this.amounts[0].textContent = r.NolimitApplication.apiPlugin.currency.formatValue(this.totalBet), this.amounts[1].textContent = r.NolimitApplication.apiPlugin.currency.formatValue(this.totalWin), this.amounts[2].textContent = r.NolimitApplication.apiPlugin.currency.formatValue(n)
					}
					generateRoundTableRow(t) {
						this.totalBet += t.totalBet, this.totalWin += t.totalWin;
						const e = o.HistoryPage.makeElement("tr");
						let i = r.NolimitApplication.apiPlugin.currency.formatValue(t.totalBet);
						t.promoName && (e.classList.add("freebets"), i = `0.00 (${r.NolimitApplication.apiPlugin.currency.formatValue(t.totalFreeBet||0)})`);
						const n = t.startTime.split(" ")[1],
							a = o.HistoryPage.makeElement("td", n);
						if (t.actionSpin) {
							const t = s.SlotKeypad.apiPlugIn.resources.getStaticRoot() + "/node_modules/@nolimitcity/slot-keypad/resources/default/templates/actionSpinsIcon.svg",
								e = document.createElement("img");
							e.src = t, e.style.marginLeft = "0.5em", e.style.height = "1em", a.append(e)
						}
						if ("FEATURE_BET" == t.requestType && null != t.requestInformation && -1 === t.requestInformation.indexOf("BOOSTED_BET")) {
							const t = s.SlotKeypad.apiPlugIn.resources.getStaticRoot() + "/node_modules/@nolimitcity/slot-keypad/resources/default/templates/nolimitBonusIcon.svg",
								e = document.createElement("img");
							e.src = t, e.style.marginLeft = "0.5em", e.style.height = "1em", a.append(e)
						}
						e.appendChild(a), e.appendChild(o.HistoryPage.makeElement("td", i)), e.appendChild(o.HistoryPage.makeElement("td", r.NolimitApplication.apiPlugin.currency.formatValue(t.totalWin)));
						const l = 0 == t.balanceAfter ? "-" : r.NolimitApplication.apiPlugin.currency.formatValue(t.balanceAfter);
						if (e.appendChild(o.HistoryPage.makeElement("td", l)), 1 != t.evicted) {
							const i = document.createElement("td");
							i.classList.add("right"), i.classList.add("replay"), i.innerHTML = '<a target="_blank"></a>', i.querySelector("a").addEventListener("click", (e => {
								s.SlotKeypad.apiPlugIn.openReplay(t.gameRoundId), e.preventDefault()
							})), e.appendChild(i)
						}
						return e
					}
					resize(t) {}
				}
			},
			11479: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.HtmlTopLabel = void 0, e.HtmlTopLabel = class {
					get element() {
						return this._element
					}
					constructor(t, e = !1) {
						if (e) this._element = document.createElement("div"), this._element.innerText = "", this._element.id = t;
						else {
							const e = document.querySelector(t);
							this._element = null != e ? e : new HTMLElement
						}
						this._element.classList.add("top-bar-item")
					}
					update(t) {
						this._element.innerText = t
					}
					show() {
						this._element.style.display = "block"
					}
					hide() {
						this._element.style.display = "none"
					}
				}
			},
			72468: function(t, e, i) {
				"use strict";
				var n = this && this.__createBinding || (Object.create ? function(t, e, i, n) {
						void 0 === n && (n = i);
						var s = Object.getOwnPropertyDescriptor(e, i);
						s && !("get" in s ? !e.__esModule : s.writable || s.configurable) || (s = {
							enumerable: !0,
							get: function() {
								return e[i]
							}
						}), Object.defineProperty(t, n, s)
					} : function(t, e, i, n) {
						void 0 === n && (n = i), t[n] = e[i]
					}),
					s = this && this.__setModuleDefault || (Object.create ? function(t, e) {
						Object.defineProperty(t, "default", {
							enumerable: !0,
							value: e
						})
					} : function(t, e) {
						t.default = e
					}),
					o = this && this.__importStar || function(t) {
						if (t && t.__esModule) return t;
						var e = {};
						if (null != t)
							for (var i in t) "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
						return s(e, t), e
					};
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NolimitApplication = void 0;
				const r = i(11546);
				Promise.resolve().then((() => o(i(82859))));
				const a = o(i(82859)),
					l = i(18371),
					h = i(49490),
					u = i(70329),
					c = i(85733),
					d = i(91980),
					p = i(64118),
					_ = i(41122),
					m = i(46334),
					g = i(17024),
					f = i(13006),
					S = i(52780),
					y = i(82935);
				class v {
					static get hasOpenDialog() {
						return v._instance._hasOpenDialog
					}
					static get resourcePath() {
						let t = "";
						const e = document.getElementsByTagName("script");
						for (let i = 0; i < e.length; i++) {
							const n = e[i].src;
							if (/\/game\.js$/.test(n)) {
								t = n.substr(0, n.length - 8);
								break
							}
						}
						return t
					}
					static get pixiLoader() {
						return v._instance._pixiApp.loader
					}
					static get pixiApp() {
						return v._instance._pixiApp
					}
					static get globalScale() {
						return v._instance._globalScale
					}
					get frame() {
						return {
							width: 720,
							height: 720
						}
					}
					get stage() {
						return this._internalStage
					}
					constructor() {
						this.name = "NolimitApplication", this._paused = !1, this._globalScale = 1, this.placement = {
							x: .5,
							y: .5
						}, this._layers = {}, this.onWebGLContextLost = t => {
							m.Logger.logDev(t.type, t), v.apiPlugin.events.trigger("error", {
								code: -1005,
								message: "Graphics init failed"
							})
						}, this.animate = () => {
							this._pixiApp.render()
						}
					}
					fetchPlugins() {
						for (let t of d.NolimitLauncher.plugins)(0, p.isApiPlugin)(t) && (v.apiPlugin = t);
						return null == v.apiPlugin ? Promise.reject(new Error("NolimitApplication is missing  ApiPlugin")) : Promise.resolve()
					}
					init() {
						return new Promise(((t, e) => {
							this.fetchPlugins().catch((t => Promise.reject(t))), this.addEventListeners(), v.events = y.create(), this._gameElement = v.apiPlugin.getGameElement(), this.nolimitContainer = document.querySelector(".nolimit.container");
							let i = v.apiPlugin.isReplay ? d.NolimitLauncher.instance.settings.maxResolutionReplay : d.NolimitLauncher.instance.settings.maxResolution;
							i = Math.min(i, 2), v.resolution = Math.min(Math.max(window.devicePixelRatio, 1), i), a.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
							try {
								this._pixiApp = new a.Application({
									autoStart: !1,
									width: 1280,
									height: 720,
									autoDensity: !1,
									antialias: !1,
									resolution: v.resolution,
									sharedTicker: !1,
									backgroundColor: 0
								})
							} catch (t) {
								v.apiPlugin.error.trigger(v.apiPlugin.translations.translate("Your device or browser doesn't support WebGL. Please check that WebGL is supported and activated."), S.APIErrorCode.GRAPHICS)
							}
							this._internalStage = new a.Container, this._internalStage.name = "Stage", this._pixiApp.stage.addChild(this._internalStage), this._dialogLayer = new a.Container, this._dialogLayer.name = "Dialog", this._pixiApp.stage.addChild(this._dialogLayer), this._keypadLayer = new a.Container, this._keypadLayer.name = "Keypad", this._pixiApp.stage.addChild(this._keypadLayer), this._gameElement.appendChild(this._pixiApp.renderer.view), this._pixiApp.renderer.view.addEventListener("webglcontextlost", this.onWebGLContextLost, !1), v.svgLoader = new c.SvgLoader(v.resourcePath, v.resolution), v._instance = this, this._freezeBlur = new l.PerformanceFreezeBlur(this._internalStage), t(this)
						}))
					}
					destroyRenderer() {
						r.GSAPCompatabilityWrapper.pauseGlobalTimeline(), this._pixiApp.renderer.view.parentNode.removeChild(this._pixiApp.renderer.view), v.pixiApp.renderer.destroy()
					}
					reInitRenderer() {
						v.resolution = Math.min(Math.max(window.devicePixelRatio, 1), 2);
						try {
							this._pixiApp = new a.Application({
								autoStart: !1,
								width: 1280,
								height: 720,
								autoDensity: !1,
								antialias: !1,
								resolution: v.resolution,
								sharedTicker: !1,
								backgroundColor: 0
							})
						} catch (t) {
							v.apiPlugin.error.trigger(v.apiPlugin.translations.translate("Your device or browser doesnt support WebGL. Please check that WebGL is supported and activated."))
						}
						r.GSAPCompatabilityWrapper.resumeGlobalTimeline(), v.apiPlugin.events.trigger(h.APIEvent.RE_INIT_RENDERER_DONE), this._pixiApp.stage.addChild(this._internalStage), this._pixiApp.stage.addChild(this._dialogLayer), this._pixiApp.stage.addChild(this._keypadLayer), this._gameElement.appendChild(this._pixiApp.renderer.view), this._pixiApp.renderer.view.addEventListener("webglcontextlost", this.onWebGLContextLost, !1), this.resize(), g.ViewPort.triggerResize()
					}
					getReady() {
						return new Promise(((t, e) => {
							this.resize(), r.GSAPCompatabilityWrapper.initTicker(this.animate), t(this)
						}))
					}
					getReadyToStart() {
						return new Promise(((t, e) => {
							t(this)
						}))
					}
					start() {
						return new Promise(((t, e) => {
							t(this)
						}))
					}
					destroy() {
						g.ViewPort.shutDown(), r.GSAPCompatabilityWrapper.removeTicker(this.animate), this._pixiApp.destroy(!0, {
							children: !0,
							texture: !0,
							baseTexture: !0
						}), console.log("NolimitApp destroy")
					}
					addEventListeners() {
						v.apiPlugin.events.on(h.APIEvent.CONFIG, (t => {
							const e = t.size.width / t.size.height;
							v.apiPlugin.options.device == u.Device.DESKTOP && g.ViewPort.confineToRatio(this.nolimitContainer, e), g.ViewPort.onResize(((e, i) => {
								const n = Math.min(e / this.frame.width, i / this.frame.height);
								this._globalScale = n, null != this.nolimitContainer && (this.nolimitContainer.style.fontSize = 10 * n + "px");
								let s = t.size.width,
									o = t.size.height;
								if (e >= t.size.width && i >= t.size.height) {
									const t = e >= i;
									if (s = o * (Math.max(e, i) / Math.min(e, i)), !t) {
										const t = s;
										s = o, o = t
									}
								} else s = e, o = i;
								this._pixiApp.renderer.resize(s, o), this._pixiApp.view.style.width = e + "px", this._pixiApp.view.style.height = i + "px", this.resize()
							})), g.ViewPort.triggerResize()
						})), v.apiPlugin.events.on(h.APIEvent.HALT, (() => {
							g.ViewPort.shutDown();
							const t = this.addBlur();
							t.add((() => {
								r.GSAPCompatabilityWrapper.removeTicker(this.animate)
							})), t.add((() => {
								this._pixiApp.destroy()
							}), 1)
						})), v.apiPlugin.events.on(h.APIEvent.PAUSE, (() => this.onPause(!0))), v.apiPlugin.events.on(h.APIEvent.RESUME, (() => this.onPause(!1))), v.apiPlugin.events.on(h.APIEvent.DESTROY_RENDERER, (() => this.destroyRenderer())), v.apiPlugin.events.on(h.APIEvent.RE_INIT_RENDERER, (() => this.reInitRenderer())), v.apiPlugin.events.on(h.APIEvent.DIALOG, (t => this.onApiDialog(t))), v.apiPlugin.events.on(h.APIEvent.FREEZE, (t => this.onFreeze(t))), v.apiPlugin.events.on(h.APIEvent.UNFREEZE, (() => this.onUnFreeze()))
					}
					onFreeze(t = !1) {
						this.addBlur(!0), t && r.GSAPCompatabilityWrapper.pauseGlobalTimeline()
					}
					onUnFreeze() {
						this.removeBlur(), r.GSAPCompatabilityWrapper.isGlobalTimelinePaused() && r.GSAPCompatabilityWrapper.resumeGlobalTimeline()
					}
					onApiDialog(t) {
						"open" == t ? this.addBlur(!0) : this.removeBlur()
					}
					addBlur(t = !1) {
						return v._instance._freezeBlur.freeze(.22, t)
					}
					removeBlur() {
						return v._instance._freezeBlur.unfreeze(.22)
					}
					onPause(t) {
						this._pauseTl && this._pauseTl.isActive() && this._pauseTl.progress(1), this._pauseTl = new f.TimelineLite, t && !this._paused ? (this._paused = !0, this._hasOpenDialog || this._pauseTl.add(v._instance._freezeBlur.freeze()), this._pauseTl.add((() => {
							r.GSAPCompatabilityWrapper.pauseGlobalTimeline()
						}), "+=0.5")) : !t && this._paused && (this._paused = !1, r.GSAPCompatabilityWrapper.resumeGlobalTimeline(), this._hasOpenDialog || this._pauseTl.add(v._instance._freezeBlur.unfreeze()))
					}
					orientationChanged() {
						for (let t in this._layers) {
							const e = this._layers[t];
							null != e.onOrientationChanged && e.onOrientationChanged()
						}
					}
					resizeLayers() {
						for (let t in this._layers) {
							const e = this._layers[t];
							null != e.onResize && e.onResize()
						}
					}
					static resize() {
						v._instance.resize()
					}
					resize() {
						const t = this._pixiApp.renderer.screen.width,
							e = this._pixiApp.renderer.screen.height,
							i = this.setOrientation(t >= e);
						let n = Math.min(t / this.frame.width, e / this.frame.height),
							s = (e - this.frame.height * n) * this.placement.y,
							o = (t - this.frame.width * n) * this.placement.x;
						v.screenBounds = {
							top: Math.round(-s / n),
							left: Math.round(-o / n),
							right: Math.round(o / n) + this.frame.width,
							bottom: Math.round(s / n) + this.frame.height,
							center: .5 * this.frame.width,
							width: Math.round(t / n),
							height: Math.round(e / n),
							scale: n
						}, this._pixiApp.stage.scale.set(n, n), this._pixiApp.stage.position.set(Math.round(o), Math.round(s)), i && this.orientationChanged(), this.resizeLayers(), null != this._currentDialog && this._currentDialog.onResize && this._currentDialog.onResize(), this._freezeBlur.onResize(), i && this._freezeBlur.onOrientationChanged(), v.events.trigger(v.RESIZE)
					}
					setOrientation(t) {
						return v.isLandscape != t && (v.isLandscape = t, !0)
					}
					static addLayerAt(t, e, i = 0) {
						v._instance._layers[t] = e, e.name = t, v._instance.stage.addChildAt(e, i), "Keypad" == t && v._instance._keypadLayer.addChildAt(e, i)
					}
					static addLayer(t, e) {
						v._instance._layers[t] = e, e.name = t, v._instance.stage.addChild(e), "Keypad" == t && v._instance._keypadLayer.addChild(e)
					}
					static removeLayer(t) {
						if (v._instance._layers[t]) {
							const e = v._instance.stage.removeChild(v._instance._layers[t]);
							return "Keypad" == t && v._instance._keypadLayer.removeChild(v._instance._layers[t]), delete v._instance._layers[t], e
						}
					}
					static getLayerByName(t) {
						return v._instance._layers[t]
					}
					static addDialog(t, e = !1) {
						v.apiPlugin.dialog.lock("PIXIDialog"), v._instance._currentDialog != t ? v.apiPlugin.slotStates.checkState(_.SlotState.READY) ? null == v._instance._currentDialog ? (v.apiPlugin.events.trigger(h.APIEvent.SCREEN, "open"), e && v._instance._freezeBlur.freeze(), v._instance._currentDialog = t, v.events.trigger(v.DIALOG_OPENED), v._instance._dialogLayer.addChild(t), v._instance._hasOpenDialog = !0) : m.Logger.warn("Dialog error: There is already a screen") : m.Logger.warn("Dialog error: game state is not READY") : m.Logger.warn("Dialog: Doubel trigger dialog. May be due to performance slowdown.")
					}
					static removeDialog(t, e = !0) {
						t != v._instance._currentDialog && v.apiPlugin.error.trigger("Dialog error: trying to remove dialog that is not current dialog");
						const i = new f.TimelineLite({
							onStart: () => {
								v.events.trigger(v.DIALOG_CLOSING)
							},
							onComplete: () => {
								v._instance._hasOpenDialog = !1, v.apiPlugin.dialog.unlock("PIXIDialog"), v.apiPlugin.events.trigger(h.APIEvent.SCREEN, "close"), v.events.trigger(v.DIALOG_CLOSED)
							}
						});
						i.add((() => {
							v._instance._currentDialog = null, v._instance._dialogLayer.removeChild(t)
						})), v._instance._freezeBlur.isFrozen && e && i.add(v._instance._freezeBlur.unfreeze(), 0)
					}
					static minimizeDialog(t) {
						t != v._instance._currentDialog && v.apiPlugin.error.trigger("Dialog error: trying to remove dialog that is not current dialog");
						const e = new f.TimelineLite({
							onStart: () => {
								v.events.trigger(v.DIALOG_MINIMIZING)
							},
							onComplete: () => {
								v._instance._hasOpenDialog = !1, v.apiPlugin.dialog.unlock("PIXIDialog")
							}
						});
						e.add((() => {
							v._instance._currentDialog = null, v._instance._dialogLayer.removeChild(t)
						})), v._instance._freezeBlur.isFrozen && e.add(v._instance._freezeBlur.unfreeze(), 0)
					}
				}
				v.DIALOG_OPENED = "dialogOpened", v.DIALOG_CLOSED = "dialogClosed", v.DIALOG_CLOSING = "dialogClosing", v.DIALOG_MINIMIZING = "dialogMinimizing", v.RESIZE = "resize", e.NolimitApplication = v
			},
			91980: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NolimitLauncher = e.LauncherSettings = void 0;
				const n = i(72468),
					s = i(78435),
					o = i(22636),
					r = i(83202),
					a = i(66516),
					l = i(46334);
				class h {
					constructor() {
						this.log = l.LogLevel.DEV, this.maxResolution = 2, this.maxResolutionReplay = 2
					}
				}
				e.LauncherSettings = h;
				class u {
					static get instance() {
						return null == this._instance && (this._instance = new u), this._instance
					}
					static get defaultResourcePath() {
						return "/node_modules/@nolimitcity/slot-launcher/resources/default/"
					}
					constructor() {
						this.settings = new h, this.logger = new l.NamedLogger("NolimitLauncher"), this.logger.level = this.settings.log, u.plugins = [], u.apiPlugin = new o.NolimitApiPlugin, u.plugins.push(u.apiPlugin), u.plugins.push(new n.NolimitApplication), u.plugins.push(new s.NolimitAutoPlayPlugin), u.plugins.push(new r.AnalyticsIntegrationPlugin), u.plugins.push(new a.GuiPlugin)
					}
					destroy() {
						for (let t = 0; t < u.plugins.length; t++)
							if ("NolimitApplication" == u.plugins[t].name) {
								const e = u.plugins[t];
								e.destroy && e.destroy(), u.plugins.splice(t, 1);
								break
							} for (; u.plugins.length > 0;) {
							let t = u.plugins.pop();
							(null == t ? void 0 : t.destroy) && t.destroy()
						}
						u.plugins = [], null != this._destructionCallback && this._destructionCallback(), u._instance = void 0
					}
					static destroy() {
						u._instance && u._instance.destroy()
					}
					setDestructionCallback(t) {
						this._destructionCallback = t
					}
					removePlugin(t) {
						for (let e = 0; e < u.plugins.length; e++)
							if (t == u.plugins[e]) return void u.plugins.splice(e, 1)
					}
					launch(t) {
						u.plugins = u.plugins.concat(t), this._allPluginNames = [];
						const e = [];
						for (let t of u.plugins) this._allPluginNames.push(t.name), e.push(t.init().then((t => this.logValue(t, "loaded"))));
						this.resetPromisesLeft("init"), Promise.all(e).then((t => this.onLoaded(t)), (t => this.onFail(t)))
					}
					onLoaded(t) {
						if (null != this._loadError) return;
						this.logger.log("initComplete");
						const e = [];
						for (let i of t) e.push(i.getReady().then((t => this.logValue(t, "ready"))));
						this.resetPromisesLeft("getReady"), Promise.all(e).then((t => this.onReady(t)), (t => this.onFail(t)))
					}
					onReady(t) {
						if (null != this._loadError) return;
						this.logger.log("getReadyComplete");
						const e = [];
						for (let i of t) e.push(i.getReadyToStart().then((t => this.logValue(t, "onReadyToStart"))));
						this.resetPromisesLeft("getReadyToStart"), Promise.all(e).then((t => this.onReadyToStart(t)), (t => this.onFail(t)))
					}
					onReadyToStart(t) {
						if (null != this._loadError) return;
						this.logger.log("getReadyToStartComplete");
						const e = [];
						for (let i of t) e.push(i.start().then((t => this.logValue(t, "start"))));
						this.resetPromisesLeft("start"), Promise.all(e).then((t => this.onStart(t)), (t => this.onFail(t)))
					}
					onStart(t) {
						null == this._loadError && (u.started = !0, this.logger.log("startComplete"), u.apiPlugin.startGame())
					}
					onFail(t) {
						this._loadError = t, console.log(t), u.apiPlugin.error.trigger(t.message, t.code)
					}
					logValue(t, e) {
						return this.settings.log != l.LogLevel.NONE && (this._promisesLeft.pluginsLeft.splice(this._promisesLeft.pluginsLeft.indexOf(t.name), 1), this.logger.log(`Plugins left in phase (${this._promisesLeft.phase}): `, this._promisesLeft.pluginsLeft)), t
					}
					resetPromisesLeft(t) {
						this._promisesLeft = {
							phase: t,
							pluginsLeft: this._allPluginNames.concat()
						}
					}
				}
				u.started = !1, e.NolimitLauncher = u
			},
			70713: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.DevConsole = void 0;
				const n = i(64390);
				class s {
					static get instance() {
						return null == this._instance && (this._instance = new s), this._instance
					}
					constructor() {}
					static addCommand(t, e) {
						this.instance[t] = () => {
							n.NolimitConfig.isDevMode && e()
						}, this.commandNames.push(t), this.commandNames.sort(((t, e) => t.localeCompare(e)))
					}
				}
				s.commandNames = [], e.DevConsole = s, document.DevConsole = s.instance
			},
			83901: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NLCStaticText = void 0;
				const n = i(72468),
					s = i(82859);
				class o extends PIXI.Sprite {
					constructor(t, e) {
						super(o.renderTextToTexture(new PIXI.Text(t, e))), this.roundPixels = !0
					}
					static renderTextToTexture(t) {
						const e = t.style.padding ? t.style.padding : 0,
							i = PIXI.RenderTexture.create({
								width: t.width + 2 * e,
								height: t.height + 2 * e,
								resolution: n.NolimitApplication.resolution
							});
						return t.position.set(e, e), n.NolimitApplication.pixiApp.renderer.render(t, i), i.trim = new s.Rectangle(-e, -e, t.width + 2 * e, t.height + 2 * e), i.orig = new s.Rectangle(e, e, t.width, t.height), i.updateUvs(), t.destroy({
							children: !0,
							texture: !0,
							baseTexture: !0
						}), i
					}
				}
				e.NLCStaticText = o
			},
			72587: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NLCText = void 0;
				const n = i(83901);
				class s extends n.NLCStaticText {
					get text() {
						return this._text
					}
					set text(t) {
						this._text = t, this.remakeTexture()
					}
					constructor(t, e) {
						super(t, e), this._text = t, this._style = null != e ? e : new PIXI.TextStyle
					}
					getStyleClone() {
						return this._style.clone()
					}
					setStyle(t) {
						this._style = t, this.remakeTexture()
					}
					remakeTexture() {
						this.texture = n.NLCStaticText.renderTextToTexture(new PIXI.Text(this._text, this._style))
					}
				}
				e.NLCText = s
			},
			37950: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.cloneScreenBounds = void 0, e.cloneScreenBounds = function(t) {
					return {
						top: t.top,
						left: t.left,
						bottom: t.bottom,
						right: t.right,
						center: t.center,
						width: t.width,
						height: t.height,
						scale: t.scale
					}
				}
			},
			18371: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PerformanceFreezeBlur = void 0;
				const n = i(13006),
					s = i(72468);
				class o {
					get isFrozen() {
						return this._isFrozen
					}
					constructor(t) {
						this._isFrozen = !1, this._hasInit = !1, this._gameStage = t
					}
					init() {
						this._resolution = .05, this._app = s.NolimitApplication.pixiApp, this._freezeTexture = PIXI.RenderTexture.create({
							width: this._app.renderer.screen.width,
							height: this._app.renderer.screen.height,
							resolution: s.NolimitApplication.resolution,
							scaleMode: PIXI.SCALE_MODES.LINEAR
						}), this._freezeSprite = new PIXI.Sprite(this._freezeTexture), this._freezeSprite.name = "freezeSprite", this._blurTexture = PIXI.RenderTexture.create({
							width: this._app.renderer.screen.width,
							height: this._app.renderer.screen.height,
							resolution: this._resolution,
							scaleMode: PIXI.SCALE_MODES.LINEAR
						}), this._blurSprite = new PIXI.Sprite(this._blurTexture), this._blurFilter = new PIXI.filters.BlurFilter, this._blurFilter.autoFit = !1, this._blurFilter.blur = 60, this._blurFilter.padding = 0, this._blurSprite.filters = [this._blurFilter], this._hasInit = !0
					}
					freeze(t = .22, e = !1) {
						if (this._isFrozen) return new n.TimelineLite;
						this._hasInit || this.init(), null != this._animation && this._animation.isActive() && (this._animation.progress(1, !1), delete this._animation), this.renderTextures(), this.resize();
						const i = new n.TimelineLite;
						return i.add((() => {
							e && (s.NolimitApplication.pixiApp.stage.interactiveChildren = !1), this._isFrozen = !0, this._freezeSprite.alpha = 0, s.NolimitApplication.pixiApp.stage.addChildAt(this._freezeSprite, 0), s.NolimitApplication.pixiApp.stage.addChildAt(this._gameStage, 0)
						})), i.add(new n.TweenLite(this._freezeSprite, t, {
							alpha: 1
						})), i.add((() => {
							s.NolimitApplication.pixiApp.stage.removeChild(this._gameStage), delete this._animation
						})), this._animation = i, i
					}
					unfreeze(t = .22) {
						if (!this._isFrozen) return new n.TimelineLite;
						null != this._animation && this._animation.isActive() && (this._animation.progress(1, !1), delete this._animation);
						const e = new n.TimelineLite({
							onComplete: () => {
								s.NolimitApplication.pixiApp.stage.removeChild(this._freezeSprite), s.NolimitApplication.pixiApp.stage.interactiveChildren = !0, delete this._animation, this._isFrozen = !1
							}
						});
						return e.add((() => {
							s.NolimitApplication.pixiApp.stage.addChildAt(this._gameStage, 0)
						})), e.add(new n.TweenLite(this._freezeSprite, t, {
							alpha: 0
						})), e
					}
					renderTextures() {
						this._freezeSprite.scale.set(1, 1), this._freezeTexture.resize(s.NolimitApplication.screenBounds.width, s.NolimitApplication.screenBounds.height), this._blurTexture.resize(s.NolimitApplication.screenBounds.width + 200, s.NolimitApplication.screenBounds.height + 200), s.NolimitApplication.pixiApp.renderer.render(this._gameStage, this._blurTexture, !0, o.getStageMatrix()), this._blurSprite.render(s.NolimitApplication.pixiApp.renderer), s.NolimitApplication.pixiApp.renderer.render(this._blurSprite, this._freezeTexture, !0)
					}
					static getStageMatrix() {
						const t = new PIXI.Matrix;
						return t.translate(-s.NolimitApplication.screenBounds.left, -s.NolimitApplication.screenBounds.top), t
					}
					resize() {
						this._freezeSprite.position.set(s.NolimitApplication.screenBounds.left, s.NolimitApplication.screenBounds.top), this._freezeSprite.width = s.NolimitApplication.screenBounds.width, this._freezeSprite.height = s.NolimitApplication.screenBounds.height
					}
					onOrientationChanged() {
						this._isFrozen && this.renderTextures()
					}
					onResize() {
						this._hasInit && this.resize()
					}
				}
				e.PerformanceFreezeBlur = o
			},
			94183: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GuiButton = void 0;
				const n = i(33169),
					s = i(46334);
				class o extends PIXI.Container {
					get pointerState() {
						return this._pointerState
					}
					constructor(t, e) {
						super(), this._boundEvents = !1, this.debug = !1, this.onPointerTap = t => {
							t.stopPropagation(), this.onClick(t)
						}, this.onPointerDown = t => {
							t.stopPropagation(), this.setPointerState(n.PointerState.DOWN)
						}, this.onPointerOver = t => {
							this.setPointerState(n.PointerState.OVER)
						}, this.onPointerUp = t => {
							this.setPointerState(n.PointerState.IDLE)
						}, this.onPointerUpOutside = t => {
							this.setPointerState(n.PointerState.IDLE)
						}, this.onPointerOut = t => {
							this.setPointerState(n.PointerState.IDLE)
						}, this.name = t, this._clickCallbacks = [], null != e && this.addClickCallback(e), this._callbackSets = []
					}
					bindEvents() {
						this.on("pointertap", this.onPointerTap), this.on("pointerdown", this.onPointerDown), this.on("pointerover", this.onPointerOver), this.on("pointerup", this.onPointerUp), this.on("pointerupoutside", this.onPointerUpOutside), this.on("pointerout", this.onPointerOut)
					}
					enable(t) {
						this._boundEvents || (this.bindEvents(), this._boundEvents = !0), this.interactive = t, this.buttonMode = t, this.setPointerState(t ? n.PointerState.IDLE : n.PointerState.DISABLED)
					}
					addClickCallback(t) {
						this._clickCallbacks.push(t)
					}
					addCallbackSet(t) {
						this._callbackSets.push(t)
					}
					setPointerState(t) {
						if (this._pointerState !== t) {
							this._pointerState = t, this.onPointerStateUpdate(t);
							for (let e of this._callbackSets) null != e[t] && e[t]();
							this.debug && s.Logger.logDev(`[${this.name}].pointerState: ${n.PointerState[this.pointerState]}`)
						}
					}
					onClick(t) {
						if (this.interactive && null != this.parent) {
							for (let t of this._clickCallbacks) t();
							this.debug && s.Logger.logDev(`[${this.name}].onClick`), t && t.stopPropagation()
						}
					}
					onPointerStateUpdate(t) {}
				}
				e.GuiButton = o
			},
			35235: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GuiToggleButton = void 0;
				const n = i(94183),
					s = i(5158);
				class o extends n.GuiButton {
					get toggled() {
						return this.toggleState === s.ToggleState.ON
					}
					set toggled(t) {
						this.toggleState = t ? s.ToggleState.ON : s.ToggleState.OFF
					}
					get toggleState() {
						return this._toggleState
					}
					set toggleState(t) {
						this._toggleState = t, this._toggleCallback(this._toggleState)
					}
					constructor(t, e) {
						super(t), this._toggleCallback = e
					}
				}
				e.GuiToggleButton = o
			},
			14615: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.IconButton = void 0;
				const n = i(94183);
				class s extends n.GuiButton {
					constructor(t, e, i, n) {
						super(t, n), this.onPointerStateUpdate = t => {
							this.setIcon()
						}, this._iconSet = e, this._colorSet = i
					}
					setIcon() {
						const t = this._iconSet.getItem(this.pointerState),
							e = this._colorSet.getItem(this.pointerState);
						t.setColor(e), t != this._icon && (this.addChild(t), this.removeChild(this._icon), this._icon = t)
					}
				}
				e.IconButton = s
			},
			66515: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.IconToggleButton = void 0;
				const n = i(35235),
					s = i(5158);
				class o extends n.GuiToggleButton {
					constructor(t, e, i, n, o) {
						super(t, (() => this.toggleCallback())), this.onPointerStateUpdate = t => {
							this.setIcon()
						}, this._iconSets = new s.ToggleStateSet(e, n), this._colorSets = new s.ToggleStateSet(i, o)
					}
					getIconSet() {
						return this._iconSets.getItem(this.toggleState)
					}
					getIconColorSet() {
						return this._colorSets.getItem(this.toggleState)
					}
					setIcon() {
						const t = this.getIconSet(),
							e = this.getIconColorSet(),
							i = t.getItem(this.pointerState),
							n = e.getItem(this.pointerState);
						i.setColor(n), i != this._icon && (this.addChild(i), this.removeChild(this._icon), this._icon = i)
					}
					addSubComponent(t, e, i) {
						this.addChild(t), this._icon || this.setIcon(), t.position.set(this._icon.width * e.x + i.x, this._icon.height * e.y + i.y)
					}
					removeSubComponent(t) {
						this.removeChild(t)
					}
					toggleCallback() {
						this.setIcon()
					}
					hide() {
						this.visible = !1
					}
					show() {
						this.visible = !0
					}
				}
				e.IconToggleButton = o
			},
			67566: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LabelButton = e.createDefaultButtonStroke = e.createDefaultButtonBackPlate = void 0;
				const n = i(35235),
					s = i(68714),
					o = i(5158),
					r = i(56254),
					a = i(85733),
					l = i(9886),
					h = i(55462),
					u = i(78229);

				function c() {
					const t = new PIXI.NineSlicePlane(a.SvgLoader.getSvgTexture(h.GuiDefaultTextures.PLATE_BASE_20), 20, 20, 20, 20);
					return t.tint = 0, t.alpha = .15, t
				}

				function d() {
					const t = new PIXI.NineSlicePlane(a.SvgLoader.getSvgTexture(h.GuiDefaultTextures.PLATE_STROKE_20), 20, 20, 20, 20);
					return t.tint = 16777215, t.alpha = .6, t
				}
				e.createDefaultButtonBackPlate = c, e.createDefaultButtonStroke = d;
				class p extends n.GuiToggleButton {
					get backplate() {
						return this._backplate
					}
					set backplate(t) {
						this._backplate = t
					}
					get stroke() {
						return this._stroke
					}
					set stroke(t) {
						this._stroke = t
					}
					get label() {
						return this._label
					}
					constructor(t, e = "", i, n, a, l, h) {
						super(t, (() => this.toggleCallback())), i = i || u.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE, n = n || new r.PointerStateColorSet(4294966272, 4294966272, 4294966272, 872414208), a = a || new r.PointerStateColorSet(4294967295, 4294967295, 4294967295, 872415231), this._colorSets = new o.ToggleStateSet(n, a), this.value = void 0, this._label = new s.Label(e, i), this._backplate = l || c(), this._stroke = h || d(), this.addChild(this._backplate), this.addChild(this._stroke), this.addChild(this._label)
					}
					setSize(t, e) {
						this._backplate.width = t, this._backplate.height = e, this._stroke.width = t, this._stroke.height = e, this._label.anchor.set(.5, .5), this._label.position.set(.5 * t, .5 * e)
					}
					resizeButtonToLabelWithMargin(t = 0, e = 0, i = 0, n = 0) {
						this.setSize(this._label.width + n + e, this._label.height + t + i), this._label.anchor.set(0, 0), this._label.position.set(n, t)
					}
					setColors() {
						const t = this._colorSets.getItem(this.toggleState).getItem(this.pointerState);
						this._label.setColor(t), this._backplate.alpha = .15 * (1 - this.toggleState), this._stroke.tint = l.GuiUtils.getColorFromARGB(t), this._stroke.alpha = l.GuiUtils.getAlphaFromARGB(t), this._stroke.alpha *= this.toggled ? 1 : .6
					}
					toggleCallback() {
						this.setColors()
					}
					onPointerStateUpdate(t) {
						this.setColors()
					}
				}
				e.LabelButton = p
			},
			26733: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BuyFeatureButton = void 0;
				const n = i(35235),
					s = i(68714),
					o = i(78229),
					r = i(77616),
					a = i(91980),
					l = i(61e3),
					h = i(37107),
					u = i(55462);
				class c extends n.GuiToggleButton {
					constructor(t) {
						super(t.name, (() => this.toggleCallback())), this.featureData = t, this.featureTicket = new h.NolimitBonusFeatureTicket(t.name);
						let e = o.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE.clone();
						e.fontSize = 20, e.fill = "#FFFFFF", e.fontWeight = r.FontWeight.NORMAL, this.costLabel = new s.Label("-1", e), this.costLabel.anchor.set(.5, 1), this.costLabel.position.set(Math.floor(.5 * this.featureTicket.size.x), 153), this._goldenCost = new PIXI.Container, e = o.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE.clone(), e.fontSize = 22, e.fill = "#FFFC00", e.fontWeight = r.FontWeight.BOLD, this.goldenCostLabel = new s.Label("-1", e), this.goldenCostLabel.anchor.set(.5, 1), this.goldenCostLabel.position.set(Math.floor(.5 * this.featureTicket.size.x), 153), this._goldenCostBackplate = new PIXI.NineSlicePlane(l.ImgLoader.getImgTexture(u.GuiDefaultTextures.NOLIMIT_BONUS_BET_BACKPLATE), 36, 36, 36, 36), this._goldenCost.addChild(this._goldenCostBackplate, this.goldenCostLabel), this._goldenCost.visible = !1, this.addChild(this.featureTicket), this.addChild(this.costLabel), this.addChild(this._goldenCost)
					}
					toggleCallback() {
						this.toggled ? (this.featureTicket.setSelected(!0), this._goldenCost.visible = !0, this.costLabel.visible = !1) : (this.featureTicket.setSelected(!1), this._goldenCost.visible = !1, this.costLabel.visible = !0)
					}
					updateCostAndValidate(t) {
						const e = +a.NolimitLauncher.apiPlugin.currency.formatValue(this.featureData.price * t);
						this.costLabel.text = c.formatCurrencyWithDecimalCutoff(e), this.goldenCostLabel.text = this.costLabel.text, this._goldenCostBackplate.width = this.goldenCostLabel.width + 50, this._goldenCostBackplate.height = this.goldenCostLabel.height + 32, this._goldenCostBackplate.position.set(this.goldenCostLabel.x, this.goldenCostLabel.y - .5 * this.goldenCostLabel.height + 5), this._goldenCostBackplate.pivot.set(.5 * this._goldenCostBackplate.width, .5 * this._goldenCostBackplate.height);
						const i = a.NolimitLauncher.apiPlugin.balance.getAmount();
						return !!(this.featureData.isBetLevelValid() && e <= i)
					}
					static formatCurrencyWithDecimalCutoff(t) {
						"string" == typeof t && (t = parseFloat(t));
						const e = t < 10 || t % 1 != 0 ? 2 : 0;
						return a.NolimitLauncher.apiPlugin.currency.format(t, {
							minimumPrecision: e
						})
					}
					enable(t) {
						super.enable(t), t ? this.alpha = 1 : !0 === a.NolimitLauncher.apiPlugin.gameClientConfiguration.hideTicketLowBalance ? this.alpha = 0 : this.alpha = .6
					}
				}
				e.BuyFeatureButton = c
			},
			92986: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.CheckBoxButton = void 0;
				const n = i(66515),
					s = i(55462),
					o = i(46980),
					r = i(85136),
					a = i(56254),
					l = i(68714),
					h = i(78229),
					u = i(61e3);
				class c extends n.IconToggleButton {
					constructor(t, e, i, n, c) {
						n = n || new a.PointerStateColorSet(4294966272, 4294966272, 4294966272, 872414208), c = c || new a.PointerStateColorSet(4294967295, 4294967295, 4294967295, 872415231);
						const d = new o.PointerStateIconSet(new r.Icon(u.ImgLoader.getImgTexture(s.GuiDefaultTextures.CHECK_BOX_SMALL_EMPTY)));
						if (super(t, new o.PointerStateIconSet(new r.Icon(u.ImgLoader.getImgTexture(s.GuiDefaultTextures.CHECK_BOX_SMALL_CHECKED))), n, d, c), null != e) {
							const t = i || h.GuiDefaults.DEFAULT_CHECKBOX_BUTTON_LABEL,
								n = new l.Label(e, t);
							n.anchor.set(0, .5), this.addSubComponent(n, {
								x: 1,
								y: .5
							}, {
								x: 4,
								y: 1
							})
						}
					}
				}
				e.CheckBoxButton = c
			},
			54554: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ContinueButton = void 0;
				const n = i(72468),
					s = i(78229),
					o = i(85733),
					r = i(55462),
					a = i(94183),
					l = i(68714),
					h = i(56254),
					u = i(9886);
				class c extends a.GuiButton {
					constructor(t) {
						super(t || "continues_button"), this.onPointerStateUpdate = t => {
							const e = u.GuiUtils.getAlphaFromARGB(this._colors.getItem(t));
							this.alpha = e
						}, t = t || n.NolimitApplication.apiPlugin.translations.translate("CONTINUE"), this._label = new l.Label(t, s.GuiDefaults.DEFAULT_CONTINUE_BUTTON_LABEL_STYLE), this._backplate = c.createBackPlate(), this._stroke = c.createButtonStroke(), this._colors = new h.PointerStateColorSet(4278190080, void 0, void 0, 2147483648), this.addChild(this._backplate), this.addChild(this._stroke), this.addChild(this._label), this.resizeButtonToLabelWithMargin(18, 30, 18, 30)
					}
					setSize(t, e) {
						this._backplate.width = t, this._backplate.height = e, this._stroke.width = t, this._stroke.height = e, this._label.anchor.set(.5, .5), this._label.position.set(.5 * t, .5 * e)
					}
					resizeButtonToLabelWithMargin(t = 0, e = 0, i = 0, n = 0) {
						this.setSize(this._label.width + n + e, this._label.height + t + i), this._label.anchor.set(0, 0), this._label.position.set(n, t)
					}
					static createBackPlate() {
						const t = new PIXI.NineSlicePlane(o.SvgLoader.getSvgTexture(r.GuiDefaultTextures.PLATE_BASE_9), 9, 9, 9, 9);
						return t.tint = 0, t.alpha = .4, t
					}
					static createButtonStroke() {
						const t = new PIXI.NineSlicePlane(o.SvgLoader.getSvgTexture(r.GuiDefaultTextures.PLATE_STROKE_9), 9, 9, 9, 9);
						return t.tint = 16777215, t.alpha = 1, t
					}
				}
				e.ContinueButton = c
			},
			79970: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LimitCapButton = void 0;
				const n = i(61e3),
					s = i(55462),
					o = i(66515),
					r = i(68714),
					a = i(56254),
					l = i(46980),
					h = i(85136),
					u = i(78229),
					c = i(77616),
					d = i(5158);
				class p extends o.IconToggleButton {
					constructor(t) {
						const e = new a.PointerStateColorSet(4294967295, 4294967295, 4294967295, 872415231);
						super(t, new l.PointerStateIconSet(new h.Icon(n.ImgLoader.getImgTexture(s.GuiDefaultTextures.LIMIT_CAP_ON))), e, new l.PointerStateIconSet(new h.Icon(n.ImgLoader.getImgTexture(s.GuiDefaultTextures.LIMIT_CAP_OFF))))
					}
					addBylines(t, e) {
						const i = u.GuiDefaults.DEFAULT_LABEL_STYLE.clone();
						i.fontWeight = c.FontWeight.BOLD, null != this.onLabel ? (this.onLabel.text = t, this.removeChild(this.onLabel)) : this.onLabel = new r.Label(t, i), null != this.offLabel ? (this.offLabel.text = e, this.removeChild(this.offLabel)) : this.offLabel = new r.Label(e, i), this.onLabel.anchor.set(.5, 0), this.onLabel.position.set(Math.floor(.5 * this.width), 0), this.offLabel.anchor.set(.5, 0), this.offLabel.position.set(Math.floor(.5 * this.width), 0);
						const o = new l.PointerStateIconSet(new h.Icon(n.ImgLoader.getImgTexture(s.GuiDefaultTextures.LIMIT_CAP_ON_AMOUNT))),
							a = new l.PointerStateIconSet(new h.Icon(n.ImgLoader.getImgTexture(s.GuiDefaultTextures.LIMIT_CAP_OFF_AMOUNT)));
						this._iconSets = new d.ToggleStateSet(o, a), this.addChild(this.onLabel, this.offLabel), this.updateLabels(), this.setIcon()
					}
					setIcon() {
						super.setIcon(), this.onLabel && this.offLabel && this.addChild(this.onLabel, this.offLabel)
					}
					updateLabels() {
						this.onLabel && this.offLabel && (this.onLabel.visible = this.toggled, this.offLabel.visible = !this.toggled)
					}
					get toggled() {
						return super.toggled
					}
					set toggled(t) {
						super.toggled = t, this.updateLabels()
					}
				}
				e.LimitCapButton = p
			},
			83236: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.RadioButton = void 0;
				const n = i(66515),
					s = i(55462),
					o = i(46980),
					r = i(85136),
					a = i(56254),
					l = i(68714),
					h = i(78229),
					u = i(61e3);
				class c extends n.IconToggleButton {
					constructor(t, e, i, n, c) {
						n = n || new a.PointerStateColorSet(4294966272, 4294966272, 4294966272, 872414208), c = c || new a.PointerStateColorSet(4294967295, 4294967295, 4294967295, 872415231);
						const d = u.ImgLoader.getImgTexture(s.GuiDefaultTextures.CHECK_BOX).clone();
						d.rotate = 12;
						const p = new o.PointerStateIconSet(new r.Icon(u.ImgLoader.getImgTexture(s.GuiDefaultTextures.CHECK_BOX)));
						if (super(t, new o.PointerStateIconSet(new r.Icon(d.clone())), n, p, c), null != e) {
							const t = i || h.GuiDefaults.DEFAULT_RADIO_BUTTON_LABEL,
								n = new l.Label(e, t);
							n.anchor.set(0, .5), this.addSubComponent(n, {
								x: 1,
								y: .5
							}, {
								x: 20,
								y: 0
							})
						}
					}
				}
				e.RadioButton = c
			},
			65508: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SelectedBuyFeatureButton = void 0;
				const n = i(94183),
					s = i(37107),
					o = i(61e3),
					r = i(55462);
				class a extends n.GuiButton {
					constructor(t, e) {
						super(t + "_selected", (() => {
							e("open")
						})), this._backgroundPlate = new PIXI.NineSlicePlane(o.ImgLoader.getImgTexture(r.GuiDefaultTextures.PLATE_BASE_20), 20, 20, 20, 20), this._backgroundPlate.alpha = 1, this._backgroundPlate.tint = 15607379, this._backgroundStroke = new PIXI.NineSlicePlane(o.ImgLoader.getImgTexture(r.GuiDefaultTextures.PLATE_STROKE_20), 20, 20, 20, 20), this._backgroundStroke.alpha = 1, this._backgroundStroke.tint = 10165059, this._backgroundStroke2 = new PIXI.NineSlicePlane(o.ImgLoader.getImgTexture(r.GuiDefaultTextures.PLATE_STROKE_20), 20, 20, 20, 20), this._backgroundStroke2.alpha = 1, this._backgroundStroke2.tint = 10165059, this.featureTicket = new s.NolimitBonusFeatureTicket(t), this.featureTicket.scale.set(.6, .6), this.featureTicket.setSelected(!0, !1), this.featureTicket.position.set(13, 12), this.setBackgroundSize(this.featureTicket.width + 26, this.featureTicket.height + 20), this.closeGfx = new PIXI.Sprite(o.ImgLoader.getImgTexture(r.GuiDefaultTextures.NOLIMIT_BONUS_CLOSE_BUTTON)), this.closeGfx.anchor.set(1, 0), this.closeGfx.scale.set(.5, .5), this.closeGfx.position.set(this.size.x + 10, -10);
						const i = new n.GuiButton(t + "_selected_close", (() => {
							e("close")
						}));
						i.addChild(this.closeGfx), i.enable(!0), this.addChild(this._backgroundPlate, this._backgroundStroke, this._backgroundStroke2), this.addChild(this.featureTicket), this.addChild(i)
					}
					setBackgroundSize(t, e) {
						this.size = new PIXI.Point(t, e), this._backgroundPlate.width = this.size.x, this._backgroundPlate.height = this.size.y, this._backgroundStroke.width = this.size.x, this._backgroundStroke.height = this.size.y, this._backgroundStroke2.width = this.size.x, this._backgroundStroke2.height = this.size.y - 3
					}
				}
				e.SelectedBuyFeatureButton = a
			},
			61952: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SoundButton = void 0;
				const n = i(66515),
					s = i(46980),
					o = i(56254),
					r = i(13006),
					a = i(85136),
					l = i(55462),
					h = i(61e3);
				class u extends n.IconToggleButton {
					constructor(t) {
						const e = new o.PointerStateColorSet(4294966272, 4294966272, 4294966272, 872414208),
							i = new o.PointerStateColorSet(4294967295, 4294967295, 4294967295, 872415231);
						super(t, new s.PointerStateIconSet(new a.Icon(h.ImgLoader.getImgTexture(l.GuiDefaultTextures.SOUND_ON))), e, new s.PointerStateIconSet(new a.Icon(h.ImgLoader.getImgTexture(l.GuiDefaultTextures.SOUND_OFF))), i), this._loadingRing = new PIXI.Sprite(h.ImgLoader.getImgTexture(l.GuiDefaultTextures.SOUND_RING)), this._loadingRing.anchor.set(.5, .5), this._loadingRing.position.set(.5 * this._loadingRing.width, .5 * this._loadingRing.height)
					}
					startLoadingAnimation(t) {
						null == this._tl && (this._tl = null != t ? new r.TimelineMax({
							repeat: -1,
							onRepeat: () => {
								t()
							}
						}) : new r.TimelineMax({
							repeat: -1
						}), this.addChild(this._loadingRing), this._tl.add(new r.TweenLite(this._loadingRing, 1, {
							rotation: 2 * Math.PI,
							ease: r.Linear.easeNone
						})))
					}
					stopLoadingAnimation() {
						null != this._tl && (this._tl.pause(), this._tl.kill(), this.removeChild(this._loadingRing), this._tl = void 0)
					}
				}
				e.SoundButton = u
			},
			37107: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NolimitBonusFeatureTicket = void 0;
				const n = i(61e3),
					s = i(55462),
					o = i(91980);
				class r extends PIXI.Container {
					constructor(t) {
						super(), this._ticketContainer = new PIXI.Container;
						const e = o.NolimitLauncher.apiPlugin.betFeatureController.getFeatureData(t);
						"FREESPIN" === (null == e ? void 0 : e.type) ? (this._baseTicketTexture = n.ImgLoader.getImgTexture(s.GuiDefaultTextures.FEATURE_TICKET_BASE_GOLD), this._selectedTicketTexture = n.ImgLoader.getImgTexture(s.GuiDefaultTextures.FEATURE_TICKET_GOLD)) : (this._baseTicketTexture = n.ImgLoader.getImgTexture(s.GuiDefaultTextures.FEATURE_TICKET_BASE_SILVER), this._selectedTicketTexture = n.ImgLoader.getImgTexture(s.GuiDefaultTextures.FEATURE_TICKET_SILVER)), this._ticketSprite = new PIXI.Sprite(this._baseTicketTexture), this.size = new PIXI.Point(this._ticketSprite.width, this._ticketSprite.height), this._shadow = new PIXI.NineSlicePlane(n.ImgLoader.getImgTexture(s.GuiDefaultTextures.PLATE_BASE_9_BLUR_40), 29, 29, 29, 29), this._shadow.tint = 0, this._shadow.alpha = .4, this._shadow.position.set(0, 18), this._shadow.width = this.size.x, this._shadow.height = this.size.y;
						let i = PIXI.utils.TextureCache[t];
						null == i && (i = PIXI.utils.TextureCache[t + ".png"]);
						const r = new PIXI.Sprite(i);
						r.height = this.size.y, r.scale.x = r.scale.y, this._ticketContainer.addChild(this._shadow), this._ticketContainer.addChild(this._ticketSprite), this._ticketContainer.addChild(r), this._ticketContainer.pivot.set(.5 * this.size.x, .5 * this.size.y), this._ticketContainer.position.set(.5 * this.size.x, .5 * this.size.y), this.addChild(this._ticketContainer)
					}
					setSelected(t, e = !0) {
						t ? (this._shadow.alpha = .4, this._ticketSprite.texture = this._selectedTicketTexture, e ? this._ticketContainer.scale.set(1.05, 1.05) : this._ticketContainer.scale.set(1, 1)) : (this._shadow.alpha = 0, this._ticketSprite.texture = this._baseTicketTexture, this._ticketContainer.scale.set(1, 1))
					}
				}
				e.NolimitBonusFeatureTicket = r
			},
			33169: (t, e) => {
				"use strict";
				var i;
				Object.defineProperty(e, "__esModule", {
						value: !0
					}), e.PointerStateSet = e.PointerState = void 0,
					function(t) {
						t[t.IDLE = 0] = "IDLE", t[t.DOWN = 1] = "DOWN", t[t.OVER = 2] = "OVER", t[t.DISABLED = 3] = "DISABLED"
					}(i = e.PointerState || (e.PointerState = {}));
				class n {
					constructor(t, e, n, s) {
						this[i.IDLE] = t, this[i.DOWN] = e, this[i.OVER] = n, this[i.DISABLED] = s
					}
					getItem(t) {
						return this[t]
					}
					clone() {
						return new n(this[i.IDLE], this[i.DOWN], this[i.OVER], this[i.DISABLED])
					}
				}
				e.PointerStateSet = n, i.IDLE, i.DOWN, i.OVER, i.DISABLED
			},
			5158: (t, e) => {
				"use strict";
				var i;
				Object.defineProperty(e, "__esModule", {
						value: !0
					}), e.ToggleStateSet = e.ToggleState = void 0,
					function(t) {
						t[t.OFF = 0] = "OFF", t[t.ON = 1] = "ON"
					}(i = e.ToggleState || (e.ToggleState = {}));
				class n {
					constructor(t, e) {
						this[i.ON] = t, this[i.OFF] = e
					}
					getItem(t) {
						return null != this[t] ? this[t] : this[i.ON]
					}
					clone() {
						return new n(this[i.ON], this[i.OFF])
					}
				}
				e.ToggleStateSet = n, i.OFF, i.ON
			},
			56254: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PointerStateColorSet = void 0;
				const n = i(33169);
				class s extends n.PointerStateSet {
					constructor(t, e, i, n) {
						super(t, e, i, n)
					}
					getItem(t) {
						return null != this[t] ? this[t] : this[n.PointerState.IDLE]
					}
					clone() {
						return super.clone()
					}
				}
				e.PointerStateColorSet = s
			},
			46980: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PointerStateIconSet = void 0;
				const n = i(33169);
				class s extends n.PointerStateSet {
					constructor(t, e, i, n) {
						super(t, e, i, n)
					}
					getItem(t) {
						return null != this[t] ? this[t] : this[n.PointerState.IDLE]
					}
				}
				e.PointerStateIconSet = s
			},
			55462: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GuiDefaultTextures = void 0;
				const n = i(61e3);
				class s {
					static makeAssetPath(t) {
						return "/node_modules/@nolimitcity/slot-launcher/resources/default/gui/" + t
					}
					static getImgConfigs() {
						return [new n.ImgAssetConfig(s.SOUND_RING), new n.ImgAssetConfig(s.SOUND_OFF), new n.ImgAssetConfig(s.SOUND_ON), new n.ImgAssetConfig(s.NOLIMIT_BONUS_ICON), new n.ImgAssetConfig(s.NOLIMIT_BOOSTER_ICON), new n.ImgAssetConfig(s.NOLIMIT_BONUS_BET_BACKPLATE), new n.ImgAssetConfig(s.NOLIMIT_BONUS_CLOSE_BUTTON), new n.ImgAssetConfig(s.FEATURE_TICKET_BASE_GOLD), new n.ImgAssetConfig(s.FEATURE_TICKET_GOLD), new n.ImgAssetConfig(s.FEATURE_TICKET_BASE_SILVER), new n.ImgAssetConfig(s.FEATURE_TICKET_SILVER), new n.ImgAssetConfig(s.LIMIT_CAP_ON_AMOUNT), new n.ImgAssetConfig(s.LIMIT_CAP_OFF_AMOUNT), new n.ImgAssetConfig(s.LIMIT_CAP_ON), new n.ImgAssetConfig(s.LIMIT_CAP_OFF), new n.ImgAssetConfig(s.CHECK_BOX), new n.ImgAssetConfig(s.CHECK_BOX_SMALL_EMPTY), new n.ImgAssetConfig(s.CHECK_BOX_SMALL_CHECKED), new n.ImgAssetConfig(s.MODAL_BACKGROUND), new n.ImgAssetConfig(s.PLATE_BASE_9), new n.ImgAssetConfig(s.PLATE_STROKE_9), new n.ImgAssetConfig(s.PLATE_BASE_9_BLUR_40), new n.ImgAssetConfig(s.PLATE_BASE_9_BLUR_20), new n.ImgAssetConfig(s.PLATE_BASE_20), new n.ImgAssetConfig(s.PLATE_STROKE_20), new n.ImgAssetConfig(s.PLATE_BASE_20_BLUR_40), new n.ImgAssetConfig(s.BULLET_SMALL), new n.ImgAssetConfig(s.BULLET_LARGE), new n.ImgAssetConfig(s.NAV_ARROW), new n.ImgAssetConfig(s.VOL_INSANE), new n.ImgAssetConfig(s.VOL_EXTREME), new n.ImgAssetConfig(s.VOL_HIGH), new n.ImgAssetConfig(s.VOL_MEDIUM), new n.ImgAssetConfig(s.X_NUDGE), new n.ImgAssetConfig(s.X_WAYS), new n.ImgAssetConfig(s.X_WAYS_INFECTIOUS), new n.ImgAssetConfig(s.X_PAYS), new n.ImgAssetConfig(s.X_BOMB), new n.ImgAssetConfig(s.X_SPLIT), new n.ImgAssetConfig(s.X_REEL_SPLIT), new n.ImgAssetConfig(s.X_SIZE), new n.ImgAssetConfig(s.X_BET), new n.ImgAssetConfig(s.X_CLUSTER), new n.ImgAssetConfig(s.X_MOUNT), new n.ImgAssetConfig(s.X_CAP), new n.ImgAssetConfig(s.X_BIZARRE), new n.ImgAssetConfig(s.X_ZONE), new n.ImgAssetConfig(s.X_GOD), new n.ImgAssetConfig(s.X_HOLE), new n.ImgAssetConfig(s.X_RIP), new n.ImgAssetConfig(s.SNOW_FLAKE), new n.ImgAssetConfig(s.RATED_R), new n.ImgAssetConfig(s.X_NUDGE_SUPER)]
					}
				}
				s.CHECK_BOX_SMALL_EMPTY = s.makeAssetPath("checkBoxSmallEmpty@2x.png"), s.CHECK_BOX_SMALL_CHECKED = s.makeAssetPath("checkBoxSmallChecked@2x.png"), s.CHECK_BOX = s.makeAssetPath("checkBox@2x.png"), s.SOUND_RING = s.makeAssetPath("ringLoader@2x.png"), s.SOUND_OFF = s.makeAssetPath("soundOff@2x.png"), s.SOUND_ON = s.makeAssetPath("soundOn@2x.png"), s.MODAL_BACKGROUND = s.makeAssetPath("modalBackground@2x.png"), s.PLATE_BASE_9 = s.makeAssetPath("plateBase9@2x.png"), s.PLATE_BASE_9_BLUR_20 = s.makeAssetPath("plateBase9blur20@2x.png"), s.PLATE_BASE_9_BLUR_40 = s.makeAssetPath("plateBase9blur40@2x.png"), s.PLATE_STROKE_9 = s.makeAssetPath("plateStroke9@2x.png"), s.PLATE_BASE_20 = s.makeAssetPath("plateBase20@2x.png"), s.PLATE_BASE_20_BLUR_40 = s.makeAssetPath("plateBase20blur40@2x.png"), s.PLATE_STROKE_20 = s.makeAssetPath("plateStroke20@2x.png"), s.BULLET_SMALL = s.makeAssetPath("bulletSmall@2x.png"), s.BULLET_LARGE = s.makeAssetPath("bulletLarge@2x.png"), s.NAV_ARROW = s.makeAssetPath("navArrow@2x.png"), s.VOL_INSANE = s.makeAssetPath("volInsane@2x.png"), s.VOL_EXTREME = s.makeAssetPath("volExtreme@2x.png"), s.VOL_HIGH = s.makeAssetPath("volHigh@2x.png"), s.VOL_MEDIUM = s.makeAssetPath("volMedium@2x.png"), s.X_NUDGE = s.makeAssetPath("xNudge@2x.png"), s.X_WAYS = s.makeAssetPath("xWays@2x.png"), s.X_WAYS_INFECTIOUS = s.makeAssetPath("xWaysInfectious@2x.png"), s.X_PAYS = s.makeAssetPath("xPays@2x.png"), s.X_BOMB = s.makeAssetPath("xBomb@2x.png"), s.X_SPLIT = s.makeAssetPath("xSplit@2x.png"), s.X_REEL_SPLIT = s.makeAssetPath("xReelSplit@2x.png"), s.X_SIZE = s.makeAssetPath("xSize@2x.png"), s.X_BET = s.makeAssetPath("xBet@2x.png"), s.X_CLUSTER = s.makeAssetPath("xCluster@2x.png"), s.X_MOUNT = s.makeAssetPath("xMount@2x.png"), s.X_CAP = s.makeAssetPath("xCap@2x.png"), s.X_BIZARRE = s.makeAssetPath("xBizarre@2x.png"), s.X_ZONE = s.makeAssetPath("xZone@2x.png"), s.X_GOD = s.makeAssetPath("xGod@2x.png"), s.X_HOLE = s.makeAssetPath("xHole@2x.png"), s.X_RIP = s.makeAssetPath("xRip@2x.png"), s.X_NUDGE_SUPER = s.makeAssetPath("xNudgeSuper@2x.png"), s.SNOW_FLAKE = s.makeAssetPath("censoredSnowFlake@2x.png"), s.RATED_R = s.makeAssetPath("ratedR.png"), s.NOLIMIT_BONUS_ICON = s.makeAssetPath("nolimitBonusIcon@2x.png"), s.NOLIMIT_BOOSTER_ICON = s.makeAssetPath("nolimitBoosterIcon@2x.png"), s.NOLIMIT_BONUS_BET_BACKPLATE = s.makeAssetPath("nolimitBonusBetBackPlate@2x.png"), s.NOLIMIT_BONUS_CLOSE_BUTTON = s.makeAssetPath("closeBtn@2x.png"), s.FEATURE_TICKET_BASE_GOLD = s.makeAssetPath("ticketBaseGold@2x.png"), s.FEATURE_TICKET_GOLD = s.makeAssetPath("ticketGold@2x.png"), s.FEATURE_TICKET_BASE_SILVER = s.makeAssetPath("ticketBaseSilver@2x.png"), s.FEATURE_TICKET_SILVER = s.makeAssetPath("ticketSilver@2x.png"), s.LIMIT_CAP_ON_AMOUNT = s.makeAssetPath("limitCapOnAmount@2x.png"), s.LIMIT_CAP_OFF_AMOUNT = s.makeAssetPath("limitCapOffAmount@2x.png"), s.LIMIT_CAP_ON = s.makeAssetPath("limitCapOn@2x.png"), s.LIMIT_CAP_OFF = s.makeAssetPath("limitCapOff@2x.png"), e.GuiDefaultTextures = s
			},
			78229: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GuiDefaults = void 0;
				const n = i(5117),
					s = i(77616);
				class o {}
				o.DEFAULT_LABEL_STYLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: n.OpenSans.FAMILY,
					fontSize: 20,
					fontStyle: s.FontStyle.NORMAL,
					fontWeight: s.FontWeight.LIGHT
				}), o.DEFAULT_LABEL_STYLE_SMALL = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: n.OpenSans.FAMILY,
					fontSize: 16,
					fontStyle: s.FontStyle.NORMAL,
					fontWeight: s.FontWeight.LIGHT
				}), o.DEFAULT_LABEL_VALUE_STYLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: n.OpenSans.FAMILY,
					fontSize: 20,
					fontStyle: s.FontStyle.NORMAL,
					fontWeight: s.FontWeight.BOLD
				}), o.INTRO_PAGE_TEXT = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: n.OpenSans.FAMILY,
					fontSize: 28,
					fontStyle: s.FontStyle.NORMAL,
					fontWeight: s.FontWeight.NORMAL,
					wordWrap: !0,
					wordWrapWidth: 340,
					breakWords: !0
				}), o.DEFAULT_CONTINUE_BUTTON_LABEL_STYLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: n.OpenSans.FAMILY,
					fontSize: 34,
					fontStyle: s.FontStyle.ITALIC,
					fontWeight: s.FontWeight.EXTRA_BOLD,
					padding: 10
				}), o.DEFAULT_BUTTON_LABEL_STYLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: n.OpenSans.FAMILY,
					fontSize: 30,
					fontStyle: s.FontStyle.NORMAL,
					fontWeight: s.FontWeight.LIGHT
				}), o.DEFAULT_RADIO_BUTTON_LABEL = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: n.OpenSans.FAMILY,
					fontSize: 34,
					fontStyle: s.FontStyle.NORMAL,
					fontWeight: s.FontWeight.NORMAL
				}), o.DEFAULT_CHECKBOX_BUTTON_LABEL = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: n.OpenSans.FAMILY,
					fontSize: 20,
					fontStyle: s.FontStyle.NORMAL,
					fontWeight: s.FontWeight.NORMAL
				}), e.GuiDefaults = o
			},
			85136: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Icon = void 0;
				const n = i(82859),
					s = i(9886);
				class o extends n.Sprite {
					constructor(t) {
						super(t)
					}
					setColor(t) {
						this.tint = s.GuiUtils.getColorFromARGB(t), this.alpha = s.GuiUtils.getAlphaFromARGB(t)
					}
				}
				e.Icon = o
			},
			16124: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ModalWindow = void 0;
				const n = i(61e3),
					s = i(55462),
					o = i(56254),
					r = i(5117),
					a = i(77616),
					l = i(67566),
					h = i(72468),
					u = i(38801),
					c = i(78229),
					d = i(92986);
				class p extends PIXI.Container {
					constructor(t, e, i, n) {
						super(), this.dontShowAgainChecked = !1, this.name = "name", this.init(e, i, n), this.onResize()
					}
					onResize() {
						this.position.set(h.NolimitApplication.screenBounds.left, h.NolimitApplication.screenBounds.top), this._screenCover.width = h.NolimitApplication.screenBounds.width, this._screenCover.height = h.NolimitApplication.screenBounds.height;
						const t = h.NolimitApplication.isLandscape ? 0 : h.NolimitApplication.screenBounds.height - this._modalBackground.height;
						this._modalBackground.position.set(.5 * h.NolimitApplication.screenBounds.width, .5 * t)
					}
					init(t, e, i = !1) {
						this._screenCover = new PIXI.Sprite(PIXI.Texture.WHITE), this._screenCover.tint = 0, this._screenCover.alpha = .6, this._screenCover.interactive = !0, this._screenCover.name = "_screenCover", this._modalBackground = new PIXI.NineSlicePlane(n.ImgLoader.getImgTexture(s.GuiDefaultTextures.MODAL_BACKGROUND), 64, 64, 64, 64), this._modalBackground.width = 640, this._modalBackground.height = 700, this._modalBackground.pivot.set(.5 * this._modalBackground.width, 0), this._modalBackground.name = "_modalBackground", this.mainContentContainer = new PIXI.Container, this.mainContentContainer.name = "mainContentContainer", this.mainContentContainer.position.set(50, 36), this._contentMaxWidth = 540, this._contentMaxHeight = 630, this._customContentContainer = new PIXI.Container, this._customContentContainer.name = "_customContentContainer", this._customContentContainer.addChild(e), this._defaultContent = new PIXI.Container, this._defaultContent.name = "_defaultContent";
						const o = this.createButtons(t);
						o.name = "buttons", o.position.set(0, 490);
						let r = new PIXI.Container;
						r.name = "dontShowAgain", i && r.addChild(this.createDontShowAgain()), u.GuiLayout.align([r, o], 10, u.Align.CENTER, u.Direction.VERTICAL), this._defaultContent.addChild(r, o), this._defaultContent.position.set(Math.floor(.5 * this._contentMaxWidth - .5 * this._defaultContent.width), this._contentMaxHeight - this._defaultContent.height - 30), this._customContentContainer.position.set(.5 * this._contentMaxWidth, .5 * (this._defaultContent.y - this._customContentContainer.height)), this.mainContentContainer.addChild(this._customContentContainer, this._defaultContent), this._modalBackground.addChild(this.mainContentContainer), this.addChild(this._screenCover, this._modalBackground)
					}
					createButtons(t) {
						const e = new PIXI.Container,
							i = [];
						let n = 130;
						for (let s of t) {
							let t = new o.PointerStateColorSet(4278190080, 4278190080, 4278190080, 855638016),
								r = new o.PointerStateColorSet(4278190080, 4278190080, 4278190080, 855638016),
								a = p.BUTTON_TEXT_STYLE;
							const u = new l.LabelButton(s.id, h.NolimitApplication.apiPlugin.translations.translate(s.label), a, r, t);
							u.resizeButtonToLabelWithMargin(10, 10, 10, 10), u.enable(!0), u.addClickCallback((() => {
								s.clickCallback(this, s.id)
							})), e.addChild(u), i.push(u), u.width > n && (n = u.width)
						}
						for (let t of i) t.setSize(n, t.height);
						return u.GuiLayout.align(i, 30, u.Align.CENTER, u.Direction.HORIZONTAL), e
					}
					createDontShowAgain() {
						let t = new o.PointerStateColorSet(4278190080, 4278190080, 4278190080, 855638016);
						const e = c.GuiDefaults.DEFAULT_CHECKBOX_BUTTON_LABEL.clone();
						e.padding = 20, e.fill = "#000000";
						const i = new d.CheckBoxButton("dontShow", h.NolimitApplication.apiPlugin.translations.translate("Don't show again"), e, t, t);
						return i.toggled = !1, i.enable(!0), i.addClickCallback((() => {
							i.toggled = !i.toggled, this.dontShowAgainChecked = i.toggled
						})), i
					}
					open() {
						h.NolimitApplication.addLayer(this.name, this)
					}
					close() {
						h.NolimitApplication.removeLayer(this.name)
					}
				}
				p.BUTTON_TEXT_STYLE = new PIXI.TextStyle({
					fill: "#000000",
					fontFamily: r.OpenSans.FAMILY,
					fontSize: 38,
					fontStyle: a.FontStyle.ITALIC,
					fontWeight: a.FontWeight.EXTRA_BOLD,
					padding: 59
				}), e.ModalWindow = p
			},
			59936: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.TextInput = void 0;
				const n = i(9886),
					s = i(72468);
				class o extends PIXI.Container {
					constructor(t, e, i, n = o.DEFAULT_STYLE, r = "number") {
						super(), this._elementInDom = !1, this._value = 0, this._lastInput = "", this.hasAddedDeFocusListener = !1, this.logData = [], this.onBlur = () => {
							this.log("onBlur");
							const t = parseFloat(this._inputElement.value.replace(",", ".").replace(/[$]/, ""));
							isNaN(t) || t <= 0 ? (this._inputElement.value = "", this._onInputChangedCallback(this.name, void 0)) : this._onInputChangedCallback(this.name, t), this.removeDeFocusListener()
						}, this.deFocusElement = t => {
							this.log("onDeFocusElement"), document.activeElement !== this._inputElement && (this.log("Do Blur!"), this._inputElement.blur(), this.onBlur())
						}, this.name = t, this._onInputChangedCallback = e, this._inputWidth = i, this._inputType = r, this._inputTextStyle = n, this.createDOM(), s.NolimitApplication.events.on(s.NolimitApplication.RESIZE, (() => this.resize()))
					}
					get visible() {
						return !this._inputElement || "block" == this._inputElement.style.display
					}
					set visible(t) {
						this._inputElement && (this._inputElement.style.display = t ? "block" : "none")
					}
					get alpha() {
						return 1 | parseFloat(this._inputElement.style.opacity)
					}
					set alpha(t) {
						this._inputElement && (this._inputElement.style.opacity = t.toString())
					}
					getCss() {
						return ".pixiTextInput input {\n            box-shadow:none;\n        }\n\n        .pixiTextInput input:focus {\n            box-shadow:none !important;\n        }\n\n        .pixiTextInput input:invalid {\n            box-shadow:none !important;\n        }"
					}
					log(t) {
						for (this.logData.push(t); this.logData.length > 15;) this.logData.shift();
						this._debugElement.innerHTML = this.logData.join("<br>")
					}
					createDOM() {
						this._deFocusElement = document.createElement("div"), this._deFocusElement.style.position = "absolute", this._deFocusElement.style.top = "0px", this._deFocusElement.style.left = "0px", this._deFocusElement.style.width = "100%", this._deFocusElement.style.height = "100%", this._deFocusElement.style.backgroundColor = "rgba(0,0,0,0.4)", this._deFocusElement.hidden = !0, this._debugElement = document.createElement("p"), this._debugElement.textContent = "DEBUG", this._debugElement.style.position = "absolute", this._debugElement.style.top = "110px", this._debugElement.style.width = "97%", this._debugElement.style.fontSize = "2em", this._debugElement.style.color = "white", this._debugElement.style.textAlign = "right", this._debugElement.hidden = !0, this._inputElement = document.createElement("input"), this._inputElement.type = this._inputType, this._inputElement.classList.add("pixiTextInput"), this._inputElement.min = "0", this._inputElement.style.opacity = "1", this._inputElement.style.position = "absolute", this._inputElement.style.transformOrigin = "0 0", this._inputElement.style.lineHeight = "1", this._inputElement.style.backgroundColor = "transparent", this._inputElement.style.border = "1px solid", this._inputElement.style.borderRadius = "5px", this._inputElement.style.borderColor = "rgba(255,255,255,0.4)", this._inputElement.style.boxShadow = "none", this._inputElement.style.boxShadow = "none";
						const t = document.createElement("style");
						t.appendChild(document.createTextNode(this.getCss())), document.head.append(t), this.addEventListener(this._inputElement), this._inputElement.style.outline = "none", this._inputElement.style.color = "string" == typeof this._inputTextStyle.fill ? this._inputTextStyle.fill : "#ffffff", this._inputElement.style.fontFamily = "string" == typeof this._inputTextStyle.fontFamily ? this._inputTextStyle.fontFamily : this._inputTextStyle.fontFamily[0], this._inputElement.style.fontSize = this._inputTextStyle.fontSize + "px", this._inputElement.style.fontStyle = this._inputTextStyle.fontStyle, this._inputElement.style.fontWeight = this._inputTextStyle.fontWeight + "px", this._inputElement.style.width = this._inputWidth + "px", this._inputElement.style.padding = "4px", this._inputElement.style.textAlign = "right";
						let e = this.getDOMInputBounds();
						this._gfx = new PIXI.Graphics, this._gfx.beginFill(16711680, 1), this._gfx.drawRect(0, 0, e.width, e.height), this._gfx.endFill(), this._gfx.alpha = 0, this.addChild(this._gfx)
					}
					addEventListener(t) {
						t.addEventListener("focus", (() => {
							this.log("onFocus"), t.style.borderColor = "rgba(255,255,255,0.6)", t.style.color = "string" == typeof this._inputTextStyle.fill ? this._inputTextStyle.fill : "#ffffff", this.addDeFocusListener()
						})), t.addEventListener("blur", (() => {
							this.onBlur()
						})), t.addEventListener("focusout", (() => {
							this.onBlur()
						})), t.addEventListener("keydown", (t => {
							const e = t.keyCode,
								i = !0 === t.ctrlKey || !0 === t.metaKey;
							t.shiftKey || t.altKey ? t.preventDefault() : [46, 8, 9, 27, 13, 110, 188, 190].includes(e) || i || e >= 35 && e <= 39 || (e < 48 || e > 57) && (e < 96 || e > 105) && (t.preventDefault(), t.stopPropagation())
						}))
					}
					addDeFocusListener() {
						this.log("addDeFocusListener"), this.hasAddedDeFocusListener || (window.document.body.addEventListener("click", this.deFocusElement), this._deFocusElement.style.cursor = "pointer", this._deFocusElement.hidden = !1, this.hasAddedDeFocusListener = !0)
					}
					removeDeFocusListener() {
						this.log("removeDeFocusListener"), window.document.body.removeEventListener("click", this.deFocusElement), this._deFocusElement.style.cursor = "default", this._deFocusElement.hidden = !0, this.hasAddedDeFocusListener = !1
					}
					getDOMInputBounds() {
						let t = !1;
						this._elementInDom || (document.body.appendChild(this._inputElement), t = !0);
						let e = this._inputElement.style.transform,
							i = this._inputElement.style.display;
						this._inputElement.style.transform = "", this._inputElement.style.display = "block";
						let n = this._inputElement.getBoundingClientRect();
						return this._inputElement.style.transform = e, this._inputElement.style.display = i, t && document.body.removeChild(this._inputElement), n
					}
					setDomParent(t) {
						this._domParent = t
					}
					addDom() {
						this._domParent ? (this._domParent.appendChild(this._deFocusElement), this._domParent.appendChild(this._debugElement), this._domParent.appendChild(this._inputElement)) : (document.body.appendChild(this._deFocusElement), document.body.appendChild(this._debugElement), document.body.appendChild(this._inputElement)), this.visible = !0, this._elementInDom = !0, this.resize()
					}
					removeDom() {
						this._domParent ? (this._domParent.removeChild(this._deFocusElement), this._domParent.removeChild(this._debugElement), this._domParent.removeChild(this._inputElement)) : (document.body.removeChild(this._deFocusElement), document.body.removeChild(this._debugElement), document.body.removeChild(this._inputElement)), this._elementInDom = !1
					}
					get valueString() {
						return this._value < 0 ? "" : this._value.toString()
					}
					get value() {
						return this._value
					}
					set value(t) {
						isNaN(t) || (this._value = t)
					}
					setElementValue(t) {
						this.value = t, this._inputElement.value = this.valueString, this.value > 0 ? (this._inputElement.style.borderColor = "rgba(255,255,0,0.4)", this._inputElement.style.color = "#ffff00") : (this._inputElement.style.borderColor = "rgba(255,255,255,0.4)", this._inputElement.style.color = "string" == typeof this._inputTextStyle.fill ? this._inputTextStyle.fill : "#ffffff")
					}
					resize() {
						if (!this._elementInDom) return;
						this.toGlobal(this.position), this._inputElement.style.top = "0px", this._inputElement.style.left = "0px";
						const t = this.worldTransform.clone();
						t.scale(s.NolimitApplication.globalScale / s.NolimitApplication.pixiApp.stage.scale.x, s.NolimitApplication.globalScale / s.NolimitApplication.pixiApp.stage.scale.y), this._inputElement.style.transform = n.GuiUtils.pixiMatrixToCSSMatrix(t)
					}
				}
				o.DEFAULT_STYLE = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: "Open Sans",
					fontSize: 20,
					fontStyle: "normal",
					fontWeight: "300"
				}), e.TextInput = o
			},
			68714: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Label = e.Margin = void 0;
				const n = i(9886),
					s = i(78229),
					o = i(72587);
				e.Margin = class {
					constructor(t, e, i, n) {
						this.top = t, this.right = e || this.top, this.bottom = i || this.top, this.left = n || this.right
					}
				};
				class r extends PIXI.Container {
					get width() {
						return this._label.width
					}
					get height() {
						return this._label.height
					}
					get tint() {
						return this._label.tint
					}
					set tint(t) {
						this._label.tint = t
					}
					constructor(t, e = s.GuiDefaults.DEFAULT_LABEL_STYLE) {
						super(), this._label = new o.NLCText(t, e.clone()), this.name = "Label[" + t + "]", this.anchor = new PIXI.ObservablePoint(((...t) => this.onAnchorUpdate(t)), this), this.addChild(this._label)
					}
					setColor(t) {
						const e = this._label.getStyleClone();
						e.fill = n.GuiUtils.getColorFromARGB(t), this._label.setStyle(e), this.alpha = n.GuiUtils.getAlphaFromARGB(t)
					}
					addBackPlate(t, e) {
						this._backPlateUpdateCallback = e, this.addChild(t), this.addChild(this._label), this.updateBackPlate()
					}
					set text(t) {
						this._label.text = t, this.updateBackPlate()
					}
					get text() {
						return this._label.text
					}
					getStyleClone() {
						return this._label.getStyleClone()
					}
					setStyle(t) {
						this._label.setStyle(t)
					}
					onAnchorUpdate(t) {
						this._label.anchor.set(this.anchor.x, this.anchor.y), this.updateBackPlate()
					}
					updateBackPlate() {
						this._backPlateUpdateCallback && this._backPlateUpdateCallback()
					}
				}
				e.Label = r
			},
			68554: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LabeledValue = void 0;
				const n = i(68714),
					s = i(78229);
				class o extends PIXI.Container {
					get label() {
						return this._label
					}
					get value() {
						return this._value
					}
					constructor(t, e, i, o = s.GuiDefaults.DEFAULT_LABEL_STYLE, r = s.GuiDefaults.DEFAULT_LABEL_VALUE_STYLE) {
						super(), this._margin = 10, this._anchorPoint = new PIXI.Point(0, 0), this.name = t, this._label = new n.Label(e, o), this._value = new n.Label(i.toString(), r), this.addChild(this._label), this.addChild(this._value), this.setAlignment()
					}
					setTextSize(t) {
						const e = this._label.getStyleClone();
						e.fontSize = t;
						const i = this._value.getStyleClone();
						i.fontSize = t, this._label.setStyle(e), this._value.setStyle(i), this.setAlignment(), this.setPivot()
					}
					setAlignment() {
						this._label.position.set(0, 0), this._value.position.set(this._label.width + this._margin, 0)
					}
					setColor(t) {
						this._label.tint = t, this._value.tint = t
					}
					setValue(t) {
						this._value.text = t, this.setAlignment(), this.setPivot()
					}
					setLabel(t) {
						this._label.text = t, this.setAlignment(), this.setPivot()
					}
					setPivot() {
						this.pivot.set(this.width * this._anchorPoint.x, this.height * this._anchorPoint.y)
					}
					setAnchor(t, e) {
						this._anchorPoint = new PIXI.Point(t, e), this.setAlignment(), this.setPivot()
					}
				}
				e.LabeledValue = o
			},
			66516: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GuiPlugin = void 0;
				const n = i(72468),
					s = i(5117),
					o = i(50108),
					r = i(55462),
					a = i(61e3);
				e.GuiPlugin = class {
					constructor() {
						this.name = "GuiPlugin"
					}
					init() {
						const t = new o.FontLoader(n.NolimitApplication.resourcePath);
						t.add(s.OpenSans.NORMAL_300), t.add(s.OpenSans.NORMAL_400), t.add(s.OpenSans.NORMAL_700), t.add(s.OpenSans.ITALIC_700), t.add(s.OpenSans.ITALIC_800);
						const e = new a.ImgLoader(n.NolimitApplication.resourcePath);
						for (let t of r.GuiDefaultTextures.getImgConfigs()) e.add(t.name, t.url);
						return Promise.all([e.load(), t.load()]).then((t => Promise.resolve(this)))
					}
					getReady() {
						return Promise.resolve(this)
					}
					getReadyToStart() {
						return Promise.resolve(this)
					}
					start() {
						return Promise.resolve(this)
					}
				}
			},
			11877: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GUIScrollContainer = void 0;
				const n = i(2059),
					s = i(94398),
					o = i(56736);
				class r extends PIXI.Container {
					constructor(t, e, i = !0, r = !0, a = !1, l) {
						super(), this.scrollEnabled = !0, this.setScrollDelta = (t, e = 0, i = 0) => {
							this.scrollEnabled && (this.setActiveScroller(t), this.checkAllowedDirections(e, i), this.setScrollTarget(t, this._scrollTarget.x + e, this._scrollTarget.y + i))
						}, this.setScrollTarget = (t, e, i) => {
							null != e && this._hasScroll.x && this._directionAllowed.x && (this._scrollTarget.x = e), null != i && this._hasScroll.y && this._directionAllowed.y && (this._scrollTarget.y = i), this.animate()
						}, this._defaultAllowedDirections = {
							x: i,
							y: r
						}, this._hasScroll = {
							x: !1,
							y: !1
						}, this._directionAllowed = {
							x: !0,
							y: !0
						}, this._maskContentSizeDiff = new PIXI.Point, this._scrollTarget = new PIXI.Point, this._maskSize = {
							width: t,
							height: e
						}, this._scrollMask = new PIXI.Graphics, this._scrollMask.name = "GuiScrollerMask", this._content = new s.Scroller(this);
						const h = {
							color: (null == l ? void 0 : l.color) || 16777215,
							thickness: (null == l ? void 0 : l.thickness) || 7.5
						};
						this._scrollBarVertical = new o.ScrollBar(this, !0, !a, h);
						const u = {
							color: (null == l ? void 0 : l.color) || 16777215,
							thickness: (null == l ? void 0 : l.thickness) || 5
						};
						this._scrollBarHorizontal = new o.ScrollBar(this, !1, !0, u), this._mouseScrollEvent = new n.MouseScroller(this), this.addChild(this._scrollMask), this.addChild(this._content), this.addChild(this._scrollBarVertical), this.addChild(this._scrollBarHorizontal), this.mask = this._scrollMask, this.drawMask(), this._scrollBarVertical.position.x = this._maskSize.width, this._scrollBarHorizontal.position.y = this._maskSize.height
					}
					reAddMouseHoverListener() {
						this._mouseScrollEvent.reAddHoverListener()
					}
					resize(t, e) {
						this._maskSize = {
							width: t,
							height: e
						}, this.drawMask(), this._scrollBarVertical.position.x = this._maskSize.width, this._scrollBarHorizontal.position.y = this._maskSize.height, this.updateContent()
					}
					addContent(t) {
						this._content.addChild(t), this.updateContent()
					}
					removeContent(t) {
						this._content.removeChild(t), this.updateContent()
					}
					removeAllContent() {
						this._content.removeChildren(), this.updateContent()
					}
					updateContent() {
						this.updateHitArea(), this.checkNeedsScroll()
					}
					drawMask() {
						this._scrollMask.clear(), this._scrollMask.beginFill(16711680), this._scrollMask.drawRect(0, 0, this._maskSize.width, this._maskSize.height), this._scrollMask.endFill()
					}
					checkNeedsScroll() {
						const t = this._content.getLocalBounds();
						this._maskContentSizeDiff = new PIXI.Point(t.right - this._maskSize.width, t.bottom - this._maskSize.height);
						const e = this._maskContentSizeDiff.x > 0,
							i = this._maskContentSizeDiff.y > 0;
						this._scrollBarHorizontal.setBarScale(this._scrollMask.width, t.right), this._scrollBarVertical.setBarScale(this._scrollMask.height, t.bottom), this._hasScroll.x != e && this.setScrollTarget(this, 0, void 0), this._hasScroll.y != i && this.setScrollTarget(this, void 0, 0), this._hasScroll.x = e, this._hasScroll.y = i, this._hasScroll.x && this._scrollBarHorizontal.resize(this._scrollMask.width, t.right), this._hasScroll.y && this._scrollBarVertical.resize(this._scrollMask.height, t.bottom), this._scrollBarHorizontal.enable(this._hasScroll.x && this._defaultAllowedDirections.x), this._scrollBarVertical.enable(this._hasScroll.y && this._defaultAllowedDirections.y), this._content.enable(this._hasScroll.x && this._defaultAllowedDirections.x || this._hasScroll.y && this._defaultAllowedDirections.y), this._mouseScrollEvent.enable(this._hasScroll.x && this._defaultAllowedDirections.x || this._hasScroll.y && this._defaultAllowedDirections.y)
					}
					updateHitArea() {
						this._content.hitArea = new PIXI.Rectangle(-this._content.x, -this._content.y, this._maskSize.width, this._maskSize.height)
					}
					clamp(t, e, i) {
						return Math.max(e, Math.min(t, i))
					}
					animate() {
						this._scrollTarget.x = this.clamp(this._scrollTarget.x, -Math.abs(this._maskContentSizeDiff.x), 0), this._scrollTarget.y = this.clamp(this._scrollTarget.y, -Math.abs(this._maskContentSizeDiff.y), 0), this._content.setScrollPosition(this._scrollTarget).eventCallback("onComplete", (() => this.updateHitArea())), this._scrollBarVertical.setScrollPosition(this._scrollTarget), this._scrollBarHorizontal.setScrollPosition(this._scrollTarget)
					}
					setActiveScroller(t) {
						this._activeScroller != t && (this._content.abort(), this._directionAllowed.x = this._defaultAllowedDirections.x, this._directionAllowed.y = this._defaultAllowedDirections.y), this._activeScroller = t, this._activeScroller == this._mouseScrollEvent && (this._directionAllowed.x = this._defaultAllowedDirections.x, this._directionAllowed.y = this._defaultAllowedDirections.y)
					}
					checkAllowedDirections(t, e) {
						this._directionAllowed.x && this._directionAllowed.y && (Math.abs(e) > Math.abs(t) ? (this._directionAllowed.y = !0, this._directionAllowed.x = !this._hasScroll.y) : (this._directionAllowed.y = !this._hasScroll.x, this._directionAllowed.x = !0))
					}
				}
				e.GUIScrollContainer = r
			},
			2059: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.MouseScroller = void 0;
				var i = PIXI.InteractionEvent;
				e.MouseScroller = class {
					constructor(t) {
						this.onMouseScrollLocal = t => {
							const e = t;
							e.preventDefault(), void 0 !== e.deltaX ? this._delta.set(e.deltaX, e.deltaY) : this._delta.set(1 == e.axis ? 60 * e.detail : 0, 2 == e.axis ? 60 * e.detail : 0), this._scrollContainer.setScrollDelta(this, -this._delta.x, -this._delta.y)
						}, this.onHover = t => {
							this._bound || (document.addEventListener("mousewheel", this.onMouseScrollLocal, {
								once: !1,
								passive: !1
							}), document.addEventListener("DOMMouseScroll", this.onMouseScrollLocal, {
								once: !1,
								passive: !1
							}), this._bound = !0)
						}, this.onMouseOut = t => {
							this._bound && (document.removeEventListener("mousewheel", this.onMouseScrollLocal), document.removeEventListener("DOMMouseScroll", this.onMouseScrollLocal), this._bound = !1)
						}, this.name = "MouseScroller", this._scrollContainer = t, this._delta = new PIXI.Point, this._bound = !1
					}
					reAddHoverListener() {
						this.onHover(new i)
					}
					enable(t) {
						t ? this.startEvent() : this.stopEvent(), this._enabled = t
					}
					stopEvent() {
						this._bound && (document.removeEventListener("mousewheel", this.onMouseScrollLocal), document.removeEventListener("DOMMouseScroll", this.onMouseScrollLocal), this._bound = !1), this._enabled && (this._scrollContainer.removeListener("mouseover", this.onHover), this._scrollContainer.removeListener("mouseout", this.onMouseOut))
					}
					startEvent() {
						this._enabled || (this._scrollContainer.on("mouseover", this.onHover), this._scrollContainer.on("mouseout", this.onMouseOut), this._scrollContainer.interactive = !0)
					}
				}
			},
			56736: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ScrollBar = void 0;
				const n = i(94398),
					s = i(13006);
				class o extends n.Scroller {
					constructor(t, e, i, n) {
						super(t), this._useFadeTween = !0, this.name = "ScrollBar" + (e ? "Vertical" : "Horizontal"), this._vertical = e, this._margin = new PIXI.Point(5, 5), this._useFadeTween = i, this._gfx = new PIXI.Graphics, this._scrollConfig = n, this.addChild(this._gfx)
					}
					setBarScale(t, e) {
						this._barScale = t / e
					}
					resize(t, e) {
						this._barScale = t / e;
						const i = this._barScale * t;
						let n, s = this._scrollConfig.thickness;
						this._gfx.clear(), this._vertical ? (n = new PIXI.Rectangle(-6 * s, this._margin.y, 6 * s, i - 2 * this._margin.y), this._gfx.beginFill(this._scrollConfig.color, 1), this._gfx.drawRoundedRect(-(s + this._margin.x), this._margin.y, s, i - 2 * this._margin.y, 5)) : (n = new PIXI.Rectangle(this._margin.x, -6 * s, i - 2 * this._margin.x, 6 * s), this._gfx.beginFill(this._scrollConfig.color, 1), this._gfx.drawRect(this._margin.x, -(s + this._margin.y), i - 2 * this._margin.x, s)), this.hitArea = n, this._gfx.endFill()
					}
					setScrollPosition(t) {
						return this.alpha = 1, this._fadeTween && this._fadeTween.kill(), this._useFadeTween && (this._fadeTween = s.TweenLite.to(this, .2, {
							duration: .2,
							alpha: .4,
							delay: 1
						})), this._scrollTween && this._scrollTween.kill(), this._vertical ? this._scrollTween = s.TweenLite.to(this.position, .2, {
							duration: .2,
							y: -t.y * this._barScale,
							ease: s.Power2.easeOut
						}) : this._scrollTween = s.TweenLite.to(this.position, .2, {
							duration: .2,
							x: -t.x * this._barScale,
							ease: s.Power2.easeOut
						}), this._scrollTween
					}
					start() {
						super.start(), this.visible = this._enabled
					}
					stop() {
						super.stop(), this.visible = this._enabled
					}
					calculateDelta(t, e) {
						let i = 0,
							n = 0;
						return this._vertical ? n = (t.y - e.y) / -this._barScale : i = (t.x - e.x) / -this._barScale, new PIXI.Point(i, n)
					}
				}
				e.ScrollBar = o
			},
			94398: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Scroller = void 0;
				const n = i(13006);
				class s extends PIXI.Container {
					constructor(t) {
						super(), this._enabled = !1, this.onDragStart = t => {
							this.data = t.data, this._prevScrollTarget = this.data.getLocalPosition(this.parent), this.setScrollDelta(this._prevScrollTarget, !0), this.on("pointermove", this.onDragMove)
						}, this.onDragMove = t => {
							if (this.data) {
								const t = this.data.getLocalPosition(this.parent);
								this.setScrollDelta(t)
							}
						}, this.onDragEnd = t => {
							if (this.data) {
								const t = this.data.getLocalPosition(this.parent);
								this.slideToStop(), this.setScrollDelta(t)
							}
							this.data = void 0, this._prevScrollTarget = void 0, this.removeListener("pointermove", this.onDragMove)
						}, this.name = "ScrollContent", this._speed = new PIXI.Point(0, 0), this._timestamp = 0, this._scrollContainer = t, this.enable(!1), this.setScrollPosition(new PIXI.Point(0, 0))
					}
					enable(t) {
						t ? this.start() : this.stop()
					}
					start() {
						this._enabled || (this._enabled = !0, this.interactive = !0, this.buttonMode = !0, this.on("pointerdown", this.onDragStart), this.on("pointerup", this.onDragEnd), this.on("pointerupoutside", this.onDragEnd))
					}
					stop() {
						this.interactive = !1, this.buttonMode = !1, this.removeListener("pointerdown", this.onDragStart), this.removeListener("pointerup", this.onDragEnd), this.removeListener("pointerupoutside", this.onDragEnd), this._enabled = !1
					}
					setScrollDelta(t, e = !1) {
						const i = e ? void 0 : this,
							n = this.calculateDelta(t, this._prevScrollTarget);
						this._scrollContainer.setScrollDelta(i, n.x, n.y), this._prevScrollTarget = t
					}
					slideToStop() {
						Math.abs(this._speed.x) < 2 && Math.abs(this._speed.y) < 2 || (this._slideTween = new n.TweenLite(this._speed, 2, {
							x: 0,
							y: 0,
							ease: n.Power2.easeOut,
							onUpdate: () => {
								this._scrollContainer.setScrollDelta(this, this._speed.x, this._speed.y)
							},
							onComplete: () => {
								this._scrollContainer.setScrollDelta(void 0, this._speed.x, this._speed.y)
							}
						}))
					}
					setScrollPosition(t) {
						return null == this._slideTween && this.calcSpeed(t), n.TweenLite.to(this.position, .2, {
							x: t.x,
							y: t.y,
							ease: n.Power2.easeOut
						})
					}
					abort() {
						this._slideTween && (this._slideTween.kill(), this._slideTween = void 0, this._speed.set(0, 0))
					}
					calcSpeed(t) {
						const e = Date.now(),
							i = e - this._timestamp;
						let n = new PIXI.Point(Math.abs(this.position.x) - Math.abs(t.x), Math.abs(this.position.y) - Math.abs(t.y));
						this._speed.set(Math.round(n.x / i), Math.round(n.y / i)), this._timestamp = e
					}
					calculateDelta(t, e) {
						return new PIXI.Point(t.x - e.x, t.y - e.y)
					}
				}
				e.Scroller = s
			},
			38801: (t, e) => {
				"use strict";
				var i, n;
				Object.defineProperty(e, "__esModule", {
						value: !0
					}), e.GuiLayout = e.Direction = e.Align = void 0, (n = e.Align || (e.Align = {}))[n.LEFT = 0] = "LEFT", n[n.TOP = 0] = "TOP", n[n.CENTER = .5] = "CENTER", n[n.RIGHT = 1] = "RIGHT", n[n.BOTTOM = 1] = "BOTTOM",
					function(t) {
						t[t.VERTICAL = 0] = "VERTICAL", t[t.HORIZONTAL = 1] = "HORIZONTAL"
					}(i = e.Direction || (e.Direction = {}));
				class s {
					static justify(t, e, n, o) {
						n = null != n ? n : 0, o = null != o ? o : i.HORIZONTAL;
						let r = 0;
						for (let e = 0; e < t.length; e++) {
							const n = t[e].getLocalBounds();
							o == i.VERTICAL ? r += n.bottom : r += n.right
						}
						const a = (e - r) / (t.length - 1);
						s.align(t, a, n, o)
					}
					static align(t, e, n, s) {
						e = null != e ? e : 0, n = null != n ? n : 0, s = null != s ? s : i.HORIZONTAL;
						let o = 0,
							r = 0;
						for (let n = 0; n < t.length; n++) {
							const a = t[n],
								l = a.getLocalBounds();
							s == i.VERTICAL ? (a.position.y = o, o += l.bottom + e, r = l.right > r ? l.right : r) : (a.position.x = o, o += l.right + e, r = l.bottom > r ? l.bottom : r)
						}
						for (let e of t) {
							const t = e.getLocalBounds();
							s == i.VERTICAL ? e.position.x = (r - t.right) * n : e.position.y = (r - t.bottom) * n
						}
					}
					static modifyMargin(t, e, n, s) {
						e = null != e ? e : 0, n = null != n ? n : i.HORIZONTAL;
						let o = 0;
						const r = t.getLocalBounds();
						let a, l, h = 0,
							u = 0;
						s && (a = s.getLocalBounds(), l = s.getGlobalPosition(), h = a.bottom + l.y, u = a.right + l.x), n == i.VERTICAL ? (o = s ? h : 0, o += r.bottom + e, t.position.y = o) : (o = s ? u : 0, o += r.right + e, t.position.x = o)
					}
					static getLargestSize(t) {
						const e = new PIXI.Point(0, 0);
						for (let i of t) {
							const t = i.getBounds();
							e.x = t.right > e.x ? t.right : e.x, e.y = t.bottom > e.y ? t.bottom : e.y
						}
						return e
					}
					static gridLayout(t, e) {
						let i = 0,
							n = 0;
						for (let e of t) {
							const t = e.getBounds();
							i = t.width > i ? t.width : i, n = t.height > n ? t.height : n
						}
						const s = Math.floor(e / i);
						for (let e = 0; e < t.length; e++) {
							const o = t[e];
							o.x = Math.floor(e % s) * i, o.y = Math.floor(e / s) * n
						}
					}
					static offset(t, e = 0, i = 0) {
						for (let n of t) n.x += e, n.y += i
					}
				}
				e.GuiLayout = s
			},
			9886: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GuiUtils = void 0, e.GuiUtils = class {
					static getAlphaFromARGB(t) {
						return (t >> 24 & 255) / 255
					}
					static getColorFromARGB(t) {
						return 16777215 & t
					}
					static getARGB(t, e = 1) {
						return 255 * e << 24 | t
					}
					static pixiMatrixToCSSMatrix(t) {
						return "matrix(" + [t.a, t.b, t.c, t.d, t.tx, t.ty].join(",") + ")"
					}
					static getDOMRelativeWorldTransform(t, e, i) {
						let n = e.worldTransform.clone();
						return n.scale(t.resolution, t.resolution), n.scale(i.width / t.width, i.height / t.height), n
					}
				}
			},
			38472: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SlideShow = void 0;
				const n = i(13006),
					s = i(46980),
					o = i(85136),
					r = i(85733),
					a = i(55462),
					l = i(56254),
					h = i(9886),
					u = i(38801),
					c = i(14615),
					d = i(17280);
				var p;
				! function(t) {
					t[t.LEFT = -1] = "LEFT", t[t.NONE = 0] = "NONE", t[t.RIGHT = 1] = "RIGHT"
				}(p || (p = {}));
				class _ extends PIXI.Container {
					get slidePixelsPerSecond() {
						return this._slidePixelsPerSecond
					}
					set slidePixelsPerSecond(t) {
						this._slidePixelsPerSecond = t
					}
					get pageFlipDelay() {
						return this._pageFlipDelay
					}
					set pageFlipDelay(t) {
						this._pageFlipDelay = t
					}
					get isSinglePaged() {
						return !!this._pages && 1 == this._pages.length
					}
					constructor(t, e, i, n) {
						super(), this._pageAnimations = [], this._slideDistance = 0, this._pageFlipDelay = _.DEFAULT_PAGE_FLIP_DELAY, this._slidePixelsPerSecond = 4e3, this._currentIndex = -1, this._colors = n, this._slideShowBackground = this.createSlideShowBackground(n.backgroundColor, n.backgroundAlpha), this._borderTop = e, this._borderBottom = i, this._borderBottom.position.y = this._slideShowBackground.height, this.setupPages(t), this.createNavigation(), this.addChild(this._slideShowBackground, this._pageContainer, this._borderTop, this._borderBottom, this._navButtonsContainer, this._navBulletsContainer)
					}
					createNavigation() {
						if (this._pageContainer.position.set(0, 195), this.isSinglePaged) this._navButtonsContainer = new PIXI.Container, this._navBulletsContainer = new PIXI.Container;
						else {
							this._navBulletsContainer = this.createNavBullets(this._pages.length), this._navBulletsContainer.name = "_navBulletsContainer", this._navButtonsContainer = this.createNavButtons();
							const t = .5 * this._navBulletsContainer.width + 15;
							this._navButtons[0].position.set(-t, .5 * this._navBulletsContainer.height), this._navButtons[1].position.set(t, .5 * this._navBulletsContainer.height), this._navButtonsContainer.name = "_navButtonsContainer", this._navBulletsContainer.position.set(0, 410), this._navButtonsContainer.position.set(0, 410)
						}
					}
					createSlideShowBackground(t = 0, e = .4) {
						const i = new PIXI.Container,
							n = new PIXI.Sprite(PIXI.Texture.WHITE);
						return n.width = 1680, n.height = 390, n.anchor.set(.5, 0), n.tint = t, n.alpha = e, i.addChild(n), i
					}
					changeWidth(t) {
						this._slideDistance = .5 * t + 360
					}
					resize() {
						for (let t of this._pages) t.resize()
					}
					startDrag() {
						null != this._scheduledFlip && this._scheduledFlip.isActive() && this._scheduledFlip.pause()
					}
					endDrag() {
						null != this._scheduledFlip && this._scheduledFlip.paused() && this._scheduledFlip.resume()
					}
					start() {
						this.isSinglePaged ? this.showSinglePage() : this.navToIndex(0)
					}
					pause() {
						this.stop()
					}
					resume() {
						this.isSinglePaged ? this.showSinglePage() : this.navToIndex(this._currentIndex + 1, p.LEFT)
					}
					stop() {
						for (let t of this._pages) t.enable(!1);
						this._scheduledFlip && this._scheduledFlip.kill(), this._currentPageSwitchAnimation && this._currentPageSwitchAnimation.isActive() && (this._currentPageSwitchAnimation.progress(1), this._currentPageSwitchAnimation.kill())
					}
					showSinglePage() {
						this._pages[0].position.set(0, 0), this._pages[0].alpha = 1, this._pages[0].visible = !0
					}
					scheduleNextAutoFlip() {
						this._scheduledFlip && this._scheduledFlip.kill(), this._scheduledFlip = new n.TweenLite(this, this._pageFlipDelay, {
							onComplete: () => {
								this.next()
							}
						})
					}
					next() {
						this.navToIndex(this._currentIndex + 1, p.LEFT)
					}
					prev() {
						this.navToIndex(this._currentIndex - 1, p.RIGHT)
					}
					navToIndex(t, e = p.NONE) {
						let i = t % this._pages.length;
						i < 0 && (i += this._pages.length), this.switchToPage(i, e);
						for (let t of this._navBullets) t.button.toggled = t.index == i, t.button.enable(t.index != i);
						this._currentIndex = i, this.scheduleNextAutoFlip()
					}
					switchToPage(t, e) {
						const i = new n.TimelineLite;
						this._currentIndex >= 0 && this._pages[this._currentIndex].enable(!1), this._pages[t].enable(!1), this._currentIndex >= 0 && i.add(this.createTransitionAnimation(this._currentIndex, this._pageBackgrounds[this._currentIndex], !1, e)), i.add(this.createTransitionAnimation(t, this._pageBackgrounds[t], !0, e), 0), i.add((() => {
							this._pages[t].enable(!0)
						})), this._currentPageSwitchAnimation && this._currentPageSwitchAnimation.isActive() && (this._currentPageSwitchAnimation.progress(1), this._currentPageSwitchAnimation.kill()), this._currentPageSwitchAnimation = i
					}
					createTransitionAnimation(t, e, i, s) {
						const o = this._pages[t],
							r = this._slideDistance * s;
						let a = Math.max(Math.abs(r) - Math.abs(o.position.x), 0) / this._slidePixelsPerSecond;
						a = 0 == r ? .2 : a;
						const l = new n.TimelineLite;
						return i ? (l.add((() => {
							o.position.x = -r, o.visible = !0, e.visible = !0, e.alpha = 0, this._pageBackgroundContainer.addChild(e)
						})), l.add([new n.TweenLite(e, a, {
							alpha: 1,
							ease: n.Linear.easeNone
						}), new n.TweenLite(o, a, {
							alpha: 1,
							ease: n.Linear.easeNone
						}), new n.TweenLite(o.position, a, {
							x: 0
						})])) : (l.add([new n.TweenLite(e, a, {
							alpha: 0,
							ease: n.Linear.easeNone
						}), new n.TweenLite(o, a, {
							alpha: 0,
							ease: n.Linear.easeNone
						}), new n.TweenLite(o.position, a, {
							x: r
						})]), l.eventCallback("onComplete", (() => {
							o.visible = !1, e.visible = !1, o.position.x = 0, e.alpha = 0
						}))), l
					}
					createNavBullets(t) {
						const e = new PIXI.Container;
						this._navBullets = [];
						for (let i = 0; i < t; i++) {
							const t = new d.SlideShowBullet(i, (t => this.navToIndex(i)), this._colors.bulletColor);
							this._navBullets.push(e.addChild(t))
						}
						return u.GuiLayout.align(this._navBullets, 10, u.Align.CENTER, u.Direction.HORIZONTAL), e.pivot.set(.5 * e.width, 0), e
					}
					createNavButtons() {
						const t = new PIXI.Container,
							e = r.SvgLoader.getSvgTexture(a.GuiDefaultTextures.NAV_ARROW).clone();
						e.rotate = 12;
						const i = new s.PointerStateIconSet(new o.Icon(e)),
							n = new l.PointerStateColorSet(h.GuiUtils.getARGB(this._colors.bulletColor, 1), h.GuiUtils.getARGB(this._colors.bulletColor, .25)),
							u = new c.IconButton("navPrev", i, n);
						u.addClickCallback((() => this.prev())), u.enable(!0), u.pivot.set(u.width, .5 * u.height);
						const d = r.SvgLoader.getSvgTexture(a.GuiDefaultTextures.NAV_ARROW),
							p = new s.PointerStateIconSet(new o.Icon(d)),
							_ = new l.PointerStateColorSet(h.GuiUtils.getARGB(this._colors.bulletColor, 1), h.GuiUtils.getARGB(this._colors.bulletColor, .25)),
							m = new c.IconButton("navPrev", p, _);
						return m.addClickCallback((() => this.next())), m.enable(!0), m.pivot.set(0, .5 * m.height), this._navButtons = [u, m], t.addChild(u, m), t
					}
					setupPages(t) {
						this._pages = t, this._pageBackgroundContainer = new PIXI.Container, this._pageBackgroundContainer.name = "_pageBackgroundContainer", this._pageBackgrounds = [], this._pageContainer = new PIXI.Container, this._pageContainer.name = "_pageContainer", this._pageContainer.addChild(this._pageBackgroundContainer);
						for (let e of t) {
							e.visible = !1, e.alpha = 0, this.isSinglePaged || e.setSwipeCallbacks((() => this.startDrag()), (() => this.endDrag()), (() => this.prev()), (() => this.next())), this._pageContainer.addChild(e);
							const t = this.createPageBackground(e);
							this._pageBackgrounds.push(t), this._pageBackgroundContainer.addChild(t)
						}
					}
					createPageBackground(t) {
						const e = new PIXI.Sprite(PIXI.Texture.WHITE);
						return null != t.backgroundColor ? (e.anchor.set(.5, .5), e.width = 1680, e.height = 390, e.visible = !1, e.alpha = 0, e.tint = t.backgroundColor) : e.texture = PIXI.Texture.EMPTY, e
					}
				}
				_.DEFAULT_PAGE_FLIP_DELAY = 10, e.SlideShow = _
			},
			17280: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SlideShowBullet = void 0;
				const n = i(66515),
					s = i(46980),
					o = i(85136),
					r = i(85733),
					a = i(55462),
					l = i(56254),
					h = i(9886);
				class u extends PIXI.Container {
					constructor(t, e, i = 16777215) {
						super();
						const u = new s.PointerStateIconSet(new o.Icon(r.SvgLoader.getSvgTexture(a.GuiDefaultTextures.BULLET_LARGE))),
							c = new s.PointerStateIconSet(new o.Icon(r.SvgLoader.getSvgTexture(a.GuiDefaultTextures.BULLET_SMALL))),
							d = new l.PointerStateColorSet(h.GuiUtils.getARGB(i, 1));
						this.index = t, this.button = new n.IconToggleButton(`navBullet[${t}]`, u, d, c), this.button.addClickCallback(e), this.button.enable(!0), this.addChild(this.button)
					}
				}
				e.SlideShowBullet = u
			},
			58295: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SlideShowPage = void 0;
				const n = i(78229),
					s = i(13006),
					o = i(72587);
				class r extends PIXI.Container {
					constructor(t, e, i, s = !0) {
						if (super(), this._snapBackDistance = 360, this.onDragStart = t => {
								this.data = t.data, this._startPos = new PIXI.Point(this.position.x, this.position.y), this._prevScrollTarget = this.data.getLocalPosition(this.parent), this.setScrollDelta(this._prevScrollTarget), this.on("pointermove", this.onDragMove), this._startDragCallback && this._startDragCallback()
							}, this.onDragMove = t => {
								if (this.data) {
									const t = this.data.getLocalPosition(this.parent);
									this.setScrollDelta(t), Math.abs(this.position.x) - Math.abs(this._startPos.x) > this._snapBackDistance && this.onDragEnd()
								}
							}, this.onDragEnd = t => {
								if (this.data) {
									const t = this.data.getLocalPosition(this.parent);
									this.setScrollDelta(t), this.snap()
								}
								this.data = void 0, this._prevScrollTarget = void 0, this.removeListener("pointermove", this.onDragMove), this._endDragCallback && this._endDragCallback()
							}, this.backgroundColor = i, null != t) {
							const e = new PIXI.Sprite(t);
							e.anchor.x = s ? 1 : 0, e.anchor.y = .5, e.position.x = s ? -10 : 10, this.addChild(e)
						}
						if (null != e) {
							const t = new o.NLCText(e, n.GuiDefaults.INTRO_PAGE_TEXT);
							t.anchor.x = s ? 0 : 1, t.anchor.y = .5, t.position.x = s ? 10 : -10, this.addChild(t)
						}
						this.hitArea = new PIXI.Rectangle(-840, -195, 1680, 390)
					}
					resize() {}
					setSwipeCallbacks(t, e, i, n) {
						this._startDragCallback = t, this._endDragCallback = e, this._prevCallback = i, this._nextCallback = n
					}
					enable(t) {
						t ? this.start() : this.stop()
					}
					start() {
						this._enabled || (this._enabled = !0, this.interactive = !0, this.buttonMode = !0, this.on("pointerdown", this.onDragStart), this.on("pointerup", this.onDragEnd), this.on("pointerupoutside", this.onDragEnd))
					}
					stop() {
						this.interactive = !1, this.buttonMode = !1, this.removeListener("pointerdown", this.onDragStart), this.removeListener("pointerup", this.onDragEnd), this.removeListener("pointerupoutside", this.onDragEnd), this._enabled = !1
					}
					setScrollDelta(t) {
						const e = this.calculateDelta(t, this._prevScrollTarget);
						this.position.x += e.x, this._prevScrollTarget = t
					}
					calculateDelta(t, e) {
						return new PIXI.Point(t.x - e.x, t.y - e.y)
					}
					snap() {
						Math.abs(this.position.x) - Math.abs(this._startPos.x) <= this._snapBackDistance ? new s.TweenLite(this.position, .2, {
							x: this._startPos.x,
							y: this._startPos.y
						}) : this.position.x > this._startPos.x ? this._prevCallback && this._prevCallback() : this._nextCallback && this._nextCallback()
					}
				}
				e.SlideShowPage = r
			},
			82748: (t, e) => {
				"use strict";
				var i;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.APIBetType = void 0, (i = e.APIBetType || (e.APIBetType = {})).NORMAL_BET = "normalBet", i.FREE_BET = "freeBet", i.ZERO_BET = "zeroBet", i.GAMBLE_BET = "gambleBet", i.PICK_AND_CLICK_BET = "pickAndClickBet", i.FEATURE_BET = "featureBet"
			},
			52780: (t, e) => {
				"use strict";
				var i;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.APIErrorCode = void 0, (i = e.APIErrorCode || (e.APIErrorCode = {}))[i.UNKNOWN = 0] = "UNKNOWN", i[i.JAVASCRIPT = -1001] = "JAVASCRIPT", i[i.PROMISE = -1002] = "PROMISE", i[i.COMMUNICATION = -1003] = "COMMUNICATION", i[i.REPLAY = -1004] = "REPLAY", i[i.GRAPHICS = -1005] = "GRAPHICS", i[i.PLUGIN_LAUNCH = -1007] = "PLUGIN_LAUNCH", i[i.FORBIDDEN = 403] = "FORBIDDEN", i[i.BAD_GATEWAY = 502] = "BAD_GATEWAY", i[i.SESSION_TIMEOUT = 1007] = "SESSION_TIMEOUT", i[i.INSUFFICIENT_FUNDS = 1025] = "INSUFFICIENT_FUNDS", i[i.RESPONSIBLE_GAMING_EXCEEDED = 1026] = "RESPONSIBLE_GAMING_EXCEEDED", i[i.RESPONSIBLE_GAMING_BLOCK = 1030] = "RESPONSIBLE_GAMING_BLOCK", i[i.OPERATOR_ERROR = 1050] = "OPERATOR_ERROR", i[i.OPERATOR_ERROR_NON_FATAL = 1051] = "OPERATOR_ERROR_NON_FATAL", i[i.FRONT_CLIENT_NOT_VALID = 13004] = "FRONT_CLIENT_NOT_VALID", i[i.FRONT_CLIENT_NOT_ACTIVE = 13005] = "FRONT_CLIENT_NOT_ACTIVE", i[i.COUNTRY_BLOCKED = 13043] = "COUNTRY_BLOCKED"
			},
			49490: (t, e) => {
				"use strict";
				var i;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.APIEvent = void 0, (i = e.APIEvent || (e.APIEvent = {})).REPLAY_END = "replayEnd", i.DESTROY_RENDERER = "detroyRenderer", i.RE_INIT_RENDERER = "reInitRenderer", i.RE_INIT_RENDERER_DONE = "reInitRendererDone", i.DIALOG = "dialog", i.REALITY_CHECK = "realityCheck", i.MINIMUM_SPIN_TIME = "minSpinTime", i.PENDING_WIN = "pendingWin", i.BET = "bet", i.BALANCE = "balance", i.BET_BOOST = "betBoost", i.BROKE = "broke", i.SET_BALANCE_ID = "setBalanceId", i.BET_LEVELS = "betLevels", i.ALLOWED_GAME_MODES = "allowedGameModes", i.BET_GAME_MODE_CHANGED = "betGameModeChanged", i.RTP = "rtp", i.BUSY = "busy", i.IDLE = "idle", i.CURRENCY = "currency", i.MESSAGES = "messages", i.WIN = "win", i.GUI_REFRESH = "guiRefresh", i.REFRESH = "refresh", i.TICK = "tick", i.UPDATE_FREE_SPINS = "updateFreeSpins", i.IS_OPEN_GAME_ROUND = "isOpenGameRound", i.FREE_BETS = "freeBets", i.FREE_FEATURE_BETS = "featureBets", i.STATE = "state", i.AUTO_PLAY = "autoplay", i.CONFIG = "config", i.CURRENT_BET = "currentBet", i.FAST_SPIN = "fastspin", i.FEATURE_BET_LEVELS = "featureBetLevels", i.ALLOWED_GAME_FEATURES = "allowedGameFeatures", i.ALLOWED_FEATURE_BETS = "allowedFeatureBets", i.SELECTED_FEATURE_BET_CHANGED = "selectedFeatureBetChanged", i.PLATFORM_FEATURE_NAME = "featureName", i.PLATFORM_FEATURE_BET = "featureBet", i.GAME_INFO = "gameInfo", i.GAME_CLIENT_CONFIGURATION = "gameClientConfiguration", i.GAME_CLIENT_CONFIGURATION_APPLIED = "gameClientConfigurationApplied", i.INIT = "init", i.GAME = "game", i.READY = "ready", i.START = "start", i.STARTED = "started", i.STOP = "stop", i.SKIPPABLE = "skippable", i.FINISHING = "finishing", i.DONE = "done", i.FINISH = "finish", i.SKIP = "skip", i.SCREEN = "screen", i.GAMBLE = "gamble", i.GAMBLING = "gambling", i.GAMBLE_DONE = "gambleDone", i.REMAINING_FREE_SPINS = "remainingFreeSpins", i.JACKPOT = "jackpot", i.HOLD = "hold", i.PAUSE = "pause", i.RESUME = "resume", i.HIDDEN = "hidden", i.HALT = "halt", i.MUSIC = "music", i.SFX = "sfx", i.SETTING_CHANGE = "settingChange", i.SETTING_PAGE_CHANGE = "settingPageChange", i.AUDIO_MASTER_MUTED = "soundMaster", i.SOFT_RESET = "softReset", i.FREEZE = "freeze", i.UNFREEZE = "unfreeze", i.ACTION_SPINS_BET = "actionSpinsBet", i.ACTION_SPINS_ROUND_COMPLETE = "actionSpinsRoundComplete", i.ACTION_SPINS_IS_ACTIVE = "actionSpinsActive", i.REPLAY_BASE_URL = "replayBaseUrl", i.SERVER_VERSION = "serverVersion"
			},
			61190: (t, e) => {
				"use strict";
				var i;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.APIExternalApiEvent = void 0, (i = e.APIExternalApiEvent || (e.APIExternalApiEvent = {})).EXIT = "exit", i.EXIT_REPLAY = "exit-replay"
			},
			70329: (t, e) => {
				"use strict";
				var i, n;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Device = e.Mute = void 0, (n = e.Mute || (e.Mute = {})).MUTED = "muted", n.UN_MUTED = "un-muted", (i = e.Device || (e.Device = {})).MOBILE = "mobile", i.DESKTOP = "desktop"
			},
			30835: (t, e) => {
				"use strict";
				var i;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.APISetting = void 0, (i = e.APISetting || (e.APISetting = {})).LEFT_HAND_MODE = "leftHanded", i.CLOCK = "clock", i.MUSIC = "music", i.SFX = "sfx", i.FAST_SPIN = "fastspin", i.DEVICE_HAS_ROUNDED_CORNERS = "deviceHasRoundedCorners", i.USE_SPACE_TO_SPIN = "useSpaceToSpin", i.BALANCE_ID = "balanceId"
			},
			50108: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.FontLoader = void 0;
				const n = i(5665);
				e.FontLoader = class {
					constructor(t) {
						this._baseUrl = t, this._assetsToLoad = []
					}
					add(t) {
						this._assetsToLoad.push(t)
					}
					load() {
						return this._assetsToLoad.length > 0 ? this.loadInternal(this._assetsToLoad) : Promise.resolve(!0)
					}
					loadInternal(t) {
						const e = [];
						for (let i of t) e.push(n.FontCache.addFontFace(i, this._baseUrl));
						return Promise.all(e).then((t => this.loadComplete(t)))
					}
					loadComplete(t) {
						return this._assetsToLoad = [], Promise.resolve(!0)
					}
				}
			},
			61e3: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ImgLoader = e.ImgAssetConfig = void 0, e.ImgAssetConfig = class {
					constructor(t) {
						this.name = t, this.url = t
					}
				}, e.ImgLoader = class {
					constructor(t) {
						this._internalLoader = new PIXI.Loader(t, 1e4), this._assetsToLoad = []
					}
					add(t, e) {
						this._assetsToLoad.push({
							name: t,
							url: e
						})
					}
					load() {
						return this._assetsToLoad.length > 0 ? this.loadInternal(this._assetsToLoad) : Promise.resolve(!0)
					}
					loadInternal(t) {
						return new Promise(((e, i) => {
							for (let e of t) this._internalLoader.add(e.name, e.url, {
								crossOrigin: "*"
							});
							this._internalLoader.load(), this._internalLoader.onError.add((() => {
								i("error loading Img Asset")
							})), this._internalLoader.onComplete.add((() => {
								e(!0)
							}))
						}))
					}
					getImgTexture(t) {
						if (!PIXI.utils.TextureCache[t]) throw new Error("Missing texture");
						return PIXI.utils.TextureCache[t]
					}
					static getImgTexture(t) {
						if (!PIXI.utils.TextureCache[t]) throw new Error("Missing texture");
						return PIXI.utils.TextureCache[t]
					}
				}
			},
			49736: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SvgAsset = void 0;
				const n = i(72468);
				e.SvgAsset = class {
					constructor(t, e, i) {
						this._name = t, this._url = e, this._resolution = i.scale, this._svgResource = new PIXI.resources.SVGResource(e, i)
					}
					load() {
						return new Promise(((t, e) => {
							this._svgResource.load().then((e => {
								const i = new PIXI.BaseTexture(e, {
										resolution: this._resolution
									}),
									s = new PIXI.Texture(i),
									o = new PIXI.Sprite(s),
									r = PIXI.RenderTexture.create({
										width: s.width,
										height: s.height
									});
								n.NolimitApplication.pixiApp.renderer.render(o, r), PIXI.Texture.addToCache(r, this._name), e.source instanceof HTMLCanvasElement && s.destroy(!0), t(r)
							}))
						}))
					}
				}
			},
			85733: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SvgLoader = e.SvgAssetConfig = void 0;
				const n = i(49736);
				e.SvgAssetConfig = class {
					constructor(t, e, i) {
						this.url = t, this.name = t, this.height = e, this.width = i
					}
				}, e.SvgLoader = class {
					constructor(t, e) {
						this._baseUrl = t, this._resolution = e, this._assetsToLoad = []
					}
					add(t, e, i, s) {
						const o = {
							scale: this._resolution,
							width: i ? i * this._resolution : void 0,
							height: s ? s * this._resolution : void 0,
							autoLoad: !1
						};
						this._assetsToLoad.push(new n.SvgAsset(t, this._baseUrl + e, o))
					}
					load() {
						return this._assetsToLoad.length > 0 ? this.loadInternal(this._assetsToLoad) : Promise.resolve(!0)
					}
					loadInternal(t) {
						const e = [];
						for (let i of t) e.push(i.load());
						return Promise.all(e).then((t => this.loadComplete(t)))
					}
					loadComplete(t) {
						return this._assetsToLoad = [], Promise.resolve(!0)
					}
					getSvgTexture(t) {
						if (!PIXI.utils.TextureCache[t]) throw new Error("Missing texture: " + t);
						return PIXI.utils.TextureCache[t]
					}
					static getSvgTexture(t) {
						if (!PIXI.utils.TextureCache[t]) throw new Error("Missing texture: " + t);
						return PIXI.utils.TextureCache[t]
					}
				}
			},
			12355: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.TemplateLoader = void 0, e.TemplateLoader = class {
					constructor(t) {
						this._baseUrl = t, this._assetsToLoad = [], this._loader = new PIXI.Loader(t, 1e4)
					}
					add(t) {
						this._assetsToLoad.push(t)
					}
					load(t) {
						if (t)
							for (let e of t) this.add(e);
						return this._assetsToLoad.length > 0 ? this.loadInternal(this._assetsToLoad) : Promise.resolve([])
					}
					loadInternal(t) {
						return new Promise(((e, i) => {
							for (let e of t) this._loader.add(e.name, e.url, {
								crossOrigin: "*"
							});
							this._loader.onError.add(((t, e, i) => {
								throw e.destroy(), t
							})), this._loader.onComplete.add(((t, i) => {
								for (let t of this._assetsToLoad) t.loadedData = null != i[t.name] ? i[t.name].data : void 0;
								e(this._assetsToLoad)
							})), this._loader.load()
						}))
					}
				}
			},
			5665: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.FontCache = void 0;
				const n = i(91980),
					s = i(23109);
				class o {
					static get styleElement() {
						return null == this._styleElement && (this._styleElement = document.createElement("style"), document.head.append(this._styleElement)), this._styleElement
					}
					static get instance() {
						return null == this._instance && (this._instance = new o), this._instance
					}
					constructor() {}
					static addFontFace(t, e) {
						if (!o.instance.isFontAdded(t)) {
							const i = document.createElement("style"),
								n = o.instance.createStyleString(t, e);
							i.appendChild(document.createTextNode(n)), document.head.appendChild(i), o.addedFonts.push(o.createSummery(t))
						}
						return new s(t.family, {
							weight: t.weight,
							style: t.style
						}).load(null, 1e4).catch((t => {
							n.NolimitLauncher.apiPlugin.warn(t)
						}))
					}
					isFontAdded(t) {
						return o.addedFonts.indexOf(o.createSummery(t)) >= 0
					}
					static createSummery(t) {
						return `${t.family},${t.weight},${t.style}`
					}
					createStyleString(t, e) {
						let i = t.weight;
						return isNaN(parseInt(t.weight)) && (i = parseInt(t.weight)), `\n@font-face {\n    font-family: '${t.family}';\n    src: url('${e+t.url}') format('woff');\n    font-weight: ${i};\n    font-style: ${t.style};\n}`
					}
				}
				o.addedFonts = [], e.FontCache = o
			},
			77616: (t, e) => {
				"use strict";
				var i, n, s;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.FontType = e.FontStyle = e.FontWeight = void 0, (s = e.FontWeight || (e.FontWeight = {})).THIN = "100", s.EXTRA_LIGHT = "200", s.ULTRA_LIGHT = "200", s.LIGHT = "300", s.NORMAL = "400", s.REGULAR = "400", s.MEDIUM = "500", s.SEMI_BOLD = "600", s.DEMI_BOLD = "600", s.BOLD = "700", s.EXTRA_BOLD = "800", s.ULTRA_BOLD = "800", s.BLACK = "900", s.HEAVY = "900", (n = e.FontStyle || (e.FontStyle = {})).NORMAL = "normal", n.ITALIC = "italic", n.OBLIQUE = "oblique", (i = e.FontType || (e.FontType = {})).EOT = "embedded-opentype", i.WOFF2 = "woff2", i.WOFF = "woff", i.TTF = "truetype", i.SVG = "svg", i.OTF = "opentype"
			},
			5117: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.OpenSans = void 0;
				const n = i(77616);
				class s {}
				s.FAMILY = "Open Sans", s.BASE_URL = "/node_modules/@nolimitcity/slot-launcher/resources/default/fonts/opensans/", s.NORMAL_300 = {
					family: s.FAMILY,
					weight: n.FontWeight.LIGHT,
					style: n.FontStyle.NORMAL,
					url: s.BASE_URL + "OpenSans-Light-webfont.woff"
				}, s.ITALIC_300 = {
					family: s.FAMILY,
					weight: n.FontWeight.LIGHT,
					style: n.FontStyle.ITALIC,
					url: s.BASE_URL + "OpenSans-LightItalic-webfont.woff"
				}, s.NORMAL_400 = {
					family: s.FAMILY,
					weight: n.FontWeight.REGULAR,
					style: n.FontStyle.NORMAL,
					url: s.BASE_URL + "OpenSans-Regular-webfont.woff"
				}, s.ITALIC_400 = {
					family: s.FAMILY,
					weight: n.FontWeight.REGULAR,
					style: n.FontStyle.ITALIC,
					url: s.BASE_URL + "OpenSans-Italic-webfont.woff"
				}, s.NORMAL_600 = {
					family: s.FAMILY,
					weight: n.FontWeight.SEMI_BOLD,
					style: n.FontStyle.NORMAL,
					url: s.BASE_URL + "OpenSans-Semibold-webfont.woff"
				}, s.ITALIC_600 = {
					family: s.FAMILY,
					weight: n.FontWeight.SEMI_BOLD,
					style: n.FontStyle.ITALIC,
					url: s.BASE_URL + "OpenSans-SemiboldItalic-webfont.woff"
				}, s.NORMAL_700 = {
					family: s.FAMILY,
					weight: n.FontWeight.BOLD,
					style: n.FontStyle.NORMAL,
					url: s.BASE_URL + "OpenSans-Bold-webfont.woff"
				}, s.ITALIC_700 = {
					family: s.FAMILY,
					weight: n.FontWeight.BOLD,
					style: n.FontStyle.ITALIC,
					url: s.BASE_URL + "OpenSans-BoldItalic-webfont.woff"
				}, s.NORMAL_800 = {
					family: s.FAMILY,
					weight: n.FontWeight.EXTRA_BOLD,
					style: n.FontStyle.NORMAL,
					url: s.BASE_URL + "OpenSans-ExtraBold-webfont.woff"
				}, s.ITALIC_800 = {
					family: s.FAMILY,
					weight: n.FontWeight.EXTRA_BOLD,
					style: n.FontStyle.ITALIC,
					url: s.BASE_URL + "OpenSans-ExtraBoldItalic-webfont.woff"
				}, e.OpenSans = s
			},
			64118: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.isApiPlugin = void 0, e.isApiPlugin = function(t) {
					return void 0 !== t.communication && void 0 !== t.slotStates
				}
			},
			3307: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.isAutoPlayPlugin = void 0, e.isAutoPlayPlugin = function(t) {
					return void 0 !== t.updateData && void 0 !== t.cancelAutoPlay
				}
			},
			34018: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.isGamblePlugin = void 0, e.isGamblePlugin = function(t) {
					return void 0 !== t.hasGamble && void 0 !== t.startGamble
				}
			},
			58676: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.isGamePlugin = void 0, e.isGamePlugin = function(t) {
					return void 0 !== t.getPaytable
				}
			},
			83900: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.isJackpotPlugin = e.JackpotPluginEvents = void 0;
				class i {}
				i.SPIN_COMPLETE = "jackpotSpinComplete", e.JackpotPluginEvents = i, e.isJackpotPlugin = function(t) {
					return void 0 !== t.addOnSpinCompleteCallback && void 0 !== t.isActive
				}
			},
			97182: (t, e) => {
				"use strict";
				var i;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.isKeypadPlugin = e.KeypadPluginEvents = void 0, (i = e.KeypadPluginEvents || (e.KeypadPluginEvents = {})).DISPLAY_BET_UPDATE = "KeypadPlugin_displayBetUpdate", i.USER_BET_UPDATE = "KeypadPlugin_userBetUpdate", e.isKeypadPlugin = function(t) {
					return void 0 !== t.setWin && void 0 !== t.setZeroBetSpinCounter
				}
			},
			16211: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.isPromotionPlugin = void 0, e.isPromotionPlugin = function(t) {
					return void 0 !== t.open && void 0 !== t.close
				}
			},
			81029: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.isSoundPlugin = void 0, e.isSoundPlugin = function(t) {
					return void 0 !== t.isLoaded && void 0 !== t.player
				}
			},
			34112: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BetLevelHandler = e.BetLevelModeData = e.isBetLevelEventData = void 0;
				const n = i(49490),
					s = i(46334);

				function o(t) {
					return void 0 !== t.bet && null != t.availableBetLevels
				}
				e.isBetLevelEventData = o;
				class r {
					get bet() {
						return this._bet
					}
					get betLevels() {
						return this._betLevels
					}
					constructor(t, e) {
						this.modeName = t, this._bet = e.bet, this.updateAvailability(e)
					}
					addBuyTimesBetValue(t) {
						this._featureTimesBetValue = t
					}
					addFeatureBetLevels(t) {
						this._featureBetLevels = t
					}
					updateAvailability(t) {
						t.betLevels ? this._betLevels = t.betLevels : t.availableBetLevels && t.unavailableBetLevels ? this._betLevels = t.availableBetLevels.concat(t.unavailableBetLevels) : this._betLevels = []
					}
					isFirst() {
						return 0 === this._betLevels.indexOf(this.bet) || -1 === this._betLevels.indexOf(this.bet)
					}
					isLast() {
						return this._betLevels.indexOf(this.bet) === this._betLevels.length - 1
					}
					increase() {
						if (this.isLast()) return !1;
						const t = this._betLevels.indexOf(this.bet) + 1;
						return this.setLevel(this._betLevels[t])
					}
					decrease() {
						if (this.isFirst()) return !1;
						const t = this._betLevels.indexOf(this.bet) - 1;
						return this.setLevel(this._betLevels[t])
					}
					getLevel() {
						return this._bet
					}
					setLevel(t) {
						return -1 !== this._betLevels.indexOf(t) && this._bet != t ? (this._bet = t, !0) : (s.Logger.warn("level", t, "not found in", this._betLevels), !1)
					}
					isValidBetForFeature(t) {
						var e;
						return null != (null === (e = this._featureBetLevels) || void 0 === e ? void 0 : e[t]) && this._featureBetLevels[t].indexOf(this._bet) > -1
					}
					getMaxBetLevelForFeature(t) {
						var e;
						return null != (null === (e = this._featureBetLevels) || void 0 === e ? void 0 : e[t]) && this._featureBetLevels[t].length > 0 ? this._featureBetLevels[t][this._featureBetLevels[t].length - 1] : "0"
					}
					getPriceForFeature(t) {
						for (let e of this._featureTimesBetValue)
							if (e.name == t) return e.price;
						throw new Error(`Could not find data for feature: ${t}`)
					}
					addMetaData(t) {
						this.metaData = t
					}
				}
				e.BetLevelModeData = r, e.BetLevelHandler = class {
					constructor(t, e) {
						var i;
						if (this.betLevelModes = new Map, this.gameModeIndex = 0, this.allowedGameModes = [], this.modeMetaData = new Map, this.gamePlugin = e, this.api = t, this.api.events.on(n.APIEvent.BET_LEVELS, (t => this.onBetLevels(t))), this.api.events.on(n.APIEvent.FEATURE_BET_LEVELS, (t => this.onFeatureBetLevels(t))), this.api.events.on(n.APIEvent.INIT, (t => this.onInit(t))), null != (null === (i = this.gamePlugin) || void 0 === i ? void 0 : i.getGameModeMetaData)) {
							const t = this.gamePlugin.getGameModeMetaData();
							for (let e in t) this.modeMetaData.set(e, t[e])
						}
						this.allowedGameModes = ["NORMAL"], this.api.events.on(n.APIEvent.ALLOWED_GAME_MODES, (t => {
							if (t.length > 0) {
								this.allowedGameModes = [];
								for (let e of t) {
									const t = this.modeMetaData.get(e);
									(null == t ? void 0 : t.standard) ? this.allowedGameModes.push(e): this.allowedGameModes.unshift(e)
								}
							}
							this.setBetLevelMode(this.allowedGameModes[this.allowedGameModes.length - 1])
						})), this.api.betHandler.addBetDataInjectCallback((t => {
							const e = this.getSelectedBetLevelModeName();
							return "NORMAL" != e && (null == t.playerInteraction && (t.playerInteraction = {}), t.playerInteraction.gameMode = e), t
						}))
					}
					getButtonLabels() {
						const t = {
								onLabel: "",
								offLabel: ""
							},
							e = this.allowedGameModes[this.allowedGameModes.length - 1],
							i = this.modeMetaData.get(e);
						i && (t.onLabel = i.buttonLabel || "");
						const n = this.allowedGameModes[0],
							s = this.modeMetaData.get(n);
						return s && (t.offLabel = s.buttonLabel || ""), t
					}
					getAllowedModeNames() {
						return this.allowedGameModes.concat()
					}
					onInit(t) {
						this._featureBuyTimesBetValue = t.featureBuyTimesBetValue || [], this._featureBuyTimesBetValueAll = t.featureBuyTimesBetValueAll || void 0, this.addFeatureBuyTimesBetValueToMode(this._featureBuyTimesBetValue, this._featureBuyTimesBetValueAll)
					}
					addFeatureBuyTimesBetValueToMode(t, e) {
						if (!(null == t || this.betLevelModes.size <= 0))
							if (this.betLevelModes.has("NORMAL")) this.betLevelModes.get("NORMAL").addBuyTimesBetValue(t);
							else {
								if (null == e) throw new Error("Error assigning featureBuyTimesBetValueAll");
								for (let [t, i] of this.betLevelModes) null != e[t] && i.addBuyTimesBetValue(e[t])
							}
					}
					onFeatureBetLevels(t) {
						this._featureBetLevels = t, this.addFeatureBetLevelsToModes(this._featureBetLevels)
					}
					addFeatureBetLevelsToModes(t) {
						if (!(null == t || this.betLevelModes.size <= 0))
							if (this.betLevelModes.has("NORMAL")) this.betLevelModes.get("NORMAL").addFeatureBetLevels(t);
							else
								for (let [e, i] of this.betLevelModes) null != t[e] && i.addFeatureBetLevels(t[e])
					}
					onBetLevels(t) {
						let e = !1;
						if (o(t)) this.betLevelModes.has("NORMAL") ? this.betLevelModes.get("NORMAL").updateAvailability(t) : (e = !0, this.betLevelModes.set("NORMAL", new r("NORMAL", t)));
						else
							for (let i in t) this.betLevelModes.has(i) ? this.betLevelModes.get(i).updateAvailability(t[i]) : (e = !0, this.betLevelModes.set(i, new r(i, t[i])));
						if (e) {
							const t = Array.from(this.betLevelModes.keys());
							this.setBetLevelMode(t[t.length - 1]), this.addFeatureBetLevelsToModes(this._featureBetLevels)
						}
					}
					hasCapWinLimitToggle() {
						return this.allowedGameModes.length > 1
					}
					isCapWinLimitToggled() {
						return this.gameModeIndex > 0
					}
					toggleCapWinLimit() {
						let t = this.gameModeIndex + 1;
						t %= this.allowedGameModes.length, this.setBetLevelMode(this.allowedGameModes[t])
					}
					setBetLevelMode(t) {
						var e;
						const i = this.allowedGameModes.indexOf(t);
						i >= 0 && this.betLevelModes.has(t) && (null === (e = this.selectedBetLevelMode) || void 0 === e ? void 0 : e.modeName) != t && (this.gameModeIndex = i, this.selectedBetLevelMode = this.betLevelModes.get(t), this.triggerCurrentBetEvent(), this.triggerBetModeChange())
					}
					getSelectedBetLevelModeName() {
						var t;
						return (null === (t = this.selectedBetLevelMode) || void 0 === t ? void 0 : t.modeName) || "NOT_SET"
					}
					get allowedModes() {
						return [...this.betLevelModes.values()]
					}
					getSelectedMode() {
						return this.selectedBetLevelMode
					}
					triggerCurrentBetEvent() {
						this.api.events.trigger(n.APIEvent.CURRENT_BET, this.getLevel())
					}
					triggerBetModeChange() {
						this.api.events.trigger(n.APIEvent.BET_GAME_MODE_CHANGED)
					}
					getMaxBetLevelForFeature(t) {
						return this.selectedBetLevelMode.getMaxBetLevelForFeature(t)
					}
					getPriceForFeature(t) {
						return this.selectedBetLevelMode.getPriceForFeature(t)
					}
					isValidBetLevelForFeature(t) {
						return this.selectedBetLevelMode.isValidBetForFeature(t)
					}
					setLevel(t) {
						this.selectedBetLevelMode.setLevel(t) && this.triggerCurrentBetEvent()
					}
					getLevel() {
						return this.selectedBetLevelMode.getLevel()
					}
					isFirst() {
						return this.selectedBetLevelMode.isFirst()
					}
					isLast() {
						return this.selectedBetLevelMode.isLast()
					}
					increase() {
						this.selectedBetLevelMode.increase() && this.triggerCurrentBetEvent()
					}
					decrease() {
						this.selectedBetLevelMode.decrease() && this.triggerCurrentBetEvent()
					}
					getAvailableLevels() {
						const t = [],
							e = this.api.balance.getAmount();
						for (let i of this.selectedBetLevelMode.betLevels) + i <= e && t.push(i);
						return t
					}
					getUnavailableLevels() {
						const t = [],
							e = this.api.balance.getAmount();
						for (let i of this.selectedBetLevelMode.betLevels) + i > e && t.push(i);
						return t
					}
					getBetLevels() {
						return this.selectedBetLevelMode.betLevels
					}
					setMessage(t) {
						this._message = t
					}
					getMessage() {
						return this._message
					}
					clearMessage() {
						this._message = void 0
					}
					isBroke() {
						return !1
					}
				}
			},
			79108: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BonusFeatureHandler = void 0;
				const n = i(49490),
					s = i(5217),
					o = i(46334);
				class r {
					get availableNames() {
						return this._availableNames
					}
					get availableTypes() {
						return this._availableTypes
					}
					get notAllowedFeatures() {
						return this._nowAllowedFeatures
					}
					constructor(t) {
						this.featureBetLevelsChangeCallbacks = [], this._allowedGameFeatures = [], this.allTypesByCategory = {
							[s.GameFeatureCategory.BONUS_BUY]: ["FREESPIN", "FEATURE_BUY"],
							[s.GameFeatureCategory.BOOSTED_BET]: ["BOOSTED_BET_X_ROWS", "BOOSTED_BET_LOCKED_REELS"]
						}, this._bonusFeatureData = [], this._nowAllowedFeatures = [], this._hasInit = !1, this.hasInitCallbacks = [], this.onInit = t => {
							if (t.featureBuyTimesBetValue) {
								for (let e of t.featureBuyTimesBetValue) this._bonusFeatureData.push(new s.BonusFeatureData(e));
								this.updateFeatureBetLevels()
							}
							this._hasInit = !0;
							for (let t of this.hasInitCallbacks) t();
							this.hasInitCallbacks = [], this.checkAllowedFeatures();
							for (let t of this._bonusFeatureData) t.betLevels.length && (this._availableTypes.add(t.type), this._availableNames.add(t.name));
							this._api.events.on(n.APIEvent.FEATURE_BET_LEVELS, this.onFeatureBetLevels)
						}, this.onFeatureBetLevels = t => {
							let e = r.isFeatureBetLevelsChanged(this._inputFeatureBetLevels, t);
							if (this._inputFeatureBetLevels = t, e) {
								this.updateFeatureBetLevels();
								for (let t of this.featureBetLevelsChangeCallbacks) t(this._inputFeatureBetLevels)
							}
						}, this._api = t, this._availableTypes = new Set, this._availableNames = new Set, this._api.events.once(n.APIEvent.ALLOWED_GAME_FEATURES, (t => {
							this._allowedGameFeatures = Array.isArray(t) ? t : t.allowedGameFeatures, this.checkAllowedFeatures()
						})), this._api.events.once(n.APIEvent.FEATURE_BET_LEVELS, (t => {
							this._inputFeatureBetLevels = t
						})), this._api.events.on(n.APIEvent.INIT, this.onInit)
					}
					checkAllowedFeatures() {
						for (let t = this._bonusFeatureData.length - 1; t >= 0; t--) {
							const e = this._bonusFeatureData[t];
							if (this._allowedGameFeatures.indexOf(e.name) < 0) {
								const e = this._bonusFeatureData.splice(t, 1)[0];
								this._nowAllowedFeatures.push(e)
							}
						}
					}
					updateFeatureBetLevels() {
						for (let t of this._bonusFeatureData) t.updateBetLevels(this._inputFeatureBetLevels);
						o.Logger.logDev("[BonusFeatureHandler] updateFeatureBetLevels :", this._bonusFeatureData)
					}
					addOnFeatureBetLevelsChangeCallback(t) {
						this.featureBetLevelsChangeCallbacks.push(t)
					}
					static isFeatureBetLevelsChanged(t = {}, e = {}) {
						const i = Object.keys(e);
						if (Object.keys(t).length == i.length) {
							for (let n = 0; n < i.length; n++)
								if (r.getMaxFromArray(e[i[n]]) != r.getMaxFromArray(t[i[n]])) return !0;
							return !1
						}
						return !0
					}
					static getMaxFromArray(t) {
						let e = Number.MIN_VALUE;
						for (let i = 0; i < t.length; i++) e = Math.max(e, +t[i]);
						return e
					}
					getFeatureDataByTypes(t) {
						let e = [];
						for (let i of t) e = e.concat(this.getFeatureDataByType(i));
						return e
					}
					getFeatureDataByType(t) {
						let e = [];
						for (let i of this._bonusFeatureData) i.type === t && e.push(i);
						return e
					}
					getFeatureDataByNames(t) {
						let e = [];
						for (let i of t) e = e.concat(this.getFeatureDataByName(i));
						return e
					}
					getFeatureDataByName(t) {
						for (let e of this._bonusFeatureData)
							if (e.name === t) return e
					}
					hasAnyType(t) {
						return this.findAnyInSet(this.availableTypes, t)
					}
					hasAnyName(t) {
						return this.findAnyInSet(this.availableNames, t)
					}
					findAnyInSet(t, e) {
						let i = !1;
						for (let n of e)
							if (i = t.has(n), i) return i;
						return i
					}
					hasInit() {
						return this._hasInit ? Promise.resolve(!0) : new Promise(((t, e) => {
							this.hasInitCallbacks.push((() => {
								t(!0)
							}))
						}))
					}
				}
				e.BonusFeatureHandler = r
			},
			5217: (t, e) => {
				"use strict";
				var i, n;
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GameFeatureNames = e.GameFeatureCategory = e.BonusFeatureData = void 0, e.BonusFeatureData = class {
					constructor(t) {
						this.name = t.name, this.type = t.type, this.price = t.price, this.betLevels = []
					}
					updateBetLevels(t) {
						for (let e in t) e == this.name && (this.betLevels = t[e])
					}
					getMaxBet() {
						let t = Number.MIN_VALUE;
						for (let e = 0; e < this.betLevels.length; e++) t = Math.max(t, +this.betLevels[e]);
						return t
					}
				}, (n = e.GameFeatureCategory || (e.GameFeatureCategory = {})).BONUS_BUY = "BONUS_BUY", n.GAMBLE = "GAMBLE", n.BOOSTED_BET = "BOOSTED_BET", (i = e.GameFeatureNames || (e.GameFeatureNames = {})).BONUS_BUY = "BONUS_BUY", i.GAMBLE_FIFTY_FIFTY = "GAMBLE_FIFTY_FIFTY", i.GAMBLE_INTO_BONUS = "GAMBLE_INTO_BONUS", i.BOOSTED_BET_X_ROWS = "BOOSTED_BET_X_ROWS", i.BOOSTED_BET_LOCKED_REELS = "BOOSTED_BET_LOCKED_REELS", i.NOLIMIT_WINNERS = "NOLIMIT_WINNERS"
			},
			38694: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ClockModel = void 0;
				const n = i(30835),
					s = i(49490),
					o = i(82935);
				e.ClockModel = class {
					constructor(t) {
						this.UPDATE = "update", this.SETTING_UPDATE = "settingUpdate", this._useSessionTime = !1, this._lastTick = {
							deltaHours: 0,
							deltaMinutes: 0,
							deltaSeconds: 0,
							hours: "00",
							minutes: "00",
							seconds: "00"
						}, this._api = t, this._events = o.create(), this._api.options.clock ? this._api.settings.set(n.APISetting.CLOCK, !0) : this._api.settings.set(n.APISetting.CLOCK, !1), this._api.events.on(s.APIEvent.TICK, (t => this.onApiTick(t))), this._api.settings.on(n.APISetting.CLOCK, (() => this.onClockSettingChanged()))
					}
					set useSessionTime(t) {
						this._useSessionTime = t
					}
					get events() {
						return this._events
					}
					get shouldShow() {
						return this._api.settings.get(n.APISetting.CLOCK, !0) && null == this._api.options.replay
					}
					get sessionTime() {
						return this._lastTick.hours + ":" + this._lastTick.minutes + ":" + this._lastTick.seconds
					}
					get normalTime() {
						const t = new Date;
						return this.padToTwo(t.getHours()) + ":" + this.padToTwo(t.getMinutes())
					}
					get useSessionTime() {
						return this._useSessionTime
					}
					get formattedTime() {
						return this._useSessionTime ? this.sessionTime : this._api.gameClientConfiguration.clockSettings.showSessionTimeUnder ? `${this.normalTime} \n${this.sessionTime}` : `${this.normalTime}`
					}
					onGameClientConfigurationApplied() {
						this._useSessionTime = this._api.gameClientConfiguration.clockSettings.useSessionTime
					}
					onApiTick(t) {
						this._lastTick = t, this.events.trigger(this.UPDATE)
					}
					padToTwo(t) {
						return ("0" + t).slice(-2)
					}
					onClockSettingChanged() {
						this.events.trigger(this.SETTING_UPDATE)
					}
				}
			},
			33025: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.DialogHandler = void 0;
				class i {
					constructor(t, e) {
						this._api = t, this._apiDialog = e
					}
					close() {
						this._apiDialog.close()
					}
					hasOpenDialog() {
						return this._apiDialog.hasOpenDialog()
					}
					lock(t) {
						this._apiDialog.lock(t)
					}
					open(t, e) {
						return this._apiDialog.open(t, e)
					}
					unlock(t) {
						this._apiDialog.unlock(t)
					}
					unlockAll() {
						this._apiDialog.unlockAll()
					}
					showGameDialog(t) {
						const e = this.createGameDialogHtml(t);
						null == t.okButtonLabel && (t.okButtonLabel = this._api.translations.translate("OK"));
						const i = this.open(e, {
							alwaysShow: t.alwaysShow,
							closeable: !0,
							onClose: t.onClose
						});
						i.classList.add("game-dialog");
						const n = i.querySelector(".ok-button");
						null != n && (n.onclick = () => {
							t.onOkClick && t.onOkClick(), this.close()
						});
						const s = i.querySelector(".cancel-button");
						null != s && (s.onclick = () => {
							t.onCancelClick && t.onCancelClick(), this.close()
						})
					}
					showNoCloseGameDialog(t) {
						const e = this.createNoCloseGameDialogHtml(t);
						this.open(e, {
							alwaysShow: t.alwaysShow,
							closeable: !1
						}).classList.add("game-dialog")
					}
					createGameDialogHtml(t) {
						return this._api.translations.render(i.GAME_DIALOG, t)
					}
					createNoCloseGameDialogHtml(t) {
						return this._api.translations.render(i.NO_CLOSE_GAME_DIALOG, t)
					}
				}
				i.GAME_DIALOG = '\n        {{#header}}<h1>{{header}}</h1>{{/header}}\n        {{#message}}<p>{{message}}</p>{{/message}}\n        \n         <button type="button" class="ok-button"> \n            {{okButtonLabel}}\n         </button>\n        \n        {{#cancelButtonLabel}}\n         <button type="button" class="cancel-button"> \n            {{cancelButtonLabel}}\n         </button>\n        {{/cancelButtonLabel}}\n        ', i.NO_CLOSE_GAME_DIALOG = "\n        {{#header}}<h1>{{header}}</h1>{{/header}}\n        {{#message}}<p>{{message}}</p>{{/message}}\n        ", e.DialogHandler = i
			},
			78539: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Fullscreen = void 0;
				const n = i(70329);
				e.Fullscreen = class {
					constructor(t) {
						this.disabled = !1, this.goFullscreen = t => {
							if (this.isFullscreen() || this.disabled) return;
							const e = document.documentElement;
							e.requestFullscreen ? e.requestFullscreen({
								navigationUI: "hide"
							}) : e.mozRequestFullScreen ? e.mozRequestFullScreen() : e.webkitRequestFullscreen ? e.webkitRequestFullscreen() : e.msRequestFullscreen && e.msRequestFullscreen()
						}, (null == t.options.fullscreen || t.options.fullscreen) && (this._target = document.documentElement, t.options.device === n.Device.MOBILE && this.addListeners(), t.events.on("exit", (() => this.addListeners())), t.events.on("halt", (() => this.removeListeners())))
					}
					addListeners() {
						this._target.addEventListener("touchend", this.goFullscreen, !0)
					}
					removeListeners() {
						this._target.removeEventListener("touchend", this.goFullscreen, !0)
					}
					disable() {
						this.disabled = !0, this.exit()
					}
					exit() {
						if (this.isFullscreen()) {
							const t = document;
							t.exitFullscreen ? t.exitFullscreen() : t.webkitExitFullscreen ? t.webkitExitFullscreen() : t.mozCancelFullScreen ? t.mozCancelFullScreen() : t.msExitFullscreen && t.msExitFullscreen()
						}
					}
					isFullscreen() {
						const t = document;
						return t.fullscreenElement || t.mozFullScreenElement || t.webkitFullscreenElement || t.msFullscreenElement
					}
				}
			},
			66704: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GameClientConfiguration = e.JurisdictionNames = void 0;
				const n = i(49490),
					s = i(30835),
					o = i(72468);
				var r;
				! function(t) {
					t.DEFAULT = "DEFAULT", t.MALTA = "MT", t.UKGC = "UKGC", t.SWEDEN_LINKS = "SE", t.SWEDEN_EVENTS = "SE", t.SWEDEN_NO_LINKS = "SE", t.DENMARK = "DK", t.ESTONIA = "EE", t.GERMANY = "DE", t.ITALY = "IT", t.LATVIA = "LV", t.LITHUANIA = "LT", t.NETHERLANDS = "NL", t.NORSKTIPPING = "NORSKTIPPING", t.ONTARIO = "ON", t.PORTUGAL = "PT", t.ROMANIA = "RO", t.SOUTH_AFRICA = "ZA", t.SPAIN = "ES", t.USA = "US", t.COLOMBIA = "CO", t.GREECE = "GR", t.BULGARIA = "BG"
				}(r = e.JurisdictionNames || (e.JurisdictionNames = {}));
				class a {
					get isSet() {
						return this._isSet
					}
					constructor(t) {
						this._api = t, this._isSet = !1, t.events.once(n.APIEvent.SERVER_VERSION, (t => {
							this.serverVersion = t
						})), t.events.once(n.APIEvent.GAME_CLIENT_CONFIGURATION, (t => this.onGameClientConfiguration(t)))
					}
					updateScreen(t) {
						const e = t.find("span.gambleGameRoundCloseIntervalHours");
						for (let t of e) t.innerHTML = this.gambleGameRoundCloseIntervalHours;
						let i = this._api.translations.translate("hour");
						this.gambleGameRoundCloseIntervalHours > 1 && (i = this._api.translations.translate("hours"));
						const n = t.find("span.gambleGameRoundCloseIntervalHoursType");
						for (let t of n) t.innerHTML = i;
						const s = t.find("span.gameRoundCloseInterval");
						for (let t of s) t.innerHTML = this.gameRoundCloseInterval;
						const l = t.find("span.gameRoundCloseIntervalType");
						for (let t of l) t.innerHTML = this._api.translations.translate(this.gameRoundCloseIntervalType.toLowerCase());
						this.hideRtp && t.find(".rtp").forEach((function(t) {
							t.style.display = "none"
						}));
						let h = !1;
						for (let t = 0; t < a.SHOW_GAMBLE_RULES_GAME_NAMES.length; t++) a.SHOW_GAMBLE_RULES_GAME_NAMES[t] == o.NolimitApplication.apiPlugin.gameInfo.displayName && (1 != this.gambleFiftyFiftyAllowed && 1 != this.gambleIntoBonusAllowed || (h = !0));
						0 == h && t.find(".gambleGameRoundCloseIntervalHours").forEach((t => {
							t.style.display = "none"
						})), this.cryptoCurrencyRules || t.find(".crypto-currency").forEach((t => {
							t.style.display = "none"
						})), this.fastSpinEnabled || t.find(".fastspin").forEach((t => {
							t.style.display = "none"
						})), this.autoPlaySettings.autoplayAllowed && !1 !== this._api.options.autoplay || t.find(".autoplay").forEach((t => {
							t.style.display = "none"
						})), this.featureBuyEnabled || t.find(".bonusBuy").forEach((t => {
							t.style.display = "none"
						})), this.boostedBetAllowed || t.find(".boostedBetAllowed").forEach((t => {
							t.style.display = "none"
						})), this.boostedBetExtraRows || this.boostedBetLockedReels || t.find(".boostedBet").forEach((t => {
							t.style.display = "none"
						})), this.boostedBetExtraRows || t.find(".boostedBetXRows").forEach((t => {
							t.style.display = "none"
						})), this.boostedBetLockedReels || t.find(".boostedBetLockedReels").forEach((t => {
							t.style.display = "none"
						})), this.gambleFiftyFiftyAllowed || this.gambleIntoBonusAllowed || t.find(".gamble").forEach((t => {
							t.style.display = "none"
						})), this.gambleFiftyFiftyAllowed || t.find(".gambleFiftyFifty").forEach((t => {
							t.style.display = "none"
						})), this.gambleIntoBonusAllowed || t.find(".gambleIntoBonus").forEach((t => {
							t.style.display = "none"
						})), this.clockSettings.allowSetting || t.find(".clockSetting").forEach((t => {
							t.style.display = "none"
						})), this.jurisdictionName !== r.NORSKTIPPING && t.find(".norsktipping-rtp").forEach((t => {
							t.style.display = "none"
						})), this.showSimulatedMaximumPayout || t.find(".simulated-maximum-payout").forEach((t => {
							t.style.display = "none"
						})), this.featureBuyEnabled || t.find(".rtp-feature").forEach((t => t.style.display = "none"));
						for (let e of this._api.betFeatureController.getNotAllowedFeatures()) t.find("." + e.name).forEach((t => t.style.display = "none"))
					}
					onGameClientConfiguration(t) {
						var e;
						this.active = t.active, this.actionSpin = t.actionSpin, this.autoPlaySettings = t.autoPlaySettings, this.belowStakeWinRestriction = t.belowStakeWinRestriction, this.boostedBetAllowed = t.boostedBetAllowed, this.boostedBetExtraRows = t.boostedBetExtraRows, this.boostedBetLockedReels = t.boostedBetLockedReels, this.clockSettings = t.clockSettings, this.cryptoCurrencyRules = t.cryptoCurrencyRules, this.fastSpinEnabled = t.fastSpinEnabled, this.featureBuyEnabled = t.featureBuyEnabled, this.gambleFiftyFiftyAllowed = t.gambleFiftyFiftyAllowed, this.gambleGameRoundCloseIntervalHours = t.gambleGameRoundCloseIntervalHours, this.gambleIntoBonusAllowed = t.gambleIntoBonusAllowed, this.gameRoundCloseInterval = t.gameRoundCloseInterval, this.gameRoundCloseIntervalType = t.gameRoundCloseIntervalType, this.jurisdictionName = t.jurisdictionName, this.maxInactivityInMinutes = t.maxInactivityInMinutes, this.minimumSpinTime = t.minimumSpinTime, this.nolimitWinnersEnabled = t.nolimitWinnersEnabled, this.operator = t.operator, this.showGameVersionInGuiGuide = t.showGameVersionInGuiGuide, this.showGameClientBuiltDate = t.showGameClientBuiltDate, this.showSimulatedMaximumPayout = t.showSimulatedMaximumPayout, this.hideRtp = t.hideRtp, this.hideTicketLowBalance = t.hideTicketLowBalance, this.showRtpWatermark = t.showRtpWatermark, this.showMaxWinProbabilityWatermark = t.showMaxWinProbabilityWatermark, this.showNetPosition = t.showNetPosition, this.replaceSlotsInGameRules = t.replaceSlotsInGameRules, this.showMinBet = t.showMinBet, this.showMaxBet = t.showMaxBet, this.showMaxBetLevelInGameRules = t.showMaxBetLevelInGameRules, this.showServerVersion = t.showServerVersion, this.showLowProbabilityGfx = !1 !== t.showLowProbabilityGfx, this.showNearMissGfx = !1 !== t.showNearMissGfx, this.useCensoredGfx = t.useCensoredGfx, this.showBaseGameHighestWinInRules = t.showBaseGameHighestWinInRules, this.replaceWincapInfo = t.replaceWincapInfo, this.explicitContentWarning = t.explicitContentWarning || !1, this.showOnlyMaxRTPForRange = t.showOnlyMaxRTPForRange, this.showVolatilityInGameRules = t.showVolatilityInGameRules, this.useCensoredGfxUS = t.useCensoredGfxUS, this.useCensoredSoundUS = t.useCensoredSoundUS, this.displayIndividualWinsInGame = t.displayIndividualWinsInGame, this.spacebarSpinAllowed = !1 !== t.spacebarSpinAllowed, void 0 === this._api.options.clock || this._api.options.clock || (this.clockSettings.allowSetting = !1, this.clockSettings.show = !1), this.gameVersion = this._api.options.version, this.showGameClientBuiltDate && (this.gameVersionDate = (null === (e = this._api.options.info) || void 0 === e ? void 0 : e.date) || void 0, this.gameVersionDate && (this.gameVersionDate = this.gameVersionDate.split("T")[0])), this._isSet = !0, this.applyRules()
					}
					applyRules() {
						this._api.settings.set(s.APISetting.CLOCK, this.clockSettings.show), this.fastSpinEnabled || this._api.settings.set(s.APISetting.FAST_SPIN, this.fastSpinEnabled), this._api.clock.onGameClientConfigurationApplied(), this._api.events.trigger(n.APIEvent.GAME_CLIENT_CONFIGURATION_APPLIED), this._api.events.trigger(n.APIEvent.MINIMUM_SPIN_TIME, this.minimumSpinTime)
					}
				}
				a.SHOW_GAMBLE_RULES_GAME_NAMES = ["Book of Shadows", "Immortal Fruits"], e.GameClientConfiguration = a
			},
			42775: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GameInfo = e.isGameInfoData = void 0;
				const n = i(49490),
					s = i(46334);

				function o(t) {
					return void 0 !== t.displayName || null != t.maxMultiplier || null != t.maxMultiplierProbability || null != t.volatility
				}
				e.isGameInfoData = o, e.GameInfo = class {
					constructor(t) {
						this._needsUpdate = !1, this._hasInit = !1, this._api = t, this.displayName = t.options.game, this.gameInfos = new Map, t.events.on(n.APIEvent.GAME_INFO, (t => this.onGameInfo(t))), t.events.on(n.APIEvent.BET_GAME_MODE_CHANGED, (() => this.modeChanged()))
					}
					modeChanged() {
						const t = this._api.betLevel.getSelectedBetLevelModeName(),
							e = this.gameInfos.get(t);
						null != e ? (this._hasInit = !0, this.selectedModeInfo = e, this.updateValues()) : (this._needsUpdate = !0, s.Logger.warn("No game info found for game mode: " + t))
					}
					updateScreen(t) {
						const e = t.find("span.maxMultiplier");
						for (let t of e) t.innerHTML = this.selectedModeInfo.maxMultiplier;
						const i = t.find("span.maxMultiplierProbability");
						for (let t of i) t.innerHTML = this.selectedModeInfo.maxMultiplierProbability;
						const n = t.find("span.commonRulesVolatility");
						for (let t of n) t.innerHTML = this.selectedModeInfo.volatility
					}
					onGameInfo(t) {
						if (o(t)) this.gameInfos.set("NORMAL", {
							displayName: t.displayName,
							maxMultiplier: t.maxMultiplier,
							maxMultiplierProbability: "1:" + t.maxMultiplierProbability,
							volatility: t.volatility
						});
						else
							for (let e in t) this.gameInfos.set(e, {
								displayName: t[e].displayName,
								maxMultiplier: t[e].maxMultiplier,
								maxMultiplierProbability: "1:" + t[e].maxMultiplierProbability,
								volatility: t[e].volatility
							});
						this._needsUpdate && (this._needsUpdate = !1, this.modeChanged())
					}
					updateValues() {
						if (this._hasInit) {
							const t = this._api.rtp.getFormattedRtp();
							this.displayName = this.selectedModeInfo.displayName, this._api.gameClientConfiguration.showRtpWatermark && (this.displayName += ", " + this._api.translations.translate("Rtp:") + " " + t), this._api.gameClientConfiguration.showMaxWinProbabilityWatermark && (this.displayName += ", " + this._api.translations.translate("Max win probability:") + " " + this.selectedModeInfo.maxMultiplierProbability), this.updateDom()
						}
					}
					updateDom() {
						const t = document.querySelector("#game-name-version");
						t && (t.innerHTML = this.displayName)
					}
				}
			},
			44401: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.MaximumWinCap = void 0;
				const n = i(49490);
				class s {
					constructor(t) {
						t.events.on(n.APIEvent.INIT, (e => {
							null != e.maxGambleExposure && (this._maxGambleExposure = t.currency.format(e.maxGambleExposure, s.MAXIMUM_GAMBLE_EXPOSURE_FORMAT_OPTIONS))
						})), t.events.on("maximumWinCap", (e => {
							this._maximumWinCap = t.currency.format(e, s.MAXIMUM_WIN_CAP_FORMAT_OPTIONS)
						}))
					}
					updateScreen(t) {
						t.find(".win-cap").forEach((t => t.innerHTML = this._maximumWinCap)), t.find(".maxGambleExposure").forEach((t => t.innerHTML = this._maxGambleExposure))
					}
				}
				s.MAXIMUM_WIN_CAP_FORMAT_OPTIONS = {
					precision: 0,
					thousandSeparator: "&thinsp;"
				}, s.MAXIMUM_GAMBLE_EXPOSURE_FORMAT_OPTIONS = {
					precision: 0,
					thousandSeparator: "&thinsp;"
				}, e.MaximumWinCap = s
			},
			69473: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NetPosition = void 0;
				const n = i(49490),
					s = i(82748);
				e.NetPosition = class {
					constructor(t) {
						this._isFeatureBuy = !1, this._api = t, t.events.on(n.APIEvent.INIT, (() => this.init()))
					}
					init() {
						this._netPosition = document.querySelector("#net-position"), this._netPosition && (this._netPosition.style.display = "none"), 1 == this._api.gameClientConfiguration.showNetPosition && 0 == this._api.isReplay && this._api.events.on(n.APIEvent.START, (() => this.addVisuals()))
					}
					addVisuals() {
						this._api.events.on(n.APIEvent.BALANCE, (t => this.onBalanceUpdate(t))), this._api.events.on(n.APIEvent.BET, (t => this.onBet(t))), this._api.events.on(n.APIEvent.ACTION_SPINS_BET, (t => this.onBet(t))), this._api.events.on(n.APIEvent.WIN, (t => this.onWin(t))), this._netPosition = document.querySelector("#net-position"), this._netPositionTranslated = this._api.translations.translate("Net position"), this._netPosition && (this._netPosition.style.display = "block"), this.setNetPosition()
					}
					onBet(t) {
						t.type == s.APIBetType.FEATURE_BET && -1 == t.featureName.indexOf("BOOSTED_BET") ? this._isFeatureBuy = !0 : t.type !== s.APIBetType.ZERO_BET && t.type !== s.APIBetType.GAMBLE_BET && this.setNetPosition()
					}
					onWin(t) {
						this.setNetPosition()
					}
					onBalanceUpdate(t) {
						1 == this._isFeatureBuy && (this._isFeatureBuy = !1, this.setNetPosition())
					}
					setNetPosition() {
						this._netPosition && (this._netPosition.innerHTML = this._netPositionTranslated + " " + this._api.currency.format(this._api.realityCheck.getTotalWins() - this._api.realityCheck.getTotalBets()))
					}
				}
			},
			22636: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NolimitApiPlugin = void 0;
				const n = i(38694),
					s = i(41122),
					o = i(49490),
					r = i(30835),
					a = i(52780),
					l = i(30831),
					h = i(44401),
					u = i(78528),
					c = i(78539),
					d = i(18027),
					p = i(23190),
					_ = i(12355),
					m = i(82934),
					g = i(79108),
					f = i(35878),
					S = i(33025),
					y = i(42775),
					v = i(66704),
					T = i(3272),
					E = i(72468),
					b = i(69473),
					A = i(91980),
					P = i(58676),
					I = i(93448),
					w = i(77536),
					L = i(34112),
					C = i(35273),
					x = i(82935);
				e.NolimitApiPlugin = class {
					constructor() {
						this.name = "ApiPlugin", this.remainingFreeSpins = 0, this.gameName = "", this.screenSystem = i(93295), this.onErrorHandler = (t, e, i, n, s) => {
							this.onGeneralError(t.toString(), e, i, n, s)
						}, this._gameApi = C, this._gameApi.init(), this._gameApi.events.on(o.APIEvent.INIT, (t => {
							this._initData = t
						})), this._gameApi.options.quality = this._gameApi.settings.get("quality", this._gameApi.options.quality), this._gameApi.log("Slot options", this._gameApi.options), this.eventSystemFactory = x, void 0 !== this._gameApi.options.replay && (window.nolimit = window.nolimit || {}, window.nolimit.api = window.nolimit.api || {}, window.nolimit.options = this._gameApi.options)
					}
					openReplay(t) {
						this.replayController.openReplay(t)
					}
					destroy() {
						this._gameApi.events.shutdown(), this._gameApi = void 0, window.removeEventListener("error", this.onErrorHandler), window.nolimit = void 0
					}
					get isReplay() {
						return null != this.options.replay
					}
					log(t, ...e) {
						this._gameApi.log(t, e)
					}
					warn(t, ...e) {
						this._gameApi.warn(t, e)
					}
					getGameElement() {
						return this._gameApi.getGameElement()
					}
					fetchPlugins() {
						for (let t of A.NolimitLauncher.plugins)(0, P.isGamePlugin)(t) && (this.gamePlugin = t)
					}
					init() {
						return new Promise(((t, e) => (this.events = this._gameApi.events, this.fetchPlugins(), this.addEventListeners(), this.betHandler = new f.BetHandler(this), this._gameApi.bet = this.betHandler.bet.bind(this.betHandler), this.lastBet = this._gameApi.lastBet, this.css = this._gameApi.css, this.overlay = this._gameApi.overlay, this.resize = this._gameApi.resize, this.messages = this._gameApi.messages, this.loaderInteraction = this._gameApi.loaderInteraction, this.time = this._gameApi.time, this.visibilityDetector = this._gameApi.visibilityDetector, this.realityCheck = this._gameApi.realityCheck, this.maxWinCap = this._gameApi.maxWinCap, this.gameMode = this._gameApi.gameMode, this.analytics = this._gameApi.analytics, this.error = this._gameApi.error, this.communication = this._gameApi.communication, this.externalApi = this._gameApi.externalApi, this.resources = this._gameApi.resources, this.balance = this._gameApi.balance, this.betLevel = new L.BetLevelHandler(this, this.gamePlugin), this.translations = this._gameApi.translations, this.currency = this._gameApi.currency, this.log = this._gameApi.log, this.options = this._gameApi.options, this.settings = this._gameApi.settings, this.dialog = new S.DialogHandler(this, this._gameApi.dialog), this.winTracker = new d.WinTracker(this), this.clock = new n.ClockModel(this), this.balanceIdHandler = new I.BalanceIdHandler(this), this.freeBets = new m.FreeBetsHandler(this), this.freeFeatureBet = new T.FreeFeatureBetHandler(this), this.rtp = new l.Rtp(this), this.maximumWinCap = new h.MaximumWinCap(this), this.payoutMultiplier = new u.PayoutMultiplier(this), this.fullscreen = new c.Fullscreen(this), this.slotStates = new s.SlotStateHandler(this), this.gameClientConfiguration = new v.GameClientConfiguration(this), this.bonusFeatures = new g.BonusFeatureHandler(this), this.gameInfo = new y.GameInfo(this), this.netPosition = new b.NetPosition(this), this.replayController = new p.ReplayController(this), this.betFeatureController = new w.BetFeatureController(this, this.gamePlugin), this.gameName = this._gameApi.options.game.replace(/(\B[A-Z][a-z])/g, " $1"), this.options.version && this.options.version.startsWith("0.") && (this.gameName = this.gameName + " (BETA)"), this.getInitData().then((e => {
							t(this)
						})))))
					}
					getReady() {
						return new Promise(((t, e) => {
							this._gameApi.loaded(), t(this)
						}))
					}
					getReadyToStart() {
						return new Promise(((t, e) => {
							if (this._gameApi.ready(), this.slotStates.checkState(s.SlotState.RESTORE) && 0 == E.NolimitApplication.apiPlugin.freeFeatureBet.hasFreeFeatureBet()) {
								const t = this.betLevel.getLevel();
								this.betLevel.setLevel(t)
							}
							this.betFeatureController.start(), t(this)
						}))
					}
					start() {
						return new Promise(((t, e) => {
							this.freeBets.start(), this.freeFeatureBet.start(), t(this)
						}))
					}
					startGame() {
						this._gameApi.start()
					}
					getGameRules() {
						const t = new _.TemplateLoader(this.resources.getStaticRoot());
						return t.add({
							name: "common-rules",
							url: "node_modules/@nolimitcity/slot-launcher/resources/default/templates/common-rules.mustache"
						}), t.load().then((t => {
							for (let e of t)
								if ("common-rules" == e.name && e.loadedData) return e.loadedData;
							throw new Error("NolimitApiPlugin could not load Rules")
						}))
					}
					getInitData() {
						return null != this._initData ? Promise.resolve(this._initData) : new Promise(((t, e) => {
							this.events.on(o.APIEvent.INIT, (e => {
								this._initData = e, setTimeout((() => t(e)))
							}))
						}))
					}
					addEventListeners() {
						this.events.on("remainingFreeSpins", (t => {
							this.remainingFreeSpins = t
						})), window.addEventListener("error", this.onErrorHandler), this.gamePlugin && this.events.on(o.APIEvent.SOFT_RESET, (() => this.onSoftReset()))
					}
					onSoftReset() {
						let t = this.settings.get(r.APISetting.SFX, !1),
							e = this.settings.get(r.APISetting.MUSIC, !1);
						this.settings.set(r.APISetting.SFX, !1), this.settings.set(r.APISetting.MUSIC, !1);
						const i = null != this.gamePlugin ? this.gamePlugin.getNoWinGameData() : void 0;
						i.isFakeData = !0, null != i && this.events.trigger(o.APIEvent.GAME, i), this.slotStates.stateIsReady().then((i => {
							this.settings.set(r.APISetting.SFX, t), this.settings.set(r.APISetting.MUSIC, e)
						}))
					}
					onGeneralError(t, e, i, n, s) {
						console.log(t, e, i, n, s), this.error.trigger(t, a.APIErrorCode.JAVASCRIPT)
					}
				}
			},
			78528: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PayoutMultiplier = void 0, e.PayoutMultiplier = class {
					constructor(t) {
						this.apiPlugin = t
					}
					updateScreen(t) {
						let e = parseFloat(this.apiPlugin.betLevel.getLevel());
						this.apiPlugin.freeBets.hasFreeBets() && (e = parseFloat(this.apiPlugin.freeBets.getBet())), t.find("[data-multiplier].multiplier").forEach((t => {
							const i = e * t.dataset.multiplier,
								n = i >= 10 && i.toFixed(2).endsWith("00");
							t.textContent = n ? i.toFixed(0) : this.apiPlugin.currency.formatValue(i)
						}))
					}
				}
			},
			23190: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ReplayController = void 0, e.ReplayController = class {
					constructor(t) {
						this.linkPopup = '\n<style>\n    @keyframes fadeOut {\n        from {\n            opacity: 1;\n        }\n        to {\n            opacity: 0;\n        }\n    }\n</style>\n<div class="overlay" style="display:flex; background: rgba(0,0,0,0.7)">\n    <div class="dialog">\n        <h1>{{#tr}}Replay{{/tr}}</h1>\n        <p>{{#tr}}To watch the replay, copy the URL and paste the link in a browser{{/tr}}</p>\n        <p style="user-select: auto">{{url}}</p>\n        \n        <p class="copied" style="opacity:0">{{#tr}}URL copied to clipboard{{/tr}}</p>    \n        <div>\n            <button type="button" class="close">{{#tr}}OK{{/tr}}</button>\n            <button type="button" class="copy">{{#tr}}COPY{{/tr}}</button>\n        </div>\n  \n    </div>\n</div>', this.blockedPopup = '\n<style>\n    @keyframes fadeOut {\n        from {\n            opacity: 1;\n        }\n        to {\n            opacity: 0;\n        }\n    }\n</style>\n<div class="overlay" style="display:flex; background: rgba(0,0,0,0.7)">\n    <div class="dialog">\n        <h1>{{#tr}}Replay launch failed{{/tr}}</h1>\n        <p>{{#tr}}Please disable pop-up block in settings or copy the URL below and paste in a browser.{{/tr}}</p>\n        <p style="user-select: auto">{{url}}</p>\n        \n        <p class="copied" style="opacity:0">{{#tr}}URL copied to clipboard{{/tr}}</p>    \n        <div>\n            <button type="button" class="close">{{#tr}}OK{{/tr}}</button>\n            <button type="button" class="copy">{{#tr}}COPY{{/tr}}</button>\n        </div>\n  \n    </div>\n</div>', this.apiPlugin = t
					}
					setupButtons(t, e) {
						const i = t.querySelectorAll(".close");
						for (let e = 0; e < i.length; e++) i[e].addEventListener("click", (() => {
							t.remove()
						}));
						const n = t.querySelectorAll(".copy"),
							s = t.querySelectorAll(".copied")[0];
						for (let t = 0; t < n.length; t++) n[t].addEventListener("click", (() => {
							s.style.animation = "none", s.offsetHeight, s.style.animation = "fadeOut 3s forwards", navigator.clipboard.writeText(e)
						}))
					}
					checkPopUpBlock(t) {
						setTimeout((() => {
							document.hidden || this.showPopup(this.blockedPopup, t)
						}), 400)
					}
					showPopup(t, e) {
						const i = document.querySelector(".nolimit.container"),
							n = document.createElement("div");
						n.innerHTML = this.apiPlugin.translations.render(t, {
							url: e
						}), this.setupButtons(n, e), i.appendChild(n)
					}
					openReplay(t) {
						!0 === this.apiPlugin.options.useReplayLinkPopup ? this.showLinkPopup(t) : this.playReplay(t)
					}
					showLinkPopup(t) {
						"string" == typeof t ? this.showPopup(this.linkPopup, t) : this.apiPlugin.communication.history.replayUrl(t).then((t => {
							this.showPopup(this.linkPopup, t.url)
						}))
					}
					playReplay(t) {
						let e = document.createElement("a");
						if (e.setAttribute("target", "_blank"), e.setAttribute("rel", "noopener"), "string" == typeof t) {
							const i = new URL(t),
								n = i.href;
							i.searchParams.append("device", this.apiPlugin.options.device), i.searchParams.append("language", this.apiPlugin.options.language), i.searchParams.append("fromGame", "true"), e.setAttribute("href", i.href), e.click(), e.remove(), this.checkPopUpBlock(n)
						} else this.apiPlugin.communication.history.replayUrl(t).then((t => {
							const i = new URL(t.url),
								n = i.href;
							i.searchParams.append("device", this.apiPlugin.options.device), i.searchParams.append("language", this.apiPlugin.options.language), i.searchParams.append("fromGame", "true"), e.setAttribute("href", i.href), e.click(), e.remove(), this.checkPopUpBlock(n)
						}))
					}
				}
			},
			30831: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Rtp = e.isRtpEventData = void 0;
				const n = i(49490),
					s = i(72468),
					o = i(46334);

				function r(t) {
					return void 0 !== t.single || void 0 !== t.min || void 0 !== t.max || void 0 !== t.fractionDigits || void 0 !== t.features
				}
				e.isRtpEventData = r;
				class a {
					addSimpleFormatter(t, e) {
						return {
							target: "span.rtp",
							value: a.formatRTP(t, e)
						}
					}
					addFormatters(t, e, i) {
						const n = null != i ? "-" + i : "",
							s = [];
						return t.single && s.push({
							target: "span.rtp" + n,
							value: a.formatRTP(t.single, e, t.fractionDigits)
						}), t.min && s.push({
							target: "span.min-rtp" + n,
							value: a.formatRTP(t.min, e, t.fractionDigits)
						}), t.max && s.push({
							target: "span.max-rtp" + n,
							value: a.formatRTP(t.max, e, t.fractionDigits)
						}), s
					}
					addFormattersForMode(t, e) {
						const i = [];
						if (i.push(...this.addFormatters(t, e)), t.features)
							for (let n in t.features) i.push(...this.addFormatters(t.features[n], e, n));
						return i
					}
					constructor(t) {
						this._gameModeRtp = new Map, this._api = t, t.events.on(n.APIEvent.RTP, (t => this.onRtp(t)))
					}
					onRtp(t) {
						const e = typeof t;
						if ("string" === e || "number" === e) {
							const e = [];
							e.push(this.addSimpleFormatter(t, this._api.options.language)), this._gameModeRtp.set("NORMAL", {
								rtpData: {
									single: t
								},
								formatters: e
							})
						} else if ("object" === e)
							if (r(t)) {
								const e = [];
								e.push(...this.addFormattersForMode(t, this._api.options.language)), this._gameModeRtp.set("NORMAL", {
									rtpData: t,
									formatters: e
								})
							} else {
								const e = t;
								for (let t in e) {
									const i = typeof e[t];
									if ("string" === i || "number" === i) {
										const i = [];
										i.push(this.addSimpleFormatter(e[t], this._api.options.language)), this._gameModeRtp.set(t, {
											rtpData: {
												single: e[t]
											},
											formatters: i
										})
									} else if (r(e[t])) {
										const i = [];
										i.push(...this.addFormattersForMode(e[t], this._api.options.language)), this._gameModeRtp.set(t, {
											rtpData: e[t],
											formatters: i
										})
									}
								}
							} this._api.gameInfo.updateValues()
					}
					getFormattedRtp() {
						const t = this._api.betLevel.getSelectedBetLevelModeName(),
							e = this._gameModeRtp.get(t);
						if (e) {
							if (null != e.rtpData.single) return a.formatRTP(e.rtpData.single, this._api.options.language, e.rtpData.fractionDigits);
							if (null != e.rtpData.min && null != e.rtpData.max) return a.formatRTP(e.rtpData.min, this._api.options.language, e.rtpData.fractionDigits) + " - " + a.formatRTP(e.rtpData.max, this._api.options.language, e.rtpData.fractionDigits)
						}
						return o.Logger.warn("No valid RTP values found"), ""
					}
					static formatRTP(t, e, i = 2) {
						try {
							return t.toLocaleString(e, {
								style: "percent",
								minimumFractionDigits: i,
								maximumFractionDigits: i
							})
						} catch (e) {
							return t.toLocaleString("en", {
								style: "percent",
								minimumFractionDigits: i,
								maximumFractionDigits: i
							})
						}
					}
					updateScreen(t) {
						const e = this._api.betLevel.getSelectedBetLevelModeName(),
							i = this._gameModeRtp.get(e);
						if (i)
							for (let e of i.formatters) {
								const i = t.find(e.target);
								for (let t of i) t.textContent = e.value
							}
						const n = s.NolimitApplication.apiPlugin.betLevel.getAllowedModeNames();
						for (let i of n) i == e ? t.find("." + i).forEach((t => t.style.display = "")) : t.find("." + i).forEach((t => t.style.display = "none"));
						s.NolimitApplication.apiPlugin.betLevel.hasCapWinLimitToggle() || t.find(".capWinToggle").forEach((t => t.style.display = "none"))
					}
				}
				e.Rtp = a
			},
			41122: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SlotStateHandler = e.SlotState = void 0;
				const n = i(49490),
					s = i(82748),
					o = i(46334);
				var r;
				! function(t) {
					t.READY = "ready", t.STARTING = "starting", t.STOPPABLE = "stoppable", t.STOPPING = "stopping", t.SKIPPABLE = "skippable", t.SKIPPED = "skipped", t.DONE = "done", t.GAMBLE = "gamble", t.GAMBLING = "gambling", t.GAMBLE_COLLECT = "gamblingCollect", t.GAMBLE_DONE = "gambleDone", t.FINISHING = "finishing", t.FINISH = "finish", t.RESTORE = "restore", t.PAUSED = "paused", t.DIALOG = "dialog", t.DIALOG_CLOSED = "dialogClosed", t.SCREEN = "screen", t.SCREEN_CLOSED = "screenClosed", t.STOP = "stop", t.SKIP = "skip", t.START_UP = "startUp"
				}(r = e.SlotState || (e.SlotState = {}));
				const a = {
					gameServer: !1,
					gameStarted: !1,
					reset: function() {
						this.gameStarted = !1, this.gameServer = !1
					},
					isStoppableAvailable: function() {
						return this.gameStarted && this.gameServer
					}
				};
				class l {
					constructor(t) {
						this.freeSpins = 0, this._state = r.START_UP, this._isRestore = !1, this._stateQueue = [], this._stateQueueBusy = !1, this._isPaused = !1, this._isActionSpinActive = !1, this.hasEndedRound = !0, this.logger = o.Logger.createNamedLogger("SlotStateHandler"), this.logger.level = o.LogLevel.DEV, this._api = t, this.container = document.querySelector(".nolimit.container"), this.addEventListeners(), this.lockDialogs(!0)
					}
					checkState(...t) {
						return t.some((t => this.container.classList.contains(t)))
					}
					getState() {
						for (let t of Object.values(r))
							if (this.container.classList.contains(t)) return t;
						return "none"
					}
					setState(t) {
						return this.isValidState(t) || this._api.error.trigger("State does not exist"), this.executeState(t)
					}
					executeState(t) {
						return new Promise((e => {
							for (let t of Object.values(r)) this.container.classList.contains(t) && this.container.classList.remove(t);
							this.container.classList.add(t), this._state = t, t != r.READY && this.setIsBusy(), this._isActionSpinActive || this._api.events.trigger(n.APIEvent.STATE, t), e(t)
						}))
					}
					isValidState(t) {
						for (let e of Object.values(r))
							if (t == e) return !0;
						return !1
					}
					addEventListeners() {
						this._api.events.on(n.APIEvent.READY, (() => {
							this._isRestore ? this.setState(r.RESTORE) : this.setState(r.READY)
						})), this._api.events.on(n.APIEvent.INIT, (t => {
							!0 === t.isRestoreState && (this._isRestore = !0, this.lockDialogs(!0))
						})), this._api.events.on(n.APIEvent.START, (t => {
							this.lockDialogs(this._isRestore), this._isRestore = !1
						})), this._api.events.on(n.APIEvent.ACTION_SPINS_IS_ACTIVE, (t => {
							this._isActionSpinActive = t
						})), this._api.events.on(n.APIEvent.ACTION_SPINS_BET, (() => {
							this.hasEndedRound = !1, this.lockDialogs(!0), this.setState(r.STARTING), this.lastBalance = this._api.balance.getAmount()
						})), this._api.events.on(n.APIEvent.BET, (t => {
							this.hasEndedRound = !1, this.lockDialogs(!0), t.type !== s.APIBetType.GAMBLE_BET ? (this.setState(r.STARTING), this.lastBalance = this._api.balance.getAmount()) : 1 == t.playerInteraction.gambleCollected ? this.setState(r.GAMBLE_COLLECT) : this.setState(r.GAMBLING)
						})), this._api.events.on(n.APIEvent.GAME, (() => {
							a.gameServer = !0, this.tryGoToStoppable()
						})), this._api.events.on(n.APIEvent.DIALOG, (t => {
							"open" == t ? this.dialogOpened() : this.dialogClosed()
						})), this._api.events.on(n.APIEvent.SCREEN, (t => {
							"open" == t ? this.dialogOpened(!0) : this.dialogClosed(!0)
						})), this._api.events.on(n.APIEvent.STARTED, (() => {
							a.gameStarted = !0, this.tryGoToStoppable()
						})), this._api.events.on(n.APIEvent.STOP, (() => {
							this.checkState(r.STOPPABLE) && this.setState(r.STOPPING)
						})), this._api.events.on(n.APIEvent.SKIPPABLE, (() => {
							this.checkState(r.STOPPING, r.SKIPPED) ? this.setState(r.SKIPPABLE) : this._api.warn("Requested Skippable in none compatible state:[" + this.getState() + "]. Ignoring request")
						})), this._api.events.on(n.APIEvent.SKIP, (() => {
							this.setState(r.SKIPPED)
						})), this._api.events.on(n.APIEvent.FINISHING, (() => {
							this.setState(r.FINISHING)
						})), this._api.events.on(n.APIEvent.FINISH, (() => {
							this.endGameRound()
						})), this._api.events.on(n.APIEvent.DONE, (() => {
							this.setState(r.DONE)
						})), this._api.events.on(n.APIEvent.GAMBLE, (() => {
							this.setState(r.GAMBLE)
						})), this._api.events.on(n.APIEvent.GAMBLE_DONE, (() => {
							this.setState(r.GAMBLE_DONE)
						})), this._api.events.on(n.APIEvent.PAUSE, (() => this.onPause())), this._api.events.on(n.APIEvent.RESUME, (() => this.onResume())), this._api.events.on(n.APIEvent.REMAINING_FREE_SPINS, (t => {
							this.freeSpins = parseInt(t)
						})), this._api.events.on("operatorDialogOpened", (() => this.onOperatorDialog(!0))), this._api.events.on("operatorDialogClosed", (() => this.onOperatorDialog(!1))), this._api.events.on(l.READY_STATE, (() => {}))
					}
					stateIsReady() {
						return new Promise(((t, e) => {
							this._api.slotStates.getState() == r.READY ? t() : this._api.events.once(l.READY_STATE, (() => {
								t()
							}))
						}))
					}
					resetGameStartedAndGameServerFlag() {
						a.reset()
					}
					lockDialogs(t) {
						t ? this._api.dialog.lock("statehandler") : this._api.dialog.unlock("statehandler")
					}
					setIsBusy() {
						this._state !== r.READY ? this._api.events.trigger(n.APIEvent.BUSY) : this._api.events.trigger(n.APIEvent.IDLE)
					}
					endGameRound() {
						this.checkState(r.DONE, r.FINISHING, r.GAMBLE_DONE) ? (this.setState(r.FINISH), a.reset(), this.prepareForReady()) : this._api.warn("State is not FINISHING, DONE or GAMBLE_DONE. Current state: ", this.getState())
					}
					tryGoToStoppable() {
						a.isStoppableAvailable() && (setTimeout((() => this.setState(r.STOPPABLE))), a.reset())
					}
					dialogOpened(t = !1) {
						t ? (this.lockDialogs(!0), this.setState(r.SCREEN)) : this.setState(r.DIALOG)
					}
					dialogClosed(t = !1) {
						t ? this.setState(r.SCREEN_CLOSED).then((t => {
							this.prepareForReady()
						})) : this.setState(r.DIALOG_CLOSED).then((t => {
							this.prepareForReady()
						}))
					}
					onOperatorDialog(t) {
						this.logger.log("onOperatorDialog, open: " + t), t ? this.container.classList.contains("overlay") || (this.container.classList.add("overlay"), this._api.events.trigger(n.APIEvent.FREEZE, !1)) : this.container.classList.contains("overlay") && (this.container.classList.remove("overlay"), this.hasEndedRound ? (this.logger.log("onOperatorDialog, hasEnded"), this._api.events.trigger(n.APIEvent.UNFREEZE, !1), this.dialogClosed()) : (this.logger.log("onOperatorDialog, waitingForEnd"), this.container.classList.add("operatorDialogClosed")))
					}
					prepareForReady() {
						return this.hasEndedRound = !0, this.container.classList.contains("overlay") ? (this.logger.log("prepareForReady, has overlay"), void this.dialogOpened()) : this.container.classList.contains("operatorDialogClosed") ? (this.logger.log("prepareForReady, operatorDialogClosed"), this.container.classList.remove("operatorDialogClosed"), this._api.events.trigger(n.APIEvent.UNFREEZE, !1), void this.dialogClosed()) : (this.logger.log("prepareForReady"), this.lockDialogs(!1), void(this.checkState(r.DIALOG, r.SCREEN) || (this.setState(r.READY), this.setIsBusy(), this._api.events.trigger(l.READY_STATE))))
					}
					onPause() {
						this._isPaused = !0
					}
					onResume() {
						this._isPaused && (this._isPaused = !1, this.prepareForReady())
					}
				}
				l.READY_STATE = "readyState", e.SlotStateHandler = l
			},
			18027: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.WinTracker = void 0;
				const n = i(49490),
					s = i(82748),
					o = i(5217);
				e.WinTracker = class {
					constructor(t) {
						this._pendingWin = !1, this._previousTotalWins = 0, this._winnings = 0, this._api = t, t.events.on(n.APIEvent.PENDING_WIN, (() => {
							this._pendingWin = !0
						})), t.events.on(n.APIEvent.BET, (t => {
							t.type === s.APIBetType.NORMAL_BET && (this._lastBalance -= parseFloat(t.bet)), t.featureName === o.GameFeatureCategory.BOOSTED_BET && (this._lastBalance -= parseFloat((1.1 * +t.bet).toFixed(2)))
						})), t.events.on(n.APIEvent.ACTION_SPINS_BET, (t => {
							t.type === s.APIBetType.NORMAL_BET && (this._lastBalance -= parseFloat(t.bet))
						})), t.events.on(n.APIEvent.BALANCE, (t => {
							t = parseFloat(t), this._lastBalance && t > this._lastBalance && (this._winnings += t - this._lastBalance), this._lastBalance = t
						})), t.events.on(n.APIEvent.DONE, (() => {
							this._pendingWin = !1
						})), t.events.on(n.APIEvent.GAMBLE_DONE, (() => {
							this._pendingWin = !1
						})), t.events.on(n.APIEvent.FINISH, (() => this.triggerWinEvent()))
					}
					triggerWinEvent() {
						if (this._api.realityCheck.getTotalWins() > this._previousTotalWins && !this._pendingWin) {
							let t = this._api.realityCheck.getTotalWins() - this._previousTotalWins,
								e = t.toFixed(2);
							const i = t.toString();
							i.indexOf(".") > -1 && i.length - i.indexOf(".") > 3 && (e = t.toFixed(4)), this._previousTotalWins = this._api.realityCheck.getTotalWins(), this._api.events.trigger(n.APIEvent.WIN, parseFloat(e))
						}
					}
					getTotalWinnings() {
						return this._winnings
					}
				}
			},
			93448: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BalanceIdHandler = void 0;
				const n = i(49490),
					s = i(30835);
				e.BalanceIdHandler = class {
					get balanceId() {
						return this._balanceId
					}
					set balanceId(t) {
						this._balanceId = t, null != this._balanceId ? (this.api.settings.set(s.APISetting.BALANCE_ID, this._balanceId), this.hasAddedInjectCallback || (this.hasAddedInjectCallback = !0, this.api.betHandler.addBetDataInjectCallback((t => this.injectBalanceIdCallback(t))))) : this.api.settings.remove(s.APISetting.BALANCE_ID)
					}
					constructor(t) {
						this.hasAddedInjectCallback = !1, this.api = t, this.api.settings.remove(s.APISetting.BALANCE_ID), t.events.on(n.APIEvent.SET_BALANCE_ID, (t => {
							this.balanceId = t
						}))
					}
					injectBalanceIdCallback(t) {
						return null == this.balanceId || (t.data ? t.data.balanceId = this.balanceId : t.data = {
							balanceId: this.balanceId
						}), t
					}
				}
			},
			77536: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BetFeatureController = e.BetFeature = void 0;
				const n = i(49490),
					s = i(72468),
					o = i(61e3);
				class r {
					get price() {
						return this._api.betLevel.getPriceForFeature(this.name)
					}
					constructor(t, e, i) {
						this._api = t, this.name = e.name, this.type = e.type;
						let n = "/nolimit/bonus/" + this.name + ".png";
						this.displayConfig = {
							name: (null == i ? void 0 : i.displayName) || this.name,
							description: null == i ? void 0 : i.displayDescription,
							order: null == (null == i ? void 0 : i.displayOrder) ? Number.MAX_VALUE : null == i ? void 0 : i.displayOrder,
							imageUrl: n,
							forceWarningPopUp: (null == i ? void 0 : i.forceWarningPopUp) || null != (null == i ? void 0 : i.replacePopUpContent) || !1,
							replacePopUpContent: null == i ? void 0 : i.replacePopUpContent
						}
					}
					getMaxCost() {
						return this.calculateCost(this.getMaxBet())
					}
					getMaxBet() {
						return this._api.betLevel.getMaxBetLevelForFeature(this.name)
					}
					isBetLevelValid() {
						return !!this._api.isReplay || this._api.betLevel.isValidBetLevelForFeature(this.name)
					}
					isBetLevelAndCostValid() {
						return this.isBetLevelValid() && this.getTotalCost() <= s.NolimitApplication.apiPlugin.balance.getAmount()
					}
					getTotalCost() {
						return this.calculateCost(this._api.betLevel.getLevel())
					}
					calculateCost(t) {
						return +(parseFloat(t) * this.price).toFixed(2)
					}
				}
				e.BetFeature = r, e.BetFeatureController = class {
					get allowedFeatures() {
						const t = this._api.betLevel.getSelectedBetLevelModeName(),
							e = this.gameModes.get(t);
						if (null != e) return e.allowedFeatures;
						throw new Error("Can't find allowedFeatures for mode: " + t)
					}
					get notAllowedFeatures() {
						const t = this._api.betLevel.getSelectedBetLevelModeName(),
							e = this.gameModes.get(t);
						if (null != e) return e.notAllowedFeatures;
						throw new Error("Can't find notAllowedFeatures feature for mode: " + t)
					}
					constructor(t, e) {
						this._hasInit = !1, this.hasInitCallbacks = [], this._api = t, this._gamePlugin = e, this._shouldShowWarning = new Map, this._shouldShowWarning.set("DEFAULT", !0), this.gameModes = new Map, this._api.events.once(n.APIEvent.ALLOWED_FEATURE_BETS, (t => {
							this._allowedFeaturesData = t, this.constructData()
						})), this._api.events.once(n.APIEvent.INIT, (t => {
							this._featureBuyTimesBetValue = t.featureBuyTimesBetValue || [], this._featureBuyTimesBetValueAll = t.featureBuyTimesBetValueAll || {}, this._numberOfModes = 0;
							for (let t in this._featureBuyTimesBetValueAll) this._numberOfModes += 1;
							this.constructData()
						})), this._api.events.once(n.APIEvent.PLATFORM_FEATURE_NAME, (t => {
							this._featureNameOnInit = t
						}))
					}
					constructData() {
						var t, e;
						if (this._allowedFeaturesData && this._featureBuyTimesBetValue && this._featureBuyTimesBetValueAll) {
							const i = (null === (t = this._gamePlugin) || void 0 === t ? void 0 : t.getNolimitBonusDisplayConfiguration) ? null === (e = this._gamePlugin) || void 0 === e ? void 0 : e.getNolimitBonusDisplayConfiguration() : {};
							if (this._numberOfModes > 0 && !Array.isArray(this._allowedFeaturesData))
								for (let t in this._featureBuyTimesBetValueAll) this._allowedFeaturesData[t] && this.gameModes.set(t, this.createGameModeData(this._allowedFeaturesData[t], this._featureBuyTimesBetValueAll[t], i));
							else this.gameModes.set("NORMAL", this.createGameModeData(this._allowedFeaturesData, this._featureBuyTimesBetValue, i));
							this.loadAssets().then((t => {
								this._hasInit = !0;
								for (let t of this.hasInitCallbacks) t();
								this.hasInitCallbacks = []
							})), delete this._allowedFeaturesData, delete this._featureBuyTimesBetValue, delete this._featureBuyTimesBetValueAll
						}
					}
					createGameModeData(t, e, i) {
						const n = {
							allowedFeatures: new Map,
							notAllowedFeatures: new Map
						};
						for (let s of e)
							if (t.indexOf(s.name) > -1) {
								const t = new r(this._api, s, i[s.name]);
								n.allowedFeatures.set(s.name, t), t.displayConfig.forceWarningPopUp && this._shouldShowWarning.set(s.name, !0)
							} else {
								const t = new r(this._api, s, i[s.name]);
								n.notAllowedFeatures.set(s.name, t)
							} return n
					}
					loadAssets() {
						const t = new o.ImgLoader(s.NolimitApplication.resourcePath),
							e = new Map;
						this.gameModes.forEach((t => {
							t.allowedFeatures.forEach(((t, i) => {
								e.set(i, t)
							}))
						}));
						const i = [...e.values()].sort(((t, e) => t.displayConfig.order - e.displayConfig.order));
						for (let e of i) t.add(e.name, e.displayConfig.imageUrl);
						return t.load()
					}
					dontShowWarningNextTime(t) {
						this._shouldShowWarning.has(t) ? this._shouldShowWarning.set(t, !1) : this._shouldShowWarning.set("DEFAULT", !1)
					}
					shouldShowWarningPopUp(t) {
						let e = this._shouldShowWarning.get(t);
						return null != e ? e : this.shouldShowWarningPopUp("DEFAULT")
					}
					isFeatureAllowed(t) {
						return this.allowedFeatures.has(t)
					}
					getNotAllowedFeatures() {
						return [...this.notAllowedFeatures.values()]
					}
					getAllowedFeatures() {
						return [...this.allowedFeatures.values()].sort(((t, e) => t.displayConfig.order - e.displayConfig.order))
					}
					getFeatureData(t) {
						return this.allowedFeatures.get(t)
					}
					getActiveBetFeature() {
						return this.activeBetFeature
					}
					setActiveBetFeature(t = "") {
						const e = this.allowedFeatures.get(t);
						this.activeBetFeature != e && (null == e || e.isBetLevelAndCostValid()) && (this.activeBetFeature = e, this._api.events.trigger(n.APIEvent.SELECTED_FEATURE_BET_CHANGED))
					}
					start() {
						this._featureNameOnInit && (this.setActiveBetFeature(this._featureNameOnInit), delete this._featureNameOnInit)
					}
					hasInit() {
						return this._hasInit ? Promise.resolve(!0) : new Promise(((t, e) => {
							this.hasInitCallbacks.push((() => {
								t(!0)
							}))
						}))
					}
				}
			},
			35878: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BetHandler = void 0;
				const n = i(49490),
					s = i(82748),
					o = i(52780),
					r = i(41122),
					a = i(49429),
					l = i(79633);
				e.BetHandler = class {
					get betBoost() {
						const t = this._api.betFeatureController.getActiveBetFeature();
						if (null != t) return {
							featureName: t.name,
							playerInteraction: {},
							calculatedPrice: t.getTotalCost(),
							originalPrice: t.price
						}
					}
					set normalBetPlayerInteraction(t) {
						this._normalBetPlayerInteraction = t
					}
					get normalBetPlayerInteraction() {
						return this._normalBetPlayerInteraction
					}
					constructor(t) {
						this._requestDataInjectionCallbacks = [], this._cancelBetAfterCollect = !1, this._isHalt = !1, this._paused = !1, this._hold = !1, this._api = t, this._timeChecker = new a.ElapsedTimeCheck(500, (() => {
							this._api.error.trigger("Bet error", o.APIErrorCode.JAVASCRIPT)
						})), this.addEventListeners()
					}
					addEventListeners() {
						this._api.events.on(n.APIEvent.INIT, (t => this.onData(t))), this._api.events.on(n.APIEvent.GAME, (t => this.onData(t))), this._api.events.on(n.APIEvent.HALT, (() => this.onHalt())), this._api.events.on(n.APIEvent.HOLD, (() => this.onHold())), this._api.events.on(n.APIEvent.PAUSE, (() => this.onPause())), this._api.events.on(n.APIEvent.RESUME, (() => this.onResume())), this._api.events.on(n.APIEvent.CURRENT_BET, (() => this.onBetLevelChange()))
					}
					onHalt() {
						this._isHalt = !0
					}
					onPause() {
						this._paused = !0
					}
					onHold() {
						this._hold = !0
					}
					onResume() {
						this._paused = !1, this._hold = !1
					}
					onBetLevelChange() {
						this.triggerBetBoostEvent()
					}
					triggerBetBoostEvent() {
						const t = this._api.betFeatureController.getActiveBetFeature();
						null != t ? this._api.events.trigger(n.APIEvent.BET_BOOST, {
							calculatedPrice: t.getTotalCost()
						}) : this._api.events.trigger(n.APIEvent.BET_BOOST, void 0)
					}
					onData(t) {
						this._mode = t.mode, this._nextMode = t.nextMode
					}
					runDesignatedFunction(t, e, i) {
						const n = `Bet was called with a non NORMAL bet type: ${t}. `;
						let o = "Please use designated function for this bet type: ";
						switch (t) {
							case s.APIBetType.FREE_BET:
								this.freeBet(i), o = "";
								break;
							case s.APIBetType.ZERO_BET:
								this.zeroBet(i), o += "betHandler.zeroBet(playerInteraction?:any):void", this._api.warn(`${n}${o}`);
								break;
							case s.APIBetType.FEATURE_BET:
								o += "betHandler.buyFeatureBet(featureName:string, playerInteraction:any = {}):void", this._api.error.trigger(`${n}${o}`);
								break;
							case s.APIBetType.PICK_AND_CLICK_BET:
								o += "betHandler.pickAndClickBet(selectedIndex:number, blockBetTrigger:boolean = false):void", this._api.error.trigger(`${n}${o}`);
								break;
							case s.APIBetType.GAMBLE_BET:
								o += "betHandler.gambleBet(gambleCollected:boolean, gambleOption?:string, gambleSelection?:string):void", this._api.error.trigger(`${n}${o}`);
								break;
							default:
								o = ""
						}
					}
					cancelNextAutoBetAfterCollect() {
						this._cancelBetAfterCollect = !0
					}
					shouldAbortBetAfterCollect(t) {
						let e = !1;
						return t && this._cancelBetAfterCollect && (e = !0), this._cancelBetAfterCollect = !1, e
					}
					bet(t = s.APIBetType.NORMAL_BET, e, i) {
						t == s.APIBetType.NORMAL_BET ? this.collectWin().then((n => {
							if (this.shouldAbortBetAfterCollect(n)) return;
							if (!this._api.slotStates.checkState(r.SlotState.READY)) return void this._api.error.trigger("Trying to bet in non ready state", o.APIErrorCode.JAVASCRIPT);
							const s = this._api.betFeatureController.getActiveBetFeature();
							null != s ? this.buyFeatureBet(s.name, s.getTotalCost(), i) : this._api.freeBets.hasFreeBets() ? this.freeBet(i) : this.normalBet(t, e, i)
						})).catch((t => {
							this._api.error.trigger("Bet error:" + t, o.APIErrorCode.JAVASCRIPT)
						})) : this.runDesignatedFunction(t, e, i)
					}
					normalBet(t = s.APIBetType.NORMAL_BET, e = this._api.betLevel.getLevel(), i) {
						if (this.checkBalance(e)) {
							const n = {
								type: t,
								bet: e,
								playerInteraction: this.assignNormalBetPlayerInteraction(i)
							};
							this.sendRequest(n)
						}
					}
					actionSpinsNormalBet(t = s.APIBetType.NORMAL_BET, e = this._api.betLevel.getLevel(), i) {
						if (t === s.APIBetType.ZERO_BET || this.checkBalance(e)) {
							const i = {
								type: t,
								bet: e,
								playerInteraction: {
									actionSpin: !0
								}
							};
							this.sendRequestForLightningSpins(i)
						}
					}
					actionSpinsPickAndClickBet(t, e = !0) {
						const i = {
								actionSpin: !0,
								selectedIndex: t.toString()
							},
							n = {
								type: s.APIBetType.ZERO_BET,
								bet: "0.00",
								playerInteraction: i
							};
						this.sendRequestForLightningSpins(n, !e)
					}
					lightningSpinsBet(t = s.APIBetType.NORMAL_BET, e = this._api.betLevel.getLevel(), i) {
						this.collectWin().then((n => {
							if (this.shouldAbortBetAfterCollect(n)) return;
							const o = this._api.betFeatureController.getActiveBetFeature();
							t === s.APIBetType.ZERO_BET ? this.actionSpinsNormalBet(t, e, i) : null != o ? this.actionSpinsBoostedBet(o) : this._api.freeBets.hasFreeBets() ? this.freeBet(i) : this.actionSpinsNormalBet(t, e, i)
						})).catch((t => {
							this._api.error.trigger("Bet error:" + t, o.APIErrorCode.JAVASCRIPT)
						}))
					}
					lightningSpinsFeatureBet(t, e = {}) {
						null == e.featureName && (e.featureName = t, e.actionSpin = !0);
						const i = {
							type: s.APIBetType.FEATURE_BET,
							bet: this._api.betLevel.getLevel(),
							featureName: t,
							playerInteraction: e
						};
						this.sendRequestForLightningSpins(i)
					}
					sendRequestForLightningSpins(t, e = !0) {
						this.allowedToSendBet() && (t = this.injectData(t), e && this._api.events.trigger(n.APIEvent.ACTION_SPINS_BET, t), this._api.communication.send("normal", t))
					}
					freeBet(t) {
						const e = {
							type: s.APIBetType.FREE_BET,
							bet: this._api.freeBets.getBet(),
							playerInteraction: this.assignNormalBetPlayerInteraction(t)
						};
						this.sendRequest(e)
					}
					assignNormalBetPlayerInteraction(t) {
						return null != t ? t.assign(this._normalBetPlayerInteraction) : t = this._normalBetPlayerInteraction, t
					}
					zeroBet(t) {
						const e = {
							type: s.APIBetType.ZERO_BET,
							bet: "0.00",
							playerInteraction: t
						};
						this.sendRequest(e)
					}
					buyFeatureBet(t, e, i = {}) {
						this.checkBalance(e) && this._api.slotStates.stateIsReady().then((() => {
							null == i.featureName && (i.featureName = t);
							const e = {
								type: s.APIBetType.FEATURE_BET,
								bet: this._api.betLevel.getLevel(),
								featureName: t,
								playerInteraction: i
							};
							this.sendRequest(e)
						}))
					}
					freeFeatureBet(t, e = {}) {
						t && this._api.slotStates.stateIsReady().then((() => {
							null == e.featureName && (e.featureName = t.featureName);
							const i = {
								type: s.APIBetType.FEATURE_BET,
								bet: t.bet.toString(),
								featureName: t.featureName,
								playerInteraction: e,
								data: {
									isPromotional: !0
								}
							};
							this.sendRequest(i)
						}))
					}
					gambleBet(t, e, i, n = !1) {
						const o = {};
						null != e && (o.gambleOption = e), null != i && (o.gambleSelection = i), o.gambleCollected = t;
						const r = {
							type: s.APIBetType.GAMBLE_BET,
							bet: "0.00",
							playerInteraction: o
						};
						n ? (r.playerInteraction.actionSpin = !0, this.sendRequestForLightningSpins(r)) : this.sendRequest(r)
					}
					boostedBet(t) {
						if (this.checkBalance(t.calculatedPrice)) {
							if (1 == t.originalPrice) {
								const e = this._api.betLevel.getLevel(),
									i = t.calculatedPrice - parseFloat(e);
								this._api.balance.subtract(i)
							}
							this.buyFeatureBet(t.featureName, t.playerInteraction)
						}
					}
					actionSpinsBoostedBet(t) {
						this.checkBalance(t.getTotalCost()) && this.lightningSpinsFeatureBet(t.name)
					}
					setBoost(t) {
						this._api.betFeatureController.setActiveBetFeature(null == t ? void 0 : t.featureName), this.triggerBetBoostEvent()
					}
					pickAndClickBet(t, e = !0) {
						const i = {
								selectedIndex: t.toString()
							},
							n = {
								type: s.APIBetType.ZERO_BET,
								bet: "0.00",
								playerInteraction: i
							};
						this.sendRequest(n, !e)
					}
					checkBalance(t) {
						return !(("string" == typeof t ? parseFloat(t) : t) > this._api.balance.getAmount() && !this._api.isReplay && (this._api.events.trigger(n.APIEvent.BROKE), l.show(this._api), 1))
					}
					collectWin() {
						return "GAMBLE" !== this._nextMode ? Promise.resolve(!1) : (this.gambleBet(!0), this._api.slotStates.stateIsReady().then((() => Promise.resolve(!0))))
					}
					sendRequest(t, e = !0) {
						this.allowedToSendBet() && (t.type != s.APIBetType.NORMAL_BET && t.type != s.APIBetType.FREE_BET && t.type != s.APIBetType.FEATURE_BET || this._timeChecker.checkTime(), t = this.injectData(t), e && this._api.events.trigger(n.APIEvent.BET, t), this._api.communication.send("normal", t))
					}
					injectData(t) {
						for (let e of this._requestDataInjectionCallbacks) t = e(t);
						return t
					}
					addBetDataInjectCallback(t) {
						this._requestDataInjectionCallbacks.push(t)
					}
					removeBetDataInjectCallback(t) {
						for (let e = this._requestDataInjectionCallbacks.length - 1; e >= 0; e--)
							if (this._requestDataInjectionCallbacks[e] == t) return void this._requestDataInjectionCallbacks.splice(e, 1)
					}
					allowedToSendBet() {
						return this._isHalt ? (this._api.log("Trying to send bet request in halt state"), !1) : this._paused ? (this._api.log("Trying to send bet request in paused state"), !1) : !this._hold || (this._api.log("Trying to send bet request in hold state"), !1)
					}
				}
			},
			82934: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.FreeBetsHandler = void 0;
				const n = i(49490),
					s = i(41122),
					o = i(22242),
					r = i(82748),
					a = i(82935);
				e.FreeBetsHandler = class {
					constructor(t) {
						this._started = !1, this.FREE_BETS_START = "freeBetsStart", this.FREE_BETS_UPDATE = "freeBetsUpdate", this.FREE_BETS_END = "freeBetsEnd", this.FREE_BETS_START_FROM_ACTION_SPINS = "freeBetsStartFromActionSpins", this.isExternalFreeBetActive = !1, this._api = t, this.events = a.create(), t.events.on(n.APIEvent.IS_OPEN_GAME_ROUND, (t => this.onOpenGameRound(t))), t.events.on(n.APIEvent.FREE_BETS, (t => this.onFreeBets(t))), t.events.on(n.APIEvent.BET, (t => this.onBet(t))), t.events.on(n.APIEvent.ACTION_SPINS_BET, (t => this.onLightningSpinsBet(t))), t.events.on(n.APIEvent.STATE, (t => this.onState(t))), t.events.on(n.APIEvent.SOFT_RESET, (() => this.onSoftReset())), t.events.on("operatorFreeBetMessages", (t => {
							let e = JSON.parse(t);
							e = Array.isArray(e) ? e : [e], this._operatorFreeBetMessages = e
						})), t.events.on("extFreeRound", (e => {
							let i = !1;
							if (null == this._currentData) {
								if (null == e.bet || null == e.rounds) return;
								this._currentData = {
									amount: "" + e.bet,
									count: e.rounds || 0,
									messages: {},
									promoName: "",
									rounds: e.rounds || 0,
									used: 0,
									winnings: ""
								}, i = !0
							}
							e.rounds && (this._currentData.count = e.rounds), e.bet && (this._currentData.amount = "" + e.bet), e.winnings && (this._currentData.winnings = "" + e.winnings), i && (this.isExternalFreeBetActive = !0, t.betHandler.addBetDataInjectCallback((t => this.injectExternalFreeBetCallback(t))), null == this._betLevelBeforeEvoFreeBets && (this._betLevelBeforeEvoFreeBets = t.betLevel.getLevel()), this.checkFreeBets())
						})), t.events.on("extFreeRoundsEnded", (() => {
							this.isExternalFreeBetActive = !1, this._currentData = void 0, null != this._betLevelBeforeEvoFreeBets && (t.betLevel.setLevel(this._betLevelBeforeEvoFreeBets), this._betLevelBeforeEvoFreeBets = void 0), this.endFreeBets()
						}))
					}
					injectExternalFreeBetCallback(t) {
						return t.type === r.APIBetType.FREE_BET && this.isExternalFreeBetActive && (t.type = r.APIBetType.NORMAL_BET, t.replayAndFeatureBuy = !0), t
					}
					onOpenGameRound(t) {
						this._isRestoreState = t
					}
					onLightningSpinsBet(t) {
						t.type === r.APIBetType.FREE_BET && this._currentData && (this._currentData.count = Math.max(this._currentData.count - 1, 0), this.events.trigger(this.FREE_BETS_UPDATE))
					}
					hasFreeBets() {
						return !!this._currentData && (!!this.isExternalFreeBetActive || this._currentData.count > 0 || this._currentData.rounds > 0 && this._currentData.rounds === this._currentData.used)
					}
					getFormattedWin() {
						return this._currentData && parseFloat(this._currentData.winnings) > 0 ? this._api.currency.format(parseFloat(this._currentData.winnings)) : void 0
					}
					getCurrentWinnings() {
						return this._currentData && parseFloat(this._currentData.winnings) > 0 ? parseFloat(this._currentData.winnings) : void 0
					}
					getBetHeader() {
						if (null == this._currentData) return this._api.translations.translate("BET");
						const t = 1 === this._currentData.count ? "FREE BET" : "FREE BETS",
							e = this._api.translations.translate(t);
						return this._currentData.count + " " + e
					}
					getBet() {
						return this._currentData ? this._currentData.amount : this._api.currency.formatValue(0)
					}
					getRemainingRounds() {
						return this._currentData ? this._currentData.count : 0
					}
					onFreeBets(t) {
						var e;
						if (this._started) {
							if (!this._api.isReplay && (Array.isArray(t) && (t = t[0]), t.previous && (!0 === (null === (e = this._currentData) || void 0 === e ? void 0 : e.hasShownStartDialog) && (this.showEndDialog(t.previous), this._currentData = void 0), delete t.previous), null != this._currentData ? this._currentData = Object.assign(this._currentData, t) : this._currentData = t, this.hasFreeBets() || (this._currentData = void 0), this._currentData && !0 !== this._currentData.hasShownStartDialog && !0 !== this._currentData.hasQueuedStartDialog))
								if (this._currentData.hasQueuedStartDialog = !0, this._isRestoreState) {
									if (this._isRestoreState && this._currentData.count - 1 > 0) {
										const t = Object.assign({}, this._currentData);
										t.count--, t.used++, this.showStartDialog(t)
									}
								} else this.showStartDialog(this._currentData)
						} else this._isDataAvailable = t
					}
					showStartDialog(t) {
						this._api.betHandler.cancelNextAutoBetAfterCollect();
						let e = this._api.translations.translate("#spinstogo out of #spinsleft spins to go");
						e = e.replace("#spinstogo", "" + t.count), e = e.replace("#spinsleft", "" + (t.count + t.used));
						const i = {
								header: this._api.translations.translate("Congratulations!"),
								message: this._api.translations.translate("You have free bets!"),
								count: t.count,
								total: t.count + t.used,
								value: this._api.currency.format(t.rounds * parseFloat(t.amount)),
								spinsToGo: e,
								operatorFreeBetMessages: this._operatorFreeBetMessages
							},
							n = Object.assign(i, t.messages),
							s = this._api.translations.render(o.FreeBetsTemplate.START_TEMPLATE, n);
						this._api.dialog.open(s, {
							alwaysShow: !0,
							closeable: !1,
							onShowCB: () => {
								this._api.betFeatureController.setActiveBetFeature()
							},
							onClose: () => {
								t.hasShownStartDialog = !0
							}
						})
					}
					showEndDialog(t) {
						this._api.betHandler.cancelNextAutoBetAfterCollect();
						const e = {
								winnings: t.winnings,
								aWinnerIsYou: parseFloat(t.winnings) > 0
							},
							i = this._api.translations.render(o.FreeBetsTemplate.END_TEMPLATE, e);
						this._api.dialog.open(i, {
							alwaysShow: !0,
							closeable: !1,
							onClose: () => {
								this.endFreeBets(), this.checkFreeBets()
							}
						})
					}
					start() {
						this._started = !0, this._isDataAvailable && (this.onFreeBets(this._isDataAvailable), this._isDataAvailable = null), this._currentData && this._isRestoreState && (this._currentData.hasShownStartDialog = !0, this._currentData.count = Math.max(this._currentData.count - 1, 0), this.events.trigger(this.FREE_BETS_UPDATE)), this.checkFreeBets()
					}
					onState(t) {
						t == s.SlotState.READY && this.checkFreeBets()
					}
					checkFreeBets() {
						null != this._currentData && this._started && this._api.slotStates.checkState(s.SlotState.READY) && this.getRemainingRounds() > 0 && this.startFreeBets()
					}
					onBet(t) {
						this._isRestoreState = !1;
						const e = this.isExternalFreeBetActive && t.type === r.APIBetType.NORMAL_BET;
						e && this._api.betHandler.cancelNextAutoBetAfterCollect(), (t.type === r.APIBetType.FREE_BET || e) && this._currentData && (this._currentData.count = Math.max(this._currentData.count - 1, 0), this.events.trigger(this.FREE_BETS_UPDATE))
					}
					onSoftReset() {
						this._currentData && (this._currentData.count = Math.max(this._currentData.count + 1, 0), this.events.trigger(this.FREE_BETS_UPDATE))
					}
					startFreeBets() {
						this.events.trigger(this.FREE_BETS_START)
					}
					endFreeBets() {
						this.events.trigger(this.FREE_BETS_END)
					}
				}
			},
			22242: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.FreeBetsTemplate = void 0;
				class i {}
				i.START_TEMPLATE = '\n<h1>{{header}}</h1>\n<p style="color: #7eff00;">{{message}}</p>\n<p style="color: #7eff00;">{{spinsToGo}}</p>\n<p style="color: #ffffff;">{{#tr}}Total value{{/tr}} {{value}}</p>\n{{#operatorFreeBetMessages}}\n    <p>{{{.}}}</p>\n{{/operatorFreeBetMessages}}\n<div>\n    <button type="button" class="close">{{#tr}}OK{{/tr}}</button>\n</div>\n', i.END_TEMPLATE = '\n{{#aWinnerIsYou}}\n<p style="color: #7eff00;">{{#tr}}Your freebets gave you a total win of{{/tr}}</p>\n<h2 style="color: #FFFFFF;">{{#formatCurrency}}winnings{{/formatCurrency}}</h2>\n{{/aWinnerIsYou}}\n<p style="color: #7eff00;">{{#tr}}Your free bets are out!{{/tr}}</p>\n<div><button type="button" class="close">{{#tr}}OK{{/tr}}</button></div>\n', e.FreeBetsTemplate = i
			},
			3272: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.FreeFeatureBetHandler = void 0;
				const n = i(49490),
					s = i(41122),
					o = i(16232),
					r = i(82748),
					a = i(8220),
					l = i(72468),
					h = i(61e3),
					u = i(82935);
				e.FreeFeatureBetHandler = class {
					constructor(t) {
						this._started = !1, this._hasShownStartDialog = !1, this._freeFeatureBetSent = !1, this._freeFeatureBetStarted = !1, this._totalWin = "-1", this.FREE_FEATURE_BET_START = "freeFeatureBetStart", this.FREE_FEATURE_BET_UPDATE = "freeFeatureBetUpdate", this.FREE_FEATURE_BET_END = "freeFeatureBetEnd", this._api = t, this.events = u.create(), t.events.on(n.APIEvent.FREE_FEATURE_BETS, (t => this.onFreeFeatureBets(t))), t.events.on(n.APIEvent.BET, (t => this.onBet(t))), t.events.on(n.APIEvent.STATE, (t => this.onState(t))), t.events.on(n.APIEvent.GAME, (t => this.onGameData(t))), t.events.on("operatorFreeFeatureBetMessages", (t => {
							let e = JSON.parse(t);
							e = Array.isArray(e) ? e : [e], this._operatorFreeFeatureBetMessages = e
						}))
					}
					onBet(t) {
						t.type === r.APIBetType.FEATURE_BET && 1 == this.hasFreeFeatureBet() && (this._freeFeatureBetSent = !0)
					}
					start() {
						this._started = !0, this.checkFreeFeatureBet()
					}
					getBet() {
						var t;
						return this._currentData ? null === (t = this._currentData) || void 0 === t ? void 0 : t.bet.toString() : "-1"
					}
					onGameData(t) {
						this.setTotalWin(t.accumulatedRoundWin)
					}
					onState(t) {
						null != this._currentData && (t == s.SlotState.RESTORE && void 0 !== this._currentData && (this._hasShownStartDialog = !0, this._freeFeatureBetSent = !0), t != s.SlotState.READY && t != s.SlotState.DIALOG || (0 == this._freeFeatureBetStarted && this.checkFreeFeatureBet(), 1 == this._freeFeatureBetSent && (this._freeFeatureBetSent = !1, this.showEndDialog())))
					}
					showEndDialog() {
						this._api.betHandler.cancelNextAutoBetAfterCollect();
						const t = +this._totalWin,
							e = {
								winnings: this._api.currency.formatValue(t),
								aWinnerIsYou: t > 0
							},
							i = this._api.translations.render(o.FreeFeatureBetTemplate.END_TEMPLATE, e);
						this._api.dialog.open(i, {
							alwaysShow: !0,
							closeable: !1,
							onClose: () => {
								this.endFreeFeatureBet()
							}
						})
					}
					checkFreeFeatureBet() {
						if (null != this._currentData && this._started && (this._api.slotStates.checkState(s.SlotState.READY) || this._api.slotStates.checkState(s.SlotState.DIALOG))) {
							if (!PIXI.utils.TextureCache[this._currentData.featureName]) {
								const t = new h.ImgLoader(l.NolimitApplication.resourcePath + "/nolimit/promo-panel/");
								return this._currentData && t.add(this._currentData.featureName, this._currentData.featureName + ".png"), Promise.all([t.load()]).then((() => this.startFreeFeatureBet()))
							}
							this.startFreeFeatureBet()
						}
					}
					startFreeFeatureBet() {
						this._api.betHandler.cancelNextAutoBetAfterCollect(), this._api.betFeatureController.setActiveBetFeature(), this._popupView = new a.FreeFeatureBetPopUpStart((() => this.onPopUpOkClicked())), 0 == this._freeFeatureBetStarted && (this._freeFeatureBetStarted = !0, 0 == this._hasShownStartDialog && void 0 !== this._currentData && (this._popupView.createPopUpView(this._currentData), l.NolimitApplication.addDialog(this._popupView, !0)), this.events.trigger(this.FREE_FEATURE_BET_START))
					}
					onPopUpOkClicked() {
						this._hasShownStartDialog = !0, this._api.betHandler.freeFeatureBet(this._currentData, {})
					}
					endFreeFeatureBet() {
						this._totalWin = "-1", this._freeFeatureBetStarted = !1, this._currentData = void 0, this._hasShownStartDialog = !1, this.events.trigger(this.FREE_FEATURE_BET_END)
					}
					onFreeFeatureBets(t) {
						this._api.isReplay || null != t && null != t.featureName && (this._currentData = t)
					}
					getBetHeader() {
						return "1 " + this._api.translations.translate("FREE BET")
					}
					getFormattedWin() {
						return ""
					}
					hasFreeFeatureBet() {
						return null != this._currentData
					}
					setTotalWin(t) {
						this._totalWin = t
					}
				}
			},
			8220: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.FreeFeatureBetPopUpStart = void 0;
				const n = i(82859),
					s = i(4258),
					o = i(68714),
					r = i(5117),
					a = i(66515),
					l = i(56254),
					h = i(46980),
					u = i(85136),
					c = i(72468),
					d = i(77616),
					p = i(61e3);
				class _ extends PIXI.Container {
					constructor(t) {
						super(), this._onOkClickedCallBack = t
					}
					createPopUpView(t) {
						this._mainContainer = new n.Container, this.addChild(this._mainContainer), this._ticketContainer = new n.Container, this._mainContainer.addChild(this._ticketContainer), this._betContainer = new PIXI.Container, this._congratsText = new o.Label(c.NolimitApplication.apiPlugin.translations.translate("Congratulations!"), _.GAME_FEATURE_CONGRATS_TEXT), this._congratsText.anchor.set(.5, .5), this._congratsText.position.y = 0, this._mainContainer.addChild(this._congratsText), this._awardedText = new o.Label(c.NolimitApplication.apiPlugin.translations.translate("You have been awarded a Nolimit Bonus!"), _.GAME_FEATURE_AWARDED_TEXT), this._awardedText.anchor.set(.5, .5), this._awardedText.position.y = this._congratsText.height + 10, this._mainContainer.addChild(this._awardedText), this._ticketContainer.position.y = this._awardedText.position.y + this._awardedText.height + 10, this._featureBG = new PIXI.Sprite(p.ImgLoader.getImgTexture(_.TICKET_ASSET_NAME)), this._ticketContainer.addChild(this._featureBG), this._ticketContainer.addChild(this._betContainer), this._featureImg = new PIXI.Sprite(p.ImgLoader.getImgTexture(t.featureName)), this._featureImg.position.x = (this._featureBG.width - 250) / 2 - this._featureImg.width / 2 + 250, this._featureImg.position.y = Math.floor((this._featureBG.height - this._featureImg.height) / 2) - 3, this._ticketContainer.addChild(this._featureImg), this._valueLabel = new o.Label(c.NolimitApplication.apiPlugin.translations.translate("VALUE"), _.GAME_FEATURE_BET_TEXT), this._valueLabel.anchor.set(0, .5), this._betContainer.addChild(this._valueLabel), this._currencyLabel = new o.Label(" " + c.NolimitApplication.apiPlugin.currency.getCode(), _.GAME_FEATURE_CURRANCY_STYLE), this._currencyLabel.anchor.set(0, .5), this._currencyLabel.visible = !c.NolimitApplication.apiPlugin.options.hideCurrency, this._betContainer.addChild(this._currencyLabel), this._currencyLabel.position.y = this._valueLabel.position.y, this._currencyLabel.position.x = this._valueLabel.position.x + this._valueLabel.width, this._betContainer.position.x = 115 - this._betContainer.width / 2, this._betContainer.position.y = 50, this._totalAmountLabel = new s.TextLabel("", _.GAME_FEATURE_PRICE_STYLE, {
							landscapeMaxWidth: 190,
							portraitMaxWith: 190
						});
						const e = t.bet < 10 || t.bet % 1 != 0 ? 2 : 0,
							i = c.NolimitApplication.apiPlugin.currency.formatValue(t.totalAmount, {
								minimumPrecision: e
							});
						this._totalAmountLabel.value = i, this._totalAmountLabel.position.x = 115, this._totalAmountLabel.position.y = this._betContainer.position.y + this._betContainer.height + 10, this._ticketContainer.addChild(this._totalAmountLabel);
						const r = new l.PointerStateColorSet(4294967295);
						let d = new h.PointerStateIconSet(new u.Icon(p.ImgLoader.getImgTexture(_.BUY_BTN_ASSET_NAME)));
						this._okButton = new a.IconToggleButton("ok_btn", d, r), this._okButton.addClickCallback((() => this.onOkButtonClicked())), this._okButton.toggled = !1, this._okButton.enable(!0), this._okButton.position.x = Math.floor(102 - this._okButton.width / 2 + 12), this._okButton.position.y = this._featureBG.height - this._okButton.height - 12, this._ticketContainer.addChild(this._okButton), this._okLabel = new s.TextLabel(c.NolimitApplication.apiPlugin.translations.translate("OK"), _.GAME_FEATURE_OK_TEXT, {
							landscapeMaxWidth: this._okButton.width - 30,
							portraitMaxWith: this._okButton.width - 30
						}), this._okLabel.anchor.set(.5, .5), this._okLabel.position.set(this._okButton.x + .5 * this._okButton.width, this._okButton.y + .5 * this._okButton.height - 4), this._ticketContainer.addChild(this._okLabel), this._awardedText.position.x = this._ticketContainer.width / 2, this._congratsText.position.x = this._ticketContainer.width / 2, this.onResize()
					}
					onOkButtonClicked() {
						c.NolimitApplication.removeDialog(this), this._onOkClickedCallBack()
					}
					onResize() {
						this._mainContainer.position.y = .5 * (720 - this._mainContainer.height), this._mainContainer.position.x = .5 * (720 - this._mainContainer.width), this._totalAmountLabel.onResize(), this._okLabel.onResize()
					}
				}
				_.TICKET_ASSET_NAME = "nolimitBonus/ticket@2x.png", _.BUY_BTN_ASSET_NAME = "nolimitBonus/buyBtn@2x.png", _.GAME_FEATURE_OK_TEXT = new PIXI.TextStyle({
					fill: "#fff500",
					fontFamily: r.OpenSans.FAMILY,
					fontSize: 30,
					fontStyle: d.FontStyle.NORMAL,
					fontWeight: d.FontWeight.EXTRA_BOLD
				}), _.GAME_FEATURE_PRICE_STYLE = new PIXI.TextStyle({
					fill: "#a76f00",
					fontFamily: r.OpenSans.FAMILY,
					fontSize: 35,
					fontStyle: d.FontStyle.NORMAL,
					fontWeight: d.FontWeight.LIGHT
				}), _.GAME_FEATURE_BET_TEXT = new PIXI.TextStyle({
					fill: "#a76f00",
					fontFamily: r.OpenSans.FAMILY,
					fontSize: 24,
					fontStyle: d.FontStyle.NORMAL,
					fontWeight: d.FontWeight.LIGHT
				}), _.GAME_FEATURE_CONGRATS_TEXT = new PIXI.TextStyle({
					fill: "#ffffff",
					fontFamily: r.OpenSans.FAMILY,
					fontSize: 36,
					fontStyle: d.FontStyle.NORMAL,
					fontWeight: d.FontWeight.LIGHT
				}), _.GAME_FEATURE_AWARDED_TEXT = new PIXI.TextStyle({
					fill: "#7eff00",
					fontFamily: r.OpenSans.FAMILY,
					fontSize: 24,
					fontStyle: d.FontStyle.NORMAL,
					fontWeight: d.FontWeight.LIGHT
				}), _.GAME_FEATURE_CURRANCY_STYLE = new PIXI.TextStyle({
					fill: "#a76f00",
					fontFamily: r.OpenSans.FAMILY,
					fontSize: 24,
					fontStyle: d.FontStyle.NORMAL,
					fontWeight: d.FontWeight.EXTRA_BOLD
				}), e.FreeFeatureBetPopUpStart = _
			},
			16232: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.FreeFeatureBetTemplate = void 0;
				class i {}
				i.START_TEMPLATE = '\n<h1>{{header}}</h1>\n<p style="color: #7eff00;">{{message}}</p>\n{{#operatorFreeBetMessages}}\n    <p>{{{.}}}</p>\n{{/operatorFreeBetMessages}}\n<div>\n    <button type="button" class="close">{{#tr}}OK{{/tr}}</button>\n</div>\n', i.END_TEMPLATE = '\n{{#aWinnerIsYou}}\n<p style="color: #7eff00;">{{#tr}}Your Nolimit Bonus gave you a total win of{{/tr}}</p>\n<h2 style="color: #FFFFFF;">{{#formatCurrency}}winnings{{/formatCurrency}}</h2>\n{{/aWinnerIsYou}}\n<p style="color: #7eff00;">{{#tr}}Your Nolimit Bonus has ended!{{/tr}}</p>\n<p style="color: #7eff00;">{{#tr}}From now on you play with your own money.{{/tr}}</p>\n<div><button type="button" class="close">{{#tr}}OK{{/tr}}</button></div>\n', e.FreeFeatureBetTemplate = i
			},
			4258: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.TextLabel = void 0;
				const n = i(40598),
					s = i(72468);
				class o extends PIXI.Text {
					constructor(t, e, i) {
						super(t, e.clone()), this._textStyle = e.clone(), this._options = i, this.init()
					}
					init() {
						this.anchor.set(.5)
					}
					onResize() {
						const t = s.NolimitApplication.screenBounds,
							e = s.NolimitApplication.isLandscape && n.Helper.isDefaultScreenRatio(t);
						this.style.fontSize = this._textStyle.fontSize, n.Helper.shrinkTextWidth(this.value, this, e ? this._options.landscapeMaxWidth : this._options.portraitMaxWith)
					}
					drawBorder() {
						this._border || (this._border = new PIXI.Graphics, this._border.name = this.text + "_BORDER", this.parent && this.parent.addChild(this._border));
						const t = s.NolimitApplication.screenBounds,
							e = s.NolimitApplication.isLandscape && n.Helper.isDefaultScreenRatio(t);
						this._border.clear(), this._border.beginFill(0), this._border.alpha = .2, e ? this._border.drawRect(0, 0, this._options.landscapeMaxWidth, this.height) : this._border.drawRect(0, 0, this._options.portraitMaxWith, this.height), this._border.pivot.set(this._border.width * this.anchor.x, this._border.height * this.anchor.y), this._border.position.set(this.x, this.y)
					}
					get value() {
						return this._value
					}
					set value(t) {
						this._value = t, this.text = t, this.onResize()
					}
					get textStyle() {
						return this._textStyle
					}
				}
				e.TextLabel = o
			},
			83202: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.AnalyticsIntegrationPlugin = void 0;
				const n = i(91980),
					s = i(64118),
					o = i(3307),
					r = i(49490),
					a = i(30835);
				e.AnalyticsIntegrationPlugin = class {
					constructor() {
						this.name = "AnalyticsIntegration"
					}
					init() {
						return new Promise(((t, e) => {
							for (let t of n.NolimitLauncher.plugins)(0, s.isApiPlugin)(t) && (this._api = t), (0, o.isAutoPlayPlugin)(t) && (this._autoplay = t);
							this.addEventListeners(), t(this)
						}))
					}
					getReady() {
						return new Promise(((t, e) => {
							t(this)
						}))
					}
					getReadyToStart() {
						return new Promise(((t, e) => {
							t(this)
						}))
					}
					start() {
						return new Promise(((t, e) => {
							t(this)
						}))
					}
					addEventListeners() {
						this._api.settings.any(((t, e) => {
							this._api.analytics.event("settings", t, e)
						})), this._api.events.on(r.APIEvent.AUTO_PLAY, (() => {
							const t = this._autoplay.getRawData(),
								e = this._autoplay.settings;
							for (let e in t) this._api.analytics.event(r.APIEvent.AUTO_PLAY, e, t[e]);
							for (let i in e) this._api.analytics.event(r.APIEvent.AUTO_PLAY, i, t[i])
						})), this._api.events.on(r.APIEvent.BET, (() => {
							this._api.analytics.event(a.APISetting.FAST_SPIN, this._api.settings.get(a.APISetting.FAST_SPIN))
						})), this._api.events.on(r.APIEvent.ACTION_SPINS_BET, (() => {
							this._api.analytics.event(a.APISetting.FAST_SPIN, this._api.settings.get(a.APISetting.FAST_SPIN))
						}))
					}
				}
			},
			78435: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NolimitAutoPlayPlugin = void 0;
				const n = i(64118),
					s = i(91980),
					o = i(49490),
					r = i(41122),
					a = i(52780);
				class l {
					get rounds() {
						return this._autoPlayData.rounds
					}
					get isAutoplayRound() {
						return this._isAutoplayRound
					}
					get settings() {
						const t = l.apiPlugIn.balance.getAmount();
						return {
							minBalancePercent: this._autoPlaySettingsData.minBalancePercent,
							maxBalancePercent: this._autoPlaySettingsData.maxBalancePercent,
							minBalancePercentText: null != this._autoPlaySettingsData.minBalancePercent ? l.apiPlugIn.currency.format(this._autoPlaySettingsData.minBalancePercent * t) : void 0,
							maxBalancePercentText: null != this._autoPlaySettingsData.maxBalancePercent ? l.apiPlugIn.currency.format(this._autoPlaySettingsData.maxBalancePercent * t) : void 0,
							maxSingleWin: this._autoPlaySettingsData.maxSingleWin
						}
					}
					getRawData() {
						return this._autoPlayData
					}
					constructor() {
						this.name = "AutoPlay", this._autoPlayDelay = 100, this._isAutoplayRound = !1, this._autoPlaySettingsData = {}, this.clearData()
					}
					updateData(t) {
						this._autoPlaySettingsData = t;
						const e = l.apiPlugIn.balance.getAmount(),
							i = l.apiPlugIn.betLevel.getLevel(),
							n = t.minBalancePercent ? t.minBalancePercent * e : void 0,
							s = t.maxBalancePercent ? t.maxBalancePercent * e : void 0,
							o = l.apiPlugIn.freeBets.hasFreeBets(),
							r = l.apiPlugIn.freeFeatureBet.hasFreeFeatureBet(),
							a = t.maxSingleWin || Number.MAX_VALUE;
						this._autoPlaySettingsData.autoCollectGamble = null == this._autoPlaySettingsData.autoCollectGamble || this._autoPlaySettingsData.autoCollectGamble, this._autoPlayData = {
							rounds: t.rounds || 0,
							minBalance: n,
							maxBalance: s,
							betLevel: parseFloat(i),
							freeBets: o,
							freeFeatureBet: r,
							maxSingleWin: a,
							autoCollectGamble: this._autoPlaySettingsData.autoCollectGamble
						}
					}
					playFreeRoundsAutoplay() {
						this.clearData();
						const t = l.apiPlugIn.freeBets.hasFreeBets(),
							e = l.apiPlugIn.freeFeatureBet.hasFreeFeatureBet(),
							i = l.apiPlugIn.freeBets.getRemainingRounds();
						this._autoPlayData.freeBets = t, this._autoPlayData.freeFeatureBet = e, this._autoPlayData.rounds = i, this._autoPlayData.autoCollectGamble = !0, l.apiPlugIn.slotStates.checkState(r.SlotState.READY) && this.runAutoPlay()
					}
					cancelAutoPlay() {
						this.clearData(), this._isAutoplayRound = !1, l.apiPlugIn.events.trigger(o.APIEvent.AUTO_PLAY)
					}
					clearData() {
						this._autoPlayData = {
							rounds: 0,
							betLevel: 0,
							freeBets: !1,
							freeFeatureBet: !1,
							maxSingleWin: void 0,
							minBalance: void 0,
							maxBalance: void 0,
							minBalanceText: void 0,
							maxBalanceText: void 0,
							lastWin: void 0,
							autoCollectGamble: void 0
						}
					}
					addEventListeners() {
						l.apiPlugIn.events.on(o.APIEvent.WIN, (t => {
							this._autoPlayData.lastWin = t
						})), l.apiPlugIn.events.on(o.APIEvent.MESSAGES, (t => {
							t.count > 0 && this.cancelAutoPlay()
						})), l.apiPlugIn.events.on(o.APIEvent.STATE, (t => {
							t == r.SlotState.READY && this.runAutoPlay(), t == r.SlotState.GAMBLE && 1 == this._autoPlayData.autoCollectGamble && 0 != this._autoPlayData.rounds && l.apiPlugIn.betHandler.gambleBet(!0)
						})), l.apiPlugIn.events.on(o.APIEvent.PAUSE, (() => {
							this.pause()
						})), l.apiPlugIn.events.on(o.APIEvent.RESUME, (() => {
							this.unPause()
						})), l.apiPlugIn.events.on(o.APIEvent.DIALOG, (t => {
							"open" == t ? this.pause() : this.unPause()
						}))
					}
					pause() {
						this._paused = !0
					}
					unPause() {
						this._paused = !1
					}
					init() {
						return new Promise(((t, e) => {
							for (let t of s.NolimitLauncher.plugins)(0, n.isApiPlugin)(t) && (l.apiPlugIn = t);
							null == l.apiPlugIn && e({
								message: "Autoplay plugin can't find apiPlugin",
								code: a.APIErrorCode.PLUGIN_LAUNCH
							}), this._autoPlayDelay = null != l.apiPlugIn.options.autoplayDelay ? l.apiPlugIn.options.autoplayDelay : this._autoPlayDelay, this.addEventListeners(), t(this)
						}))
					}
					turnOffAutoplayOnBonus() {
						l.apiPlugIn.gameClientConfiguration.autoPlaySettings.turnOffAutoplayOnBonus && this.cancelAutoPlay()
					}
					getReady() {
						return Promise.resolve(this)
					}
					getReadyToStart() {
						return Promise.resolve(this)
					}
					start() {
						return Promise.resolve(this)
					}
					runAutoPlay() {
						this.shouldPlay() ? null == this._activeTimeout && (this._activeTimeout = setTimeout((() => this.runAutoplayAfterDelay()), this._autoPlayDelay)) : this.cancelAutoPlay()
					}
					runAutoplayAfterDelay() {
						!this._paused && this._autoPlayData.rounds > 0 && (this._autoPlayData.rounds = this._autoPlayData.rounds - 1, this._isAutoplayRound = this._autoPlayData.rounds > 0, l.apiPlugIn.events.trigger(o.APIEvent.AUTO_PLAY), l.apiPlugIn.betHandler.bet()), this._activeTimeout = void 0
					}
					shouldPlay() {
						const t = l.apiPlugIn.balance.getAmount();
						let e = this._autoPlayData.betLevel;
						const i = l.apiPlugIn.betFeatureController.getActiveBetFeature();
						null != i && (e = i.getTotalCost());
						const n = t - e;
						this._isAutoplayRound = this._autoPlayData.rounds > 0;
						const s = l.apiPlugIn.freeBets.hasFreeBets() && this._autoPlayData.freeBets,
							o = l.apiPlugIn.freeFeatureBet.hasFreeFeatureBet() && this._autoPlayData.freeFeatureBet;
						return !(!this._isAutoplayRound || n < 0 && !s || n < 0 && !o || (l.apiPlugIn.freeBets.hasFreeBets() !== this._autoPlayData.freeBets ? (l.apiPlugIn.log("Autoplay:", "Free bets status has changed to:", l.apiPlugIn.freeBets.hasFreeBets(), "from", this._autoPlayData.freeBets), 1) : l.apiPlugIn.freeFeatureBet.hasFreeFeatureBet() !== this._autoPlayData.freeFeatureBet ? (l.apiPlugIn.log("Autoplay:", "Free Feature bet status has changed to:", l.apiPlugIn.freeFeatureBet.hasFreeFeatureBet(), "from", this._autoPlayData.freeFeatureBet), 1) : void 0 !== this._autoPlayData.lastWin && void 0 !== this._autoPlayData.maxSingleWin && this._autoPlayData.lastWin > this._autoPlayData.maxSingleWin ? (l.apiPlugIn.log("Autoplay:", "Win has exceeded maxBalancePercent win of:", this._autoPlayData.maxSingleWin.toFixed(2)), 1) : void 0 !== this._autoPlayData.maxBalance && t >= this._autoPlayData.maxBalance ? (l.apiPlugIn.log("Autoplay:", "Balance has reached maximum:", this._autoPlayData.maxBalance.toFixed(2)), 1) : void 0 !== this._autoPlayData.minBalance && n < this._autoPlayData.minBalance && (l.apiPlugIn.log("Autoplay:", "Balance has reached minimum:", this._autoPlayData.minBalance.toFixed(2)), 1)))
					}
				}
				e.NolimitAutoPlayPlugin = l
			},
			68610: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.isNolimitGameIntroPlugin = e.NolimitGameIntroPlugin = void 0;
				const n = i(92047),
					s = i(81029),
					o = i(64118),
					r = i(91980),
					a = i(58676),
					l = i(70263),
					h = i(16124),
					u = i(61190);
				class c {
					constructor(t) {
						this.name = "NolimitGameIntro", this._viewConfig = t
					}
					fetchPlugins() {
						for (let t of r.NolimitLauncher.plugins)(0, s.isSoundPlugin)(t) && (c.soundPlugin = t), (0, o.isApiPlugin)(t) && (c.apiPlugin = t), (0, a.isGamePlugin)(t) && (c.gamePlugin = t);
						return null == c.soundPlugin ? Promise.reject(new Error("NolimitGameIntroPlugin is missing SoundPlugin")) : null == c.apiPlugin ? Promise.reject(new Error("NolimitGameIntroPlugin is missing ApiPlugin")) : Promise.resolve()
					}
					init() {
						return new Promise(((t, e) => {
							this.fetchPlugins().catch((t => Promise.reject(t))), this.nonGameIntroPages = [];
							const i = c.apiPlugin.resources,
								n = c.apiPlugin.translations,
								s = n.language + ".json";
							i.loadJson("translations/" + s).then((e => {
								this.loadTranslations(n, t, e)
							}), (() => {
								console.warn(n.language + " not found, defaulting to en"), n.language = "en", i.loadJson("translations/en.json").then((e => {
									this.loadTranslations(n, t, e)
								}))
							}))
						}))
					}
					getReady() {
						return new Promise(((t, e) => {
							void 0 !== this._viewConfig.gameClientConfigurationApplied && this._viewConfig.gameClientConfigurationApplied(c.apiPlugin.gameClientConfiguration), this._viewConfig.pages = this._viewConfig.pages.concat(this.nonGameIntroPages), c.apiPlugin.gameClientConfiguration.explicitContentWarning && this._viewConfig.pages.unshift(new l.RatedRIntroPage), this._view = new n.GameIntroView(this._viewConfig), this._view.show();
							const i = c.apiPlugin.settings.get("ratedRDontShowAgain", !1);
							c.apiPlugin.gameClientConfiguration.explicitContentWarning && !i && this.openRatedRModal(), t(this)
						}))
					}
					openRatedRModal() {
						const t = (t, e) => {
								console.log(e), console.log(t.dontShowAgainChecked), "exit" == e ? c.apiPlugin.externalApi.trigger(u.APIExternalApiEvent.EXIT).or(history.back.bind(history)) : (c.apiPlugin.settings.set("ratedRDontShowAgain", t.dontShowAgainChecked), this._view.resumeSlideShow(), t.close())
							},
							e = new l.RatedRIntroPage;
						e.scale.set(.9, .9);
						const i = e.getLocalBounds();
						e.pivot.set(0, i.top);
						const n = new PIXI.Container;
						n.addChild(e);
						const s = new h.ModalWindow("RatedRModal", [{
							id: "exit",
							label: "EXIT",
							clickCallback: t
						}, {
							id: "ok",
							label: "OK",
							clickCallback: t
						}], n, !0);
						this._view.pauseSlideShow(), s.open()
					}
					getReadyToStart() {
						return new Promise(((t, e) => {
							this._view.gameLoadComplete().then((e => {
								this._view.close(), t(this)
							}))
						}))
					}
					start() {
						return new Promise(((t, e) => {
							t(this)
						}))
					}
					loadTranslations(t, e, i) {
						const n = c.apiPlugin.resources,
							s = t.language + ".json";
						n.loadJson(s, "/node_modules/@nolimitcity/game-api/resources/translations/").then((o => {
							t.add(o), n.loadJson(s, "/node_modules/@nolimitcity/slot-translations/resources/translations/").then((n => {
								t.add(n), t.add(i), this._viewConfig.init().then((() => {
									let t = [];
									for (let e of r.NolimitLauncher.plugins) null != e.getIntroPages && t.push(e.getIntroPages());
									Promise.all(t).then((t => {
										for (let e of t) this.nonGameIntroPages = this.nonGameIntroPages.concat(e);
										e(this)
									}))
								}))
							}))
						}))
					}
				}
				e.NolimitGameIntroPlugin = c, e.isNolimitGameIntroPlugin = function(t) {
					return "NolimitGameIntro" === t.name
				}
			},
			92047: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GameIntroView = e.Volatility = void 0;
				const n = i(67394),
					s = i(38472),
					o = i(55462),
					r = i(38801),
					a = i(83236),
					l = i(72468),
					h = i(37950),
					u = i(68610),
					c = i(13006),
					d = i(91980),
					p = i(61952),
					_ = i(61e3);
				var m;
				! function(t) {
					t[t.MEDIUM = 0] = "MEDIUM", t[t.HIGH = 1] = "HIGH", t[t.EXTREME = 2] = "EXTREME", t[t.INSANE = 3] = "INSANE"
				}(m = e.Volatility || (e.Volatility = {}));
				class g extends PIXI.Container {
					constructor(t) {
						super(), this._config = t, this.initAnimations(), this.updateSoundButton()
					}
					initAnimations() {
						this._background = this._config.background, this._topInfo = this._config.logo, this.slideShow = new s.SlideShow(this._config.pages, this._config.borderTop, this._config.borderBottom, this._config.colors.slideShowColors), this._gameStampsContainer = this.createStamps(this._config.stampConfig), this._gameStampsContainer.pivot.set(this._gameStampsContainer.width, .5 * this._gameStampsContainer.height), this._continueButton = new n.LoadingButton, this._continueButton.addClickCallback((() => {
							this._config.continueButtonClickSound ? u.NolimitGameIntroPlugin.soundPlugin.player.playEffect(this._config.continueButtonClickSound) : u.NolimitGameIntroPlugin.soundPlugin.playKeypadEffect("click")
						})), this.soundButton = new p.SoundButton("sound"), this.soundButton.addClickCallback((() => {
							u.NolimitGameIntroPlugin.soundPlugin.toggleQuickMute(), this.updateSoundButton()
						})), this._background.position.set(360, 360), this.addChild(this._background, this._topInfo, this.slideShow, this._gameStampsContainer, this._continueButton, this.soundButton)
					}
					onResize() {
						const t = (0, h.cloneScreenBounds)(l.NolimitApplication.screenBounds);
						if (this.slideShow.position.set(360, 130), this.slideShow.changeWidth(t.width), this.slideShow.resize(), l.NolimitApplication.isLandscape) this._continueButton.position.set(360, 615), this.soundButton.position.set(t.left + 20, 575), this._gameStampsContainer.position.set(t.right - 20, 675);
						else {
							this._gameStampsContainer.position.set(t.right - 20, 590);
							const e = .5 * (t.bottom - 640) + 640;
							this._continueButton.position.set(360, e), this.soundButton.position.set(t.left + 20, e - 40)
						}
						this._topInfo.position.set(360, 65), this._config.onResize && this._config.onResize()
					}
					createStamps(t) {
						const e = new PIXI.Container,
							i = [];
						if (t.snowflake && d.NolimitLauncher.apiPlugin.gameClientConfiguration.useCensoredGfx && i.push(e.addChild(new PIXI.Sprite(_.ImgLoader.getImgTexture(o.GuiDefaultTextures.SNOW_FLAKE)))), t.xSplit && i.push(e.addChild(new PIXI.Sprite(_.ImgLoader.getImgTexture(o.GuiDefaultTextures.X_SPLIT)))), t.xReelSplit && i.push(e.addChild(new PIXI.Sprite(_.ImgLoader.getImgTexture(o.GuiDefaultTextures.X_REEL_SPLIT)))), t.xBomb && i.push(e.addChild(new PIXI.Sprite(_.ImgLoader.getImgTexture(o.GuiDefaultTextures.X_BOMB)))), t.xSize && i.push(e.addChild(new PIXI.Sprite(_.ImgLoader.getImgTexture(o.GuiDefaultTextures.X_SIZE)))), t.xBet && d.NolimitLauncher.apiPlugin.gameClientConfiguration.boostedBetAllowed && i.push(e.addChild(new PIXI.Sprite(_.ImgLoader.getImgTexture(o.GuiDefaultTextures.X_BET)))), t.xPays && i.push(e.addChild(new PIXI.Sprite(_.ImgLoader.getImgTexture(o.GuiDefaultTextures.X_PAYS)))), t.xWays && i.push(e.addChild(new PIXI.Sprite(_.ImgLoader.getImgTexture(o.GuiDefaultTextures.X_WAYS)))), t.xWaysInfectious && i.push(e.addChild(new PIXI.Sprite(_.ImgLoader.getImgTexture(o.GuiDefaultTextures.X_WAYS_INFECTIOUS)))), t.xNudge && i.push(e.addChild(new PIXI.Sprite(_.ImgLoader.getImgTexture(o.GuiDefaultTextures.X_NUDGE)))), t.xCluster && i.push(e.addChild(new PIXI.Sprite(_.ImgLoader.getImgTexture(o.GuiDefaultTextures.X_CLUSTER)))), t.xMount && i.push(e.addChild(new PIXI.Sprite(_.ImgLoader.getImgTexture(o.GuiDefaultTextures.X_MOUNT)))), t.xCap && i.push(e.addChild(new PIXI.Sprite(_.ImgLoader.getImgTexture(o.GuiDefaultTextures.X_CAP)))), t.xBizarre && i.push(e.addChild(new PIXI.Sprite(_.ImgLoader.getImgTexture(o.GuiDefaultTextures.X_BIZARRE)))), t.xZone && i.push(e.addChild(new PIXI.Sprite(_.ImgLoader.getImgTexture(o.GuiDefaultTextures.X_ZONE)))), t.xGod && i.push(e.addChild(new PIXI.Sprite(_.ImgLoader.getImgTexture(o.GuiDefaultTextures.X_GOD)))), t.xHole && i.push(e.addChild(new PIXI.Sprite(_.ImgLoader.getImgTexture(o.GuiDefaultTextures.X_HOLE)))), t.xRip && i.push(e.addChild(new PIXI.Sprite(_.ImgLoader.getImgTexture(o.GuiDefaultTextures.X_RIP)))), t.xNudgeSuper && i.push(e.addChild(new PIXI.Sprite(_.ImgLoader.getImgTexture(o.GuiDefaultTextures.X_NUDGE_SUPER)))), void 0 !== t.volatility) {
							const n = new PIXI.Sprite(g.getVolatilityTexture(t.volatility));
							n.pivot.set(0, 6), i.push(e.addChild(n))
						}
						r.GuiLayout.align(i, 10, r.Align.LEFT, r.Direction.HORIZONTAL);
						for (let t of i) t.tint = this._config.colors.stampColor, t.alpha = .8;
						return e
					}
					static getVolatilityTexture(t) {
						switch (t) {
							case m.INSANE:
								return _.ImgLoader.getImgTexture(o.GuiDefaultTextures.VOL_INSANE);
							case m.EXTREME:
								return _.ImgLoader.getImgTexture(o.GuiDefaultTextures.VOL_EXTREME);
							case m.HIGH:
								return _.ImgLoader.getImgTexture(o.GuiDefaultTextures.VOL_HIGH);
							case m.MEDIUM:
							default:
								return _.ImgLoader.getImgTexture(o.GuiDefaultTextures.VOL_MEDIUM)
						}
					}
					updateSoundButton() {
						const t = u.NolimitGameIntroPlugin.soundPlugin.isLoaded,
							e = u.NolimitGameIntroPlugin.soundPlugin.loading,
							i = !u.NolimitGameIntroPlugin.soundPlugin.isQuickMute();
						e || i && !t ? (this.soundButton.toggled = !1, this.soundButton.enable(!1), this.soundButton.startLoadingAnimation((() => {
							this.updateSoundButton()
						}))) : (this.soundButton.stopLoadingAnimation(), this.soundButton.toggled = i, this.soundButton.enable(!0))
					}
					createSoundSetting() {
						const t = new PIXI.Container,
							e = new a.RadioButton("SoundSetting", u.NolimitGameIntroPlugin.apiPlugin.translations.translate("Sound on"));
						return e.addClickCallback((() => {
							u.NolimitGameIntroPlugin.soundPlugin.toggleQuickMute(), e.toggled = !u.NolimitGameIntroPlugin.soundPlugin.isQuickMute()
						})), e.enable(!0), e.toggled = !u.NolimitGameIntroPlugin.soundPlugin.isQuickMute(), t.addChild(e), t
					}
					show() {
						this.onResize(), l.NolimitApplication.addLayer("INTRO", this), this._config.onShow && this._config.onShow(), this.slideShow.start(), this._continueButton.start()
					}
					close(t) {
						const e = new c.TimelineLite;
						return this._config.getCloseTimeline ? e.add(this._config.getCloseTimeline(this)) : e.add(new c.TweenLite(this, .2, {
							alpha: 0,
							ease: c.Linear.easeNone
						})), e.add((() => {
							l.NolimitApplication.removeLayer("INTRO"), this.slideShow.stop(), this.soundButton.stopLoadingAnimation(), this._config.onClose && this._config.onClose(), t && t()
						})), e
					}
					gameLoadComplete() {
						return new Promise((t => {
							this._continueButton.loadingComplete((() => {
								this._continueButton.disable(), t(!0)
							}))
						}))
					}
					pauseSlideShow() {
						this.slideShow.pause()
					}
					resumeSlideShow() {
						this.slideShow.resume()
					}
				}
				e.GameIntroView = g
			},
			67394: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LoadingButton = void 0;
				const n = i(13006),
					s = i(54554),
					o = i(72468);
				class r extends PIXI.Container {
					get progress() {
						return this._progress
					}
					set progress(t) {
						this._progress = t, this.updateMask(this._progress)
					}
					constructor(t) {
						super(), this._progress = 0, this._stroke = t, this._strokeMask = new PIXI.Graphics, this._strokeMask.position.set(.5 * this._stroke.width, .5 * this._stroke.height), this._stroke.mask = this._strokeMask, this._maskRadius = Math.max(this._stroke.width, this._stroke.height), this.addChild(this._stroke), this.addChild(this._strokeMask)
					}
					updateMask(t) {
						const e = 2 * Math.PI * t - .5 * Math.PI;
						this._strokeMask.clear(), this._strokeMask.beginFill(16711680, .2), this._strokeMask.arc(0, 0, this._maskRadius, .5 * -Math.PI, e, !1), this._strokeMask.lineTo(0, 0), this._strokeMask.endFill()
					}
				}
				class a extends PIXI.Container {
					constructor() {
						super(), this._loadingButton = new s.ContinueButton(o.NolimitApplication.apiPlugin.translations.translate("LOADING")), this._continueButton = new s.ContinueButton, this._loadingButton.enable(!1), this._continueButton.enable(!1), this._continueButton.visible = !1, this._loadingButton.resizeButtonToLabelWithMargin(18, 30, 18, 30), this._continueButton.resizeButtonToLabelWithMargin(18, 30, 18, 30);
						const t = new PIXI.Point(Math.max(this._loadingButton.width, this._continueButton.width), Math.max(this._loadingButton.height, this._continueButton.height));
						this._loadingButton.setSize(t.x, t.y), this._continueButton.setSize(t.x, t.y);
						const e = s.ContinueButton.createButtonStroke();
						e.width = t.x, e.height = t.y, this._animatedStroke = new r(e), this.addChild(this._loadingButton, this._animatedStroke, this._continueButton), this.pivot.set(.5 * t.x, .5 * t.y)
					}
					addClickCallback(t) {
						this._continueButton.addClickCallback(t)
					}
					loadingComplete(t) {
						this._progressTimeline.kill(), this._progressTimeline = new n.TimelineLite({
							onComplete: () => {
								this._continueButton.visible = !0, this.removeChild(this._loadingButton), this.removeChild(this._animatedStroke), this._continueButton.addClickCallback(t), this._continueButton.enable(!0)
							}
						}), this._progressTimeline.add(new n.TweenLite(this._animatedStroke, .2, {
							progress: 1,
							ease: n.Power2.easeOut
						}))
					}
					disable() {
						this._continueButton.enable(!1)
					}
					start() {
						this._progressTimeline = new n.TimelineLite, this._progressTimeline.add(new n.TweenLite(this._animatedStroke, 10, {
							progress: .8,
							ease: n.Power2.easeOut
						}))
					}
				}
				e.LoadingButton = a
			},
			70263: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.RatedRIntroPage = void 0;
				const n = i(58295),
					s = i(61e3),
					o = i(55462),
					r = i(72587),
					a = i(72468),
					l = i(5117),
					h = i(77616);
				class u extends n.SlideShowPage {
					constructor() {
						super();
						const t = new PIXI.TextStyle({
								fill: "#000000",
								fontFamily: l.OpenSans.FAMILY,
								fontSize: 24,
								fontStyle: h.FontStyle.NORMAL,
								fontWeight: h.FontWeight.BOLD,
								wordWrap: !0,
								wordWrapWidth: 320,
								breakWords: !0
							}),
							e = new PIXI.Container,
							i = new PIXI.Sprite(s.ImgLoader.getImgTexture(o.GuiDefaultTextures.RATED_R));
						i.anchor.set(.5, .5);
						const n = new r.NLCText(a.NolimitApplication.apiPlugin.translations.translate("This game contains strong adult content that may be objectionable to some players."), t);
						n.anchor.set(0, .5), n.position.set(-60, 0), e.addChild(i, n), this.addChild(e)
					}
				}
				e.RatedRIntroPage = u
			},
			64390: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NolimitConfig = void 0;
				class i {
					static get isDevMode() {
						var t;
						return !0 === (null === (t = window.nolimit) || void 0 === t ? void 0 : t.development) || !1
					}
				}
				i.DEFAULT_SCREEN_MIN_RATIO = 1.6, e.NolimitConfig = i
			},
			49429: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ElapsedTimeCheck = void 0, e.ElapsedTimeCheck = class {
					constructor(t, e) {
						this._lastTime = 0, this.threshold = t, this._callback = e
					}
					checkTime() {
						const t = Date.now(),
							e = t - this._lastTime;
						this._lastTime = t, e < this.threshold && this._callback()
					}
				}
			},
			11546: function(t, e, i) {
				"use strict";
				var n = this && this.__createBinding || (Object.create ? function(t, e, i, n) {
						void 0 === n && (n = i);
						var s = Object.getOwnPropertyDescriptor(e, i);
						s && !("get" in s ? !e.__esModule : s.writable || s.configurable) || (s = {
							enumerable: !0,
							get: function() {
								return e[i]
							}
						}), Object.defineProperty(t, n, s)
					} : function(t, e, i, n) {
						void 0 === n && (n = i), t[n] = e[i]
					}),
					s = this && this.__setModuleDefault || (Object.create ? function(t, e) {
						Object.defineProperty(t, "default", {
							enumerable: !0,
							value: e
						})
					} : function(t, e) {
						t.default = e
					}),
					o = this && this.__importStar || function(t) {
						if (t && t.__esModule) return t;
						var e = {};
						if (null != t)
							for (var i in t) "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
						return s(e, t), e
					};
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GSAPCompatabilityWrapper = void 0;
				const r = o(i(13006)),
					a = i(46334);
				e.GSAPCompatabilityWrapper = class {
					constructor() {}
					static get isGsap3() {
						if (null == this._isGsap3) {
							try {
								this._isGsap3 = null != r.gsap.ticker
							} catch (t) {
								this._isGsap3 = !1
							}
							this._isGsap3 ? a.Logger.log(`GSAP ${r.gsap.version}`) : a.Logger.log("GSAP 2.0.2")
						}
						return this._isGsap3
					}
					static initTicker(t) {
						this.isGsap3 ? r.gsap.ticker.add(t) : r.TweenMax.ticker.addEventListener("tick", t)
					}
					static removeTicker(t) {
						this.isGsap3 ? r.gsap.ticker.remove(t) : r.TweenMax.ticker.removeEventListener("tick", t)
					}
					static pauseGlobalTimeline() {
						return this.isGsap3 ? (r.gsap.globalTimeline.pause(), r.gsap.ticker.sleep(), !0) : (r.TweenMax.globalTimeScale(0), !0)
					}
					static resumeGlobalTimeline() {
						return this.isGsap3 ? (r.gsap.ticker.wake(), r.gsap.globalTimeline.play(), !0) : (r.TweenMax.globalTimeScale(1), !0)
					}
					static isGlobalTimelinePaused() {
						return this.isGsap3 ? r.gsap.globalTimeline.paused() : 0 === r.TweenMax.globalTimeScale()
					}
					static delayedCall(t, e, i) {
						return this.isGsap3 ? r.gsap.delayedCall(t, e, i) : r.TweenLite.delayedCall(t, e, i)
					}
				}
			},
			40598: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Helper = void 0;
				const n = i(64390);
				e.Helper = class {
					static shrinkTextWidth(t, e, i) {
						for (; e.width > i;) {
							if (this.isString(e.style.fontSize)) {
								if (e.style.fontSize.indexOf("em") > -1) throw new Error("Helper.shrinkTextWidth(), I am lazy so I don't want to parse em, please use number or px.");
								e.style.fontSize = parseInt(e.style.fontSize)
							}
							if (e.style.fontSize--, e.style.fontSize <= 10) return void(e.style.fontSize = 10)
						}
					}
					static isString(t) {
						return "string" == typeof t
					}
					static isDefaultScreenRatio(t) {
						return Math.max(t.width, t.height) / Math.min(t.width, t.height) > n.NolimitConfig.DEFAULT_SCREEN_MIN_RATIO
					}
				}
			},
			46334: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Logger = e.NamedLogger = e.LogLevel = void 0;
				const n = i(64390);
				var s;
				! function(t) {
					t.NONE = "NONE", t.DEV = "DEV", t.INFO = "INFO"
				}(s = e.LogLevel || (e.LogLevel = {}));
				class o {
					constructor(t, e) {
						this.level = s.DEV, this.name = t, this.style = e, this.stylePrefix = null != e ? "%c" : ""
					}
					log(t, ...e) {
						this.style && e.unshift(this.style), this.level == s.INFO ? r.log(`${this.stylePrefix}[${this.name}]: ${t}`, ...e) : this.level == s.DEV && r.logDev(`${this.stylePrefix}[${this.name}]: ${t}`, ...e)
					}
					warn(t, ...e) {
						this.level != s.NONE && r.warn(`[${this.name}]: ${t}`, ...e)
					}
				}
				e.NamedLogger = o;
				class r {
					static createNamedLogger(t) {
						const e = new o(t);
						return r.namedLoggers.push(e), e
					}
					static findNamedLogger(t) {
						r.namedLoggers.forEach((e => {
							if (e.name == t) return e
						}))
					}
					static log(t, ...e) {
						console.log(t, ...e)
					}
					static logDev(t, ...e) {
						n.NolimitConfig.isDevMode && console.log(t, ...e)
					}
					static warn(t, ...e) {
						n.NolimitConfig.isDevMode && console.warn(t, ...e)
					}
					static deprecated(t, e) {
						if (n.NolimitConfig.isDevMode) {
							if (r.displayedDeprecationWarnings[t]) return;
							console.warn("SlotGame Deprecation Warning: ", t + "\nDeprecated since v" + e), r.displayedDeprecationWarnings[t] = !0
						}
					}
				}
				r.namedLoggers = [], r.displayedDeprecationWarnings = {}, e.Logger = r
			},
			17024: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ViewPort = void 0;
				class i {
					get confineToRatio() {
						return this._confineToRatio
					}
					set confineToRatio(t) {
						this._confineToRatio = t
					}
					get ratio() {
						return this._ratio
					}
					set ratio(t) {
						this._ratio = t
					}
					get element() {
						return this._element
					}
					set element(t) {
						this._element = t
					}
					static get instance() {
						return null == this._instance && (this._instance = new i), this._instance
					}
					constructor() {
						this._confineToRatio = !1, this.onWindowResize = t => {
							const e = document.documentElement.clientWidth,
								n = document.documentElement.clientHeight;
							let s = new PIXI.Rectangle(0, 0, e, n);
							i.instance.confineToRatio && (s = e / n < i.instance.ratio ? i.fitWidth(i.instance.ratio) : i.fitHeight(i.instance.ratio), s.x = (e - s.width) / 2, s.y = (n - s.height) / 2, i.instance.element.style.width = s.width + "px", i.instance.element.style.height = s.height + "px", i.instance.element.style.left = s.x + "px", i.instance.element.style.top = s.y + "px"), null != i.instance._resizeCallback && i.instance._resizeCallback(s.width, s.height)
						}, window.addEventListener("resize", this.onWindowResize)
					}
					static fitWidth(t) {
						return new PIXI.Rectangle(0, 0, document.documentElement.clientWidth, Math.round(document.documentElement.clientWidth / t))
					}
					static fitHeight(t) {
						return new PIXI.Rectangle(0, 0, Math.round(document.documentElement.clientHeight * t), document.documentElement.clientHeight)
					}
					static confineToRatio(t, e) {
						i.instance.confineToRatio = !0, i.instance.element = t, i.instance.ratio = e
					}
					static onResize(t) {
						i.instance._resizeCallback = t
					}
					static shutDown() {
						window.removeEventListener("resize", i.instance.onWindowResize)
					}
					static triggerResize() {
						i.instance.onWindowResize(void 0)
					}
				}
				e.ViewPort = i
			},
			23109: t => {
				! function() {
					function e(t, e) {
						document.addEventListener ? t.addEventListener("scroll", e, !1) : t.attachEvent("scroll", e)
					}

					function i(t) {
						this.g = document.createElement("div"), this.g.setAttribute("aria-hidden", "true"), this.g.appendChild(document.createTextNode(t)), this.h = document.createElement("span"), this.i = document.createElement("span"), this.m = document.createElement("span"), this.j = document.createElement("span"), this.l = -1, this.h.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.i.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.j.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.m.style.cssText = "display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;", this.h.appendChild(this.m), this.i.appendChild(this.j), this.g.appendChild(this.h), this.g.appendChild(this.i)
					}

					function n(t, e) {
						t.g.style.cssText = "max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:" + e + ";"
					}

					function s(t) {
						var e = t.g.offsetWidth,
							i = e + 100;
						return t.j.style.width = i + "px", t.i.scrollLeft = i, t.h.scrollLeft = t.h.scrollWidth + 100, t.l !== e && (t.l = e, !0)
					}

					function o(t, i) {
						function n() {
							var t = o;
							s(t) && null !== t.g.parentNode && i(t.l)
						}
						var o = t;
						e(t.h, n), e(t.i, n), s(t)
					}

					function r(t, e, i) {
						e = e || {}, i = i || window, this.family = t, this.style = e.style || "normal", this.weight = e.weight || "normal", this.stretch = e.stretch || "normal", this.context = i
					}
					var a = null,
						l = null,
						h = null,
						u = null;

					function c(t) {
						return null === u && (u = !!t.document.fonts), u
					}

					function d(t, e) {
						var i = t.style,
							n = t.weight;
						if (null === h) {
							var s = document.createElement("div");
							try {
								s.style.font = "condensed 100px sans-serif"
							} catch (t) {}
							h = "" !== s.style.font
						}
						return [i, n, h ? t.stretch : "", "100px", e].join(" ")
					}
					r.prototype.load = function(t, e) {
						var s = this,
							r = t || "BESbswy",
							h = 0,
							u = e || 3e3,
							p = (new Date).getTime();
						return new Promise((function(t, e) {
							if (c(s.context) && ! function(t) {
									return null === l && (c(t) && /Apple/.test(window.navigator.vendor) ? (t = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent), l = !!t && 603 > parseInt(t[1], 10)) : l = !1), l
								}(s.context)) {
								var _ = new Promise((function(t, e) {
										! function i() {
											(new Date).getTime() - p >= u ? e(Error(u + "ms timeout exceeded")) : s.context.document.fonts.load(d(s, '"' + s.family + '"'), r).then((function(e) {
												1 <= e.length ? t() : setTimeout(i, 25)
											}), e)
										}()
									})),
									m = new Promise((function(t, e) {
										h = setTimeout((function() {
											e(Error(u + "ms timeout exceeded"))
										}), u)
									}));
								Promise.race([m, _]).then((function() {
									clearTimeout(h), t(s)
								}), e)
							} else ! function(t) {
								document.body ? t() : document.addEventListener ? document.addEventListener("DOMContentLoaded", (function e() {
									document.removeEventListener("DOMContentLoaded", e), t()
								})) : document.attachEvent("onreadystatechange", (function e() {
									"interactive" != document.readyState && "complete" != document.readyState || (document.detachEvent("onreadystatechange", e), t())
								}))
							}((function() {
								function l() {
									var e;
									(e = -1 != g && -1 != f || -1 != g && -1 != S || -1 != f && -1 != S) && ((e = g != f && g != S && f != S) || (null === a && (e = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent), a = !!e && (536 > parseInt(e[1], 10) || 536 === parseInt(e[1], 10) && 11 >= parseInt(e[2], 10))), e = a && (g == y && f == y && S == y || g == v && f == v && S == v || g == T && f == T && S == T)), e = !e), e && (null !== E.parentNode && E.parentNode.removeChild(E), clearTimeout(h), t(s))
								}
								var c = new i(r),
									_ = new i(r),
									m = new i(r),
									g = -1,
									f = -1,
									S = -1,
									y = -1,
									v = -1,
									T = -1,
									E = document.createElement("div");
								E.dir = "ltr", n(c, d(s, "sans-serif")), n(_, d(s, "serif")), n(m, d(s, "monospace")), E.appendChild(c.g), E.appendChild(_.g), E.appendChild(m.g), s.context.document.body.appendChild(E), y = c.g.offsetWidth, v = _.g.offsetWidth, T = m.g.offsetWidth,
									function t() {
										if ((new Date).getTime() - p >= u) null !== E.parentNode && E.parentNode.removeChild(E), e(Error(u + "ms timeout exceeded"));
										else {
											var i = s.context.document.hidden;
											!0 !== i && void 0 !== i || (g = c.g.offsetWidth, f = _.g.offsetWidth, S = m.g.offsetWidth, l()), h = setTimeout(t, 50)
										}
									}(), o(c, (function(t) {
										g = t, l()
									})), n(c, d(s, '"' + s.family + '",sans-serif')), o(_, (function(t) {
										f = t, l()
									})), n(_, d(s, '"' + s.family + '",serif')), o(m, (function(t) {
										S = t, l()
									})), n(m, d(s, '"' + s.family + '",monospace'))
							}))
						}))
					}, t.exports = r
				}()
			},
			38075: (t, e, i) => {
				"use strict";
				var n = i(70453),
					s = i(10487),
					o = s(n("String.prototype.indexOf"));
				t.exports = function(t, e) {
					var i = n(t, !!e);
					return "function" == typeof i && o(t, ".prototype.") > -1 ? s(i) : i
				}
			},
			10487: (t, e, i) => {
				"use strict";
				var n = i(66743),
					s = i(70453),
					o = i(96897),
					r = i(69675),
					a = s("%Function.prototype.apply%"),
					l = s("%Function.prototype.call%"),
					h = s("%Reflect.apply%", !0) || n.call(l, a),
					u = i(30655),
					c = s("%Math.max%");
				t.exports = function(t) {
					if ("function" != typeof t) throw new r("a function is required");
					var e = h(n, l, arguments);
					return o(e, 1 + c(0, t.length - (arguments.length - 1)), !0)
				};
				var d = function() {
					return h(n, a, arguments)
				};
				u ? u(t.exports, "apply", {
					value: d
				}) : t.exports.apply = d
			},
			12610: (t, e, i) => {
				"use strict";
				i.d(e, {
					A: () => a
				});
				var n = i(71354),
					s = i.n(n),
					o = i(76314),
					r = i.n(o)()(s());
				r.push([t.id, ".nolimit button {\n    font-family: 'Open Sans', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, 'Lucida Grande', sans-serif;\n    color: white;\n    background-color: rgba(0, 0, 0, 0.5);\n\n    border: 0.05em solid rgba(255, 255, 255, 0.5);\n    border-radius: 0.4em;\n\n    background-clip: padding-box;\n\n    font-style: italic;\n    font-weight: 800;\n    font-size: 4em;\n\n    margin: 0.8em;\n    padding: 0.1em 1.0em;\n\n    text-transform: uppercase;\n\n\n    opacity: 0.8;\n\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n\n    cursor: pointer;\n\n    backface-visibility: hidden;\n    -webkit-backface-visibility: hidden;\n}\n\n[data-device=\"desktop\"] .nolimit button:hover {\n    border-color: white;\n    opacity: 1;\n}\n\n[data-device=\"mobile\"] .nolimit button {\n    border-color: white;\n    opacity: 1;\n    cursor: default;\n}\n\n.nolimit button:active {\n    border-color: white;\n    transform: scale(0.95);\n    opacity: 1;\n}\n\n.nolimit button.active {\n    opacity: 1;\n    color: #fbf800;\n    border-color: #fbf800;\n}\n\n.nolimit button.close:not(.icon) {\n    width: auto;\n}\n\n[data-device=\"desktop\"] .nolimit button.disabled,\n[data-device=\"desktop\"] .nolimit button.disabled:hover,\n[data-device=\"mobile\"] .nolimit button.disabled {\n    border-color: rgba(255, 255, 255, 0.5);\n    cursor: default;\n    transform: none;\n    opacity: 0.5;\n}\n\n.nolimit button.disabled.waiting{\nanimation-name: waiting;\nanimation-duration: 2s;\nanimation-iteration-count:infinite;\n}\n\n@keyframes waiting {\n    0%  {opacity:0.5}\n    50% {opacity:0.2}\n    100% {opacity:0.5}\n}\n", "", {
					version: 3,
					sources: ["webpack://./node_modules/@nolimitcity/game-api/src/css/button.css"],
					names: [],
					mappings: "AAAA;IACI,wIAAwI;IACxI,YAAY;IACZ,oCAAoC;;IAEpC,6CAA6C;IAC7C,oBAAoB;;IAEpB,4BAA4B;;IAE5B,kBAAkB;IAClB,gBAAgB;IAChB,cAAc;;IAEd,aAAa;IACb,oBAAoB;;IAEpB,yBAAyB;;;IAGzB,YAAY;;IAEZ,2BAA2B;IAC3B,yBAAyB;IACzB,sBAAsB;IACtB,qBAAqB;;IAErB,eAAe;;IAEf,2BAA2B;IAC3B,mCAAmC;AACvC;;AAEA;IACI,mBAAmB;IACnB,UAAU;AACd;;AAEA;IACI,mBAAmB;IACnB,UAAU;IACV,eAAe;AACnB;;AAEA;IACI,mBAAmB;IACnB,sBAAsB;IACtB,UAAU;AACd;;AAEA;IACI,UAAU;IACV,cAAc;IACd,qBAAqB;AACzB;;AAEA;IACI,WAAW;AACf;;AAEA;;;IAGI,sCAAsC;IACtC,eAAe;IACf,eAAe;IACf,YAAY;AAChB;;AAEA;AACA,uBAAuB;AACvB,sBAAsB;AACtB,kCAAkC;AAClC;;AAEA;IACI,KAAK,WAAW;IAChB,KAAK,WAAW;IAChB,MAAM,WAAW;AACrB",
					sourcesContent: [".nolimit button {\n    font-family: 'Open Sans', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, 'Lucida Grande', sans-serif;\n    color: white;\n    background-color: rgba(0, 0, 0, 0.5);\n\n    border: 0.05em solid rgba(255, 255, 255, 0.5);\n    border-radius: 0.4em;\n\n    background-clip: padding-box;\n\n    font-style: italic;\n    font-weight: 800;\n    font-size: 4em;\n\n    margin: 0.8em;\n    padding: 0.1em 1.0em;\n\n    text-transform: uppercase;\n\n\n    opacity: 0.8;\n\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n\n    cursor: pointer;\n\n    backface-visibility: hidden;\n    -webkit-backface-visibility: hidden;\n}\n\n[data-device=\"desktop\"] .nolimit button:hover {\n    border-color: white;\n    opacity: 1;\n}\n\n[data-device=\"mobile\"] .nolimit button {\n    border-color: white;\n    opacity: 1;\n    cursor: default;\n}\n\n.nolimit button:active {\n    border-color: white;\n    transform: scale(0.95);\n    opacity: 1;\n}\n\n.nolimit button.active {\n    opacity: 1;\n    color: #fbf800;\n    border-color: #fbf800;\n}\n\n.nolimit button.close:not(.icon) {\n    width: auto;\n}\n\n[data-device=\"desktop\"] .nolimit button.disabled,\n[data-device=\"desktop\"] .nolimit button.disabled:hover,\n[data-device=\"mobile\"] .nolimit button.disabled {\n    border-color: rgba(255, 255, 255, 0.5);\n    cursor: default;\n    transform: none;\n    opacity: 0.5;\n}\n\n.nolimit button.disabled.waiting{\nanimation-name: waiting;\nanimation-duration: 2s;\nanimation-iteration-count:infinite;\n}\n\n@keyframes waiting {\n    0%  {opacity:0.5}\n    50% {opacity:0.2}\n    100% {opacity:0.5}\n}\n"],
					sourceRoot: ""
				}]);
				const a = r
			},
			34590: (t, e, i) => {
				"use strict";
				i.d(e, {
					A: () => a
				});
				var n = i(71354),
					s = i.n(n),
					o = i(76314),
					r = i.n(o)()(s());
				r.push([t.id, "\n.nolimit .dialog {\n    border: 0.2em solid rgba(255, 255, 255, 0.5);\n    border-radius: 2em;\n    background-clip: padding-box;\n    background-color: rgba(0, 0, 0, 0.5);\n    text-align: center;\n    padding-top: 0em;\n    padding-right: 4em;\n    padding-left: 4em;\n    padding-bottom: 0em;\n    font-weight: 200;\n    overflow: hidden;\n    height:auto;\n    width:auto;\n    max-width: 90%;\n    max-height: 90%;\n}\n\n.nolimit .dialog, .nolimit .dialog a {\n    color: #fbf800;\n}\n.nolimit .dialog a {\n    font-size:1.4em\n}\n\n.nolimit .dialog a:hover {\n    font-weight: 400;\n}\n\n.nolimit .hidden {\n    position: absolute;\n    left: -200vw;\n    padding: 0;\n    margin: 0;\n}\n\n.nolimit .hidden .dialog {\n    width: 70vw;\n    max-height: 90%;\n    height: auto;\n\n}\n\n.nolimit .dialog h1, .nolimit .dialog p, .nolimit .dialog ul {\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n}\n\n.nolimit .dialog h1, .nolimit .dialog h2 {\n    color: white;\n    margin-top: 1em;\n    margin-bottom: 1em;\n    font-weight: 300;\n}\n\n.nolimit .dialog h1 {\n    font-size: 3em;\n}\n\n.nolimit .dialog h2 {\n    font-size: 2.8em;\n}\n\n.nolimit .dialog ul {\n    list-style: none none;\n    font-size: 1.6em;\n    padding: 0;\n}\n\n.nolimit .dialog p {\n    margin: 1em;\n    font-weight: 200;\n    font-size: 1.7em;\n}\n\n.nolimit .dialog .grid {\n    width: 100%;\n    display: table;\n    table-layout: fixed;\n}\n\n.nolimit .dialog .grid > * {\n    display: table-cell;\n}\n", "", {
					version: 3,
					sources: ["webpack://./node_modules/@nolimitcity/game-api/src/css/dialog.css"],
					names: [],
					mappings: ";AACA;IACI,4CAA4C;IAC5C,kBAAkB;IAClB,4BAA4B;IAC5B,oCAAoC;IACpC,kBAAkB;IAClB,gBAAgB;IAChB,kBAAkB;IAClB,iBAAiB;IACjB,mBAAmB;IACnB,gBAAgB;IAChB,gBAAgB;IAChB,WAAW;IACX,UAAU;IACV,cAAc;IACd,eAAe;AACnB;;AAEA;IACI,cAAc;AAClB;AACA;IACI;AACJ;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,kBAAkB;IAClB,YAAY;IACZ,UAAU;IACV,SAAS;AACb;;AAEA;IACI,WAAW;IACX,eAAe;IACf,YAAY;;AAEhB;;AAEA;IACI,2BAA2B;IAC3B,yBAAyB;IACzB,sBAAsB;IACtB,qBAAqB;AACzB;;AAEA;IACI,YAAY;IACZ,eAAe;IACf,kBAAkB;IAClB,gBAAgB;AACpB;;AAEA;IACI,cAAc;AAClB;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,qBAAqB;IACrB,gBAAgB;IAChB,UAAU;AACd;;AAEA;IACI,WAAW;IACX,gBAAgB;IAChB,gBAAgB;AACpB;;AAEA;IACI,WAAW;IACX,cAAc;IACd,mBAAmB;AACvB;;AAEA;IACI,mBAAmB;AACvB",
					sourcesContent: ["\n.nolimit .dialog {\n    border: 0.2em solid rgba(255, 255, 255, 0.5);\n    border-radius: 2em;\n    background-clip: padding-box;\n    background-color: rgba(0, 0, 0, 0.5);\n    text-align: center;\n    padding-top: 0em;\n    padding-right: 4em;\n    padding-left: 4em;\n    padding-bottom: 0em;\n    font-weight: 200;\n    overflow: hidden;\n    height:auto;\n    width:auto;\n    max-width: 90%;\n    max-height: 90%;\n}\n\n.nolimit .dialog, .nolimit .dialog a {\n    color: #fbf800;\n}\n.nolimit .dialog a {\n    font-size:1.4em\n}\n\n.nolimit .dialog a:hover {\n    font-weight: 400;\n}\n\n.nolimit .hidden {\n    position: absolute;\n    left: -200vw;\n    padding: 0;\n    margin: 0;\n}\n\n.nolimit .hidden .dialog {\n    width: 70vw;\n    max-height: 90%;\n    height: auto;\n\n}\n\n.nolimit .dialog h1, .nolimit .dialog p, .nolimit .dialog ul {\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n}\n\n.nolimit .dialog h1, .nolimit .dialog h2 {\n    color: white;\n    margin-top: 1em;\n    margin-bottom: 1em;\n    font-weight: 300;\n}\n\n.nolimit .dialog h1 {\n    font-size: 3em;\n}\n\n.nolimit .dialog h2 {\n    font-size: 2.8em;\n}\n\n.nolimit .dialog ul {\n    list-style: none none;\n    font-size: 1.6em;\n    padding: 0;\n}\n\n.nolimit .dialog p {\n    margin: 1em;\n    font-weight: 200;\n    font-size: 1.7em;\n}\n\n.nolimit .dialog .grid {\n    width: 100%;\n    display: table;\n    table-layout: fixed;\n}\n\n.nolimit .dialog .grid > * {\n    display: table-cell;\n}\n"],
					sourceRoot: ""
				}]);
				const a = r
			},
			23917: (t, e, i) => {
				"use strict";
				i.d(e, {
					A: () => a
				});
				var n = i(71354),
					s = i.n(n),
					o = i(76314),
					r = i.n(o)()(s());
				r.push([t.id, "@keyframes blink {\n    0% {\n        opacity: 1;\n    }\n    50% {\n        opacity: 0;\n    }\n    100% {\n        opacity: 1;\n    }\n}\n\nhtml {\n    box-sizing: border-box;\n}\n\n[data-device=\"mobile\"] .nolimit .desktop {\n    display: none !important;\n}\n\n[data-device=\"desktop\"] .nolimit .mobile {\n    display: none !important;\n}\n\n.nolimit #game-name-version {\n    /*    pointer-events: none;\n        position: absolute;\n        z-index: 2147483647;\n        -webkit-touch-callout: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n\n       padding: 0.1em 0.4em;\n        border-radius: 0.3em;\n        font-size: 1.4em;\n        font-weight: 100;\n        opacity: 1;\n        color: #ffffff;\n        background-color: rgba(0, 0, 0, 0.5);\n\n        top: 0.71em;\n        right: 0.71em;\n        margin-right: env(safe-area-inset-right);*/\n}\n\n.nolimit #net-position{\n    pointer-events: none;\n    position: absolute;\n    z-index: 2147483647;\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n    white-space: nowrap;\n\n    padding: 0.1em 0.4em;\n    border-radius: 0.3em;\n    font-size: 1.4em;\n    font-weight: 100;\n    opacity: 1;\n    color: #ffffff;\n    background-color: rgba(0, 0, 0, 0.5);\n\n    top: 1.8em;\n    right: 0em;\n    margin-right: env(safe-area-inset-right);\n}\n\n.nolimit * {\n    position: initial;\n    width: initial;\n    height: initial;\n    object-fit: initial;\n}\n\nhtml, body, .nolimit.container, .nolimit.container > .game {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n}\n\nbody {\n    position: fixed;\n    background-color: #000;\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n    font-family: 'Open Sans', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, 'Lucida Grande', sans-serif;\n}\n\n*, *:before, *:after {\n    box-sizing: inherit;\n}\n\n.blurred {\n    -webkit-filter: blur(3em);\n    filter: blur(3em);\n}\n\nhtml, button, a {\n    -ms-touch-action: manipulation;\n    touch-action: manipulation;\n}\n\n.nolimit.container {\n    position: absolute;\n}\n\n[data-device=\"mobile\"] .nolimit.container {\n    top: 0;\n    left: 0;\n}\n\n.nolimit.container.loading {\n    visibility: hidden;\n}\n\n.nolimit > .fun, .nolimit > .beta, .nolimit > .replay {\n    position: absolute;\n    z-index: 10000;\n    font-weight: 600;\n    padding: 4px 8px;\n    font-size: 1rem;\n    top: 0;\n\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n}\n\n[data-device=\"mobile\"] .nolimit > .replay {\n    top: 1rem;\n}\n\n@media screen and (orientation: portrait) {\n    [data-device=\"mobile\"] .nolimit > .replay {\n        font-size: 10vw;\n    }\n}\n\n.nolimit > .replay {\n    color: white;\n    right: 0;\n    font-weight: bold;\n    font-size: 5vw;\n    margin: 0 0.6rem;\n    animation: 1.5s linear infinite blink;\n    display: none;\n}\n\n\n\n\n.nolimit > .beta {\n    color: #fbf800;\n    right: 0;\n    opacity: 0.7;\n}\n\n.nolimit > .game {\n    text-align: center;\n    position: relative;\n}\n\n\n.nolimit .top-label-left, .top-label-right {\n    pointer-events: none;\n    position: absolute;\n    z-index: 2147483647;\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n\n    padding: 0.1em 0.4em;\n    border-radius: 0.3em;\n    font-size: 1.4em;\n    font-weight: 100;\n    opacity: 1;\n    color: #ffffff;\n    background-color: rgba(0, 0, 0, 0.5);\n    top: 0.71em;\n}\n\n\n.nolimit .top-bar-left, .top-bar-right {\n    pointer-events: none;\n    z-index: 2147483647;\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n\n    display: flex;\n    flex-direction: row;\n    position: absolute;\n    top:1em;\n}\n.nolimit .top-bar-left{\n    left: 1em;\n    margin-left: env(safe-area-inset-left);\n}\n.nolimit .top-bar-left .top-bar-item  {\n    margin-right: 0.5em;\n}\n\n.nolimit .top-bar-right{\n    right: 1em;\n    margin-right: env(safe-area-inset-right);\n}\n.nolimit .top-bar-right .top-bar-item  {\n    margin-left: 0.5em;\n}\n\n.nolimit .top-bar-item {\n    padding: 0.1em 0.4em;\n    border-radius: 0.3em;\n    font-size: 1.4em;\n    font-weight: 100;\n    opacity: 1;\n    color: #ffffff;\n    background-color: rgba(0, 0, 0, 0.5);\n}\n\n\n\n", "", {
					version: 3,
					sources: ["webpack://./node_modules/@nolimitcity/game-api/src/css/main.css"],
					names: [],
					mappings: "AAAA;IACI;QACI,UAAU;IACd;IACA;QACI,UAAU;IACd;IACA;QACI,UAAU;IACd;AACJ;;AAEA;IACI,sBAAsB;AAC1B;;AAEA;IACI,wBAAwB;AAC5B;;AAEA;IACI,wBAAwB;AAC5B;;AAEA;IACI;;;;;;;;;;;;;;;;;;;kDAmB8C;AAClD;;AAEA;IACI,oBAAoB;IACpB,kBAAkB;IAClB,mBAAmB;IACnB,2BAA2B;IAC3B,yBAAyB;IACzB,sBAAsB;IACtB,qBAAqB;IACrB,iBAAiB;IACjB,mBAAmB;;IAEnB,oBAAoB;IACpB,oBAAoB;IACpB,gBAAgB;IAChB,gBAAgB;IAChB,UAAU;IACV,cAAc;IACd,oCAAoC;;IAEpC,UAAU;IACV,UAAU;IACV,wCAAwC;AAC5C;;AAEA;IACI,iBAAiB;IACjB,cAAc;IACd,eAAe;IACf,mBAAmB;AACvB;;AAEA;IACI,SAAS;IACT,WAAW;IACX,YAAY;IACZ,gBAAgB;AACpB;;AAEA;IACI,eAAe;IACf,sBAAsB;IACtB,6CAA6C;IAC7C,wIAAwI;AAC5I;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,yBAAyB;IACzB,iBAAiB;AACrB;;AAEA;IACI,8BAA8B;IAC9B,0BAA0B;AAC9B;;AAEA;IACI,kBAAkB;AACtB;;AAEA;IACI,MAAM;IACN,OAAO;AACX;;AAEA;IACI,kBAAkB;AACtB;;AAEA;IACI,kBAAkB;IAClB,cAAc;IACd,gBAAgB;IAChB,gBAAgB;IAChB,eAAe;IACf,MAAM;;IAEN,2BAA2B;IAC3B,yBAAyB;IACzB,sBAAsB;IACtB,qBAAqB;AACzB;;AAEA;IACI,SAAS;AACb;;AAEA;IACI;QACI,eAAe;IACnB;AACJ;;AAEA;IACI,YAAY;IACZ,QAAQ;IACR,iBAAiB;IACjB,cAAc;IACd,gBAAgB;IAChB,qCAAqC;IACrC,aAAa;AACjB;;;;;AAKA;IACI,cAAc;IACd,QAAQ;IACR,YAAY;AAChB;;AAEA;IACI,kBAAkB;IAClB,kBAAkB;AACtB;;;AAGA;IACI,oBAAoB;IACpB,kBAAkB;IAClB,mBAAmB;IACnB,2BAA2B;IAC3B,yBAAyB;IACzB,sBAAsB;IACtB,qBAAqB;IACrB,iBAAiB;;IAEjB,oBAAoB;IACpB,oBAAoB;IACpB,gBAAgB;IAChB,gBAAgB;IAChB,UAAU;IACV,cAAc;IACd,oCAAoC;IACpC,WAAW;AACf;;;AAGA;IACI,oBAAoB;IACpB,mBAAmB;IACnB,2BAA2B;IAC3B,yBAAyB;IACzB,sBAAsB;IACtB,qBAAqB;IACrB,iBAAiB;;IAEjB,aAAa;IACb,mBAAmB;IACnB,kBAAkB;IAClB,OAAO;AACX;AACA;IACI,SAAS;IACT,sCAAsC;AAC1C;AACA;IACI,mBAAmB;AACvB;;AAEA;IACI,UAAU;IACV,wCAAwC;AAC5C;AACA;IACI,kBAAkB;AACtB;;AAEA;IACI,oBAAoB;IACpB,oBAAoB;IACpB,gBAAgB;IAChB,gBAAgB;IAChB,UAAU;IACV,cAAc;IACd,oCAAoC;AACxC",
					sourcesContent: ["@keyframes blink {\n    0% {\n        opacity: 1;\n    }\n    50% {\n        opacity: 0;\n    }\n    100% {\n        opacity: 1;\n    }\n}\n\nhtml {\n    box-sizing: border-box;\n}\n\n[data-device=\"mobile\"] .nolimit .desktop {\n    display: none !important;\n}\n\n[data-device=\"desktop\"] .nolimit .mobile {\n    display: none !important;\n}\n\n.nolimit #game-name-version {\n    /*    pointer-events: none;\n        position: absolute;\n        z-index: 2147483647;\n        -webkit-touch-callout: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n\n       padding: 0.1em 0.4em;\n        border-radius: 0.3em;\n        font-size: 1.4em;\n        font-weight: 100;\n        opacity: 1;\n        color: #ffffff;\n        background-color: rgba(0, 0, 0, 0.5);\n\n        top: 0.71em;\n        right: 0.71em;\n        margin-right: env(safe-area-inset-right);*/\n}\n\n.nolimit #net-position{\n    pointer-events: none;\n    position: absolute;\n    z-index: 2147483647;\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n    white-space: nowrap;\n\n    padding: 0.1em 0.4em;\n    border-radius: 0.3em;\n    font-size: 1.4em;\n    font-weight: 100;\n    opacity: 1;\n    color: #ffffff;\n    background-color: rgba(0, 0, 0, 0.5);\n\n    top: 1.8em;\n    right: 0em;\n    margin-right: env(safe-area-inset-right);\n}\n\n.nolimit * {\n    position: initial;\n    width: initial;\n    height: initial;\n    object-fit: initial;\n}\n\nhtml, body, .nolimit.container, .nolimit.container > .game {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n}\n\nbody {\n    position: fixed;\n    background-color: #000;\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n    font-family: 'Open Sans', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, 'Lucida Grande', sans-serif;\n}\n\n*, *:before, *:after {\n    box-sizing: inherit;\n}\n\n.blurred {\n    -webkit-filter: blur(3em);\n    filter: blur(3em);\n}\n\nhtml, button, a {\n    -ms-touch-action: manipulation;\n    touch-action: manipulation;\n}\n\n.nolimit.container {\n    position: absolute;\n}\n\n[data-device=\"mobile\"] .nolimit.container {\n    top: 0;\n    left: 0;\n}\n\n.nolimit.container.loading {\n    visibility: hidden;\n}\n\n.nolimit > .fun, .nolimit > .beta, .nolimit > .replay {\n    position: absolute;\n    z-index: 10000;\n    font-weight: 600;\n    padding: 4px 8px;\n    font-size: 1rem;\n    top: 0;\n\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n}\n\n[data-device=\"mobile\"] .nolimit > .replay {\n    top: 1rem;\n}\n\n@media screen and (orientation: portrait) {\n    [data-device=\"mobile\"] .nolimit > .replay {\n        font-size: 10vw;\n    }\n}\n\n.nolimit > .replay {\n    color: white;\n    right: 0;\n    font-weight: bold;\n    font-size: 5vw;\n    margin: 0 0.6rem;\n    animation: 1.5s linear infinite blink;\n    display: none;\n}\n\n\n\n\n.nolimit > .beta {\n    color: #fbf800;\n    right: 0;\n    opacity: 0.7;\n}\n\n.nolimit > .game {\n    text-align: center;\n    position: relative;\n}\n\n\n.nolimit .top-label-left, .top-label-right {\n    pointer-events: none;\n    position: absolute;\n    z-index: 2147483647;\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n\n    padding: 0.1em 0.4em;\n    border-radius: 0.3em;\n    font-size: 1.4em;\n    font-weight: 100;\n    opacity: 1;\n    color: #ffffff;\n    background-color: rgba(0, 0, 0, 0.5);\n    top: 0.71em;\n}\n\n\n.nolimit .top-bar-left, .top-bar-right {\n    pointer-events: none;\n    z-index: 2147483647;\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n\n    display: flex;\n    flex-direction: row;\n    position: absolute;\n    top:1em;\n}\n.nolimit .top-bar-left{\n    left: 1em;\n    margin-left: env(safe-area-inset-left);\n}\n.nolimit .top-bar-left .top-bar-item  {\n    margin-right: 0.5em;\n}\n\n.nolimit .top-bar-right{\n    right: 1em;\n    margin-right: env(safe-area-inset-right);\n}\n.nolimit .top-bar-right .top-bar-item  {\n    margin-left: 0.5em;\n}\n\n.nolimit .top-bar-item {\n    padding: 0.1em 0.4em;\n    border-radius: 0.3em;\n    font-size: 1.4em;\n    font-weight: 100;\n    opacity: 1;\n    color: #ffffff;\n    background-color: rgba(0, 0, 0, 0.5);\n}\n\n\n\n"],
					sourceRoot: ""
				}]);
				const a = r
			},
			98068: (t, e, i) => {
				"use strict";
				i.d(e, {
					A: () => a
				});
				var n = i(71354),
					s = i.n(n),
					o = i(76314),
					r = i.n(o)()(s());
				r.push([t.id, ".nolimit .overlay {\n    position: fixed;\n    top: 0;\n    left: 0;\n    overflow: hidden;\n    z-index: 2147483645;\n    display: none;\n\n    align-items: center;\n    justify-content: center;\n    width: 100%;\n    height: 100%;\n}\n\n.nolimit.overlay .overlay {\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n}\n\n.nolimit.overlay .overlay {\n    background-color: rgba(0, 0, 0, 0);\n}\n\n.nolimit.overlay .overlay.blackout {\n    background-color: rgba(0, 0, 0, 1);\n}\n", "", {
					version: 3,
					sources: ["webpack://./node_modules/@nolimitcity/game-api/src/css/overlay.css"],
					names: [],
					mappings: "AAAA;IACI,eAAe;IACf,MAAM;IACN,OAAO;IACP,gBAAgB;IAChB,mBAAmB;IACnB,aAAa;;IAEb,mBAAmB;IACnB,uBAAuB;IACvB,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,qBAAqB;IACrB,oBAAoB;IACpB,aAAa;AACjB;;AAEA;IACI,kCAAkC;AACtC;;AAEA;IACI,kCAAkC;AACtC",
					sourcesContent: [".nolimit .overlay {\n    position: fixed;\n    top: 0;\n    left: 0;\n    overflow: hidden;\n    z-index: 2147483645;\n    display: none;\n\n    align-items: center;\n    justify-content: center;\n    width: 100%;\n    height: 100%;\n}\n\n.nolimit.overlay .overlay {\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n}\n\n.nolimit.overlay .overlay {\n    background-color: rgba(0, 0, 0, 0);\n}\n\n.nolimit.overlay .overlay.blackout {\n    background-color: rgba(0, 0, 0, 1);\n}\n"],
					sourceRoot: ""
				}]);
				const a = r
			},
			76314: t => {
				"use strict";
				t.exports = function(t) {
					var e = [];
					return e.toString = function() {
						return this.map((function(e) {
							var i = "",
								n = void 0 !== e[5];
							return e[4] && (i += "@supports (".concat(e[4], ") {")), e[2] && (i += "@media ".concat(e[2], " {")), n && (i += "@layer".concat(e[5].length > 0 ? " ".concat(e[5]) : "", " {")), i += t(e), n && (i += "}"), e[2] && (i += "}"), e[4] && (i += "}"), i
						})).join("")
					}, e.i = function(t, i, n, s, o) {
						"string" == typeof t && (t = [
							[null, t, void 0]
						]);
						var r = {};
						if (n)
							for (var a = 0; a < this.length; a++) {
								var l = this[a][0];
								null != l && (r[l] = !0)
							}
						for (var h = 0; h < t.length; h++) {
							var u = [].concat(t[h]);
							n && r[u[0]] || (void 0 !== o && (void 0 === u[5] || (u[1] = "@layer".concat(u[5].length > 0 ? " ".concat(u[5]) : "", " {").concat(u[1], "}")), u[5] = o), i && (u[2] ? (u[1] = "@media ".concat(u[2], " {").concat(u[1], "}"), u[2] = i) : u[2] = i), s && (u[4] ? (u[1] = "@supports (".concat(u[4], ") {").concat(u[1], "}"), u[4] = s) : u[4] = "".concat(s)), e.push(u))
						}
					}, e
				}
			},
			71354: t => {
				"use strict";
				t.exports = function(t) {
					var e = t[1],
						i = t[3];
					if (!i) return e;
					if ("function" == typeof btoa) {
						var n = btoa(unescape(encodeURIComponent(JSON.stringify(i)))),
							s = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(n),
							o = "/*# ".concat(s, " */");
						return [e].concat([o]).join("\n")
					}
					return [e].join("\n")
				}
			},
			30041: (t, e, i) => {
				"use strict";
				var n = i(30655),
					s = i(58068),
					o = i(69675),
					r = i(75795);
				t.exports = function(t, e, i) {
					if (!t || "object" != typeof t && "function" != typeof t) throw new o("`obj` must be an object or a function`");
					if ("string" != typeof e && "symbol" != typeof e) throw new o("`property` must be a string or a symbol`");
					if (arguments.length > 3 && "boolean" != typeof arguments[3] && null !== arguments[3]) throw new o("`nonEnumerable`, if provided, must be a boolean or null");
					if (arguments.length > 4 && "boolean" != typeof arguments[4] && null !== arguments[4]) throw new o("`nonWritable`, if provided, must be a boolean or null");
					if (arguments.length > 5 && "boolean" != typeof arguments[5] && null !== arguments[5]) throw new o("`nonConfigurable`, if provided, must be a boolean or null");
					if (arguments.length > 6 && "boolean" != typeof arguments[6]) throw new o("`loose`, if provided, must be a boolean");
					var a = arguments.length > 3 ? arguments[3] : null,
						l = arguments.length > 4 ? arguments[4] : null,
						h = arguments.length > 5 ? arguments[5] : null,
						u = arguments.length > 6 && arguments[6],
						c = !!r && r(t, e);
					if (n) n(t, e, {
						configurable: null === h && c ? c.configurable : !h,
						enumerable: null === a && c ? c.enumerable : !a,
						value: i,
						writable: null === l && c ? c.writable : !l
					});
					else {
						if (!u && (a || l || h)) throw new s("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
						t[e] = i
					}
				}
			},
			66570: t => {
				"use strict";

				function e(t, e, n) {
					n = n || 2;
					var o, r, a, l, c, d, _, m = e && e.length,
						g = m ? e[0] * n : t.length,
						f = i(t, 0, g, n, !0),
						S = [];
					if (!f || f.next === f.prev) return S;
					if (m && (f = function(t, e, n, s) {
							var o, r, a, l = [];
							for (o = 0, r = e.length; o < r; o++)(a = i(t, e[o] * s, o < r - 1 ? e[o + 1] * s : t.length, s, !1)) === a.next && (a.steiner = !0), l.push(p(a));
							for (l.sort(h), o = 0; o < l.length; o++) n = u(l[o], n);
							return n
						}(t, e, f, n)), t.length > 80 * n) {
						o = a = t[0], r = l = t[1];
						for (var y = n; y < g; y += n)(c = t[y]) < o && (o = c), (d = t[y + 1]) < r && (r = d), c > a && (a = c), d > l && (l = d);
						_ = 0 !== (_ = Math.max(a - o, l - r)) ? 32767 / _ : 0
					}
					return s(f, S, n, o, r, _, 0), S
				}

				function i(t, e, i, n, s) {
					var o, r;
					if (s === I(t, e, i, n) > 0)
						for (o = e; o < i; o += n) r = b(o, t[o], t[o + 1], r);
					else
						for (o = i - n; o >= e; o -= n) r = b(o, t[o], t[o + 1], r);
					return r && f(r, r.next) && (A(r), r = r.next), r
				}

				function n(t, e) {
					if (!t) return t;
					e || (e = t);
					var i, n = t;
					do {
						if (i = !1, n.steiner || !f(n, n.next) && 0 !== g(n.prev, n, n.next)) n = n.next;
						else {
							if (A(n), (n = e = n.prev) === n.next) break;
							i = !0
						}
					} while (i || n !== e);
					return e
				}

				function s(t, e, i, h, u, c, p) {
					if (t) {
						!p && c && function(t, e, i, n) {
							var s = t;
							do {
								0 === s.z && (s.z = d(s.x, s.y, e, i, n)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next
							} while (s !== t);
							s.prevZ.nextZ = null, s.prevZ = null,
								function(t) {
									var e, i, n, s, o, r, a, l, h = 1;
									do {
										for (i = t, t = null, o = null, r = 0; i;) {
											for (r++, n = i, a = 0, e = 0; e < h && (a++, n = n.nextZ); e++);
											for (l = h; a > 0 || l > 0 && n;) 0 !== a && (0 === l || !n || i.z <= n.z) ? (s = i, i = i.nextZ, a--) : (s = n, n = n.nextZ, l--), o ? o.nextZ = s : t = s, s.prevZ = o, o = s;
											i = n
										}
										o.nextZ = null, h *= 2
									} while (r > 1)
								}(s)
						}(t, h, u, c);
						for (var _, m, g = t; t.prev !== t.next;)
							if (_ = t.prev, m = t.next, c ? r(t, h, u, c) : o(t)) e.push(_.i / i | 0), e.push(t.i / i | 0), e.push(m.i / i | 0), A(t), t = m.next, g = m.next;
							else if ((t = m) === g) {
							p ? 1 === p ? s(t = a(n(t), e, i), e, i, h, u, c, 2) : 2 === p && l(t, e, i, h, u, c) : s(n(t), e, i, h, u, c, 1);
							break
						}
					}
				}

				function o(t) {
					var e = t.prev,
						i = t,
						n = t.next;
					if (g(e, i, n) >= 0) return !1;
					for (var s = e.x, o = i.x, r = n.x, a = e.y, l = i.y, h = n.y, u = s < o ? s < r ? s : r : o < r ? o : r, c = a < l ? a < h ? a : h : l < h ? l : h, d = s > o ? s > r ? s : r : o > r ? o : r, p = a > l ? a > h ? a : h : l > h ? l : h, m = n.next; m !== e;) {
						if (m.x >= u && m.x <= d && m.y >= c && m.y <= p && _(s, a, o, l, r, h, m.x, m.y) && g(m.prev, m, m.next) >= 0) return !1;
						m = m.next
					}
					return !0
				}

				function r(t, e, i, n) {
					var s = t.prev,
						o = t,
						r = t.next;
					if (g(s, o, r) >= 0) return !1;
					for (var a = s.x, l = o.x, h = r.x, u = s.y, c = o.y, p = r.y, m = a < l ? a < h ? a : h : l < h ? l : h, f = u < c ? u < p ? u : p : c < p ? c : p, S = a > l ? a > h ? a : h : l > h ? l : h, y = u > c ? u > p ? u : p : c > p ? c : p, v = d(m, f, e, i, n), T = d(S, y, e, i, n), E = t.prevZ, b = t.nextZ; E && E.z >= v && b && b.z <= T;) {
						if (E.x >= m && E.x <= S && E.y >= f && E.y <= y && E !== s && E !== r && _(a, u, l, c, h, p, E.x, E.y) && g(E.prev, E, E.next) >= 0) return !1;
						if (E = E.prevZ, b.x >= m && b.x <= S && b.y >= f && b.y <= y && b !== s && b !== r && _(a, u, l, c, h, p, b.x, b.y) && g(b.prev, b, b.next) >= 0) return !1;
						b = b.nextZ
					}
					for (; E && E.z >= v;) {
						if (E.x >= m && E.x <= S && E.y >= f && E.y <= y && E !== s && E !== r && _(a, u, l, c, h, p, E.x, E.y) && g(E.prev, E, E.next) >= 0) return !1;
						E = E.prevZ
					}
					for (; b && b.z <= T;) {
						if (b.x >= m && b.x <= S && b.y >= f && b.y <= y && b !== s && b !== r && _(a, u, l, c, h, p, b.x, b.y) && g(b.prev, b, b.next) >= 0) return !1;
						b = b.nextZ
					}
					return !0
				}

				function a(t, e, i) {
					var s = t;
					do {
						var o = s.prev,
							r = s.next.next;
						!f(o, r) && S(o, s, s.next, r) && T(o, r) && T(r, o) && (e.push(o.i / i | 0), e.push(s.i / i | 0), e.push(r.i / i | 0), A(s), A(s.next), s = t = r), s = s.next
					} while (s !== t);
					return n(s)
				}

				function l(t, e, i, o, r, a) {
					var l = t;
					do {
						for (var h = l.next.next; h !== l.prev;) {
							if (l.i !== h.i && m(l, h)) {
								var u = E(l, h);
								return l = n(l, l.next), u = n(u, u.next), s(l, e, i, o, r, a, 0), void s(u, e, i, o, r, a, 0)
							}
							h = h.next
						}
						l = l.next
					} while (l !== t)
				}

				function h(t, e) {
					return t.x - e.x
				}

				function u(t, e) {
					var i = function(t, e) {
						var i, n = e,
							s = t.x,
							o = t.y,
							r = -1 / 0;
						do {
							if (o <= n.y && o >= n.next.y && n.next.y !== n.y) {
								var a = n.x + (o - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
								if (a <= s && a > r && (r = a, i = n.x < n.next.x ? n : n.next, a === s)) return i
							}
							n = n.next
						} while (n !== e);
						if (!i) return null;
						var l, h = i,
							u = i.x,
							d = i.y,
							p = 1 / 0;
						n = i;
						do {
							s >= n.x && n.x >= u && s !== n.x && _(o < d ? s : r, o, u, d, o < d ? r : s, o, n.x, n.y) && (l = Math.abs(o - n.y) / (s - n.x), T(n, t) && (l < p || l === p && (n.x > i.x || n.x === i.x && c(i, n))) && (i = n, p = l)), n = n.next
						} while (n !== h);
						return i
					}(t, e);
					if (!i) return e;
					var s = E(i, t);
					return n(s, s.next), n(i, i.next)
				}

				function c(t, e) {
					return g(t.prev, t, e.prev) < 0 && g(e.next, t, t.next) < 0
				}

				function d(t, e, i, n, s) {
					return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - i) * s | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * s | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
				}

				function p(t) {
					var e = t,
						i = t;
					do {
						(e.x < i.x || e.x === i.x && e.y < i.y) && (i = e), e = e.next
					} while (e !== t);
					return i
				}

				function _(t, e, i, n, s, o, r, a) {
					return (s - r) * (e - a) >= (t - r) * (o - a) && (t - r) * (n - a) >= (i - r) * (e - a) && (i - r) * (o - a) >= (s - r) * (n - a)
				}

				function m(t, e) {
					return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
						var i = t;
						do {
							if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && S(i, i.next, t, e)) return !0;
							i = i.next
						} while (i !== t);
						return !1
					}(t, e) && (T(t, e) && T(e, t) && function(t, e) {
						var i = t,
							n = !1,
							s = (t.x + e.x) / 2,
							o = (t.y + e.y) / 2;
						do {
							i.y > o != i.next.y > o && i.next.y !== i.y && s < (i.next.x - i.x) * (o - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next
						} while (i !== t);
						return n
					}(t, e) && (g(t.prev, t, e.prev) || g(t, e.prev, e)) || f(t, e) && g(t.prev, t, t.next) > 0 && g(e.prev, e, e.next) > 0)
				}

				function g(t, e, i) {
					return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
				}

				function f(t, e) {
					return t.x === e.x && t.y === e.y
				}

				function S(t, e, i, n) {
					var s = v(g(t, e, i)),
						o = v(g(t, e, n)),
						r = v(g(i, n, t)),
						a = v(g(i, n, e));
					return s !== o && r !== a || !(0 !== s || !y(t, i, e)) || !(0 !== o || !y(t, n, e)) || !(0 !== r || !y(i, t, n)) || !(0 !== a || !y(i, e, n))
				}

				function y(t, e, i) {
					return e.x <= Math.max(t.x, i.x) && e.x >= Math.min(t.x, i.x) && e.y <= Math.max(t.y, i.y) && e.y >= Math.min(t.y, i.y)
				}

				function v(t) {
					return t > 0 ? 1 : t < 0 ? -1 : 0
				}

				function T(t, e) {
					return g(t.prev, t, t.next) < 0 ? g(t, e, t.next) >= 0 && g(t, t.prev, e) >= 0 : g(t, e, t.prev) < 0 || g(t, t.next, e) < 0
				}

				function E(t, e) {
					var i = new P(t.i, t.x, t.y),
						n = new P(e.i, e.x, e.y),
						s = t.next,
						o = e.prev;
					return t.next = e, e.prev = t, i.next = s, s.prev = i, n.next = i, i.prev = n, o.next = n, n.prev = o, n
				}

				function b(t, e, i, n) {
					var s = new P(t, e, i);
					return n ? (s.next = n.next, s.prev = n, n.next.prev = s, n.next = s) : (s.prev = s, s.next = s), s
				}

				function A(t) {
					t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
				}

				function P(t, e, i) {
					this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
				}

				function I(t, e, i, n) {
					for (var s = 0, o = e, r = i - n; o < i; o += n) s += (t[r] - t[o]) * (t[o + 1] + t[r + 1]), r = o;
					return s
				}
				t.exports = e, t.exports.default = e, e.deviation = function(t, e, i, n) {
					var s = e && e.length,
						o = s ? e[0] * i : t.length,
						r = Math.abs(I(t, 0, o, i));
					if (s)
						for (var a = 0, l = e.length; a < l; a++) {
							var h = e[a] * i,
								u = a < l - 1 ? e[a + 1] * i : t.length;
							r -= Math.abs(I(t, h, u, i))
						}
					var c = 0;
					for (a = 0; a < n.length; a += 3) {
						var d = n[a] * i,
							p = n[a + 1] * i,
							_ = n[a + 2] * i;
						c += Math.abs((t[d] - t[_]) * (t[p + 1] - t[d + 1]) - (t[d] - t[p]) * (t[_ + 1] - t[d + 1]))
					}
					return 0 === r && 0 === c ? 0 : Math.abs((c - r) / r)
				}, e.flatten = function(t) {
					for (var e = t[0][0].length, i = {
							vertices: [],
							holes: [],
							dimensions: e
						}, n = 0, s = 0; s < t.length; s++) {
						for (var o = 0; o < t[s].length; o++)
							for (var r = 0; r < e; r++) i.vertices.push(t[s][o][r]);
						s > 0 && (n += t[s - 1].length, i.holes.push(n))
					}
					return i
				}
			},
			30655: (t, e, i) => {
				"use strict";
				var n = i(70453)("%Object.defineProperty%", !0) || !1;
				if (n) try {
					n({}, "a", {
						value: 1
					})
				} catch (t) {
					n = !1
				}
				t.exports = n
			},
			41237: t => {
				"use strict";
				t.exports = EvalError
			},
			69383: t => {
				"use strict";
				t.exports = Error
			},
			79290: t => {
				"use strict";
				t.exports = RangeError
			},
			79538: t => {
				"use strict";
				t.exports = ReferenceError
			},
			58068: t => {
				"use strict";
				t.exports = SyntaxError
			},
			69675: t => {
				"use strict";
				t.exports = TypeError
			},
			35345: t => {
				"use strict";
				t.exports = URIError
			},
			36354: function(t, e, i) {
				var n;
				! function(s) {
					var o = s.Promise,
						r = o && "resolve" in o && "reject" in o && "all" in o && "race" in o && function() {
							var t;
							return new o((function(e) {
								t = e
							})), "function" == typeof t
						}();
					e ? (e.Promise = r ? o : I, e.Polyfill = I) : void 0 === (n = function() {
						return r ? o : I
					}.call(e, i, e, t)) || (t.exports = n);
					var a = "pending",
						l = "sealed",
						h = "fulfilled",
						u = "rejected",
						c = function() {};

					function d(t) {
						return "[object Array]" === Object.prototype.toString.call(t)
					}
					var p, _ = "undefined" != typeof setImmediate ? setImmediate : setTimeout,
						m = [];

					function g() {
						for (var t = 0; t < m.length; t++) m[t][0](m[t][1]);
						m = [], p = !1
					}

					function f(t, e) {
						m.push([t, e]), p || (p = !0, _(g, 0))
					}

					function S(t) {
						var e = t.owner,
							i = e.state_,
							n = e.data_,
							s = t[i],
							o = t.then;
						if ("function" == typeof s) {
							i = h;
							try {
								n = s(n)
							} catch (t) {
								E(o, t)
							}
						}
						y(o, n) || (i === h && v(o, n), i === u && E(o, n))
					}

					function y(t, e) {
						var i;
						try {
							if (t === e) throw new TypeError("A promises callback cannot return that same promise.");
							if (e && ("function" == typeof e || "object" == typeof e)) {
								var n = e.then;
								if ("function" == typeof n) return n.call(e, (function(n) {
									i || (i = !0, e !== n ? v(t, n) : T(t, n))
								}), (function(e) {
									i || (i = !0, E(t, e))
								})), !0
							}
						} catch (e) {
							return i || E(t, e), !0
						}
						return !1
					}

					function v(t, e) {
						t !== e && y(t, e) || T(t, e)
					}

					function T(t, e) {
						t.state_ === a && (t.state_ = l, t.data_ = e, f(A, t))
					}

					function E(t, e) {
						t.state_ === a && (t.state_ = l, t.data_ = e, f(P, t))
					}

					function b(t) {
						var e = t.then_;
						t.then_ = void 0;
						for (var i = 0; i < e.length; i++) S(e[i])
					}

					function A(t) {
						t.state_ = h, b(t)
					}

					function P(t) {
						t.state_ = u, b(t)
					}

					function I(t) {
						if ("function" != typeof t) throw new TypeError("Promise constructor takes a function argument");
						if (this instanceof I == 0) throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
						this.then_ = [],
							function(t, e) {
								function i(t) {
									E(e, t)
								}
								try {
									t((function(t) {
										v(e, t)
									}), i)
								} catch (t) {
									i(t)
								}
							}(t, this)
					}
					I.prototype = {
						constructor: I,
						state_: a,
						then_: null,
						data_: void 0,
						then: function(t, e) {
							var i = {
								owner: this,
								then: new this.constructor(c),
								fulfilled: t,
								rejected: e
							};
							return this.state_ === h || this.state_ === u ? f(S, i) : this.then_.push(i), i.then
						},
						catch: function(t) {
							return this.then(null, t)
						}
					}, I.all = function(t) {
						if (!d(t)) throw new TypeError("You must pass an array to Promise.all().");
						return new this((function(e, i) {
							var n = [],
								s = 0;

							function o(t) {
								return s++,
									function(i) {
										n[t] = i, --s || e(n)
									}
							}
							for (var r, a = 0; a < t.length; a++)(r = t[a]) && "function" == typeof r.then ? r.then(o(a), i) : n[a] = r;
							s || e(n)
						}))
					}, I.race = function(t) {
						if (!d(t)) throw new TypeError("You must pass an array to Promise.race().");
						return new this((function(e, i) {
							for (var n, s = 0; s < t.length; s++)(n = t[s]) && "function" == typeof n.then ? n.then(e, i) : e(n)
						}))
					}, I.resolve = function(t) {
						return t && "object" == typeof t && t.constructor === this ? t : new this((function(e) {
							e(t)
						}))
					}, I.reject = function(t) {
						return new this((function(e, i) {
							i(t)
						}))
					}
				}("undefined" != typeof window ? window : void 0 !== i.g ? i.g : "undefined" != typeof self ? self : this)
			},
			30228: t => {
				"use strict";
				var e = Object.prototype.hasOwnProperty,
					i = "~";

				function n() {}

				function s(t, e, i) {
					this.fn = t, this.context = e, this.once = i || !1
				}

				function o(t, e, n, o, r) {
					if ("function" != typeof n) throw new TypeError("The listener must be a function");
					var a = new s(n, o || t, r),
						l = i ? i + e : e;
					return t._events[l] ? t._events[l].fn ? t._events[l] = [t._events[l], a] : t._events[l].push(a) : (t._events[l] = a, t._eventsCount++), t
				}

				function r(t, e) {
					0 == --t._eventsCount ? t._events = new n : delete t._events[e]
				}

				function a() {
					this._events = new n, this._eventsCount = 0
				}
				Object.create && (n.prototype = Object.create(null), (new n).__proto__ || (i = !1)), a.prototype.eventNames = function() {
					var t, n, s = [];
					if (0 === this._eventsCount) return s;
					for (n in t = this._events) e.call(t, n) && s.push(i ? n.slice(1) : n);
					return Object.getOwnPropertySymbols ? s.concat(Object.getOwnPropertySymbols(t)) : s
				}, a.prototype.listeners = function(t) {
					var e = i ? i + t : t,
						n = this._events[e];
					if (!n) return [];
					if (n.fn) return [n.fn];
					for (var s = 0, o = n.length, r = new Array(o); s < o; s++) r[s] = n[s].fn;
					return r
				}, a.prototype.listenerCount = function(t) {
					var e = i ? i + t : t,
						n = this._events[e];
					return n ? n.fn ? 1 : n.length : 0
				}, a.prototype.emit = function(t, e, n, s, o, r) {
					var a = i ? i + t : t;
					if (!this._events[a]) return !1;
					var l, h, u = this._events[a],
						c = arguments.length;
					if (u.fn) {
						switch (u.once && this.removeListener(t, u.fn, void 0, !0), c) {
							case 1:
								return u.fn.call(u.context), !0;
							case 2:
								return u.fn.call(u.context, e), !0;
							case 3:
								return u.fn.call(u.context, e, n), !0;
							case 4:
								return u.fn.call(u.context, e, n, s), !0;
							case 5:
								return u.fn.call(u.context, e, n, s, o), !0;
							case 6:
								return u.fn.call(u.context, e, n, s, o, r), !0
						}
						for (h = 1, l = new Array(c - 1); h < c; h++) l[h - 1] = arguments[h];
						u.fn.apply(u.context, l)
					} else {
						var d, p = u.length;
						for (h = 0; h < p; h++) switch (u[h].once && this.removeListener(t, u[h].fn, void 0, !0), c) {
							case 1:
								u[h].fn.call(u[h].context);
								break;
							case 2:
								u[h].fn.call(u[h].context, e);
								break;
							case 3:
								u[h].fn.call(u[h].context, e, n);
								break;
							case 4:
								u[h].fn.call(u[h].context, e, n, s);
								break;
							default:
								if (!l)
									for (d = 1, l = new Array(c - 1); d < c; d++) l[d - 1] = arguments[d];
								u[h].fn.apply(u[h].context, l)
						}
					}
					return !0
				}, a.prototype.on = function(t, e, i) {
					return o(this, t, e, i, !1)
				}, a.prototype.once = function(t, e, i) {
					return o(this, t, e, i, !0)
				}, a.prototype.removeListener = function(t, e, n, s) {
					var o = i ? i + t : t;
					if (!this._events[o]) return this;
					if (!e) return r(this, o), this;
					var a = this._events[o];
					if (a.fn) a.fn !== e || s && !a.once || n && a.context !== n || r(this, o);
					else {
						for (var l = 0, h = [], u = a.length; l < u; l++)(a[l].fn !== e || s && !a[l].once || n && a[l].context !== n) && h.push(a[l]);
						h.length ? this._events[o] = 1 === h.length ? h[0] : h : r(this, o)
					}
					return this
				}, a.prototype.removeAllListeners = function(t) {
					var e;
					return t ? (e = i ? i + t : t, this._events[e] && r(this, e)) : (this._events = new n, this._eventsCount = 0), this
				}, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = i, a.EventEmitter = a, t.exports = a
			},
			78904: t => {
				! function() {
					function e(t, e) {
						document.addEventListener ? t.addEventListener("scroll", e, !1) : t.attachEvent("scroll", e)
					}

					function i(t) {
						this.a = document.createElement("div"), this.a.setAttribute("aria-hidden", "true"), this.a.appendChild(document.createTextNode(t)), this.b = document.createElement("span"), this.c = document.createElement("span"), this.h = document.createElement("span"), this.f = document.createElement("span"), this.g = -1, this.b.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.c.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.f.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.h.style.cssText = "display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;", this.b.appendChild(this.h), this.c.appendChild(this.f), this.a.appendChild(this.b), this.a.appendChild(this.c)
					}

					function n(t, e) {
						t.a.style.cssText = "max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:" + e + ";"
					}

					function s(t) {
						var e = t.a.offsetWidth,
							i = e + 100;
						return t.f.style.width = i + "px", t.c.scrollLeft = i, t.b.scrollLeft = t.b.scrollWidth + 100, t.g !== e && (t.g = e, !0)
					}

					function o(t, i) {
						function n() {
							var t = o;
							s(t) && t.a.parentNode && i(t.g)
						}
						var o = t;
						e(t.b, n), e(t.c, n), s(t)
					}

					function r(t, e) {
						var i = e || {};
						this.family = t, this.style = i.style || "normal", this.weight = i.weight || "normal", this.stretch = i.stretch || "normal"
					}
					var a = null,
						l = null,
						h = null,
						u = null;

					function c() {
						return null === u && (u = !!document.fonts), u
					}

					function d() {
						if (null === h) {
							var t = document.createElement("div");
							try {
								t.style.font = "condensed 100px sans-serif"
							} catch (t) {}
							h = "" !== t.style.font
						}
						return h
					}

					function p(t, e) {
						return [t.style, t.weight, d() ? t.stretch : "", "100px", e].join(" ")
					}
					r.prototype.load = function(t, e) {
						var s = this,
							r = t || "BESbswy",
							h = 0,
							u = e || 3e3,
							d = (new Date).getTime();
						return new Promise((function(t, e) {
							if (c() && ! function() {
									if (null === l)
										if (c() && /Apple/.test(window.navigator.vendor)) {
											var t = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent);
											l = !!t && 603 > parseInt(t[1], 10)
										} else l = !1;
									return l
								}()) {
								var _ = new Promise((function(t, e) {
										! function i() {
											(new Date).getTime() - d >= u ? e(Error(u + "ms timeout exceeded")) : document.fonts.load(p(s, '"' + s.family + '"'), r).then((function(e) {
												1 <= e.length ? t() : setTimeout(i, 25)
											}), e)
										}()
									})),
									m = new Promise((function(t, e) {
										h = setTimeout((function() {
											e(Error(u + "ms timeout exceeded"))
										}), u)
									}));
								Promise.race([m, _]).then((function() {
									clearTimeout(h), t(s)
								}), e)
							} else ! function(t) {
								document.body ? t() : document.addEventListener ? document.addEventListener("DOMContentLoaded", (function e() {
									document.removeEventListener("DOMContentLoaded", e), t()
								})) : document.attachEvent("onreadystatechange", (function e() {
									"interactive" != document.readyState && "complete" != document.readyState || (document.detachEvent("onreadystatechange", e), t())
								}))
							}((function() {
								function l() {
									var e;
									(e = -1 != g && -1 != f || -1 != g && -1 != S || -1 != f && -1 != S) && ((e = g != f && g != S && f != S) || (null === a && (e = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent), a = !!e && (536 > parseInt(e[1], 10) || 536 === parseInt(e[1], 10) && 11 >= parseInt(e[2], 10))), e = a && (g == y && f == y && S == y || g == v && f == v && S == v || g == T && f == T && S == T)), e = !e), e && (E.parentNode && E.parentNode.removeChild(E), clearTimeout(h), t(s))
								}
								var c = new i(r),
									_ = new i(r),
									m = new i(r),
									g = -1,
									f = -1,
									S = -1,
									y = -1,
									v = -1,
									T = -1,
									E = document.createElement("div");
								E.dir = "ltr", n(c, p(s, "sans-serif")), n(_, p(s, "serif")), n(m, p(s, "monospace")), E.appendChild(c.a), E.appendChild(_.a), E.appendChild(m.a), document.body.appendChild(E), y = c.a.offsetWidth, v = _.a.offsetWidth, T = m.a.offsetWidth,
									function t() {
										if ((new Date).getTime() - d >= u) E.parentNode && E.parentNode.removeChild(E), e(Error(u + "ms timeout exceeded"));
										else {
											var i = document.hidden;
											!0 !== i && void 0 !== i || (g = c.a.offsetWidth, f = _.a.offsetWidth, S = m.a.offsetWidth, l()), h = setTimeout(t, 50)
										}
									}(), o(c, (function(t) {
										g = t, l()
									})), n(c, p(s, '"' + s.family + '",sans-serif')), o(_, (function(t) {
										f = t, l()
									})), n(_, p(s, '"' + s.family + '",serif')), o(m, (function(t) {
										S = t, l()
									})), n(m, p(s, '"' + s.family + '",monospace'))
							}))
						}))
					}, t.exports = r
				}()
			},
			89353: t => {
				"use strict";
				var e = Object.prototype.toString,
					i = Math.max,
					n = function(t, e) {
						for (var i = [], n = 0; n < t.length; n += 1) i[n] = t[n];
						for (var s = 0; s < e.length; s += 1) i[s + t.length] = e[s];
						return i
					};
				t.exports = function(t) {
					var s = this;
					if ("function" != typeof s || "[object Function]" !== e.apply(s)) throw new TypeError("Function.prototype.bind called on incompatible " + s);
					for (var o, r = function(t, e) {
							for (var i = [], n = 1, s = 0; n < t.length; n += 1, s += 1) i[s] = t[n];
							return i
						}(arguments), a = i(0, s.length - r.length), l = [], h = 0; h < a; h++) l[h] = "$" + h;
					if (o = Function("binder", "return function (" + function(t, e) {
							for (var i = "", n = 0; n < t.length; n += 1) i += t[n], n + 1 < t.length && (i += ",");
							return i
						}(l) + "){ return binder.apply(this,arguments); }")((function() {
							if (this instanceof o) {
								var e = s.apply(this, n(r, arguments));
								return Object(e) === e ? e : this
							}
							return s.apply(t, n(r, arguments))
						})), s.prototype) {
						var u = function() {};
						u.prototype = s.prototype, o.prototype = new u, u.prototype = null
					}
					return o
				}
			},
			66743: (t, e, i) => {
				"use strict";
				var n = i(89353);
				t.exports = Function.prototype.bind || n
			},
			70453: (t, e, i) => {
				"use strict";
				var n, s = i(69383),
					o = i(41237),
					r = i(79290),
					a = i(79538),
					l = i(58068),
					h = i(69675),
					u = i(35345),
					c = Function,
					d = function(t) {
						try {
							return c('"use strict"; return (' + t + ").constructor;")()
						} catch (t) {}
					},
					p = Object.getOwnPropertyDescriptor;
				if (p) try {
					p({}, "")
				} catch (t) {
					p = null
				}
				var _ = function() {
						throw new h
					},
					m = p ? function() {
						try {
							return _
						} catch (t) {
							try {
								return p(arguments, "callee").get
							} catch (t) {
								return _
							}
						}
					}() : _,
					g = i(64039)(),
					f = i(80024)(),
					S = Object.getPrototypeOf || (f ? function(t) {
						return t.__proto__
					} : null),
					y = {},
					v = "undefined" != typeof Uint8Array && S ? S(Uint8Array) : n,
					T = {
						__proto__: null,
						"%AggregateError%": "undefined" == typeof AggregateError ? n : AggregateError,
						"%Array%": Array,
						"%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? n : ArrayBuffer,
						"%ArrayIteratorPrototype%": g && S ? S([][Symbol.iterator]()) : n,
						"%AsyncFromSyncIteratorPrototype%": n,
						"%AsyncFunction%": y,
						"%AsyncGenerator%": y,
						"%AsyncGeneratorFunction%": y,
						"%AsyncIteratorPrototype%": y,
						"%Atomics%": "undefined" == typeof Atomics ? n : Atomics,
						"%BigInt%": "undefined" == typeof BigInt ? n : BigInt,
						"%BigInt64Array%": "undefined" == typeof BigInt64Array ? n : BigInt64Array,
						"%BigUint64Array%": "undefined" == typeof BigUint64Array ? n : BigUint64Array,
						"%Boolean%": Boolean,
						"%DataView%": "undefined" == typeof DataView ? n : DataView,
						"%Date%": Date,
						"%decodeURI%": decodeURI,
						"%decodeURIComponent%": decodeURIComponent,
						"%encodeURI%": encodeURI,
						"%encodeURIComponent%": encodeURIComponent,
						"%Error%": s,
						"%eval%": eval,
						"%EvalError%": o,
						"%Float32Array%": "undefined" == typeof Float32Array ? n : Float32Array,
						"%Float64Array%": "undefined" == typeof Float64Array ? n : Float64Array,
						"%FinalizationRegistry%": "undefined" == typeof FinalizationRegistry ? n : FinalizationRegistry,
						"%Function%": c,
						"%GeneratorFunction%": y,
						"%Int8Array%": "undefined" == typeof Int8Array ? n : Int8Array,
						"%Int16Array%": "undefined" == typeof Int16Array ? n : Int16Array,
						"%Int32Array%": "undefined" == typeof Int32Array ? n : Int32Array,
						"%isFinite%": isFinite,
						"%isNaN%": isNaN,
						"%IteratorPrototype%": g && S ? S(S([][Symbol.iterator]())) : n,
						"%JSON%": "object" == typeof JSON ? JSON : n,
						"%Map%": "undefined" == typeof Map ? n : Map,
						"%MapIteratorPrototype%": "undefined" != typeof Map && g && S ? S((new Map)[Symbol.iterator]()) : n,
						"%Math%": Math,
						"%Number%": Number,
						"%Object%": Object,
						"%parseFloat%": parseFloat,
						"%parseInt%": parseInt,
						"%Promise%": "undefined" == typeof Promise ? n : Promise,
						"%Proxy%": "undefined" == typeof Proxy ? n : Proxy,
						"%RangeError%": r,
						"%ReferenceError%": a,
						"%Reflect%": "undefined" == typeof Reflect ? n : Reflect,
						"%RegExp%": RegExp,
						"%Set%": "undefined" == typeof Set ? n : Set,
						"%SetIteratorPrototype%": "undefined" != typeof Set && g && S ? S((new Set)[Symbol.iterator]()) : n,
						"%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? n : SharedArrayBuffer,
						"%String%": String,
						"%StringIteratorPrototype%": g && S ? S("" [Symbol.iterator]()) : n,
						"%Symbol%": g ? Symbol : n,
						"%SyntaxError%": l,
						"%ThrowTypeError%": m,
						"%TypedArray%": v,
						"%TypeError%": h,
						"%Uint8Array%": "undefined" == typeof Uint8Array ? n : Uint8Array,
						"%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? n : Uint8ClampedArray,
						"%Uint16Array%": "undefined" == typeof Uint16Array ? n : Uint16Array,
						"%Uint32Array%": "undefined" == typeof Uint32Array ? n : Uint32Array,
						"%URIError%": u,
						"%WeakMap%": "undefined" == typeof WeakMap ? n : WeakMap,
						"%WeakRef%": "undefined" == typeof WeakRef ? n : WeakRef,
						"%WeakSet%": "undefined" == typeof WeakSet ? n : WeakSet
					};
				if (S) try {
					null.error
				} catch (t) {
					var E = S(S(t));
					T["%Error.prototype%"] = E
				}
				var b = function t(e) {
						var i;
						if ("%AsyncFunction%" === e) i = d("async function () {}");
						else if ("%GeneratorFunction%" === e) i = d("function* () {}");
						else if ("%AsyncGeneratorFunction%" === e) i = d("async function* () {}");
						else if ("%AsyncGenerator%" === e) {
							var n = t("%AsyncGeneratorFunction%");
							n && (i = n.prototype)
						} else if ("%AsyncIteratorPrototype%" === e) {
							var s = t("%AsyncGenerator%");
							s && S && (i = S(s.prototype))
						}
						return T[e] = i, i
					},
					A = {
						__proto__: null,
						"%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
						"%ArrayPrototype%": ["Array", "prototype"],
						"%ArrayProto_entries%": ["Array", "prototype", "entries"],
						"%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
						"%ArrayProto_keys%": ["Array", "prototype", "keys"],
						"%ArrayProto_values%": ["Array", "prototype", "values"],
						"%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
						"%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
						"%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
						"%BooleanPrototype%": ["Boolean", "prototype"],
						"%DataViewPrototype%": ["DataView", "prototype"],
						"%DatePrototype%": ["Date", "prototype"],
						"%ErrorPrototype%": ["Error", "prototype"],
						"%EvalErrorPrototype%": ["EvalError", "prototype"],
						"%Float32ArrayPrototype%": ["Float32Array", "prototype"],
						"%Float64ArrayPrototype%": ["Float64Array", "prototype"],
						"%FunctionPrototype%": ["Function", "prototype"],
						"%Generator%": ["GeneratorFunction", "prototype"],
						"%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
						"%Int8ArrayPrototype%": ["Int8Array", "prototype"],
						"%Int16ArrayPrototype%": ["Int16Array", "prototype"],
						"%Int32ArrayPrototype%": ["Int32Array", "prototype"],
						"%JSONParse%": ["JSON", "parse"],
						"%JSONStringify%": ["JSON", "stringify"],
						"%MapPrototype%": ["Map", "prototype"],
						"%NumberPrototype%": ["Number", "prototype"],
						"%ObjectPrototype%": ["Object", "prototype"],
						"%ObjProto_toString%": ["Object", "prototype", "toString"],
						"%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
						"%PromisePrototype%": ["Promise", "prototype"],
						"%PromiseProto_then%": ["Promise", "prototype", "then"],
						"%Promise_all%": ["Promise", "all"],
						"%Promise_reject%": ["Promise", "reject"],
						"%Promise_resolve%": ["Promise", "resolve"],
						"%RangeErrorPrototype%": ["RangeError", "prototype"],
						"%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
						"%RegExpPrototype%": ["RegExp", "prototype"],
						"%SetPrototype%": ["Set", "prototype"],
						"%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
						"%StringPrototype%": ["String", "prototype"],
						"%SymbolPrototype%": ["Symbol", "prototype"],
						"%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
						"%TypedArrayPrototype%": ["TypedArray", "prototype"],
						"%TypeErrorPrototype%": ["TypeError", "prototype"],
						"%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
						"%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
						"%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
						"%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
						"%URIErrorPrototype%": ["URIError", "prototype"],
						"%WeakMapPrototype%": ["WeakMap", "prototype"],
						"%WeakSetPrototype%": ["WeakSet", "prototype"]
					},
					P = i(66743),
					I = i(9957),
					w = P.call(Function.call, Array.prototype.concat),
					L = P.call(Function.apply, Array.prototype.splice),
					C = P.call(Function.call, String.prototype.replace),
					x = P.call(Function.call, String.prototype.slice),
					B = P.call(Function.call, RegExp.prototype.exec),
					O = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
					N = /\\(\\)?/g,
					M = function(t, e) {
						var i, n = t;
						if (I(A, n) && (n = "%" + (i = A[n])[0] + "%"), I(T, n)) {
							var s = T[n];
							if (s === y && (s = b(n)), void 0 === s && !e) throw new h("intrinsic " + t + " exists, but is not available. Please file an issue!");
							return {
								alias: i,
								name: n,
								value: s
							}
						}
						throw new l("intrinsic " + t + " does not exist!")
					};
				t.exports = function(t, e) {
					if ("string" != typeof t || 0 === t.length) throw new h("intrinsic name must be a non-empty string");
					if (arguments.length > 1 && "boolean" != typeof e) throw new h('"allowMissing" argument must be a boolean');
					if (null === B(/^%?[^%]*%?$/, t)) throw new l("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
					var i = function(t) {
							var e = x(t, 0, 1),
								i = x(t, -1);
							if ("%" === e && "%" !== i) throw new l("invalid intrinsic syntax, expected closing `%`");
							if ("%" === i && "%" !== e) throw new l("invalid intrinsic syntax, expected opening `%`");
							var n = [];
							return C(t, O, (function(t, e, i, s) {
								n[n.length] = i ? C(s, N, "$1") : e || t
							})), n
						}(t),
						n = i.length > 0 ? i[0] : "",
						s = M("%" + n + "%", e),
						o = s.name,
						r = s.value,
						a = !1,
						u = s.alias;
					u && (n = u[0], L(i, w([0, 1], u)));
					for (var c = 1, d = !0; c < i.length; c += 1) {
						var _ = i[c],
							m = x(_, 0, 1),
							g = x(_, -1);
						if (('"' === m || "'" === m || "`" === m || '"' === g || "'" === g || "`" === g) && m !== g) throw new l("property names with quotes must have matching quotes");
						if ("constructor" !== _ && d || (a = !0), I(T, o = "%" + (n += "." + _) + "%")) r = T[o];
						else if (null != r) {
							if (!(_ in r)) {
								if (!e) throw new h("base intrinsic for " + t + " exists, but the property is not available.");
								return
							}
							if (p && c + 1 >= i.length) {
								var f = p(r, _);
								r = (d = !!f) && "get" in f && !("originalValue" in f.get) ? f.get : r[_]
							} else d = I(r, _), r = r[_];
							d && !a && (T[o] = r)
						}
					}
					return r
				}
			},
			75795: (t, e, i) => {
				"use strict";
				var n = i(70453)("%Object.getOwnPropertyDescriptor%", !0);
				if (n) try {
					n([], "length")
				} catch (t) {
					n = null
				}
				t.exports = n
			},
			23765: (t, e, i) => {
				"use strict";
				i.d(e, {
					Ay: () => s,
					F: () => d,
					FL: () => _,
					MI: () => m,
					MO: () => c,
					UL: () => a,
					WG: () => u,
					X5: () => l,
					tN: () => g,
					uW: () => n,
					ys: () => p,
					zM: () => h,
					zQ: () => o
				}), t = i.hmd(t);
				var n = "undefined" != typeof window ? window : t.exports && void 0 !== i.g ? i.g : {},
					s = function(t, e) {
						var i = {},
							n = t.document,
							s = t.GreenSockGlobals = t.GreenSockGlobals || t;
						if (s.TweenLite) return s.TweenLite;
						var o, r, a, l, h, u, c, d = function(t) {
								var e, i = t.split("."),
									n = s;
								for (e = 0; e < i.length; e++) n[i[e]] = n = n[i[e]] || {};
								return n
							},
							p = d("com.greensock"),
							_ = 1e-10,
							m = function(t) {
								var e, i = [],
									n = t.length;
								for (e = 0; e !== n; i.push(t[e++]));
								return i
							},
							g = function() {},
							f = (u = Object.prototype.toString, c = u.call([]), function(t) {
								return null != t && (t instanceof Array || "object" == typeof t && !!t.push && u.call(t) === c)
							}),
							S = {},
							y = function(t, e, n, o) {
								this.sc = S[t] ? S[t].sc : [], S[t] = this, this.gsClass = null, this.func = n;
								var r = [];
								this.check = function(a) {
									for (var l, h, u, c, p = e.length, _ = p; --p > -1;)(l = S[e[p]] || new y(e[p], [])).gsClass ? (r[p] = l.gsClass, _--) : a && l.sc.push(this);
									if (0 === _ && n)
										for (u = (h = ("com.greensock." + t).split(".")).pop(), c = d(h.join("."))[u] = this.gsClass = n.apply(n, r), o && (s[u] = i[u] = c), p = 0; p < this.sc.length; p++) this.sc[p].check()
								}, this.check(!0)
							},
							v = t._gsDefine = function(t, e, i, n) {
								return new y(t, e, i, n)
							},
							T = p._class = function(t, e, i) {
								return e = e || function() {}, v(t, [], (function() {
									return e
								}), i), e
							};
						v.globals = s;
						var E = [0, 0, 1, 1],
							b = T("easing.Ease", (function(t, e, i, n) {
								this._func = t, this._type = i || 0, this._power = n || 0, this._params = e ? E.concat(e) : E
							}), !0),
							A = b.map = {},
							P = b.register = function(t, e, i, n) {
								for (var s, o, r, a, l = e.split(","), h = l.length, u = (i || "easeIn,easeOut,easeInOut").split(","); --h > -1;)
									for (o = l[h], s = n ? T("easing." + o, null, !0) : p.easing[o] || {}, r = u.length; --r > -1;) a = u[r], A[o + "." + a] = A[a + o] = s[a] = t.getRatio ? t : t[a] || new t
							};
						for ((a = b.prototype)._calcEnd = !1, a.getRatio = function(t) {
								if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
								var e = this._type,
									i = this._power,
									n = 1 === e ? 1 - t : 2 === e ? t : t < .5 ? 2 * t : 2 * (1 - t);
								return 1 === i ? n *= n : 2 === i ? n *= n * n : 3 === i ? n *= n * n * n : 4 === i && (n *= n * n * n * n), 1 === e ? 1 - n : 2 === e ? n : t < .5 ? n / 2 : 1 - n / 2
							}, r = (o = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"]).length; --r > -1;) a = o[r] + ",Power" + r, P(new b(null, null, 1, r), a, "easeOut", !0), P(new b(null, null, 2, r), a, "easeIn" + (0 === r ? ",easeNone" : "")), P(new b(null, null, 3, r), a, "easeInOut");
						A.linear = p.easing.Linear.easeIn, A.swing = p.easing.Quad.easeInOut;
						var I = T("events.EventDispatcher", (function(t) {
							this._listeners = {}, this._eventTarget = t || this
						}));
						(a = I.prototype).addEventListener = function(t, e, i, n, s) {
							s = s || 0;
							var o, r, a = this._listeners[t],
								u = 0;
							for (this !== l || h || l.wake(), null == a && (this._listeners[t] = a = []), r = a.length; --r > -1;)(o = a[r]).c === e && o.s === i ? a.splice(r, 1) : 0 === u && o.pr < s && (u = r + 1);
							a.splice(u, 0, {
								c: e,
								s: i,
								up: n,
								pr: s
							})
						}, a.removeEventListener = function(t, e) {
							var i, n = this._listeners[t];
							if (n)
								for (i = n.length; --i > -1;)
									if (n[i].c === e) return void n.splice(i, 1)
						}, a.dispatchEvent = function(t) {
							var e, i, n, s = this._listeners[t];
							if (s)
								for ((e = s.length) > 1 && (s = s.slice(0)), i = this._eventTarget; --e > -1;)(n = s[e]) && (n.up ? n.c.call(n.s || i, {
									type: t,
									target: i
								}) : n.c.call(n.s || i))
						};
						var w = t.requestAnimationFrame,
							L = t.cancelAnimationFrame,
							C = Date.now || function() {
								return (new Date).getTime()
							},
							x = C();
						for (r = (o = ["ms", "moz", "webkit", "o"]).length; --r > -1 && !w;) w = t[o[r] + "RequestAnimationFrame"], L = t[o[r] + "CancelAnimationFrame"] || t[o[r] + "CancelRequestAnimationFrame"];
						T("Ticker", (function(t, e) {
							var i, s, o, r, a, u = this,
								c = C(),
								d = !(!1 === e || !w) && "auto",
								p = 500,
								m = 33,
								f = function(t) {
									var e, n, l = C() - x;
									l > p && (c += l - m), x += l, u.time = (x - c) / 1e3, e = u.time - a, (!i || e > 0 || !0 === t) && (u.frame++, a += e + (e >= r ? .004 : r - e), n = !0), !0 !== t && (o = s(f)), n && u.dispatchEvent("tick")
								};
							I.call(u), u.time = u.frame = 0, u.tick = function() {
								f(!0)
							}, u.lagSmoothing = function(t, e) {
								if (!arguments.length) return p < 1 / _;
								p = t || 1 / _, m = Math.min(e, p, 0)
							}, u.sleep = function() {
								null != o && (d && L ? L(o) : clearTimeout(o), s = g, o = null, u === l && (h = !1))
							}, u.wake = function(t) {
								null !== o ? u.sleep() : t ? c += -x + (x = C()) : u.frame > 10 && (x = C() - p + 5), s = 0 === i ? g : d && w ? w : function(t) {
									return setTimeout(t, 1e3 * (a - u.time) + 1 | 0)
								}, u === l && (h = !0), f(2)
							}, u.fps = function(t) {
								if (!arguments.length) return i;
								r = 1 / ((i = t) || 60), a = this.time + r, u.wake()
							}, u.useRAF = function(t) {
								if (!arguments.length) return d;
								u.sleep(), d = t, u.fps(i)
							}, u.fps(t), setTimeout((function() {
								"auto" === d && u.frame < 5 && "hidden" !== (n || {}).visibilityState && u.useRAF(!1)
							}), 1500)
						})), (a = p.Ticker.prototype = new p.events.EventDispatcher).constructor = p.Ticker;
						var B = T("core.Animation", (function(t, e) {
							if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = !0 === e.immediateRender, this.data = e.data, this._reversed = !0 === e.reversed, Z) {
								h || l.wake();
								var i = this.vars.useFrames ? q : Z;
								i.add(this, i._time), this.vars.paused && this.paused(!0)
							}
						}));
						l = B.ticker = new p.Ticker, (a = B.prototype)._dirty = a._gc = a._initted = a._paused = !1, a._totalTime = a._time = 0, a._rawPrevTime = -1, a._next = a._last = a._onUpdate = a._timeline = a.timeline = null, a._paused = !1;
						var O = function() {
							h && C() - x > 2e3 && ("hidden" !== (n || {}).visibilityState || !l.lagSmoothing()) && l.wake();
							var t = setTimeout(O, 2e3);
							t.unref && t.unref()
						};
						O(), a.play = function(t, e) {
							return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
						}, a.pause = function(t, e) {
							return null != t && this.seek(t, e), this.paused(!0)
						}, a.resume = function(t, e) {
							return null != t && this.seek(t, e), this.paused(!1)
						}, a.seek = function(t, e) {
							return this.totalTime(Number(t), !1 !== e)
						}, a.restart = function(t, e) {
							return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, !1 !== e, !0)
						}, a.reverse = function(t, e) {
							return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
						}, a.render = function(t, e, i) {}, a.invalidate = function() {
							return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this
						}, a.isActive = function() {
							var t, e = this._timeline,
								i = this._startTime;
							return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime(!0)) >= i && t < i + this.totalDuration() / this._timeScale - 1e-7
						}, a._enabled = function(t, e) {
							return h || l.wake(), this._gc = !t, this._active = this.isActive(), !0 !== e && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1
						}, a._kill = function(t, e) {
							return this._enabled(!1, !1)
						}, a.kill = function(t, e) {
							return this._kill(t, e), this
						}, a._uncache = function(t) {
							for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;
							return this
						}, a._swapSelfInParams = function(t) {
							for (var e = t.length, i = t.concat(); --e > -1;) "{self}" === t[e] && (i[e] = this);
							return i
						}, a._callback = function(t) {
							var e = this.vars,
								i = e[t],
								n = e[t + "Params"],
								s = e[t + "Scope"] || e.callbackScope || this;
							switch (n ? n.length : 0) {
								case 0:
									i.call(s);
									break;
								case 1:
									i.call(s, n[0]);
									break;
								case 2:
									i.call(s, n[0], n[1]);
									break;
								default:
									i.apply(s, n)
							}
						}, a.eventCallback = function(t, e, i, n) {
							if ("on" === (t || "").substr(0, 2)) {
								var s = this.vars;
								if (1 === arguments.length) return s[t];
								null == e ? delete s[t] : (s[t] = e, s[t + "Params"] = f(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, s[t + "Scope"] = n), "onUpdate" === t && (this._onUpdate = e)
							}
							return this
						}, a.delay = function(t) {
							return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay
						}, a.duration = function(t) {
							return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration)
						}, a.totalDuration = function(t) {
							return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration
						}, a.time = function(t, e) {
							return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
						}, a.totalTime = function(t, e, i) {
							if (h || l.wake(), !arguments.length) return this._totalTime;
							if (this._timeline) {
								if (t < 0 && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
									this._dirty && this.totalDuration();
									var n = this._totalDuration,
										s = this._timeline;
									if (t > n && !i && (t = n), this._startTime = (this._paused ? this._pauseTime : s._time) - (this._reversed ? n - t : t) / this._timeScale, s._dirty || this._uncache(!1), s._timeline)
										for (; s._timeline;) s._timeline._time !== (s._startTime + s._totalTime) / s._timeScale && s.totalTime(s._totalTime, !0), s = s._timeline
								}
								this._gc && this._enabled(!0, !1), this._totalTime === t && 0 !== this._duration || (D.length && Q(), this.render(t, e, !1), D.length && Q())
							}
							return this
						}, a.progress = a.totalProgress = function(t, e) {
							var i = this.duration();
							return arguments.length ? this.totalTime(i * t, e) : i ? this._time / i : this.ratio
						}, a.startTime = function(t) {
							return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime
						}, a.endTime = function(t) {
							return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale
						}, a.timeScale = function(t) {
							if (!arguments.length) return this._timeScale;
							var e, i;
							for (t = t || _, this._timeline && this._timeline.smoothChildTiming && (i = (e = this._pauseTime) || 0 === e ? e : this._timeline.totalTime(), this._startTime = i - (i - this._startTime) * this._timeScale / t), this._timeScale = t, i = this.timeline; i && i.timeline;) i._dirty = !0, i.totalDuration(), i = i.timeline;
							return this
						}, a.reversed = function(t) {
							return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
						}, a.paused = function(t) {
							if (!arguments.length) return this._paused;
							var e, i, n = this._timeline;
							return t != this._paused && n && (h || t || l.wake(), i = (e = n.rawTime()) - this._pauseTime, !t && n.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && 0 !== i && this._initted && this.duration() && (e = n.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, this.render(e, e === this._totalTime, !0))), this._gc && !t && this._enabled(!0, !1), this
						};
						var N = T("core.SimpleTimeline", (function(t) {
							B.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0
						}));
						(a = N.prototype = new B).constructor = N, a.kill()._gc = !1, a._first = a._last = a._recent = null, a._sortChildren = !1, a.add = a.insert = function(t, e, i, n) {
							var s, o;
							if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = this.rawTime() - (t._timeline.rawTime() - t._pauseTime)), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), s = this._last, this._sortChildren)
								for (o = t._startTime; s && s._startTime > o;) s = s._prev;
							return s ? (t._next = s._next, s._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = s, this._recent = t, this._timeline && this._uncache(!0), this
						}, a._remove = function(t, e) {
							return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
						}, a.render = function(t, e, i) {
							var n, s = this._first;
							for (this._totalTime = this._time = this._rawPrevTime = t; s;) n = s._next, (s._active || t >= s._startTime && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = n
						}, a.rawTime = function() {
							return h || l.wake(), this._totalTime
						};
						var M = T("TweenLite", (function(e, i, n) {
								if (B.call(this, i, n), this.render = M.prototype.render, null == e) throw "Cannot tween a null target.";
								this.target = e = "string" != typeof e ? e : M.selector(e) || e;
								var s, o, r, a = e.jquery || e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType),
									l = this.vars.overwrite;
								if (this._overwrite = l = null == l ? K[M.defaultOverwrite] : "number" == typeof l ? 0 | l : K[l], (a || e instanceof Array || e.push && f(e)) && "number" != typeof e[0])
									for (this._targets = r = m(e), this._propLookup = [], this._siblings = [], s = 0; s < r.length; s++)(o = r[s]) ? "string" != typeof o ? o.length && o !== t && o[0] && (o[0] === t || o[0].nodeType && o[0].style && !o.nodeType) ? (r.splice(s--, 1), this._targets = r = r.concat(m(o))) : (this._siblings[s] = J(o, this, !1), 1 === l && this._siblings[s].length > 1 && et(o, this, null, 1, this._siblings[s])) : "string" == typeof(o = r[s--] = M.selector(o)) && r.splice(s + 1, 1) : r.splice(s--, 1);
								else this._propLookup = {}, this._siblings = J(e, this, !1), 1 === l && this._siblings.length > 1 && et(e, this, null, 1, this._siblings);
								(this.vars.immediateRender || 0 === i && 0 === this._delay && !1 !== this.vars.immediateRender) && (this._time = -1e-10, this.render(Math.min(0, -this._delay)))
							}), !0),
							R = function(e) {
								return e && e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType)
							};
						(a = M.prototype = new B).constructor = M, a.kill()._gc = !1, a.ratio = 0, a._firstPT = a._targets = a._overwrittenProps = a._startAt = null, a._notifyPluginsOfEnabled = a._lazy = !1, M.version = "2.0.2", M.defaultEase = a._ease = new b(null, null, 1, 1), M.defaultOverwrite = "auto", M.ticker = l, M.autoSleep = 120, M.lagSmoothing = function(t, e) {
							l.lagSmoothing(t, e)
						}, M.selector = t.$ || t.jQuery || function(e) {
							var i = t.$ || t.jQuery;
							return i ? (M.selector = i, i(e)) : (n || (n = t.document), n ? n.querySelectorAll ? n.querySelectorAll(e) : n.getElementById("#" === e.charAt(0) ? e.substr(1) : e) : e)
						};
						var D = [],
							k = {},
							F = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
							G = /[\+-]=-?[\.\d]/,
							U = function(t) {
								for (var e, i = this._firstPT, n = 1e-6; i;) e = i.blob ? 1 === t && null != this.end ? this.end : t ? this.join("") : this.start : i.c * t + i.s, i.m ? e = i.m.call(this._tween, e, this._target || i.t, this._tween) : e < n && e > -n && !i.blob && (e = 0), i.f ? i.fp ? i.t[i.p](i.fp, e) : i.t[i.p](e) : i.t[i.p] = e, i = i._next
							},
							W = function(t, e, i, n) {
								var s, o, r, a, l, h, u, c = [],
									d = 0,
									p = "",
									_ = 0;
								for (c.start = t, c.end = e, t = c[0] = t + "", e = c[1] = e + "", i && (i(c), t = c[0], e = c[1]), c.length = 0, s = t.match(F) || [], o = e.match(F) || [], n && (n._next = null, n.blob = 1, c._firstPT = c._applyPT = n), l = o.length, a = 0; a < l; a++) u = o[a], p += (h = e.substr(d, e.indexOf(u, d) - d)) || !a ? h : ",", d += h.length, _ ? _ = (_ + 1) % 5 : "rgba(" === h.substr(-5) && (_ = 1), u === s[a] || s.length <= a ? p += u : (p && (c.push(p), p = ""), r = parseFloat(s[a]), c.push(r), c._firstPT = {
									_next: c._firstPT,
									t: c,
									p: c.length - 1,
									s: r,
									c: ("=" === u.charAt(1) ? parseInt(u.charAt(0) + "1", 10) * parseFloat(u.substr(2)) : parseFloat(u) - r) || 0,
									f: 0,
									m: _ && _ < 4 ? Math.round : 0
								}), d += u.length;
								return (p += e.substr(d)) && c.push(p), c.setRatio = U, G.test(e) && (c.end = null), c
							},
							H = function(t, e, i, n, s, o, r, a, l) {
								"function" == typeof n && (n = n(l || 0, t));
								var h = typeof t[e],
									u = "function" !== h ? "" : e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3),
									c = "get" !== i ? i : u ? r ? t[u](r) : t[u]() : t[e],
									d = "string" == typeof n && "=" === n.charAt(1),
									p = {
										t,
										p: e,
										s: c,
										f: "function" === h,
										pg: 0,
										n: s || e,
										m: o ? "function" == typeof o ? o : Math.round : 0,
										pr: 0,
										c: d ? parseInt(n.charAt(0) + "1", 10) * parseFloat(n.substr(2)) : parseFloat(n) - c || 0
									};
								if (("number" != typeof c || "number" != typeof n && !d) && (r || isNaN(c) || !d && isNaN(n) || "boolean" == typeof c || "boolean" == typeof n ? (p.fp = r, p = {
										t: W(c, d ? parseFloat(p.s) + p.c + (p.s + "").replace(/[0-9\-\.]/g, "") : n, a || M.defaultStringFilter, p),
										p: "setRatio",
										s: 0,
										c: 1,
										f: 2,
										pg: 0,
										n: s || e,
										pr: 0,
										m: 0
									}) : (p.s = parseFloat(c), d || (p.c = parseFloat(n) - p.s || 0))), p.c) return (p._next = this._firstPT) && (p._next._prev = p), this._firstPT = p, p
							},
							V = M._internals = {
								isArray: f,
								isSelector: R,
								lazyTweens: D,
								blobDif: W
							},
							X = M._plugins = {},
							Y = V.tweenLookup = {},
							z = 0,
							j = V.reservedProps = {
								ease: 1,
								delay: 1,
								overwrite: 1,
								onComplete: 1,
								onCompleteParams: 1,
								onCompleteScope: 1,
								useFrames: 1,
								runBackwards: 1,
								startAt: 1,
								onUpdate: 1,
								onUpdateParams: 1,
								onUpdateScope: 1,
								onStart: 1,
								onStartParams: 1,
								onStartScope: 1,
								onReverseComplete: 1,
								onReverseCompleteParams: 1,
								onReverseCompleteScope: 1,
								onRepeat: 1,
								onRepeatParams: 1,
								onRepeatScope: 1,
								easeParams: 1,
								yoyo: 1,
								immediateRender: 1,
								repeat: 1,
								repeatDelay: 1,
								data: 1,
								paused: 1,
								reversed: 1,
								autoCSS: 1,
								lazy: 1,
								onOverwrite: 1,
								callbackScope: 1,
								stringFilter: 1,
								id: 1,
								yoyoEase: 1
							},
							K = {
								none: 0,
								all: 1,
								auto: 2,
								concurrent: 3,
								allOnStart: 4,
								preexisting: 5,
								true: 1,
								false: 0
							},
							q = B._rootFramesTimeline = new N,
							Z = B._rootTimeline = new N,
							$ = 30,
							Q = V.lazyRender = function() {
								var t, e = D.length;
								for (k = {}; --e > -1;)(t = D[e]) && !1 !== t._lazy && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1);
								D.length = 0
							};
						Z._startTime = l.time, q._startTime = l.frame, Z._active = q._active = !0, setTimeout(Q, 1), B._updateRoot = M.render = function() {
							var t, e, i;
							if (D.length && Q(), Z.render((l.time - Z._startTime) * Z._timeScale, !1, !1), q.render((l.frame - q._startTime) * q._timeScale, !1, !1), D.length && Q(), l.frame >= $) {
								for (i in $ = l.frame + (parseInt(M.autoSleep, 10) || 120), Y) {
									for (t = (e = Y[i].tweens).length; --t > -1;) e[t]._gc && e.splice(t, 1);
									0 === e.length && delete Y[i]
								}
								if ((!(i = Z._first) || i._paused) && M.autoSleep && !q._first && 1 === l._listeners.tick.length) {
									for (; i && i._paused;) i = i._next;
									i || l.sleep()
								}
							}
						}, l.addEventListener("tick", B._updateRoot);
						var J = function(t, e, i) {
								var n, s, o = t._gsTweenID;
								if (Y[o || (t._gsTweenID = o = "t" + z++)] || (Y[o] = {
										target: t,
										tweens: []
									}), e && ((n = Y[o].tweens)[s = n.length] = e, i))
									for (; --s > -1;) n[s] === e && n.splice(s, 1);
								return Y[o].tweens
							},
							tt = function(t, e, i, n) {
								var s, o, r = t.vars.onOverwrite;
								return r && (s = r(t, e, i, n)), (r = M.onOverwrite) && (o = r(t, e, i, n)), !1 !== s && !1 !== o
							},
							et = function(t, e, i, n, s) {
								var o, r, a, l;
								if (1 === n || n >= 4) {
									for (l = s.length, o = 0; o < l; o++)
										if ((a = s[o]) !== e) a._gc || a._kill(null, t, e) && (r = !0);
										else if (5 === n) break;
									return r
								}
								var h, u = e._startTime + _,
									c = [],
									d = 0,
									p = 0 === e._duration;
								for (o = s.length; --o > -1;)(a = s[o]) === e || a._gc || a._paused || (a._timeline !== e._timeline ? (h = h || it(e, 0, p), 0 === it(a, h, p) && (c[d++] = a)) : a._startTime <= u && a._startTime + a.totalDuration() / a._timeScale > u && ((p || !a._initted) && u - a._startTime <= 2e-10 || (c[d++] = a)));
								for (o = d; --o > -1;)
									if (l = (a = c[o])._firstPT, 2 === n && a._kill(i, t, e) && (r = !0), 2 !== n || !a._firstPT && a._initted && l) {
										if (2 !== n && !tt(a, e)) continue;
										a._enabled(!1, !1) && (r = !0)
									} return r
							},
							it = function(t, e, i) {
								for (var n = t._timeline, s = n._timeScale, o = t._startTime; n._timeline;) {
									if (o += n._startTime, s *= n._timeScale, n._paused) return -100;
									n = n._timeline
								}
								return (o /= s) > e ? o - e : i && o === e || !t._initted && o - e < 2e-10 ? _ : (o += t.totalDuration() / t._timeScale / s) > e + _ ? 0 : o - e - _
							};
						a._init = function() {
							var t, e, i, n, s, o, r = this.vars,
								a = this._overwrittenProps,
								l = this._duration,
								h = !!r.immediateRender,
								u = r.ease;
							if (r.startAt) {
								for (n in this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), s = {}, r.startAt) s[n] = r.startAt[n];
								if (s.data = "isStart", s.overwrite = !1, s.immediateRender = !0, s.lazy = h && !1 !== r.lazy, s.startAt = s.delay = null, s.onUpdate = r.onUpdate, s.onUpdateParams = r.onUpdateParams, s.onUpdateScope = r.onUpdateScope || r.callbackScope || this, this._startAt = M.to(this.target || {}, 0, s), h)
									if (this._time > 0) this._startAt = null;
									else if (0 !== l) return
							} else if (r.runBackwards && 0 !== l)
								if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
								else {
									for (n in 0 !== this._time && (h = !1), i = {}, r) j[n] && "autoCSS" !== n || (i[n] = r[n]);
									if (i.overwrite = 0, i.data = "isFromStart", i.lazy = h && !1 !== r.lazy, i.immediateRender = h, this._startAt = M.to(this.target, 0, i), h) {
										if (0 === this._time) return
									} else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
								} if (this._ease = u = u ? u instanceof b ? u : "function" == typeof u ? new b(u, r.easeParams) : A[u] || M.defaultEase : M.defaultEase, r.easeParams instanceof Array && u.config && (this._ease = u.config.apply(u, r.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
								for (o = this._targets.length, t = 0; t < o; t++) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], a ? a[t] : null, t) && (e = !0);
							else e = this._initProps(this.target, this._propLookup, this._siblings, a, 0);
							if (e && M._onPluginEvent("_onInitAllProps", this), a && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), r.runBackwards)
								for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
							this._onUpdate = r.onUpdate, this._initted = !0
						}, a._initProps = function(e, i, n, s, o) {
							var r, a, l, h, u, c;
							if (null == e) return !1;
							for (r in k[e._gsTweenID] && Q(), this.vars.css || e.style && e !== t && e.nodeType && X.css && !1 !== this.vars.autoCSS && function(t, e) {
									var i, n = {};
									for (i in t) j[i] || i in e && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!X[i] || X[i] && X[i]._autoCSS) || (n[i] = t[i], delete t[i]);
									t.css = n
								}(this.vars, e), this.vars)
								if (c = this.vars[r], j[r]) c && (c instanceof Array || c.push && f(c)) && -1 !== c.join("").indexOf("{self}") && (this.vars[r] = c = this._swapSelfInParams(c, this));
								else if (X[r] && (h = new X[r])._onInitTween(e, this.vars[r], this, o)) {
								for (this._firstPT = u = {
										_next: this._firstPT,
										t: h,
										p: "setRatio",
										s: 0,
										c: 1,
										f: 1,
										n: r,
										pg: 1,
										pr: h._priority,
										m: 0
									}, a = h._overwriteProps.length; --a > -1;) i[h._overwriteProps[a]] = this._firstPT;
								(h._priority || h._onInitAllProps) && (l = !0), (h._onDisable || h._onEnable) && (this._notifyPluginsOfEnabled = !0), u._next && (u._next._prev = u)
							} else i[r] = H.call(this, e, r, "get", c, r, 0, null, this.vars.stringFilter, o);
							return s && this._kill(s, e) ? this._initProps(e, i, n, s, o) : this._overwrite > 1 && this._firstPT && n.length > 1 && et(e, this, i, this._overwrite, n) ? (this._kill(i, e), this._initProps(e, i, n, s, o)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (k[e._gsTweenID] = !0), l)
						}, a.render = function(t, e, i) {
							var n, s, o, r, a = this._time,
								l = this._duration,
								h = this._rawPrevTime;
							if (t >= l - 1e-7 && t >= 0) this._totalTime = this._time = l, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (n = !0, s = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === l && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (h < 0 || t <= 0 && t >= -1e-7 || h === _ && "isPause" !== this.data) && h !== t && (i = !0, h > _ && (s = "onReverseComplete")), this._rawPrevTime = r = !e || t || h === t ? t : _);
							else if (t < 1e-7) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== a || 0 === l && h > 0) && (s = "onReverseComplete", n = this._reversed), t < 0 && (this._active = !1, 0 === l && (this._initted || !this.vars.lazy || i) && (h >= 0 && (h !== _ || "isPause" !== this.data) && (i = !0), this._rawPrevTime = r = !e || t || h === t ? t : _)), (!this._initted || this._startAt && this._startAt.progress()) && (i = !0);
							else if (this._totalTime = this._time = t, this._easeType) {
								var u = t / l,
									c = this._easeType,
									d = this._easePower;
								(1 === c || 3 === c && u >= .5) && (u = 1 - u), 3 === c && (u *= 2), 1 === d ? u *= u : 2 === d ? u *= u * u : 3 === d ? u *= u * u * u : 4 === d && (u *= u * u * u * u), this.ratio = 1 === c ? 1 - u : 2 === c ? u : t / l < .5 ? u / 2 : 1 - u / 2
							} else this.ratio = this._ease.getRatio(t / l);
							if (this._time !== a || i) {
								if (!this._initted) {
									if (this._init(), !this._initted || this._gc) return;
									if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = a, this._rawPrevTime = h, D.push(this), void(this._lazy = [t, e]);
									this._time && !n ? this.ratio = this._ease.getRatio(this._time / l) : n && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
								}
								for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== a && t >= 0 && (this._active = !0), 0 === a && (this._startAt && (t >= 0 ? this._startAt.render(t, !0, i) : s || (s = "_dummyGS")), this.vars.onStart && (0 === this._time && 0 !== l || e || this._callback("onStart"))), o = this._firstPT; o;) o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next;
								this._onUpdate && (t < 0 && this._startAt && -1e-4 !== t && this._startAt.render(t, !0, i), e || (this._time !== a || n || i) && this._callback("onUpdate")), s && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && -1e-4 !== t && this._startAt.render(t, !0, i), n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[s] && this._callback(s), 0 === l && this._rawPrevTime === _ && r !== _ && (this._rawPrevTime = 0)))
							}
						}, a._kill = function(t, e, i) {
							if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1);
							e = "string" != typeof e ? e || this._targets || this.target : M.selector(e) || e;
							var n, s, o, r, a, l, h, u, c, d = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline,
								p = this._firstPT;
							if ((f(e) || R(e)) && "number" != typeof e[0])
								for (n = e.length; --n > -1;) this._kill(t, e[n], i) && (l = !0);
							else {
								if (this._targets) {
									for (n = this._targets.length; --n > -1;)
										if (e === this._targets[n]) {
											a = this._propLookup[n] || {}, this._overwrittenProps = this._overwrittenProps || [], s = this._overwrittenProps[n] = t ? this._overwrittenProps[n] || {} : "all";
											break
										}
								} else {
									if (e !== this.target) return !1;
									a = this._propLookup, s = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
								}
								if (a) {
									if (h = t || a, u = t !== s && "all" !== s && t !== a && ("object" != typeof t || !t._tempKill), i && (M.onOverwrite || this.vars.onOverwrite)) {
										for (o in h) a[o] && (c || (c = []), c.push(o));
										if ((c || !t) && !tt(this, i, e, c)) return !1
									}
									for (o in h)(r = a[o]) && (d && (r.f ? r.t[r.p](r.s) : r.t[r.p] = r.s, l = !0), r.pg && r.t._kill(h) && (l = !0), r.pg && 0 !== r.t._overwriteProps.length || (r._prev ? r._prev._next = r._next : r === this._firstPT && (this._firstPT = r._next), r._next && (r._next._prev = r._prev), r._next = r._prev = null), delete a[o]), u && (s[o] = 1);
									!this._firstPT && this._initted && p && this._enabled(!1, !1)
								}
							}
							return l
						}, a.invalidate = function() {
							return this._notifyPluginsOfEnabled && M._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], B.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -1e-10, this.render(Math.min(0, -this._delay))), this
						}, a._enabled = function(t, e) {
							if (h || l.wake(), t && this._gc) {
								var i, n = this._targets;
								if (n)
									for (i = n.length; --i > -1;) this._siblings[i] = J(n[i], this, !0);
								else this._siblings = J(this.target, this, !0)
							}
							return B.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && M._onPluginEvent(t ? "_onEnable" : "_onDisable", this)
						}, M.to = function(t, e, i) {
							return new M(t, e, i)
						}, M.from = function(t, e, i) {
							return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new M(t, e, i)
						}, M.fromTo = function(t, e, i, n) {
							return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new M(t, e, n)
						}, M.delayedCall = function(t, e, i, n, s) {
							return new M(e, 0, {
								delay: t,
								onComplete: e,
								onCompleteParams: i,
								callbackScope: n,
								onReverseComplete: e,
								onReverseCompleteParams: i,
								immediateRender: !1,
								lazy: !1,
								useFrames: s,
								overwrite: 0
							})
						}, M.set = function(t, e) {
							return new M(t, 0, e)
						}, M.getTweensOf = function(t, e) {
							if (null == t) return [];
							var i, n, s, o;
							if (t = "string" != typeof t ? t : M.selector(t) || t, (f(t) || R(t)) && "number" != typeof t[0]) {
								for (i = t.length, n = []; --i > -1;) n = n.concat(M.getTweensOf(t[i], e));
								for (i = n.length; --i > -1;)
									for (o = n[i], s = i; --s > -1;) o === n[s] && n.splice(i, 1)
							} else if (t._gsTweenID)
								for (i = (n = J(t).concat()).length; --i > -1;)(n[i]._gc || e && !n[i].isActive()) && n.splice(i, 1);
							return n || []
						}, M.killTweensOf = M.killDelayedCallsTo = function(t, e, i) {
							"object" == typeof e && (i = e, e = !1);
							for (var n = M.getTweensOf(t, e), s = n.length; --s > -1;) n[s]._kill(i, t)
						};
						var nt = T("plugins.TweenPlugin", (function(t, e) {
							this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = nt.prototype
						}), !0);
						if (a = nt.prototype, nt.version = "1.19.0", nt.API = 2, a._firstPT = null, a._addTween = H, a.setRatio = U, a._kill = function(t) {
								var e, i = this._overwriteProps,
									n = this._firstPT;
								if (null != t[this._propName]) this._overwriteProps = [];
								else
									for (e = i.length; --e > -1;) null != t[i[e]] && i.splice(e, 1);
								for (; n;) null != t[n.n] && (n._next && (n._next._prev = n._prev), n._prev ? (n._prev._next = n._next, n._prev = null) : this._firstPT === n && (this._firstPT = n._next)), n = n._next;
								return !1
							}, a._mod = a._roundProps = function(t) {
								for (var e, i = this._firstPT; i;)(e = t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")]) && "function" == typeof e && (2 === i.f ? i.t._applyPT.m = e : i.m = e), i = i._next
							}, M._onPluginEvent = function(t, e) {
								var i, n, s, o, r, a = e._firstPT;
								if ("_onInitAllProps" === t) {
									for (; a;) {
										for (r = a._next, n = s; n && n.pr > a.pr;) n = n._next;
										(a._prev = n ? n._prev : o) ? a._prev._next = a: s = a, (a._next = n) ? n._prev = a : o = a, a = r
									}
									a = e._firstPT = s
								}
								for (; a;) a.pg && "function" == typeof a.t[t] && a.t[t]() && (i = !0), a = a._next;
								return i
							}, nt.activate = function(t) {
								for (var e = t.length; --e > -1;) t[e].API === nt.API && (X[(new t[e])._propName] = t[e]);
								return !0
							}, v.plugin = function(t) {
								if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition.";
								var e, i = t.propName,
									n = t.priority || 0,
									s = t.overwriteProps,
									o = {
										init: "_onInitTween",
										set: "setRatio",
										kill: "_kill",
										round: "_mod",
										mod: "_mod",
										initAll: "_onInitAllProps"
									},
									r = T("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", (function() {
										nt.call(this, i, n), this._overwriteProps = s || []
									}), !0 === t.global),
									a = r.prototype = new nt(i);
								for (e in a.constructor = r, r.API = t.API, o) "function" == typeof t[e] && (a[o[e]] = t[e]);
								return r.version = t.version, nt.activate([r]), r
							}, o = t._gsQueue) {
							for (r = 0; r < o.length; r++) o[r]();
							for (a in S) S[a].func || t.console.log("GSAP encountered missing dependency: " + a)
						}
						return h = !1, M
					}(n),
					o = n.GreenSockGlobals,
					r = o.com.greensock,
					a = r.core.SimpleTimeline,
					l = r.core.Animation,
					h = o.Ease,
					u = o.Linear,
					c = u,
					d = o.Power1,
					p = o.Power2,
					_ = o.Power3,
					m = o.Power4,
					g = o.TweenPlugin;
				r.events.EventDispatcher
			},
			13006: (t, e, i) => {
				"use strict";
				i.r(e), i.d(e, {
					AttrPlugin: () => l,
					Back: () => L,
					BezierPlugin: () => I,
					Bounce: () => x,
					CSSPlugin: () => a,
					Circ: () => M,
					DirectionalRotationPlugin: () => p,
					Ease: () => n.zM,
					Elastic: () => C,
					Expo: () => R,
					ExpoScaleEase: () => k,
					Linear: () => n.WG,
					Power0: () => n.MO,
					Power1: () => n.F,
					Power2: () => n.ys,
					Power3: () => n.FL,
					Power4: () => n.MI,
					RoughEase: () => B,
					RoundPropsPlugin: () => h,
					Sine: () => D,
					SlowMo: () => O,
					SteppedEase: () => N,
					TimelineLite: () => s,
					TimelineMax: () => o,
					TweenLite: () => n.Ay,
					TweenMax: () => F,
					TweenPlugin: () => n.tN,
					_gsScope: () => n.uW,
					default: () => F
				});
				var n = i(23765);
				n.uW._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], (function() {
					var t = function(t) {
							n.UL.call(this, t), this._labels = {}, this.autoRemoveChildren = !0 === this.vars.autoRemoveChildren, this.smoothChildTiming = !0 === this.vars.smoothChildTiming, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
							var e, i, s = this.vars;
							for (i in s) e = s[i], r(e) && -1 !== e.join("").indexOf("{self}") && (s[i] = this._swapSelfInParams(e));
							r(s.tweens) && this.add(s.tweens, 0, s.align, s.stagger)
						},
						e = 1e-10,
						i = n.Ay._internals,
						s = t._internals = {},
						o = i.isSelector,
						r = i.isArray,
						a = i.lazyTweens,
						l = i.lazyRender,
						h = n.uW._gsDefine.globals,
						u = function(t) {
							var e, i = {};
							for (e in t) i[e] = t[e];
							return i
						},
						c = function(t, e, i) {
							var n, s, o = t.cycle;
							for (n in o) s = o[n], t[n] = "function" == typeof s ? s(i, e[i]) : s[i % s.length];
							delete t.cycle
						},
						d = s.pauseCallback = function() {},
						p = function(t) {
							var e, i = [],
								n = t.length;
							for (e = 0; e !== n; i.push(t[e++]));
							return i
						},
						_ = t.prototype = new n.UL;
					return t.version = "2.0.2", _.constructor = t, _.kill()._gc = _._forcingPlayhead = _._hasPause = !1, _.to = function(t, e, i, s) {
						var o = i.repeat && h.TweenMax || n.Ay;
						return e ? this.add(new o(t, e, i), s) : this.set(t, i, s)
					}, _.from = function(t, e, i, s) {
						return this.add((i.repeat && h.TweenMax || n.Ay).from(t, e, i), s)
					}, _.fromTo = function(t, e, i, s, o) {
						var r = s.repeat && h.TweenMax || n.Ay;
						return e ? this.add(r.fromTo(t, e, i, s), o) : this.set(t, s, o)
					}, _.staggerTo = function(e, i, s, r, a, l, h, d) {
						var _, m, g = new t({
								onComplete: l,
								onCompleteParams: h,
								callbackScope: d,
								smoothChildTiming: this.smoothChildTiming
							}),
							f = s.cycle;
						for ("string" == typeof e && (e = n.Ay.selector(e) || e), o(e = e || []) && (e = p(e)), (r = r || 0) < 0 && ((e = p(e)).reverse(), r *= -1), m = 0; m < e.length; m++)(_ = u(s)).startAt && (_.startAt = u(_.startAt), _.startAt.cycle && c(_.startAt, e, m)), f && (c(_, e, m), null != _.duration && (i = _.duration, delete _.duration)), g.to(e[m], i, _, m * r);
						return this.add(g, a)
					}, _.staggerFrom = function(t, e, i, n, s, o, r, a) {
						return i.immediateRender = 0 != i.immediateRender, i.runBackwards = !0, this.staggerTo(t, e, i, n, s, o, r, a)
					}, _.staggerFromTo = function(t, e, i, n, s, o, r, a, l) {
						return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, this.staggerTo(t, e, n, s, o, r, a, l)
					}, _.call = function(t, e, i, s) {
						return this.add(n.Ay.delayedCall(0, t, e, i), s)
					}, _.set = function(t, e, i) {
						return i = this._parseTimeOrLabel(i, 0, !0), null == e.immediateRender && (e.immediateRender = i === this._time && !this._paused), this.add(new n.Ay(t, 0, e), i)
					}, t.exportRoot = function(e, i) {
						null == (e = e || {}).smoothChildTiming && (e.smoothChildTiming = !0);
						var s, o, r, a, l = new t(e),
							h = l._timeline;
						for (null == i && (i = !0), h._remove(l, !0), l._startTime = 0, l._rawPrevTime = l._time = l._totalTime = h._time, r = h._first; r;) a = r._next, i && r instanceof n.Ay && r.target === r.vars.onComplete || ((o = r._startTime - r._delay) < 0 && (s = 1), l.add(r, o)), r = a;
						return h.add(l, 0), s && l.totalDuration(), l
					}, _.add = function(e, i, s, o) {
						var a, l, h, u, c, d;
						if ("number" != typeof i && (i = this._parseTimeOrLabel(i, 0, !0, e)), !(e instanceof n.X5)) {
							if (e instanceof Array || e && e.push && r(e)) {
								for (s = s || "normal", o = o || 0, a = i, l = e.length, h = 0; h < l; h++) r(u = e[h]) && (u = new t({
									tweens: u
								})), this.add(u, a), "string" != typeof u && "function" != typeof u && ("sequence" === s ? a = u._startTime + u.totalDuration() / u._timeScale : "start" === s && (u._startTime -= u.delay())), a += o;
								return this._uncache(!0)
							}
							if ("string" == typeof e) return this.addLabel(e, i);
							if ("function" != typeof e) throw "Cannot add " + e + " into the timeline; it is not a tween, timeline, function, or string.";
							e = n.Ay.delayedCall(0, e)
						}
						if (n.UL.prototype.add.call(this, e, i), e._time && (a = Math.max(0, Math.min(e.totalDuration(), (this.rawTime() - e._startTime) * e._timeScale)), Math.abs(a - e._totalTime) > 1e-5 && e.render(a, !1, !1)), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
							for (d = (c = this).rawTime() > e._startTime; c._timeline;) d && c._timeline.smoothChildTiming ? c.totalTime(c._totalTime, !0) : c._gc && c._enabled(!0, !1), c = c._timeline;
						return this
					}, _.remove = function(t) {
						if (t instanceof n.X5) {
							this._remove(t, !1);
							var e = t._timeline = t.vars.useFrames ? n.X5._rootFramesTimeline : n.X5._rootTimeline;
							return t._startTime = (t._paused ? t._pauseTime : e._time) - (t._reversed ? t.totalDuration() - t._totalTime : t._totalTime) / t._timeScale, this
						}
						if (t instanceof Array || t && t.push && r(t)) {
							for (var i = t.length; --i > -1;) this.remove(t[i]);
							return this
						}
						return "string" == typeof t ? this.removeLabel(t) : this.kill(null, t)
					}, _._remove = function(t, e) {
						return n.UL.prototype._remove.call(this, t, e), this._last ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
					}, _.append = function(t, e) {
						return this.add(t, this._parseTimeOrLabel(null, e, !0, t))
					}, _.insert = _.insertMultiple = function(t, e, i, n) {
						return this.add(t, e || 0, i, n)
					}, _.appendMultiple = function(t, e, i, n) {
						return this.add(t, this._parseTimeOrLabel(null, e, !0, t), i, n)
					}, _.addLabel = function(t, e) {
						return this._labels[t] = this._parseTimeOrLabel(e), this
					}, _.addPause = function(t, e, i, s) {
						var o = n.Ay.delayedCall(0, d, i, s || this);
						return o.vars.onComplete = o.vars.onReverseComplete = e, o.data = "isPause", this._hasPause = !0, this.add(o, t)
					}, _.removeLabel = function(t) {
						return delete this._labels[t], this
					}, _.getLabelTime = function(t) {
						return null != this._labels[t] ? this._labels[t] : -1
					}, _._parseTimeOrLabel = function(t, e, i, s) {
						var o, a;
						if (s instanceof n.X5 && s.timeline === this) this.remove(s);
						else if (s && (s instanceof Array || s.push && r(s)))
							for (a = s.length; --a > -1;) s[a] instanceof n.X5 && s[a].timeline === this && this.remove(s[a]);
						if (o = "number" != typeof t || e ? this.duration() > 99999999999 ? this.recent().endTime(!1) : this._duration : 0, "string" == typeof e) return this._parseTimeOrLabel(e, i && "number" == typeof t && null == this._labels[e] ? t - o : 0, i);
						if (e = e || 0, "string" != typeof t || !isNaN(t) && null == this._labels[t]) null == t && (t = o);
						else {
							if (-1 === (a = t.indexOf("="))) return null == this._labels[t] ? i ? this._labels[t] = o + e : e : this._labels[t] + e;
							e = parseInt(t.charAt(a - 1) + "1", 10) * Number(t.substr(a + 1)), t = a > 1 ? this._parseTimeOrLabel(t.substr(0, a - 1), 0, i) : o
						}
						return Number(t) + e
					}, _.seek = function(t, e) {
						return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), !1 !== e)
					}, _.stop = function() {
						return this.paused(!0)
					}, _.gotoAndPlay = function(t, e) {
						return this.play(t, e)
					}, _.gotoAndStop = function(t, e) {
						return this.pause(t, e)
					}, _.render = function(t, i, n) {
						this._gc && this._enabled(!0, !1);
						var s, o, r, h, u, c, d, p = this._time,
							_ = this._dirty ? this.totalDuration() : this._totalDuration,
							m = this._startTime,
							g = this._timeScale,
							f = this._paused;
						if (p !== this._time && (t += this._time - p), t >= _ - 1e-7 && t >= 0) this._totalTime = this._time = _, this._reversed || this._hasPausedChild() || (o = !0, h = "onComplete", u = !!this._timeline.autoRemoveChildren, 0 === this._duration && (t <= 0 && t >= -1e-7 || this._rawPrevTime < 0 || this._rawPrevTime === e) && this._rawPrevTime !== t && this._first && (u = !0, this._rawPrevTime > e && (h = "onReverseComplete"))), this._rawPrevTime = this._duration || !i || t || this._rawPrevTime === t ? t : e, t = _ + 1e-4;
						else if (t < 1e-7)
							if (this._totalTime = this._time = 0, (0 !== p || 0 === this._duration && this._rawPrevTime !== e && (this._rawPrevTime > 0 || t < 0 && this._rawPrevTime >= 0)) && (h = "onReverseComplete", o = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (u = o = !0, h = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (u = !0), this._rawPrevTime = t;
							else {
								if (this._rawPrevTime = this._duration || !i || t || this._rawPrevTime === t ? t : e, 0 === t && o)
									for (s = this._first; s && 0 === s._startTime;) s._duration || (o = !1), s = s._next;
								t = 0, this._initted || (u = !0)
							}
						else {
							if (this._hasPause && !this._forcingPlayhead && !i) {
								if (t >= p)
									for (s = this._first; s && s._startTime <= t && !c;) s._duration || "isPause" !== s.data || s.ratio || 0 === s._startTime && 0 === this._rawPrevTime || (c = s), s = s._next;
								else
									for (s = this._last; s && s._startTime >= t && !c;) s._duration || "isPause" === s.data && s._rawPrevTime > 0 && (c = s), s = s._prev;
								c && (this._time = t = c._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
							}
							this._totalTime = this._time = this._rawPrevTime = t
						}
						if (this._time !== p && this._first || n || u || c) {
							if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== p && t > 0 && (this._active = !0), 0 === p && this.vars.onStart && (0 === this._time && this._duration || i || this._callback("onStart")), (d = this._time) >= p)
								for (s = this._first; s && (r = s._next, d === this._time && (!this._paused || f));)(s._active || s._startTime <= d && !s._paused && !s._gc) && (c === s && this.pause(), s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, i, n) : s.render((t - s._startTime) * s._timeScale, i, n)), s = r;
							else
								for (s = this._last; s && (r = s._prev, d === this._time && (!this._paused || f));) {
									if (s._active || s._startTime <= p && !s._paused && !s._gc) {
										if (c === s) {
											for (c = s._prev; c && c.endTime() > this._time;) c.render(c._reversed ? c.totalDuration() - (t - c._startTime) * c._timeScale : (t - c._startTime) * c._timeScale, i, n), c = c._prev;
											c = null, this.pause()
										}
										s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, i, n) : s.render((t - s._startTime) * s._timeScale, i, n)
									}
									s = r
								}
							this._onUpdate && (i || (a.length && l(), this._callback("onUpdate"))), h && (this._gc || m !== this._startTime && g === this._timeScale || (0 === this._time || _ >= this.totalDuration()) && (o && (a.length && l(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !i && this.vars[h] && this._callback(h)))
						}
					}, _._hasPausedChild = function() {
						for (var e = this._first; e;) {
							if (e._paused || e instanceof t && e._hasPausedChild()) return !0;
							e = e._next
						}
						return !1
					}, _.getChildren = function(t, e, i, s) {
						s = s || -9999999999;
						for (var o = [], r = this._first, a = 0; r;) r._startTime < s || (r instanceof n.Ay ? !1 !== e && (o[a++] = r) : (!1 !== i && (o[a++] = r), !1 !== t && (a = (o = o.concat(r.getChildren(!0, e, i))).length))), r = r._next;
						return o
					}, _.getTweensOf = function(t, e) {
						var i, s, o = this._gc,
							r = [],
							a = 0;
						for (o && this._enabled(!0, !0), s = (i = n.Ay.getTweensOf(t)).length; --s > -1;)(i[s].timeline === this || e && this._contains(i[s])) && (r[a++] = i[s]);
						return o && this._enabled(!1, !0), r
					}, _.recent = function() {
						return this._recent
					}, _._contains = function(t) {
						for (var e = t.timeline; e;) {
							if (e === this) return !0;
							e = e.timeline
						}
						return !1
					}, _.shiftChildren = function(t, e, i) {
						i = i || 0;
						for (var n, s = this._first, o = this._labels; s;) s._startTime >= i && (s._startTime += t), s = s._next;
						if (e)
							for (n in o) o[n] >= i && (o[n] += t);
						return this._uncache(!0)
					}, _._kill = function(t, e) {
						if (!t && !e) return this._enabled(!1, !1);
						for (var i = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), n = i.length, s = !1; --n > -1;) i[n]._kill(t, e) && (s = !0);
						return s
					}, _.clear = function(t) {
						var e = this.getChildren(!1, !0, !0),
							i = e.length;
						for (this._time = this._totalTime = 0; --i > -1;) e[i]._enabled(!1, !1);
						return !1 !== t && (this._labels = {}), this._uncache(!0)
					}, _.invalidate = function() {
						for (var t = this._first; t;) t.invalidate(), t = t._next;
						return n.X5.prototype.invalidate.call(this)
					}, _._enabled = function(t, e) {
						if (t === this._gc)
							for (var i = this._first; i;) i._enabled(t, !0), i = i._next;
						return n.UL.prototype._enabled.call(this, t, e)
					}, _.totalTime = function(t, e, i) {
						this._forcingPlayhead = !0;
						var s = n.X5.prototype.totalTime.apply(this, arguments);
						return this._forcingPlayhead = !1, s
					}, _.duration = function(t) {
						return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration)
					}, _.totalDuration = function(t) {
						if (!arguments.length) {
							if (this._dirty) {
								for (var e, i, n = 0, s = this._last, o = 999999999999; s;) e = s._prev, s._dirty && s.totalDuration(), s._startTime > o && this._sortChildren && !s._paused && !this._calculatingDuration ? (this._calculatingDuration = 1, this.add(s, s._startTime - s._delay), this._calculatingDuration = 0) : o = s._startTime, s._startTime < 0 && !s._paused && (n -= s._startTime, this._timeline.smoothChildTiming && (this._startTime += s._startTime / this._timeScale, this._time -= s._startTime, this._totalTime -= s._startTime, this._rawPrevTime -= s._startTime), this.shiftChildren(-s._startTime, !1, -9999999999), o = 0), (i = s._startTime + s._totalDuration / s._timeScale) > n && (n = i), s = e;
								this._duration = this._totalDuration = n, this._dirty = !1
							}
							return this._totalDuration
						}
						return t && this.totalDuration() ? this.timeScale(this._totalDuration / t) : this
					}, _.paused = function(t) {
						if (!t)
							for (var e = this._first, i = this._time; e;) e._startTime === i && "isPause" === e.data && (e._rawPrevTime = 0), e = e._next;
						return n.X5.prototype.paused.apply(this, arguments)
					}, _.usesFrames = function() {
						for (var t = this._timeline; t._timeline;) t = t._timeline;
						return t === n.X5._rootFramesTimeline
					}, _.rawTime = function(t) {
						return t && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(t) - this._startTime) * this._timeScale
					}, t
				}), !0);
				var s = n.zQ.TimelineLite;
				n.uW._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], (function() {
					var t = function(t) {
							s.call(this, t), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = !0 === this.vars.yoyo, this._dirty = !0
						},
						e = 1e-10,
						i = n.Ay._internals,
						o = i.lazyTweens,
						r = i.lazyRender,
						a = n.uW._gsDefine.globals,
						l = new n.zM(null, null, 1, 0),
						h = t.prototype = new s;
					return h.constructor = t, h.kill()._gc = !1, t.version = "2.0.2", h.invalidate = function() {
						return this._yoyo = !0 === this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), s.prototype.invalidate.call(this)
					}, h.addCallback = function(t, e, i, s) {
						return this.add(n.Ay.delayedCall(0, t, i, s), e)
					}, h.removeCallback = function(t, e) {
						if (t)
							if (null == e) this._kill(null, t);
							else
								for (var i = this.getTweensOf(t, !1), n = i.length, s = this._parseTimeOrLabel(e); --n > -1;) i[n]._startTime === s && i[n]._enabled(!1, !1);
						return this
					}, h.removePause = function(t) {
						return this.removeCallback(s._internals.pauseCallback, t)
					}, h.tweenTo = function(t, e) {
						e = e || {};
						var i, s, o, r = {
								ease: l,
								useFrames: this.usesFrames(),
								immediateRender: !1,
								lazy: !1
							},
							h = e.repeat && a.TweenMax || n.Ay;
						for (s in e) r[s] = e[s];
						return r.time = this._parseTimeOrLabel(t), i = Math.abs(Number(r.time) - this._time) / this._timeScale || .001, o = new h(this, i, r), r.onStart = function() {
							o.target.paused(!0), o.vars.time === o.target.time() || i !== o.duration() || o.isFromTo || o.duration(Math.abs(o.vars.time - o.target.time()) / o.target._timeScale).render(o.time(), !0, !0), e.onStart && e.onStart.apply(e.onStartScope || e.callbackScope || o, e.onStartParams || [])
						}, o
					}, h.tweenFromTo = function(t, e, i) {
						i = i || {}, t = this._parseTimeOrLabel(t), i.startAt = {
							onComplete: this.seek,
							onCompleteParams: [t],
							callbackScope: this
						}, i.immediateRender = !1 !== i.immediateRender;
						var n = this.tweenTo(e, i);
						return n.isFromTo = 1, n.duration(Math.abs(n.vars.time - t) / this._timeScale || .001)
					}, h.render = function(t, i, n) {
						this._gc && this._enabled(!0, !1);
						var s, a, l, h, u, c, d, p, _ = this._time,
							m = this._dirty ? this.totalDuration() : this._totalDuration,
							g = this._duration,
							f = this._totalTime,
							S = this._startTime,
							y = this._timeScale,
							v = this._rawPrevTime,
							T = this._paused,
							E = this._cycle;
						if (_ !== this._time && (t += this._time - _), t >= m - 1e-7 && t >= 0) this._locked || (this._totalTime = m, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (a = !0, h = "onComplete", u = !!this._timeline.autoRemoveChildren, 0 === this._duration && (t <= 0 && t >= -1e-7 || v < 0 || v === e) && v !== t && this._first && (u = !0, v > e && (h = "onReverseComplete"))), this._rawPrevTime = this._duration || !i || t || this._rawPrevTime === t ? t : e, this._yoyo && 1 & this._cycle ? this._time = t = 0 : (this._time = g, t = g + 1e-4);
						else if (t < 1e-7)
							if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== _ || 0 === g && v !== e && (v > 0 || t < 0 && v >= 0) && !this._locked) && (h = "onReverseComplete", a = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (u = a = !0, h = "onReverseComplete") : v >= 0 && this._first && (u = !0), this._rawPrevTime = t;
							else {
								if (this._rawPrevTime = g || !i || t || this._rawPrevTime === t ? t : e, 0 === t && a)
									for (s = this._first; s && 0 === s._startTime;) s._duration || (a = !1), s = s._next;
								t = 0, this._initted || (u = !0)
							}
						else if (0 === g && v < 0 && (u = !0), this._time = this._rawPrevTime = t, this._locked || (this._totalTime = t, 0 !== this._repeat && (c = g + this._repeatDelay, this._cycle = this._totalTime / c | 0, 0 !== this._cycle && this._cycle === this._totalTime / c && f <= t && this._cycle--, this._time = this._totalTime - this._cycle * c, this._yoyo && 1 & this._cycle && (this._time = g - this._time), this._time > g ? (this._time = g, t = g + 1e-4) : this._time < 0 ? this._time = t = 0 : t = this._time)), this._hasPause && !this._forcingPlayhead && !i) {
							if ((t = this._time) >= _ || this._repeat && E !== this._cycle)
								for (s = this._first; s && s._startTime <= t && !d;) s._duration || "isPause" !== s.data || s.ratio || 0 === s._startTime && 0 === this._rawPrevTime || (d = s), s = s._next;
							else
								for (s = this._last; s && s._startTime >= t && !d;) s._duration || "isPause" === s.data && s._rawPrevTime > 0 && (d = s), s = s._prev;
							d && d._startTime < g && (this._time = t = d._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
						}
						if (this._cycle !== E && !this._locked) {
							var b = this._yoyo && !!(1 & E),
								A = b === (this._yoyo && !!(1 & this._cycle)),
								P = this._totalTime,
								I = this._cycle,
								w = this._rawPrevTime,
								L = this._time;
							if (this._totalTime = E * g, this._cycle < E ? b = !b : this._totalTime += g, this._time = _, this._rawPrevTime = 0 === g ? v - 1e-4 : v, this._cycle = E, this._locked = !0, _ = b ? 0 : g, this.render(_, i, 0 === g), i || this._gc || this.vars.onRepeat && (this._cycle = I, this._locked = !1, this._callback("onRepeat")), _ !== this._time) return;
							if (A && (this._cycle = E, this._locked = !0, _ = b ? g + 1e-4 : -1e-4, this.render(_, !0, !1)), this._locked = !1, this._paused && !T) return;
							this._time = L, this._totalTime = P, this._cycle = I, this._rawPrevTime = w
						}
						if (this._time !== _ && this._first || n || u || d) {
							if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== f && t > 0 && (this._active = !0), 0 === f && this.vars.onStart && (0 === this._totalTime && this._totalDuration || i || this._callback("onStart")), (p = this._time) >= _)
								for (s = this._first; s && (l = s._next, p === this._time && (!this._paused || T));)(s._active || s._startTime <= this._time && !s._paused && !s._gc) && (d === s && this.pause(), s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, i, n) : s.render((t - s._startTime) * s._timeScale, i, n)), s = l;
							else
								for (s = this._last; s && (l = s._prev, p === this._time && (!this._paused || T));) {
									if (s._active || s._startTime <= _ && !s._paused && !s._gc) {
										if (d === s) {
											for (d = s._prev; d && d.endTime() > this._time;) d.render(d._reversed ? d.totalDuration() - (t - d._startTime) * d._timeScale : (t - d._startTime) * d._timeScale, i, n), d = d._prev;
											d = null, this.pause()
										}
										s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, i, n) : s.render((t - s._startTime) * s._timeScale, i, n)
									}
									s = l
								}
							this._onUpdate && (i || (o.length && r(), this._callback("onUpdate"))), h && (this._locked || this._gc || S !== this._startTime && y === this._timeScale || (0 === this._time || m >= this.totalDuration()) && (a && (o.length && r(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !i && this.vars[h] && this._callback(h)))
						} else f !== this._totalTime && this._onUpdate && (i || this._callback("onUpdate"))
					}, h.getActive = function(t, e, i) {
						null == t && (t = !0), null == e && (e = !0), null == i && (i = !1);
						var n, s, o = [],
							r = this.getChildren(t, e, i),
							a = 0,
							l = r.length;
						for (n = 0; n < l; n++)(s = r[n]).isActive() && (o[a++] = s);
						return o
					}, h.getLabelAfter = function(t) {
						t || 0 !== t && (t = this._time);
						var e, i = this.getLabelsArray(),
							n = i.length;
						for (e = 0; e < n; e++)
							if (i[e].time > t) return i[e].name;
						return null
					}, h.getLabelBefore = function(t) {
						null == t && (t = this._time);
						for (var e = this.getLabelsArray(), i = e.length; --i > -1;)
							if (e[i].time < t) return e[i].name;
						return null
					}, h.getLabelsArray = function() {
						var t, e = [],
							i = 0;
						for (t in this._labels) e[i++] = {
							time: this._labels[t],
							name: t
						};
						return e.sort((function(t, e) {
							return t.time - e.time
						})), e
					}, h.invalidate = function() {
						return this._locked = !1, s.prototype.invalidate.call(this)
					}, h.progress = function(t, e) {
						return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 1 & this._cycle ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration() || 0
					}, h.totalProgress = function(t, e) {
						return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration() || 0
					}, h.totalDuration = function(t) {
						return arguments.length ? -1 !== this._repeat && t ? this.timeScale(this.totalDuration() / t) : this : (this._dirty && (s.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
					}, h.time = function(t, e) {
						return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 1 & this._cycle ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
					}, h.repeat = function(t) {
						return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
					}, h.repeatDelay = function(t) {
						return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
					}, h.yoyo = function(t) {
						return arguments.length ? (this._yoyo = t, this) : this._yoyo
					}, h.currentLabel = function(t) {
						return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8)
					}, t
				}), !0);
				var o = n.zQ.TimelineMax;
				n.uW._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], (function() {
					var t = function(t) {
							var e, i = [],
								n = t.length;
							for (e = 0; e !== n; i.push(t[e++]));
							return i
						},
						e = function(t, e, i) {
							var n, s, o = t.cycle;
							for (n in o) s = o[n], t[n] = "function" == typeof s ? s(i, e[i]) : s[i % s.length];
							delete t.cycle
						},
						i = function(t, e, s) {
							n.Ay.call(this, t, e, s), this._cycle = 0, this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._repeat && this._uncache(!0), this.render = i.prototype.render
						},
						s = 1e-10,
						o = n.Ay._internals,
						r = o.isSelector,
						a = o.isArray,
						l = i.prototype = n.Ay.to({}, .1, {}),
						h = [];
					i.version = "2.0.2", l.constructor = i, l.kill()._gc = !1, i.killTweensOf = i.killDelayedCallsTo = n.Ay.killTweensOf, i.getTweensOf = n.Ay.getTweensOf, i.lagSmoothing = n.Ay.lagSmoothing, i.ticker = n.Ay.ticker, i.render = n.Ay.render, l.invalidate = function() {
						return this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._yoyoEase = null, this._uncache(!0), n.Ay.prototype.invalidate.call(this)
					}, l.updateTo = function(t, e) {
						var i, s = this.ratio,
							o = this.vars.immediateRender || t.immediateRender;
						for (i in e && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay)), t) this.vars[i] = t[i];
						if (this._initted || o)
							if (e) this._initted = !1, o && this.render(0, !0, !0);
							else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && n.Ay._onPluginEvent("_onDisable", this), this._time / this._duration > .998) {
							var r = this._totalTime;
							this.render(0, !0, !1), this._initted = !1, this.render(r, !0, !1)
						} else if (this._initted = !1, this._init(), this._time > 0 || o)
							for (var a, l = 1 / (1 - s), h = this._firstPT; h;) a = h.s + h.c, h.c *= l, h.s = a - h.c, h = h._next;
						return this
					}, l.render = function(t, e, i) {
						this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
						var r, a, l, h, u, c, d, p, _, m = this._dirty ? this.totalDuration() : this._totalDuration,
							g = this._time,
							f = this._totalTime,
							S = this._cycle,
							y = this._duration,
							v = this._rawPrevTime;
						if (t >= m - 1e-7 && t >= 0 ? (this._totalTime = m, this._cycle = this._repeat, this._yoyo && 1 & this._cycle ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = y, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (r = !0, a = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === y && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (v < 0 || t <= 0 && t >= -1e-7 || v === s && "isPause" !== this.data) && v !== t && (i = !0, v > s && (a = "onReverseComplete")), this._rawPrevTime = p = !e || t || v === t ? t : s)) : t < 1e-7 ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== f || 0 === y && v > 0) && (a = "onReverseComplete", r = this._reversed), t < 0 && (this._active = !1, 0 === y && (this._initted || !this.vars.lazy || i) && (v >= 0 && (i = !0), this._rawPrevTime = p = !e || t || v === t ? t : s)), this._initted || (i = !0)) : (this._totalTime = this._time = t, 0 !== this._repeat && (h = y + this._repeatDelay, this._cycle = this._totalTime / h | 0, 0 !== this._cycle && this._cycle === this._totalTime / h && f <= t && this._cycle--, this._time = this._totalTime - this._cycle * h, this._yoyo && 1 & this._cycle && (this._time = y - this._time, (_ = this._yoyoEase || this.vars.yoyoEase) && (this._yoyoEase || (!0 !== _ || this._initted ? this._yoyoEase = _ = !0 === _ ? this._ease : _ instanceof n.zM ? _ : n.zM.map[_] : (_ = this.vars.ease, this._yoyoEase = _ = _ ? _ instanceof n.zM ? _ : "function" == typeof _ ? new n.zM(_, this.vars.easeParams) : n.zM.map[_] || n.Ay.defaultEase : n.Ay.defaultEase)), this.ratio = _ ? 1 - _.getRatio((y - this._time) / y) : 0)), this._time > y ? this._time = y : this._time < 0 && (this._time = 0)), this._easeType && !_ ? (u = this._time / y, (1 === (c = this._easeType) || 3 === c && u >= .5) && (u = 1 - u), 3 === c && (u *= 2), 1 === (d = this._easePower) ? u *= u : 2 === d ? u *= u * u : 3 === d ? u *= u * u * u : 4 === d && (u *= u * u * u * u), 1 === c ? this.ratio = 1 - u : 2 === c ? this.ratio = u : this._time / y < .5 ? this.ratio = u / 2 : this.ratio = 1 - u / 2) : _ || (this.ratio = this._ease.getRatio(this._time / y))), g !== this._time || i || S !== this._cycle) {
							if (!this._initted) {
								if (this._init(), !this._initted || this._gc) return;
								if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = g, this._totalTime = f, this._rawPrevTime = v, this._cycle = S, o.lazyTweens.push(this), void(this._lazy = [t, e]);
								!this._time || r || _ ? r && this._ease._calcEnd && !_ && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) : this.ratio = this._ease.getRatio(this._time / y)
							}
							for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== g && t >= 0 && (this._active = !0), 0 === f && (2 === this._initted && t > 0 && this._init(), this._startAt && (t >= 0 ? this._startAt.render(t, !0, i) : a || (a = "_dummyGS")), this.vars.onStart && (0 === this._totalTime && 0 !== y || e || this._callback("onStart"))), l = this._firstPT; l;) l.f ? l.t[l.p](l.c * this.ratio + l.s) : l.t[l.p] = l.c * this.ratio + l.s, l = l._next;
							this._onUpdate && (t < 0 && this._startAt && this._startTime && this._startAt.render(t, !0, i), e || (this._totalTime !== f || a) && this._callback("onUpdate")), this._cycle !== S && (e || this._gc || this.vars.onRepeat && this._callback("onRepeat")), a && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, !0, i), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[a] && this._callback(a), 0 === y && this._rawPrevTime === s && p !== s && (this._rawPrevTime = 0)))
						} else f !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate"))
					}, i.to = function(t, e, n) {
						return new i(t, e, n)
					}, i.from = function(t, e, n) {
						return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, new i(t, e, n)
					}, i.fromTo = function(t, e, n, s) {
						return s.startAt = n, s.immediateRender = 0 != s.immediateRender && 0 != n.immediateRender, new i(t, e, s)
					}, i.staggerTo = i.allTo = function(s, o, l, u, c, d, p) {
						u = u || 0;
						var _, m, g, f, S = 0,
							y = [],
							v = function() {
								l.onComplete && l.onComplete.apply(l.onCompleteScope || this, arguments), c.apply(p || l.callbackScope || this, d || h)
							},
							T = l.cycle,
							E = l.startAt && l.startAt.cycle;
						for (a(s) || ("string" == typeof s && (s = n.Ay.selector(s) || s), r(s) && (s = t(s))), s = s || [], u < 0 && ((s = t(s)).reverse(), u *= -1), _ = s.length - 1, g = 0; g <= _; g++) {
							for (f in m = {}, l) m[f] = l[f];
							if (T && (e(m, s, g), null != m.duration && (o = m.duration, delete m.duration)), E) {
								for (f in E = m.startAt = {}, l.startAt) E[f] = l.startAt[f];
								e(m.startAt, s, g)
							}
							m.delay = S + (m.delay || 0), g === _ && c && (m.onComplete = v), y[g] = new i(s[g], o, m), S += u
						}
						return y
					}, i.staggerFrom = i.allFrom = function(t, e, n, s, o, r, a) {
						return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, i.staggerTo(t, e, n, s, o, r, a)
					}, i.staggerFromTo = i.allFromTo = function(t, e, n, s, o, r, a, l) {
						return s.startAt = n, s.immediateRender = 0 != s.immediateRender && 0 != n.immediateRender, i.staggerTo(t, e, s, o, r, a, l)
					}, i.delayedCall = function(t, e, n, s, o) {
						return new i(e, 0, {
							delay: t,
							onComplete: e,
							onCompleteParams: n,
							callbackScope: s,
							onReverseComplete: e,
							onReverseCompleteParams: n,
							immediateRender: !1,
							useFrames: o,
							overwrite: 0
						})
					}, i.set = function(t, e) {
						return new i(t, 0, e)
					}, i.isTweening = function(t) {
						return n.Ay.getTweensOf(t, !0).length > 0
					};
					var u = function(t, e) {
							for (var i = [], s = 0, o = t._first; o;) o instanceof n.Ay ? i[s++] = o : (e && (i[s++] = o), s = (i = i.concat(u(o, e))).length), o = o._next;
							return i
						},
						c = i.getAllTweens = function(t) {
							return u(n.X5._rootTimeline, t).concat(u(n.X5._rootFramesTimeline, t))
						};
					i.killAll = function(t, e, i, s) {
						null == e && (e = !0), null == i && (i = !0);
						var o, r, a, l = c(0 != s),
							h = l.length,
							u = e && i && s;
						for (a = 0; a < h; a++) r = l[a], (u || r instanceof n.UL || (o = r.target === r.vars.onComplete) && i || e && !o) && (t ? r.totalTime(r._reversed ? 0 : r.totalDuration()) : r._enabled(!1, !1))
					}, i.killChildTweensOf = function(e, s) {
						if (null != e) {
							var l, h, u, c, d, p = o.tweenLookup;
							if ("string" == typeof e && (e = n.Ay.selector(e) || e), r(e) && (e = t(e)), a(e))
								for (c = e.length; --c > -1;) i.killChildTweensOf(e[c], s);
							else {
								for (u in l = [], p)
									for (h = p[u].target.parentNode; h;) h === e && (l = l.concat(p[u].tweens)), h = h.parentNode;
								for (d = l.length, c = 0; c < d; c++) s && l[c].totalTime(l[c].totalDuration()), l[c]._enabled(!1, !1)
							}
						}
					};
					var d = function(t, e, i, s) {
						e = !1 !== e, i = !1 !== i;
						for (var o, r, a = c(s = !1 !== s), l = e && i && s, h = a.length; --h > -1;) r = a[h], (l || r instanceof n.UL || (o = r.target === r.vars.onComplete) && i || e && !o) && r.paused(t)
					};
					return i.pauseAll = function(t, e, i) {
						d(!0, t, e, i)
					}, i.resumeAll = function(t, e, i) {
						d(!1, t, e, i)
					}, i.globalTimeScale = function(t) {
						var e = n.X5._rootTimeline,
							i = n.Ay.ticker.time;
						return arguments.length ? (t = t || s, e._startTime = i - (i - e._startTime) * e._timeScale / t, e = n.X5._rootFramesTimeline, i = n.Ay.ticker.frame, e._startTime = i - (i - e._startTime) * e._timeScale / t, e._timeScale = n.X5._rootTimeline._timeScale = t, t) : e._timeScale
					}, l.progress = function(t, e) {
						return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 1 & this._cycle ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration()
					}, l.totalProgress = function(t, e) {
						return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration()
					}, l.time = function(t, e) {
						return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 1 & this._cycle ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
					}, l.duration = function(t) {
						return arguments.length ? n.X5.prototype.duration.call(this, t) : this._duration
					}, l.totalDuration = function(t) {
						return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
					}, l.repeat = function(t) {
						return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
					}, l.repeatDelay = function(t) {
						return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
					}, l.yoyo = function(t) {
						return arguments.length ? (this._yoyo = t, this) : this._yoyo
					}, i
				}), !0);
				var r = n.zQ.TweenMax;
				n.uW._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], (function() {
					var t, e, i, s, o = function() {
							n.tN.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = o.prototype.setRatio
						},
						r = n.uW._gsDefine.globals,
						a = {},
						l = o.prototype = new n.tN("css");
					l.constructor = o, o.version = "2.0.2", o.API = 2, o.defaultTransformPerspective = 0, o.defaultSkewType = "compensated", o.defaultSmoothOrigin = !0, l = "px", o.suffixMap = {
						top: l,
						right: l,
						bottom: l,
						left: l,
						width: l,
						height: l,
						fontSize: l,
						padding: l,
						margin: l,
						perspective: l,
						lineHeight: ""
					};
					var h, u, c, d, p, _, m, g, f = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
						S = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
						y = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
						v = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
						T = /(?:\d|\-|\+|=|#|\.)*/g,
						E = /opacity *= *([^)]*)/i,
						b = /opacity:([^;]*)/i,
						A = /alpha\(opacity *=.+?\)/i,
						P = /^(rgb|hsl)/,
						I = /([A-Z])/g,
						w = /-([a-z])/gi,
						L = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
						C = function(t, e) {
							return e.toUpperCase()
						},
						x = /(?:Left|Right|Width)/i,
						B = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
						O = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
						N = /,(?=[^\)]*(?:\(|$))/gi,
						M = /[\s,\(]/i,
						R = Math.PI / 180,
						D = 180 / Math.PI,
						k = {},
						F = {
							style: {}
						},
						G = n.uW.document || {
							createElement: function() {
								return F
							}
						},
						U = function(t, e) {
							return G.createElementNS ? G.createElementNS(e || "http://www.w3.org/1999/xhtml", t) : G.createElement(t)
						},
						W = U("div"),
						H = U("img"),
						V = o._internals = {
							_specialProps: a
						},
						X = (n.uW.navigator || {}).userAgent || "",
						Y = function() {
							var t = X.indexOf("Android"),
								e = U("a");
							return c = -1 !== X.indexOf("Safari") && -1 === X.indexOf("Chrome") && (-1 === t || parseFloat(X.substr(t + 8, 2)) > 3), p = c && parseFloat(X.substr(X.indexOf("Version/") + 8, 2)) < 6, d = -1 !== X.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(X) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(X)) && (_ = parseFloat(RegExp.$1)), !!e && (e.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(e.style.opacity))
						}(),
						z = function(t) {
							return E.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
						},
						j = function(t) {
							n.uW.console && console.log(t)
						},
						K = "",
						q = "",
						Z = function(t, e) {
							var i, n, s = (e = e || W).style;
							if (void 0 !== s[t]) return t;
							for (t = t.charAt(0).toUpperCase() + t.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], n = 5; --n > -1 && void 0 === s[i[n] + t];);
							return n >= 0 ? (K = "-" + (q = 3 === n ? "ms" : i[n]).toLowerCase() + "-", q + t) : null
						},
						$ = ("undefined" != typeof window ? window : G.defaultView || {
							getComputedStyle: function() {}
						}).getComputedStyle,
						Q = o.getStyle = function(t, e, i, n, s) {
							var o;
							return Y || "opacity" !== e ? (!n && t.style[e] ? o = t.style[e] : (i = i || $(t)) ? o = i[e] || i.getPropertyValue(e) || i.getPropertyValue(e.replace(I, "-$1").toLowerCase()) : t.currentStyle && (o = t.currentStyle[e]), null == s || o && "none" !== o && "auto" !== o && "auto auto" !== o ? o : s) : z(t)
						},
						J = V.convertToPixels = function(t, e, i, s, r) {
							if ("px" === s || !s && "lineHeight" !== e) return i;
							if ("auto" === s || !i) return 0;
							var a, l, h, u = x.test(e),
								c = t,
								d = W.style,
								p = i < 0,
								_ = 1 === i;
							if (p && (i = -i), _ && (i *= 100), "lineHeight" !== e || s)
								if ("%" === s && -1 !== e.indexOf("border")) a = i / 100 * (u ? t.clientWidth : t.clientHeight);
								else {
									if (d.cssText = "border:0 solid red;position:" + Q(t, "position") + ";line-height:0;", "%" !== s && c.appendChild && "v" !== s.charAt(0) && "rem" !== s) d[u ? "borderLeftWidth" : "borderTopWidth"] = i + s;
									else {
										if (c = t.parentNode || G.body, -1 !== Q(c, "display").indexOf("flex") && (d.position = "absolute"), l = c._gsCache, h = n.Ay.ticker.frame, l && u && l.time === h) return l.width * i / 100;
										d[u ? "width" : "height"] = i + s
									}
									c.appendChild(W), a = parseFloat(W[u ? "offsetWidth" : "offsetHeight"]), c.removeChild(W), u && "%" === s && !1 !== o.cacheWidths && ((l = c._gsCache = c._gsCache || {}).time = h, l.width = a / i * 100), 0 !== a || r || (a = J(t, e, i, s, !0))
								}
							else l = $(t).lineHeight, t.style.lineHeight = i, a = parseFloat($(t).lineHeight), t.style.lineHeight = l;
							return _ && (a /= 100), p ? -a : a
						},
						tt = V.calculateOffset = function(t, e, i) {
							if ("absolute" !== Q(t, "position", i)) return 0;
							var n = "left" === e ? "Left" : "Top",
								s = Q(t, "margin" + n, i);
							return t["offset" + n] - (J(t, e, parseFloat(s), s.replace(T, "")) || 0)
						},
						et = function(t, e) {
							var i, n, s, o = {};
							if (e = e || $(t, null))
								if (i = e.length)
									for (; --i > -1;) - 1 !== (s = e[i]).indexOf("-transform") && Ot !== s || (o[s.replace(w, C)] = e.getPropertyValue(s));
								else
									for (i in e) - 1 !== i.indexOf("Transform") && Bt !== i || (o[i] = e[i]);
							else if (e = t.currentStyle || t.style)
								for (i in e) "string" == typeof i && void 0 === o[i] && (o[i.replace(w, C)] = e[i]);
							return Y || (o.opacity = z(t)), n = Yt(t, e, !1), o.rotation = n.rotation, o.skewX = n.skewX, o.scaleX = n.scaleX, o.scaleY = n.scaleY, o.x = n.x, o.y = n.y, Mt && (o.z = n.z, o.rotationX = n.rotationX, o.rotationY = n.rotationY, o.scaleZ = n.scaleZ), o.filters && delete o.filters, o
						},
						it = function(t, e, i, n, s) {
							var o, r, a, l = {},
								h = t.style;
							for (r in i) "cssText" !== r && "length" !== r && isNaN(r) && (e[r] !== (o = i[r]) || s && s[r]) && -1 === r.indexOf("Origin") && ("number" != typeof o && "string" != typeof o || (l[r] = "auto" !== o || "left" !== r && "top" !== r ? "" !== o && "auto" !== o && "none" !== o || "string" != typeof e[r] || "" === e[r].replace(v, "") ? o : 0 : tt(t, r), void 0 !== h[r] && (a = new ft(h, r, h[r], a))));
							if (n)
								for (r in n) "className" !== r && (l[r] = n[r]);
							return {
								difs: l,
								firstMPT: a
							}
						},
						nt = {
							width: ["Left", "Right"],
							height: ["Top", "Bottom"]
						},
						st = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
						ot = function(t, e, i) {
							if ("svg" === (t.nodeName + "").toLowerCase()) return (i || $(t))[e] || 0;
							if (t.getCTM && Ht(t)) return t.getBBox()[e] || 0;
							var n = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight),
								s = nt[e],
								o = s.length;
							for (i = i || $(t, null); --o > -1;) n -= parseFloat(Q(t, "padding" + s[o], i, !0)) || 0, n -= parseFloat(Q(t, "border" + s[o] + "Width", i, !0)) || 0;
							return n
						},
						rt = function(t, e) {
							if ("contain" === t || "auto" === t || "auto auto" === t) return t + " ";
							null != t && "" !== t || (t = "0 0");
							var i, n = t.split(" "),
								s = -1 !== t.indexOf("left") ? "0%" : -1 !== t.indexOf("right") ? "100%" : n[0],
								o = -1 !== t.indexOf("top") ? "0%" : -1 !== t.indexOf("bottom") ? "100%" : n[1];
							if (n.length > 3 && !e) {
								for (n = t.split(", ").join(",").split(","), t = [], i = 0; i < n.length; i++) t.push(rt(n[i]));
								return t.join(",")
							}
							return null == o ? o = "center" === s ? "50%" : "0" : "center" === o && (o = "50%"), ("center" === s || isNaN(parseFloat(s)) && -1 === (s + "").indexOf("=")) && (s = "50%"), t = s + " " + o + (n.length > 2 ? " " + n[2] : ""), e && (e.oxp = -1 !== s.indexOf("%"), e.oyp = -1 !== o.indexOf("%"), e.oxr = "=" === s.charAt(1), e.oyr = "=" === o.charAt(1), e.ox = parseFloat(s.replace(v, "")), e.oy = parseFloat(o.replace(v, "")), e.v = t), e || t
						},
						at = function(t, e) {
							return "function" == typeof t && (t = t(g, m)), "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e) || 0
						},
						lt = function(t, e) {
							"function" == typeof t && (t = t(g, m));
							var i = "string" == typeof t && "=" === t.charAt(1);
							return "string" == typeof t && "v" === t.charAt(t.length - 2) && (t = (i ? t.substr(0, 2) : 0) + window["inner" + ("vh" === t.substr(-2) ? "Height" : "Width")] * (parseFloat(i ? t.substr(2) : t) / 100)), null == t ? e : i ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) + e : parseFloat(t) || 0
						},
						ht = function(t, e, i, n) {
							var s, o, r, a, l, h = 1e-6;
							return "function" == typeof t && (t = t(g, m)), null == t ? a = e : "number" == typeof t ? a = t : (s = 360, o = t.split("_"), r = ((l = "=" === t.charAt(1)) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(o[0].substr(2)) : parseFloat(o[0])) * (-1 === t.indexOf("rad") ? 1 : D) - (l ? 0 : e), o.length && (n && (n[i] = e + r), -1 !== t.indexOf("short") && (r %= s) != r % 180 && (r = r < 0 ? r + s : r - s), -1 !== t.indexOf("_cw") && r < 0 ? r = (r + 3599999999640) % s - (r / s | 0) * s : -1 !== t.indexOf("ccw") && r > 0 && (r = (r - 3599999999640) % s - (r / s | 0) * s)), a = e + r), a < h && a > -h && (a = 0), a
						},
						ut = {
							aqua: [0, 255, 255],
							lime: [0, 255, 0],
							silver: [192, 192, 192],
							black: [0, 0, 0],
							maroon: [128, 0, 0],
							teal: [0, 128, 128],
							blue: [0, 0, 255],
							navy: [0, 0, 128],
							white: [255, 255, 255],
							fuchsia: [255, 0, 255],
							olive: [128, 128, 0],
							yellow: [255, 255, 0],
							orange: [255, 165, 0],
							gray: [128, 128, 128],
							purple: [128, 0, 128],
							green: [0, 128, 0],
							red: [255, 0, 0],
							pink: [255, 192, 203],
							cyan: [0, 255, 255],
							transparent: [255, 255, 255, 0]
						},
						ct = function(t, e, i) {
							return 255 * (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (i - e) * t * 6 : t < .5 ? i : 3 * t < 2 ? e + (i - e) * (2 / 3 - t) * 6 : e) + .5 | 0
						},
						dt = o.parseColor = function(t, e) {
							var i, n, s, o, r, a, l, h, u, c, d;
							if (t)
								if ("number" == typeof t) i = [t >> 16, t >> 8 & 255, 255 & t];
								else {
									if ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), ut[t]) i = ut[t];
									else if ("#" === t.charAt(0)) 4 === t.length && (n = t.charAt(1), s = t.charAt(2), o = t.charAt(3), t = "#" + n + n + s + s + o + o), i = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & 255, 255 & t];
									else if ("hsl" === t.substr(0, 3))
										if (i = d = t.match(f), e) {
											if (-1 !== t.indexOf("=")) return t.match(S)
										} else r = Number(i[0]) % 360 / 360, a = Number(i[1]) / 100, n = 2 * (l = Number(i[2]) / 100) - (s = l <= .5 ? l * (a + 1) : l + a - l * a), i.length > 3 && (i[3] = Number(i[3])), i[0] = ct(r + 1 / 3, n, s), i[1] = ct(r, n, s), i[2] = ct(r - 1 / 3, n, s);
									else i = t.match(f) || ut.transparent;
									i[0] = Number(i[0]), i[1] = Number(i[1]), i[2] = Number(i[2]), i.length > 3 && (i[3] = Number(i[3]))
								}
							else i = ut.black;
							return e && !d && (n = i[0] / 255, s = i[1] / 255, o = i[2] / 255, l = ((h = Math.max(n, s, o)) + (u = Math.min(n, s, o))) / 2, h === u ? r = a = 0 : (c = h - u, a = l > .5 ? c / (2 - h - u) : c / (h + u), r = h === n ? (s - o) / c + (s < o ? 6 : 0) : h === s ? (o - n) / c + 2 : (n - s) / c + 4, r *= 60), i[0] = r + .5 | 0, i[1] = 100 * a + .5 | 0, i[2] = 100 * l + .5 | 0), i
						},
						pt = function(t, e) {
							var i, n, s, o = t.match(_t) || [],
								r = 0,
								a = "";
							if (!o.length) return t;
							for (i = 0; i < o.length; i++) n = o[i], r += (s = t.substr(r, t.indexOf(n, r) - r)).length + n.length, 3 === (n = dt(n, e)).length && n.push(1), a += s + (e ? "hsla(" + n[0] + "," + n[1] + "%," + n[2] + "%," + n[3] : "rgba(" + n.join(",")) + ")";
							return a + t.substr(r)
						},
						_t = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
					for (l in ut) _t += "|" + l + "\\b";
					_t = new RegExp(_t + ")", "gi"), o.colorStringFilter = function(t) {
						var e, i = t[0] + " " + t[1];
						_t.test(i) && (e = -1 !== i.indexOf("hsl(") || -1 !== i.indexOf("hsla("), t[0] = pt(t[0], e), t[1] = pt(t[1], e)), _t.lastIndex = 0
					}, n.Ay.defaultStringFilter || (n.Ay.defaultStringFilter = o.colorStringFilter);
					var mt = function(t, e, i, n) {
							if (null == t) return function(t) {
								return t
							};
							var s, o = e ? (t.match(_t) || [""])[0] : "",
								r = t.split(o).join("").match(y) || [],
								a = t.substr(0, t.indexOf(r[0])),
								l = ")" === t.charAt(t.length - 1) ? ")" : "",
								h = -1 !== t.indexOf(" ") ? " " : ",",
								u = r.length,
								c = u > 0 ? r[0].replace(f, "") : "";
							return u ? e ? (s = function(t) {
								var e, d, p, _;
								if ("number" == typeof t) t += c;
								else if (n && N.test(t)) {
									for (_ = t.replace(N, "|").split("|"), p = 0; p < _.length; p++) _[p] = s(_[p]);
									return _.join(",")
								}
								if (e = (t.match(_t) || [o])[0], p = (d = t.split(e).join("").match(y) || []).length, u > p--)
									for (; ++p < u;) d[p] = i ? d[(p - 1) / 2 | 0] : r[p];
								return a + d.join(h) + h + e + l + (-1 !== t.indexOf("inset") ? " inset" : "")
							}, s) : (s = function(t) {
								var e, o, d;
								if ("number" == typeof t) t += c;
								else if (n && N.test(t)) {
									for (o = t.replace(N, "|").split("|"), d = 0; d < o.length; d++) o[d] = s(o[d]);
									return o.join(",")
								}
								if (d = (e = t.match(y) || []).length, u > d--)
									for (; ++d < u;) e[d] = i ? e[(d - 1) / 2 | 0] : r[d];
								return a + e.join(h) + l
							}, s) : function(t) {
								return t
							}
						},
						gt = function(t) {
							return t = t.split(","),
								function(e, i, n, s, o, r, a) {
									var l, h = (i + "").split(" ");
									for (a = {}, l = 0; l < 4; l++) a[t[l]] = h[l] = h[l] || h[(l - 1) / 2 | 0];
									return s.parse(e, a, o, r)
								}
						},
						ft = (V._setPluginRatio = function(t) {
							this.plugin.setRatio(t);
							for (var e, i, n, s, o, r = this.data, a = r.proxy, l = r.firstMPT, h = 1e-6; l;) e = a[l.v], l.r ? e = l.r(e) : e < h && e > -h && (e = 0), l.t[l.p] = e, l = l._next;
							if (r.autoRotate && (r.autoRotate.rotation = r.mod ? r.mod.call(this._tween, a.rotation, this.t, this._tween) : a.rotation), 1 === t || 0 === t)
								for (l = r.firstMPT, o = 1 === t ? "e" : "b"; l;) {
									if ((i = l.t).type) {
										if (1 === i.type) {
											for (s = i.xs0 + i.s + i.xs1, n = 1; n < i.l; n++) s += i["xn" + n] + i["xs" + (n + 1)];
											i[o] = s
										}
									} else i[o] = i.s + i.xs0;
									l = l._next
								}
						}, function(t, e, i, n, s) {
							this.t = t, this.p = e, this.v = i, this.r = s, n && (n._prev = this, this._next = n)
						}),
						St = (V._parseToProxy = function(t, e, i, n, s, o) {
							var r, a, l, h, u, c = n,
								d = {},
								p = {},
								_ = i._transform,
								m = k;
							for (i._transform = null, k = e, n = u = i.parse(t, e, n, s), k = m, o && (i._transform = _, c && (c._prev = null, c._prev && (c._prev._next = null))); n && n !== c;) {
								if (n.type <= 1 && (p[a = n.p] = n.s + n.c, d[a] = n.s, o || (h = new ft(n, "s", a, h, n.r), n.c = 0), 1 === n.type))
									for (r = n.l; --r > 0;) l = "xn" + r, p[a = n.p + "_" + l] = n.data[l], d[a] = n[l], o || (h = new ft(n, l, a, h, n.rxp[l]));
								n = n._next
							}
							return {
								proxy: d,
								end: p,
								firstMPT: h,
								pt: u
							}
						}, V.CSSPropTween = function(e, i, n, o, r, a, l, h, u, c, d) {
							this.t = e, this.p = i, this.s = n, this.c = o, this.n = l || i, e instanceof St || s.push(this.n), this.r = h ? "function" == typeof h ? h : Math.round : h, this.type = a || 0, u && (this.pr = u, t = !0), this.b = void 0 === c ? n : c, this.e = void 0 === d ? n + o : d, r && (this._next = r, r._prev = this)
						}),
						yt = function(t, e, i, n, s, o) {
							var r = new St(t, e, i, n - i, s, -1, o);
							return r.b = i, r.e = r.xs0 = n, r
						},
						vt = o.parseComplex = function(t, e, i, n, s, r, a, l, u, c) {
							i = i || r || "", "function" == typeof n && (n = n(g, m)), a = new St(t, e, 0, 0, a, c ? 2 : 1, null, !1, l, i, n), n += "", s && _t.test(n + i) && (n = [i, n], o.colorStringFilter(n), i = n[0], n = n[1]);
							var d, p, _, y, v, T, E, b, A, P, I, w, L, C = i.split(", ").join(",").split(" "),
								x = n.split(", ").join(",").split(" "),
								B = C.length,
								O = !1 !== h;
							for (-1 === n.indexOf(",") && -1 === i.indexOf(",") || (-1 !== (n + i).indexOf("rgb") || -1 !== (n + i).indexOf("hsl") ? (C = C.join(" ").replace(N, ", ").split(" "), x = x.join(" ").replace(N, ", ").split(" ")) : (C = C.join(" ").split(",").join(", ").split(" "), x = x.join(" ").split(",").join(", ").split(" ")), B = C.length), B !== x.length && (B = (C = (r || "").split(" ")).length), a.plugin = u, a.setRatio = c, _t.lastIndex = 0, d = 0; d < B; d++)
								if (y = C[d], v = x[d] + "", (b = parseFloat(y)) || 0 === b) a.appendXtra("", b, at(v, b), v.replace(S, ""), !(!O || -1 === v.indexOf("px")) && Math.round, !0);
								else if (s && _t.test(y)) w = ")" + ((w = v.indexOf(")") + 1) ? v.substr(w) : ""), L = -1 !== v.indexOf("hsl") && Y, P = v, y = dt(y, L), v = dt(v, L), (A = y.length + v.length > 6) && !Y && 0 === v[3] ? (a["xs" + a.l] += a.l ? " transparent" : "transparent", a.e = a.e.split(x[d]).join("transparent")) : (Y || (A = !1), L ? a.appendXtra(P.substr(0, P.indexOf("hsl")) + (A ? "hsla(" : "hsl("), y[0], at(v[0], y[0]), ",", !1, !0).appendXtra("", y[1], at(v[1], y[1]), "%,", !1).appendXtra("", y[2], at(v[2], y[2]), A ? "%," : "%" + w, !1) : a.appendXtra(P.substr(0, P.indexOf("rgb")) + (A ? "rgba(" : "rgb("), y[0], v[0] - y[0], ",", Math.round, !0).appendXtra("", y[1], v[1] - y[1], ",", Math.round).appendXtra("", y[2], v[2] - y[2], A ? "," : w, Math.round), A && (y = y.length < 4 ? 1 : y[3], a.appendXtra("", y, (v.length < 4 ? 1 : v[3]) - y, w, !1))), _t.lastIndex = 0;
							else if (T = y.match(f)) {
								if (!(E = v.match(S)) || E.length !== T.length) return a;
								for (_ = 0, p = 0; p < T.length; p++) I = T[p], P = y.indexOf(I, _), a.appendXtra(y.substr(_, P - _), Number(I), at(E[p], I), "", !(!O || "px" !== y.substr(P + I.length, 2)) && Math.round, 0 === p), _ = P + I.length;
								a["xs" + a.l] += y.substr(_)
							} else a["xs" + a.l] += a.l || a["xs" + a.l] ? " " + v : v;
							if (-1 !== n.indexOf("=") && a.data) {
								for (w = a.xs0 + a.data.s, d = 1; d < a.l; d++) w += a["xs" + d] + a.data["xn" + d];
								a.e = w + a["xs" + d]
							}
							return a.l || (a.type = -1, a.xs0 = a.e), a.xfirst || a
						},
						Tt = 9;
					for ((l = St.prototype).l = l.pr = 0; --Tt > 0;) l["xn" + Tt] = 0, l["xs" + Tt] = "";
					l.xs0 = "", l._next = l._prev = l.xfirst = l.data = l.plugin = l.setRatio = l.rxp = null, l.appendXtra = function(t, e, i, n, s, o) {
						var r = this,
							a = r.l;
						return r["xs" + a] += o && (a || r["xs" + a]) ? " " + t : t || "", i || 0 === a || r.plugin ? (r.l++, r.type = r.setRatio ? 2 : 1, r["xs" + r.l] = n || "", a > 0 ? (r.data["xn" + a] = e + i, r.rxp["xn" + a] = s, r["xn" + a] = e, r.plugin || (r.xfirst = new St(r, "xn" + a, e, i, r.xfirst || r, 0, r.n, s, r.pr), r.xfirst.xs0 = 0), r) : (r.data = {
							s: e + i
						}, r.rxp = {}, r.s = e, r.c = i, r.r = s, r)) : (r["xs" + a] += e + (n || ""), r)
					};
					var Et = function(t, e) {
							e = e || {}, this.p = e.prefix && Z(t) || t, a[t] = a[this.p] = this, this.format = e.formatter || mt(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.pr = e.priority || 0
						},
						bt = V._registerComplexSpecialProp = function(t, e, i) {
							"object" != typeof e && (e = {
								parser: i
							});
							var n, s = t.split(","),
								o = e.defaultValue;
							for (i = i || [o], n = 0; n < s.length; n++) e.prefix = 0 === n && e.prefix, e.defaultValue = i[n] || o, new Et(s[n], e)
						},
						At = V._registerPluginProp = function(t) {
							if (!a[t]) {
								var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin";
								bt(t, {
									parser: function(t, i, n, s, o, l, h) {
										var u = r.com.greensock.plugins[e];
										return u ? (u._cssRegister(), a[n].parse(t, i, n, s, o, l, h)) : (j("Error: " + e + " js file not loaded."), o)
									}
								})
							}
						};
					(l = Et.prototype).parseComplex = function(t, e, i, n, s, o) {
						var r, a, l, h, u, c, d = this.keyword;
						if (this.multi && (N.test(i) || N.test(e) ? (a = e.replace(N, "|").split("|"), l = i.replace(N, "|").split("|")) : d && (a = [e], l = [i])), l) {
							for (h = l.length > a.length ? l.length : a.length, r = 0; r < h; r++) e = a[r] = a[r] || this.dflt, i = l[r] = l[r] || this.dflt, d && (u = e.indexOf(d)) !== (c = i.indexOf(d)) && (-1 === c ? a[r] = a[r].split(d).join("") : -1 === u && (a[r] += " " + d));
							e = a.join(", "), i = l.join(", ")
						}
						return vt(t, this.p, e, i, this.clrs, this.dflt, n, this.pr, s, o)
					}, l.parse = function(t, e, n, s, o, r, a) {
						return this.parseComplex(t.style, this.format(Q(t, this.p, i, !1, this.dflt)), this.format(e), o, r)
					}, o.registerSpecialProp = function(t, e, i) {
						bt(t, {
							parser: function(t, n, s, o, r, a, l) {
								var h = new St(t, s, 0, 0, r, 2, s, !1, i);
								return h.plugin = a, h.setRatio = e(t, n, o._tween, s), h
							},
							priority: i
						})
					}, o.useSVGTransformAttr = !0;
					var Pt, It, wt, Lt, Ct, xt = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
						Bt = Z("transform"),
						Ot = K + "transform",
						Nt = Z("transformOrigin"),
						Mt = null !== Z("perspective"),
						Rt = V.Transform = function() {
							this.perspective = parseFloat(o.defaultTransformPerspective) || 0, this.force3D = !(!1 === o.defaultForce3D || !Mt) && (o.defaultForce3D || "auto")
						},
						Dt = n.uW.SVGElement,
						kt = function(t, e, i) {
							var n, s = G.createElementNS("http://www.w3.org/2000/svg", t),
								o = /([a-z])([A-Z])/g;
							for (n in i) s.setAttributeNS(null, n.replace(o, "$1-$2").toLowerCase(), i[n]);
							return e.appendChild(s), s
						},
						Ft = G.documentElement || {},
						Gt = (Ct = _ || /Android/i.test(X) && !n.uW.chrome, G.createElementNS && !Ct && (It = kt("svg", Ft), Lt = (wt = kt("rect", It, {
							width: 100,
							height: 50,
							x: 100
						})).getBoundingClientRect().width, wt.style[Nt] = "50% 50%", wt.style[Bt] = "scaleX(0.5)", Ct = Lt === wt.getBoundingClientRect().width && !(d && Mt), Ft.removeChild(It)), Ct),
						Ut = function(t, e, i, n, s, r) {
							var a, l, h, u, c, d, p, _, m, g, f, S, y, v, T = t._gsTransform,
								E = Xt(t, !0);
							T && (y = T.xOrigin, v = T.yOrigin), (!n || (a = n.split(" ")).length < 2) && (0 === (p = t.getBBox()).x && 0 === p.y && p.width + p.height === 0 && (p = {
								x: parseFloat(t.hasAttribute("x") ? t.getAttribute("x") : t.hasAttribute("cx") ? t.getAttribute("cx") : 0) || 0,
								y: parseFloat(t.hasAttribute("y") ? t.getAttribute("y") : t.hasAttribute("cy") ? t.getAttribute("cy") : 0) || 0,
								width: 0,
								height: 0
							}), a = [(-1 !== (e = rt(e).split(" "))[0].indexOf("%") ? parseFloat(e[0]) / 100 * p.width : parseFloat(e[0])) + p.x, (-1 !== e[1].indexOf("%") ? parseFloat(e[1]) / 100 * p.height : parseFloat(e[1])) + p.y]), i.xOrigin = u = parseFloat(a[0]), i.yOrigin = c = parseFloat(a[1]), n && E !== Vt && (d = E[0], p = E[1], _ = E[2], m = E[3], g = E[4], f = E[5], (S = d * m - p * _) && (l = u * (m / S) + c * (-_ / S) + (_ * f - m * g) / S, h = u * (-p / S) + c * (d / S) - (d * f - p * g) / S, u = i.xOrigin = a[0] = l, c = i.yOrigin = a[1] = h)), T && (r && (i.xOffset = T.xOffset, i.yOffset = T.yOffset, T = i), s || !1 !== s && !1 !== o.defaultSmoothOrigin ? (l = u - y, h = c - v, T.xOffset += l * E[0] + h * E[2] - l, T.yOffset += l * E[1] + h * E[3] - h) : T.xOffset = T.yOffset = 0), r || t.setAttribute("data-svg-origin", a.join(" "))
						},
						Wt = function(t) {
							var e, i = U("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
								n = this.parentNode,
								s = this.nextSibling,
								o = this.style.cssText;
							if (Ft.appendChild(i), i.appendChild(this), this.style.display = "block", t) try {
								e = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = Wt
							} catch (t) {} else this._originalGetBBox && (e = this._originalGetBBox());
							return s ? n.insertBefore(this, s) : n.appendChild(this), Ft.removeChild(i), this.style.cssText = o, e
						},
						Ht = function(t) {
							return !(!Dt || !t.getCTM || t.parentNode && !t.ownerSVGElement || ! function(t) {
								try {
									return t.getBBox()
								} catch (e) {
									return Wt.call(t, !0)
								}
							}(t))
						},
						Vt = [1, 0, 0, 1, 0, 0],
						Xt = function(t, e) {
							var i, n, s, o, r, a, l = t._gsTransform || new Rt,
								h = 1e5,
								u = t.style;
							if (Bt ? n = Q(t, Ot, null, !0) : t.currentStyle && (n = (n = t.currentStyle.filter.match(B)) && 4 === n.length ? [n[0].substr(4), Number(n[2].substr(4)), Number(n[1].substr(4)), n[3].substr(4), l.x || 0, l.y || 0].join(",") : ""), i = !n || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, !Bt || !(a = !$(t) || "none" === $(t).display) && t.parentNode || (a && (o = u.display, u.display = "block"), t.parentNode || (r = 1, Ft.appendChild(t)), i = !(n = Q(t, Ot, null, !0)) || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, o ? u.display = o : a && qt(u, "display"), r && Ft.removeChild(t)), (l.svg || t.getCTM && Ht(t)) && (i && -1 !== (u[Bt] + "").indexOf("matrix") && (n = u[Bt], i = 0), s = t.getAttribute("transform"), i && s && (n = "matrix(" + (s = t.transform.baseVal.consolidate().matrix).a + "," + s.b + "," + s.c + "," + s.d + "," + s.e + "," + s.f + ")", i = 0)), i) return Vt;
							for (s = (n || "").match(f) || [], Tt = s.length; --Tt > -1;) o = Number(s[Tt]), s[Tt] = (r = o - (o |= 0)) ? (r * h + (r < 0 ? -.5 : .5) | 0) / h + o : o;
							return e && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s
						},
						Yt = V.getTransform = function(t, e, i, s) {
							if (t._gsTransform && i && !s) return t._gsTransform;
							var r, a, l, h, u, c, d = i && t._gsTransform || new Rt,
								p = d.scaleX < 0,
								_ = 2e-5,
								m = 1e5,
								g = Mt && (parseFloat(Q(t, Nt, e, !1, "0 0 0").split(" ")[2]) || d.zOrigin) || 0,
								f = parseFloat(o.defaultTransformPerspective) || 0;
							if (d.svg = !(!t.getCTM || !Ht(t)), d.svg && (Ut(t, Q(t, Nt, e, !1, "50% 50%") + "", d, t.getAttribute("data-svg-origin")), Pt = o.useSVGTransformAttr || Gt), (r = Xt(t)) !== Vt) {
								if (16 === r.length) {
									var S, y, v, T, E, b = r[0],
										A = r[1],
										P = r[2],
										I = r[3],
										w = r[4],
										L = r[5],
										C = r[6],
										x = r[7],
										B = r[8],
										O = r[9],
										N = r[10],
										M = r[12],
										R = r[13],
										k = r[14],
										F = r[11],
										G = Math.atan2(C, N);
									d.zOrigin && (M = B * (k = -d.zOrigin) - r[12], R = O * k - r[13], k = N * k + d.zOrigin - r[14]), d.rotationX = G * D, G && (S = w * (T = Math.cos(-G)) + B * (E = Math.sin(-G)), y = L * T + O * E, v = C * T + N * E, B = w * -E + B * T, O = L * -E + O * T, N = C * -E + N * T, F = x * -E + F * T, w = S, L = y, C = v), G = Math.atan2(-P, N), d.rotationY = G * D, G && (y = A * (T = Math.cos(-G)) - O * (E = Math.sin(-G)), v = P * T - N * E, O = A * E + O * T, N = P * E + N * T, F = I * E + F * T, b = S = b * T - B * E, A = y, P = v), G = Math.atan2(A, b), d.rotation = G * D, G && (S = b * (T = Math.cos(G)) + A * (E = Math.sin(G)), y = w * T + L * E, v = B * T + O * E, A = A * T - b * E, L = L * T - w * E, O = O * T - B * E, b = S, w = y, B = v), d.rotationX && Math.abs(d.rotationX) + Math.abs(d.rotation) > 359.9 && (d.rotationX = d.rotation = 0, d.rotationY = 180 - d.rotationY), G = Math.atan2(w, L), d.scaleX = (Math.sqrt(b * b + A * A + P * P) * m + .5 | 0) / m, d.scaleY = (Math.sqrt(L * L + C * C) * m + .5 | 0) / m, d.scaleZ = (Math.sqrt(B * B + O * O + N * N) * m + .5 | 0) / m, b /= d.scaleX, w /= d.scaleY, A /= d.scaleX, L /= d.scaleY, Math.abs(G) > _ ? (d.skewX = G * D, w = 0, "simple" !== d.skewType && (d.scaleY *= 1 / Math.cos(G))) : d.skewX = 0, d.perspective = F ? 1 / (F < 0 ? -F : F) : 0, d.x = M, d.y = R, d.z = k, d.svg && (d.x -= d.xOrigin - (d.xOrigin * b - d.yOrigin * w), d.y -= d.yOrigin - (d.yOrigin * A - d.xOrigin * L))
								} else if (!Mt || s || !r.length || d.x !== r[4] || d.y !== r[5] || !d.rotationX && !d.rotationY) {
									var U = r.length >= 6,
										W = U ? r[0] : 1,
										H = r[1] || 0,
										V = r[2] || 0,
										X = U ? r[3] : 1;
									d.x = r[4] || 0, d.y = r[5] || 0, l = Math.sqrt(W * W + H * H), h = Math.sqrt(X * X + V * V), u = W || H ? Math.atan2(H, W) * D : d.rotation || 0, c = V || X ? Math.atan2(V, X) * D + u : d.skewX || 0, d.scaleX = l, d.scaleY = h, d.rotation = u, d.skewX = c, Mt && (d.rotationX = d.rotationY = d.z = 0, d.perspective = f, d.scaleZ = 1), d.svg && (d.x -= d.xOrigin - (d.xOrigin * W + d.yOrigin * V), d.y -= d.yOrigin - (d.xOrigin * H + d.yOrigin * X))
								}
								for (a in Math.abs(d.skewX) > 90 && Math.abs(d.skewX) < 270 && (p ? (d.scaleX *= -1, d.skewX += d.rotation <= 0 ? 180 : -180, d.rotation += d.rotation <= 0 ? 180 : -180) : (d.scaleY *= -1, d.skewX += d.skewX <= 0 ? 180 : -180)), d.zOrigin = g, d) d[a] < _ && d[a] > -_ && (d[a] = 0)
							}
							return i && (t._gsTransform = d, d.svg && (Pt && t.style[Bt] ? n.Ay.delayedCall(.001, (function() {
								qt(t.style, Bt)
							})) : !Pt && t.getAttribute("transform") && n.Ay.delayedCall(.001, (function() {
								t.removeAttribute("transform")
							})))), d
						},
						zt = function(t) {
							var e, i, n = this.data,
								s = -n.rotation * R,
								o = s + n.skewX * R,
								r = 1e5,
								a = (Math.cos(s) * n.scaleX * r | 0) / r,
								l = (Math.sin(s) * n.scaleX * r | 0) / r,
								h = (Math.sin(o) * -n.scaleY * r | 0) / r,
								u = (Math.cos(o) * n.scaleY * r | 0) / r,
								c = this.t.style,
								d = this.t.currentStyle;
							if (d) {
								i = l, l = -h, h = -i, e = d.filter, c.filter = "";
								var p, m, g = this.t.offsetWidth,
									f = this.t.offsetHeight,
									S = "absolute" !== d.position,
									y = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + l + ", M21=" + h + ", M22=" + u,
									v = n.x + g * n.xPercent / 100,
									b = n.y + f * n.yPercent / 100;
								if (null != n.ox && (v += (p = (n.oxp ? g * n.ox * .01 : n.ox) - g / 2) - (p * a + (m = (n.oyp ? f * n.oy * .01 : n.oy) - f / 2) * l), b += m - (p * h + m * u)), y += S ? ", Dx=" + ((p = g / 2) - (p * a + (m = f / 2) * l) + v) + ", Dy=" + (m - (p * h + m * u) + b) + ")" : ", sizingMethod='auto expand')", -1 !== e.indexOf("DXImageTransform.Microsoft.Matrix(") ? c.filter = e.replace(O, y) : c.filter = y + " " + e, 0 !== t && 1 !== t || 1 === a && 0 === l && 0 === h && 1 === u && (S && -1 === y.indexOf("Dx=0, Dy=0") || E.test(e) && 100 !== parseFloat(RegExp.$1) || -1 === e.indexOf(e.indexOf("Alpha")) && c.removeAttribute("filter")), !S) {
									var A, P, I, w = _ < 8 ? 1 : -1;
									for (p = n.ieOffsetX || 0, m = n.ieOffsetY || 0, n.ieOffsetX = Math.round((g - ((a < 0 ? -a : a) * g + (l < 0 ? -l : l) * f)) / 2 + v), n.ieOffsetY = Math.round((f - ((u < 0 ? -u : u) * f + (h < 0 ? -h : h) * g)) / 2 + b), Tt = 0; Tt < 4; Tt++) I = (i = -1 !== (A = d[P = st[Tt]]).indexOf("px") ? parseFloat(A) : J(this.t, P, parseFloat(A), A.replace(T, "")) || 0) !== n[P] ? Tt < 2 ? -n.ieOffsetX : -n.ieOffsetY : Tt < 2 ? p - n.ieOffsetX : m - n.ieOffsetY, c[P] = (n[P] = Math.round(i - I * (0 === Tt || 2 === Tt ? 1 : w))) + "px"
								}
							}
						},
						jt = V.set3DTransformRatio = V.setTransformRatio = function(t) {
							var e, i, n, s, o, r, a, l, h, u, c, p, _, m, g, f, S, y, v, T, E, b, A, P = this.data,
								I = this.t.style,
								w = P.rotation,
								L = P.rotationX,
								C = P.rotationY,
								x = P.scaleX,
								B = P.scaleY,
								O = P.scaleZ,
								N = P.x,
								M = P.y,
								D = P.z,
								k = P.svg,
								F = P.perspective,
								G = P.force3D,
								U = P.skewY,
								W = P.skewX;
							if (U && (W += U, w += U), !((1 !== t && 0 !== t || "auto" !== G || this.tween._totalTime !== this.tween._totalDuration && this.tween._totalTime) && G || D || F || C || L || 1 !== O) || Pt && k || !Mt) w || W || k ? (w *= R, b = W * R, A = 1e5, i = Math.cos(w) * x, o = Math.sin(w) * x, n = Math.sin(w - b) * -B, r = Math.cos(w - b) * B, b && "simple" === P.skewType && (e = Math.tan(b - U * R), n *= e = Math.sqrt(1 + e * e), r *= e, U && (e = Math.tan(U * R), i *= e = Math.sqrt(1 + e * e), o *= e)), k && (N += P.xOrigin - (P.xOrigin * i + P.yOrigin * n) + P.xOffset, M += P.yOrigin - (P.xOrigin * o + P.yOrigin * r) + P.yOffset, Pt && (P.xPercent || P.yPercent) && (g = this.t.getBBox(), N += .01 * P.xPercent * g.width, M += .01 * P.yPercent * g.height), N < (g = 1e-6) && N > -g && (N = 0), M < g && M > -g && (M = 0)), v = (i * A | 0) / A + "," + (o * A | 0) / A + "," + (n * A | 0) / A + "," + (r * A | 0) / A + "," + N + "," + M + ")", k && Pt ? this.t.setAttribute("transform", "matrix(" + v) : I[Bt] = (P.xPercent || P.yPercent ? "translate(" + P.xPercent + "%," + P.yPercent + "%) matrix(" : "matrix(") + v) : I[Bt] = (P.xPercent || P.yPercent ? "translate(" + P.xPercent + "%," + P.yPercent + "%) matrix(" : "matrix(") + x + ",0,0," + B + "," + N + "," + M + ")";
							else {
								if (d && (x < (g = 1e-4) && x > -g && (x = O = 2e-5), B < g && B > -g && (B = O = 2e-5), !F || P.z || P.rotationX || P.rotationY || (F = 0)), w || W) w *= R, f = i = Math.cos(w), S = o = Math.sin(w), W && (w -= W * R, f = Math.cos(w), S = Math.sin(w), "simple" === P.skewType && (e = Math.tan((W - U) * R), f *= e = Math.sqrt(1 + e * e), S *= e, P.skewY && (e = Math.tan(U * R), i *= e = Math.sqrt(1 + e * e), o *= e))), n = -S, r = f;
								else {
									if (!(C || L || 1 !== O || F || k)) return void(I[Bt] = (P.xPercent || P.yPercent ? "translate(" + P.xPercent + "%," + P.yPercent + "%) translate3d(" : "translate3d(") + N + "px," + M + "px," + D + "px)" + (1 !== x || 1 !== B ? " scale(" + x + "," + B + ")" : ""));
									i = r = 1, n = o = 0
								}
								u = 1, s = a = l = h = c = p = 0, _ = F ? -1 / F : 0, m = P.zOrigin, g = 1e-6, T = ",", E = "0", (w = C * R) && (f = Math.cos(w), l = -(S = Math.sin(w)), c = _ * -S, s = i * S, a = o * S, u = f, _ *= f, i *= f, o *= f), (w = L * R) && (e = n * (f = Math.cos(w)) + s * (S = Math.sin(w)), y = r * f + a * S, h = u * S, p = _ * S, s = n * -S + s * f, a = r * -S + a * f, u *= f, _ *= f, n = e, r = y), 1 !== O && (s *= O, a *= O, u *= O, _ *= O), 1 !== B && (n *= B, r *= B, h *= B, p *= B), 1 !== x && (i *= x, o *= x, l *= x, c *= x), (m || k) && (m && (N += s * -m, M += a * -m, D += u * -m + m), k && (N += P.xOrigin - (P.xOrigin * i + P.yOrigin * n) + P.xOffset, M += P.yOrigin - (P.xOrigin * o + P.yOrigin * r) + P.yOffset), N < g && N > -g && (N = E), M < g && M > -g && (M = E), D < g && D > -g && (D = 0)), v = P.xPercent || P.yPercent ? "translate(" + P.xPercent + "%," + P.yPercent + "%) matrix3d(" : "matrix3d(", v += (i < g && i > -g ? E : i) + T + (o < g && o > -g ? E : o) + T + (l < g && l > -g ? E : l), v += T + (c < g && c > -g ? E : c) + T + (n < g && n > -g ? E : n) + T + (r < g && r > -g ? E : r), L || C || 1 !== O ? (v += T + (h < g && h > -g ? E : h) + T + (p < g && p > -g ? E : p) + T + (s < g && s > -g ? E : s), v += T + (a < g && a > -g ? E : a) + T + (u < g && u > -g ? E : u) + T + (_ < g && _ > -g ? E : _) + T) : v += ",0,0,0,0,1,0,", v += N + T + M + T + D + T + (F ? 1 + -D / F : 1) + ")", I[Bt] = v
							}
						};
					(l = Rt.prototype).x = l.y = l.z = l.skewX = l.skewY = l.rotation = l.rotationX = l.rotationY = l.zOrigin = l.xPercent = l.yPercent = l.xOffset = l.yOffset = 0, l.scaleX = l.scaleY = l.scaleZ = 1, bt("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
						parser: function(t, e, n, s, r, a, l) {
							if (s._lastParsedTransform === l) return r;
							s._lastParsedTransform = l;
							var h, u = l.scale && "function" == typeof l.scale ? l.scale : 0;
							"function" == typeof l[n] && (h = l[n], l[n] = e), u && (l.scale = u(g, t));
							var c, d, p, _, f, S, y, v, T, E = t._gsTransform,
								b = t.style,
								A = 1e-6,
								P = xt.length,
								I = l,
								w = {},
								L = "transformOrigin",
								C = Yt(t, i, !0, I.parseTransform),
								x = I.transform && ("function" == typeof I.transform ? I.transform(g, m) : I.transform);
							if (C.skewType = I.skewType || C.skewType || o.defaultSkewType, s._transform = C, "rotationZ" in I && (I.rotation = I.rotationZ), x && "string" == typeof x && Bt)(d = W.style)[Bt] = x, d.display = "block", d.position = "absolute", -1 !== x.indexOf("%") && (d.width = Q(t, "width"), d.height = Q(t, "height")), G.body.appendChild(W), c = Yt(W, null, !1), "simple" === C.skewType && (c.scaleY *= Math.cos(c.skewX * R)), C.svg && (S = C.xOrigin, y = C.yOrigin, c.x -= C.xOffset, c.y -= C.yOffset, (I.transformOrigin || I.svgOrigin) && (x = {}, Ut(t, rt(I.transformOrigin), x, I.svgOrigin, I.smoothOrigin, !0), S = x.xOrigin, y = x.yOrigin, c.x -= x.xOffset - C.xOffset, c.y -= x.yOffset - C.yOffset), (S || y) && (v = Xt(W, !0), c.x -= S - (S * v[0] + y * v[2]), c.y -= y - (S * v[1] + y * v[3]))), G.body.removeChild(W), c.perspective || (c.perspective = C.perspective), null != I.xPercent && (c.xPercent = lt(I.xPercent, C.xPercent)), null != I.yPercent && (c.yPercent = lt(I.yPercent, C.yPercent));
							else if ("object" == typeof I) {
								if (c = {
										scaleX: lt(null != I.scaleX ? I.scaleX : I.scale, C.scaleX),
										scaleY: lt(null != I.scaleY ? I.scaleY : I.scale, C.scaleY),
										scaleZ: lt(I.scaleZ, C.scaleZ),
										x: lt(I.x, C.x),
										y: lt(I.y, C.y),
										z: lt(I.z, C.z),
										xPercent: lt(I.xPercent, C.xPercent),
										yPercent: lt(I.yPercent, C.yPercent),
										perspective: lt(I.transformPerspective, C.perspective)
									}, null != (f = I.directionalRotation))
									if ("object" == typeof f)
										for (d in f) I[d] = f[d];
									else I.rotation = f;
								"string" == typeof I.x && -1 !== I.x.indexOf("%") && (c.x = 0, c.xPercent = lt(I.x, C.xPercent)), "string" == typeof I.y && -1 !== I.y.indexOf("%") && (c.y = 0, c.yPercent = lt(I.y, C.yPercent)), c.rotation = ht("rotation" in I ? I.rotation : "shortRotation" in I ? I.shortRotation + "_short" : C.rotation, C.rotation, "rotation", w), Mt && (c.rotationX = ht("rotationX" in I ? I.rotationX : "shortRotationX" in I ? I.shortRotationX + "_short" : C.rotationX || 0, C.rotationX, "rotationX", w), c.rotationY = ht("rotationY" in I ? I.rotationY : "shortRotationY" in I ? I.shortRotationY + "_short" : C.rotationY || 0, C.rotationY, "rotationY", w)), c.skewX = ht(I.skewX, C.skewX), c.skewY = ht(I.skewY, C.skewY)
							}
							for (Mt && null != I.force3D && (C.force3D = I.force3D, _ = !0), (p = C.force3D || C.z || C.rotationX || C.rotationY || c.z || c.rotationX || c.rotationY || c.perspective) || null == I.scale || (c.scaleZ = 1); --P > -1;)((x = c[T = xt[P]] - C[T]) > A || x < -A || null != I[T] || null != k[T]) && (_ = !0, r = new St(C, T, C[T], x, r), T in w && (r.e = w[T]), r.xs0 = 0, r.plugin = a, s._overwriteProps.push(r.n));
							return x = I.transformOrigin, C.svg && (x || I.svgOrigin) && (S = C.xOffset, y = C.yOffset, Ut(t, rt(x), c, I.svgOrigin, I.smoothOrigin), r = yt(C, "xOrigin", (E ? C : c).xOrigin, c.xOrigin, r, L), r = yt(C, "yOrigin", (E ? C : c).yOrigin, c.yOrigin, r, L), S === C.xOffset && y === C.yOffset || (r = yt(C, "xOffset", E ? S : C.xOffset, C.xOffset, r, L), r = yt(C, "yOffset", E ? y : C.yOffset, C.yOffset, r, L)), x = "0px 0px"), (x || Mt && p && C.zOrigin) && (Bt ? (_ = !0, T = Nt, x = (x || Q(t, T, i, !1, "50% 50%")) + "", (r = new St(b, T, 0, 0, r, -1, L)).b = b[T], r.plugin = a, Mt ? (d = C.zOrigin, x = x.split(" "), C.zOrigin = (x.length > 2 && (0 === d || "0px" !== x[2]) ? parseFloat(x[2]) : d) || 0, r.xs0 = r.e = x[0] + " " + (x[1] || "50%") + " 0px", (r = new St(C, "zOrigin", 0, 0, r, -1, r.n)).b = d, r.xs0 = r.e = C.zOrigin) : r.xs0 = r.e = x) : rt(x + "", C)), _ && (s._transformType = C.svg && Pt || !p && 3 !== this._transformType ? 2 : 3), h && (l[n] = h), u && (l.scale = u), r
						},
						prefix: !0
					}), bt("boxShadow", {
						defaultValue: "0px 0px 0px 0px #999",
						prefix: !0,
						color: !0,
						multi: !0,
						keyword: "inset"
					}), bt("borderRadius", {
						defaultValue: "0px",
						parser: function(t, n, s, o, r, a) {
							n = this.format(n);
							var l, h, u, c, d, p, _, m, g, f, S, y, v, T, E, b, A = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
								P = t.style;
							for (g = parseFloat(t.offsetWidth), f = parseFloat(t.offsetHeight), l = n.split(" "), h = 0; h < A.length; h++) this.p.indexOf("border") && (A[h] = Z(A[h])), -1 !== (d = c = Q(t, A[h], i, !1, "0px")).indexOf(" ") && (c = d.split(" "), d = c[0], c = c[1]), p = u = l[h], _ = parseFloat(d), y = d.substr((_ + "").length), (v = "=" === p.charAt(1)) ? (m = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), m *= parseFloat(p), S = p.substr((m + "").length - (m < 0 ? 1 : 0)) || "") : (m = parseFloat(p), S = p.substr((m + "").length)), "" === S && (S = e[s] || y), S !== y && (T = J(t, "borderLeft", _, y), E = J(t, "borderTop", _, y), "%" === S ? (d = T / g * 100 + "%", c = E / f * 100 + "%") : "em" === S ? (d = T / (b = J(t, "borderLeft", 1, "em")) + "em", c = E / b + "em") : (d = T + "px", c = E + "px"), v && (p = parseFloat(d) + m + S, u = parseFloat(c) + m + S)), r = vt(P, A[h], d + " " + c, p + " " + u, !1, "0px", r);
							return r
						},
						prefix: !0,
						formatter: mt("0px 0px 0px 0px", !1, !0)
					}), bt("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
						defaultValue: "0px",
						parser: function(t, e, n, s, o, r) {
							return vt(t.style, n, this.format(Q(t, n, i, !1, "0px 0px")), this.format(e), !1, "0px", o)
						},
						prefix: !0,
						formatter: mt("0px 0px", !1, !0)
					}), bt("backgroundPosition", {
						defaultValue: "0 0",
						parser: function(t, e, n, s, o, r) {
							var a, l, h, u, c, d, p = "background-position",
								m = i || $(t, null),
								g = this.format((m ? _ ? m.getPropertyValue(p + "-x") + " " + m.getPropertyValue(p + "-y") : m.getPropertyValue(p) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
								f = this.format(e);
							if (-1 !== g.indexOf("%") != (-1 !== f.indexOf("%")) && f.split(",").length < 2 && (d = Q(t, "backgroundImage").replace(L, "")) && "none" !== d) {
								for (a = g.split(" "), l = f.split(" "), H.setAttribute("src", d), h = 2; --h > -1;)(u = -1 !== (g = a[h]).indexOf("%")) != (-1 !== l[h].indexOf("%")) && (c = 0 === h ? t.offsetWidth - H.width : t.offsetHeight - H.height, a[h] = u ? parseFloat(g) / 100 * c + "px" : parseFloat(g) / c * 100 + "%");
								g = a.join(" ")
							}
							return this.parseComplex(t.style, g, f, o, r)
						},
						formatter: rt
					}), bt("backgroundSize", {
						defaultValue: "0 0",
						formatter: function(t) {
							return "co" === (t += "").substr(0, 2) ? t : rt(-1 === t.indexOf(" ") ? t + " " + t : t)
						}
					}), bt("perspective", {
						defaultValue: "0px",
						prefix: !0
					}), bt("perspectiveOrigin", {
						defaultValue: "50% 50%",
						prefix: !0
					}), bt("transformStyle", {
						prefix: !0
					}), bt("backfaceVisibility", {
						prefix: !0
					}), bt("userSelect", {
						prefix: !0
					}), bt("margin", {
						parser: gt("marginTop,marginRight,marginBottom,marginLeft")
					}), bt("padding", {
						parser: gt("paddingTop,paddingRight,paddingBottom,paddingLeft")
					}), bt("clip", {
						defaultValue: "rect(0px,0px,0px,0px)",
						parser: function(t, e, n, s, o, r) {
							var a, l, h;
							return _ < 9 ? (l = t.currentStyle, h = _ < 8 ? " " : ",", a = "rect(" + l.clipTop + h + l.clipRight + h + l.clipBottom + h + l.clipLeft + ")", e = this.format(e).split(",").join(h)) : (a = this.format(Q(t, this.p, i, !1, this.dflt)), e = this.format(e)), this.parseComplex(t.style, a, e, o, r)
						}
					}), bt("textShadow", {
						defaultValue: "0px 0px 0px #999",
						color: !0,
						multi: !0
					}), bt("autoRound,strictUnits", {
						parser: function(t, e, i, n, s) {
							return s
						}
					}), bt("border", {
						defaultValue: "0px solid #000",
						parser: function(t, e, n, s, o, r) {
							var a = Q(t, "borderTopWidth", i, !1, "0px"),
								l = this.format(e).split(" "),
								h = l[0].replace(T, "");
							return "px" !== h && (a = parseFloat(a) / J(t, "borderTopWidth", 1, h) + h), this.parseComplex(t.style, this.format(a + " " + Q(t, "borderTopStyle", i, !1, "solid") + " " + Q(t, "borderTopColor", i, !1, "#000")), l.join(" "), o, r)
						},
						color: !0,
						formatter: function(t) {
							var e = t.split(" ");
							return e[0] + " " + (e[1] || "solid") + " " + (t.match(_t) || ["#000"])[0]
						}
					}), bt("borderWidth", {
						parser: gt("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
					}), bt("float,cssFloat,styleFloat", {
						parser: function(t, e, i, n, s, o) {
							var r = t.style,
								a = "cssFloat" in r ? "cssFloat" : "styleFloat";
							return new St(r, a, 0, 0, s, -1, i, !1, 0, r[a], e)
						}
					});
					var Kt = function(t) {
						var e, i = this.t,
							n = i.filter || Q(this.data, "filter") || "",
							s = this.s + this.c * t | 0;
						100 === s && (-1 === n.indexOf("atrix(") && -1 === n.indexOf("radient(") && -1 === n.indexOf("oader(") ? (i.removeAttribute("filter"), e = !Q(this.data, "filter")) : (i.filter = n.replace(A, ""), e = !0)), e || (this.xn1 && (i.filter = n = n || "alpha(opacity=" + s + ")"), -1 === n.indexOf("pacity") ? 0 === s && this.xn1 || (i.filter = n + " alpha(opacity=" + s + ")") : i.filter = n.replace(E, "opacity=" + s))
					};
					bt("opacity,alpha,autoAlpha", {
						defaultValue: "1",
						parser: function(t, e, n, s, o, r) {
							var a = parseFloat(Q(t, "opacity", i, !1, "1")),
								l = t.style,
								h = "autoAlpha" === n;
							return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + a), h && 1 === a && "hidden" === Q(t, "visibility", i) && 0 !== e && (a = 0), Y ? o = new St(l, "opacity", a, e - a, o) : ((o = new St(l, "opacity", 100 * a, 100 * (e - a), o)).xn1 = h ? 1 : 0, l.zoom = 1, o.type = 2, o.b = "alpha(opacity=" + o.s + ")", o.e = "alpha(opacity=" + (o.s + o.c) + ")", o.data = t, o.plugin = r, o.setRatio = Kt), h && ((o = new St(l, "visibility", 0, 0, o, -1, null, !1, 0, 0 !== a ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit")).xs0 = "inherit", s._overwriteProps.push(o.n), s._overwriteProps.push(n)), o
						}
					});
					var qt = function(t, e) {
							e && (t.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), t.removeProperty(e.replace(I, "-$1").toLowerCase())) : t.removeAttribute(e))
						},
						Zt = function(t) {
							if (this.t._gsClassPT = this, 1 === t || 0 === t) {
								this.t.setAttribute("class", 0 === t ? this.b : this.e);
								for (var e = this.data, i = this.t.style; e;) e.v ? i[e.p] = e.v : qt(i, e.p), e = e._next;
								1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null)
							} else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
						};
					bt("className", {
						parser: function(e, n, s, o, r, a, l) {
							var h, u, c, d, p, _ = e.getAttribute("class") || "",
								m = e.style.cssText;
							if ((r = o._classNamePT = new St(e, s, 0, 0, r, 2)).setRatio = Zt, r.pr = -11, t = !0, r.b = _, u = et(e, i), c = e._gsClassPT) {
								for (d = {}, p = c.data; p;) d[p.p] = 1, p = p._next;
								c.setRatio(1)
							}
							return e._gsClassPT = r, r.e = "=" !== n.charAt(1) ? n : _.replace(new RegExp("(?:\\s|^)" + n.substr(2) + "(?![\\w-])"), "") + ("+" === n.charAt(0) ? " " + n.substr(2) : ""), e.setAttribute("class", r.e), h = it(e, u, et(e), l, d), e.setAttribute("class", _), r.data = h.firstMPT, e.style.cssText = m, r.xfirst = o.parse(e, h.difs, r, a)
						}
					});
					var $t = function(t) {
						if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
							var e, i, n, s, o, r = this.t.style,
								l = a.transform.parse;
							if ("all" === this.e) r.cssText = "", s = !0;
							else
								for (n = (e = this.e.split(" ").join("").split(",")).length; --n > -1;) i = e[n], a[i] && (a[i].parse === l ? s = !0 : i = "transformOrigin" === i ? Nt : a[i].p), qt(r, i);
							s && (qt(r, Bt), (o = this.t._gsTransform) && (o.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform))
						}
					};
					for (bt("clearProps", {
							parser: function(e, i, n, s, o) {
								return (o = new St(e, n, 0, 0, o, 2)).setRatio = $t, o.e = i, o.pr = -10, o.data = s._tween, t = !0, o
							}
						}), l = "bezier,throwProps,physicsProps,physics2D".split(","), Tt = l.length; Tt--;) At(l[Tt]);
					(l = o.prototype)._firstPT = l._lastParsedTransform = l._transform = null, l._onInitTween = function(n, r, l, d) {
						if (!n.nodeType) return !1;
						this._target = m = n, this._tween = l, this._vars = r, g = d, h = r.autoRound, t = !1, e = r.suffixMap || o.suffixMap, i = $(n, ""), s = this._overwriteProps;
						var _, f, S, y, v, T, E, A, P, I = n.style;
						if (u && "" === I.zIndex && ("auto" !== (_ = Q(n, "zIndex", i)) && "" !== _ || this._addLazySet(I, "zIndex", 0)), "string" == typeof r && (y = I.cssText, _ = et(n, i), I.cssText = y + ";" + r, _ = it(n, _, et(n)).difs, !Y && b.test(r) && (_.opacity = parseFloat(RegExp.$1)), r = _, I.cssText = y), r.className ? this._firstPT = f = a.className.parse(n, r.className, "className", this, null, null, r) : this._firstPT = f = this.parse(n, r, null), this._transformType) {
							for (P = 3 === this._transformType, Bt ? c && (u = !0, "" === I.zIndex && ("auto" !== (E = Q(n, "zIndex", i)) && "" !== E || this._addLazySet(I, "zIndex", 0)), p && this._addLazySet(I, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (P ? "visible" : "hidden"))) : I.zoom = 1, S = f; S && S._next;) S = S._next;
							A = new St(n, "transform", 0, 0, null, 2), this._linkCSSP(A, null, S), A.setRatio = Bt ? jt : zt, A.data = this._transform || Yt(n, i, !0), A.tween = l, A.pr = -1, s.pop()
						}
						if (t) {
							for (; f;) {
								for (T = f._next, S = y; S && S.pr > f.pr;) S = S._next;
								(f._prev = S ? S._prev : v) ? f._prev._next = f: y = f, (f._next = S) ? S._prev = f : v = f, f = T
							}
							this._firstPT = y
						}
						return !0
					}, l.parse = function(t, n, s, o) {
						var r, l, u, c, d, p, _, f, S, y, v = t.style;
						for (r in n) {
							if ("function" == typeof(p = n[r]) && (p = p(g, m)), l = a[r]) s = l.parse(t, p, r, this, s, o, n);
							else {
								if ("--" === r.substr(0, 2)) {
									this._tween._propLookup[r] = this._addTween.call(this._tween, t.style, "setProperty", $(t).getPropertyValue(r) + "", p + "", r, !1, r);
									continue
								}
								d = Q(t, r, i) + "", S = "string" == typeof p, "color" === r || "fill" === r || "stroke" === r || -1 !== r.indexOf("Color") || S && P.test(p) ? (S || (p = ((p = dt(p)).length > 3 ? "rgba(" : "rgb(") + p.join(",") + ")"), s = vt(v, r, d, p, !0, "transparent", s, 0, o)) : S && M.test(p) ? s = vt(v, r, d, p, !0, null, s, 0, o) : (_ = (u = parseFloat(d)) || 0 === u ? d.substr((u + "").length) : "", "" !== d && "auto" !== d || ("width" === r || "height" === r ? (u = ot(t, r, i), _ = "px") : "left" === r || "top" === r ? (u = tt(t, r, i), _ = "px") : (u = "opacity" !== r ? 0 : 1, _ = "")), (y = S && "=" === p.charAt(1)) ? (c = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), c *= parseFloat(p), f = p.replace(T, "")) : (c = parseFloat(p), f = S ? p.replace(T, "") : ""), "" === f && (f = r in e ? e[r] : _), p = c || 0 === c ? (y ? c + u : c) + f : n[r], _ !== f && ("" === f && "lineHeight" !== r || (c || 0 === c) && u && (u = J(t, r, u, _), "%" === f ? (u /= J(t, r, 100, "%") / 100, !0 !== n.strictUnits && (d = u + "%")) : "em" === f || "rem" === f || "vw" === f || "vh" === f ? u /= J(t, r, 1, f) : "px" !== f && (c = J(t, r, c, f), f = "px"), y && (c || 0 === c) && (p = c + u + f))), y && (c += u), !u && 0 !== u || !c && 0 !== c ? void 0 !== v[r] && (p || p + "" != "NaN" && null != p) ? (s = new St(v, r, c || u || 0, 0, s, -1, r, !1, 0, d, p)).xs0 = "none" !== p || "display" !== r && -1 === r.indexOf("Style") ? p : d : j("invalid " + r + " tween value: " + n[r]) : (s = new St(v, r, u, c - u, s, 0, r, !1 !== h && ("px" === f || "zIndex" === r), 0, d, p)).xs0 = f)
							}
							o && s && !s.plugin && (s.plugin = o)
						}
						return s
					}, l.setRatio = function(t) {
						var e, i, n, s = this._firstPT,
							o = 1e-6;
						if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
							if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || -1e-6 === this._tween._rawPrevTime)
								for (; s;) {
									if (e = s.c * t + s.s, s.r ? e = s.r(e) : e < o && e > -o && (e = 0), s.type)
										if (1 === s.type)
											if (2 === (n = s.l)) s.t[s.p] = s.xs0 + e + s.xs1 + s.xn1 + s.xs2;
											else if (3 === n) s.t[s.p] = s.xs0 + e + s.xs1 + s.xn1 + s.xs2 + s.xn2 + s.xs3;
									else if (4 === n) s.t[s.p] = s.xs0 + e + s.xs1 + s.xn1 + s.xs2 + s.xn2 + s.xs3 + s.xn3 + s.xs4;
									else if (5 === n) s.t[s.p] = s.xs0 + e + s.xs1 + s.xn1 + s.xs2 + s.xn2 + s.xs3 + s.xn3 + s.xs4 + s.xn4 + s.xs5;
									else {
										for (i = s.xs0 + e + s.xs1, n = 1; n < s.l; n++) i += s["xn" + n] + s["xs" + (n + 1)];
										s.t[s.p] = i
									} else - 1 === s.type ? s.t[s.p] = s.xs0 : s.setRatio && s.setRatio(t);
									else s.t[s.p] = e + s.xs0;
									s = s._next
								} else
									for (; s;) 2 !== s.type ? s.t[s.p] = s.b : s.setRatio(t), s = s._next;
							else
								for (; s;) {
									if (2 !== s.type)
										if (s.r && -1 !== s.type)
											if (e = s.r(s.s + s.c), s.type) {
												if (1 === s.type) {
													for (n = s.l, i = s.xs0 + e + s.xs1, n = 1; n < s.l; n++) i += s["xn" + n] + s["xs" + (n + 1)];
													s.t[s.p] = i
												}
											} else s.t[s.p] = e + s.xs0;
									else s.t[s.p] = s.e;
									else s.setRatio(t);
									s = s._next
								}
					}, l._enableTransforms = function(t) {
						this._transform = this._transform || Yt(this._target, i, !0), this._transformType = this._transform.svg && Pt || !t && 3 !== this._transformType ? 2 : 3
					};
					var Qt = function(t) {
						this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
					};
					l._addLazySet = function(t, e, i) {
						var n = this._firstPT = new St(t, e, 0, 0, this._firstPT, 2);
						n.e = i, n.setRatio = Qt, n.data = this
					}, l._linkCSSP = function(t, e, i, n) {
						return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, n = !0), i ? i._next = t : n || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = i), t
					}, l._mod = function(t) {
						for (var e = this._firstPT; e;) "function" == typeof t[e.p] && (e.r = t[e.p]), e = e._next
					}, l._kill = function(t) {
						var e, i, s, o = t;
						if (t.autoAlpha || t.alpha) {
							for (i in o = {}, t) o[i] = t[i];
							o.opacity = 1, o.autoAlpha && (o.visibility = 1)
						}
						for (t.className && (e = this._classNamePT) && ((s = e.xfirst) && s._prev ? this._linkCSSP(s._prev, e._next, s._prev._prev) : s === this._firstPT && (this._firstPT = e._next), e._next && this._linkCSSP(e._next, e._next._next, s._prev), this._classNamePT = null), e = this._firstPT; e;) e.plugin && e.plugin !== i && e.plugin._kill && (e.plugin._kill(t), i = e.plugin), e = e._next;
						return n.tN.prototype._kill.call(this, o)
					};
					var Jt = function(t, e, i) {
						var n, s, o, r;
						if (t.slice)
							for (s = t.length; --s > -1;) Jt(t[s], e, i);
						else
							for (s = (n = t.childNodes).length; --s > -1;) r = (o = n[s]).type, o.style && (e.push(et(o)), i && i.push(o)), 1 !== r && 9 !== r && 11 !== r || !o.childNodes.length || Jt(o, e, i)
					};
					return o.cascadeTo = function(t, e, i) {
						var s, o, r, a, l = n.Ay.to(t, e, i),
							h = [l],
							u = [],
							c = [],
							d = [],
							p = n.Ay._internals.reservedProps;
						for (t = l._targets || l.target, Jt(t, u, d), l.render(e, !0, !0), Jt(t, c), l.render(0, !0, !0), l._enabled(!0), s = d.length; --s > -1;)
							if ((o = it(d[s], u[s], c[s])).firstMPT) {
								for (r in o = o.difs, i) p[r] && (o[r] = i[r]);
								for (r in a = {}, o) a[r] = u[s][r];
								h.push(n.Ay.fromTo(d[s], e, a, o))
							} return h
					}, n.tN.activate([o]), o
				}), !0);
				var a = n.zQ.CSSPlugin,
					l = n.uW._gsDefine.plugin({
						propName: "attr",
						API: 2,
						version: "0.6.1",
						init: function(t, e, i, n) {
							var s, o;
							if ("function" != typeof t.setAttribute) return !1;
							for (s in e) "function" == typeof(o = e[s]) && (o = o(n, t)), this._addTween(t, "setAttribute", t.getAttribute(s) + "", o + "", s, !1, s), this._overwriteProps.push(s);
							return !0
						}
					}),
					h = n.uW._gsDefine.plugin({
						propName: "roundProps",
						version: "1.7.0",
						priority: -1,
						API: 2,
						init: function(t, e, i) {
							return this._tween = i, !0
						}
					}),
					u = function(t) {
						var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1;
						return function(i) {
							return (Math.round(i / t) * t * e | 0) / e
						}
					},
					c = function(t, e) {
						for (; t;) t.f || t.blob || (t.m = e || Math.round), t = t._next
					},
					d = h.prototype;
				d._onInitAllProps = function() {
					var t, e, i, n, s = this._tween,
						o = s.vars.roundProps,
						r = {},
						a = s._propLookup.roundProps;
					if ("object" != typeof o || o.push)
						for ("string" == typeof o && (o = o.split(",")), i = o.length; --i > -1;) r[o[i]] = Math.round;
					else
						for (n in o) r[n] = u(o[n]);
					for (n in r)
						for (t = s._firstPT; t;) e = t._next, t.pg ? t.t._mod(r) : t.n === n && (2 === t.f && t.t ? c(t.t._firstPT, r[n]) : (this._add(t.t, n, t.s, t.c, r[n]), e && (e._prev = t._prev), t._prev ? t._prev._next = e : s._firstPT === t && (s._firstPT = e), t._next = t._prev = null, s._propLookup[n] = a)), t = e;
					return !1
				}, d._add = function(t, e, i, n, s) {
					this._addTween(t, e, i, i + n, e, s || Math.round), this._overwriteProps.push(e)
				};
				var p = n.uW._gsDefine.plugin({
					propName: "directionalRotation",
					version: "0.3.1",
					API: 2,
					init: function(t, e, i, n) {
						"object" != typeof e && (e = {
							rotation: e
						}), this.finals = {};
						var s, o, r, a, l, h, u = !0 === e.useRadians ? 2 * Math.PI : 360,
							c = 1e-6;
						for (s in e) "useRadians" !== s && ("function" == typeof(a = e[s]) && (a = a(n, t)), o = (h = (a + "").split("_"))[0], r = parseFloat("function" != typeof t[s] ? t[s] : t[s.indexOf("set") || "function" != typeof t["get" + s.substr(3)] ? s : "get" + s.substr(3)]()), l = (a = this.finals[s] = "string" == typeof o && "=" === o.charAt(1) ? r + parseInt(o.charAt(0) + "1", 10) * Number(o.substr(2)) : Number(o) || 0) - r, h.length && (-1 !== (o = h.join("_")).indexOf("short") && (l %= u) != l % (u / 2) && (l = l < 0 ? l + u : l - u), -1 !== o.indexOf("_cw") && l < 0 ? l = (l + 9999999999 * u) % u - (l / u | 0) * u : -1 !== o.indexOf("ccw") && l > 0 && (l = (l - 9999999999 * u) % u - (l / u | 0) * u)), (l > c || l < -c) && (this._addTween(t, s, r, r + l, s), this._overwriteProps.push(s)));
						return !0
					},
					set: function(t) {
						var e;
						if (1 !== t) this._super.setRatio.call(this, t);
						else
							for (e = this._firstPT; e;) e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p], e = e._next
					}
				});
				p._autoCSS = !0;
				var _ = 180 / Math.PI,
					m = [],
					g = [],
					f = [],
					S = {},
					y = n.uW._gsDefine.globals,
					v = function(t, e, i, n) {
						i === n && (i = n - (n - e) / 1e6), t === e && (e = t + (i - t) / 1e6), this.a = t, this.b = e, this.c = i, this.d = n, this.da = n - t, this.ca = i - t, this.ba = e - t
					},
					T = function(t, e, i, n) {
						var s = {
								a: t
							},
							o = {},
							r = {},
							a = {
								c: n
							},
							l = (t + e) / 2,
							h = (e + i) / 2,
							u = (i + n) / 2,
							c = (l + h) / 2,
							d = (h + u) / 2,
							p = (d - c) / 8;
						return s.b = l + (t - l) / 4, o.b = c + p, s.c = o.a = (s.b + o.b) / 2, o.c = r.a = (c + d) / 2, r.b = d - p, a.b = u + (n - u) / 4, r.c = a.a = (r.b + a.b) / 2, [s, o, r, a]
					},
					E = function(t, e, i, n, s) {
						var o, r, a, l, h, u, c, d, p, _, S, y, v, E = t.length - 1,
							b = 0,
							A = t[0].a;
						for (o = 0; o < E; o++) r = (h = t[b]).a, a = h.d, l = t[b + 1].d, s ? (S = m[o], v = ((y = g[o]) + S) * e * .25 / (n ? .5 : f[o] || .5), d = a - ((u = a - (a - r) * (n ? .5 * e : 0 !== S ? v / S : 0)) + (((c = a + (l - a) * (n ? .5 * e : 0 !== y ? v / y : 0)) - u) * (3 * S / (S + y) + .5) / 4 || 0))) : d = a - ((u = a - (a - r) * e * .5) + (c = a + (l - a) * e * .5)) / 2, u += d, c += d, h.c = p = u, h.b = 0 !== o ? A : A = h.a + .6 * (h.c - h.a), h.da = a - r, h.ca = p - r, h.ba = A - r, i ? (_ = T(r, A, p, a), t.splice(b, 1, _[0], _[1], _[2], _[3]), b += 4) : b++, A = c;
						(h = t[b]).b = A, h.c = A + .4 * (h.d - A), h.da = h.d - h.a, h.ca = h.c - h.a, h.ba = A - h.a, i && (_ = T(h.a, A, h.c, h.d), t.splice(b, 1, _[0], _[1], _[2], _[3]))
					},
					b = function(t, e, i, n) {
						var s, o, r, a, l, h, u = [];
						if (n)
							for (o = (t = [n].concat(t)).length; --o > -1;) "string" == typeof(h = t[o][e]) && "=" === h.charAt(1) && (t[o][e] = n[e] + Number(h.charAt(0) + h.substr(2)));
						if ((s = t.length - 2) < 0) return u[0] = new v(t[0][e], 0, 0, t[0][e]), u;
						for (o = 0; o < s; o++) r = t[o][e], a = t[o + 1][e], u[o] = new v(r, 0, 0, a), i && (l = t[o + 2][e], m[o] = (m[o] || 0) + (a - r) * (a - r), g[o] = (g[o] || 0) + (l - a) * (l - a));
						return u[o] = new v(t[o][e], 0, 0, t[o + 1][e]), u
					},
					A = function(t, e, i, n, s, o) {
						var r, a, l, h, u, c, d, p, _ = {},
							y = [],
							v = o || t[0];
						for (a in s = "string" == typeof s ? "," + s + "," : ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", null == e && (e = 1), t[0]) y.push(a);
						if (t.length > 1) {
							for (p = t[t.length - 1], d = !0, r = y.length; --r > -1;)
								if (a = y[r], Math.abs(v[a] - p[a]) > .05) {
									d = !1;
									break
								} d && (t = t.concat(), o && t.unshift(o), t.push(t[1]), o = t[t.length - 3])
						}
						for (m.length = g.length = f.length = 0, r = y.length; --r > -1;) a = y[r], S[a] = -1 !== s.indexOf("," + a + ","), _[a] = b(t, a, S[a], o);
						for (r = m.length; --r > -1;) m[r] = Math.sqrt(m[r]), g[r] = Math.sqrt(g[r]);
						if (!n) {
							for (r = y.length; --r > -1;)
								if (S[a])
									for (c = (l = _[y[r]]).length - 1, h = 0; h < c; h++) u = l[h + 1].da / g[h] + l[h].da / m[h] || 0, f[h] = (f[h] || 0) + u * u;
							for (r = f.length; --r > -1;) f[r] = Math.sqrt(f[r])
						}
						for (r = y.length, h = i ? 4 : 1; --r > -1;) l = _[a = y[r]], E(l, e, i, n, S[a]), d && (l.splice(0, h), l.splice(l.length - h, h));
						return _
					},
					P = function(t, e, i) {
						for (var n, s, o, r, a, l, h, u, c, d, p, _ = 1 / i, m = t.length; --m > -1;)
							for (o = (d = t[m]).a, r = d.d - o, a = d.c - o, l = d.b - o, n = s = 0, u = 1; u <= i; u++) n = s - (s = ((h = _ * u) * h * r + 3 * (c = 1 - h) * (h * a + c * l)) * h), e[p = m * i + u - 1] = (e[p] || 0) + n * n
					},
					I = n.uW._gsDefine.plugin({
						propName: "bezier",
						priority: -1,
						version: "1.3.8",
						API: 2,
						global: !0,
						init: function(t, e, i) {
							this._target = t, e instanceof Array && (e = {
								values: e
							}), this._func = {}, this._mod = {}, this._props = [], this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10);
							var n, s, o, r, a, l = e.values || [],
								h = {},
								u = l[0],
								c = e.autoRotate || i.vars.orientToBezier;
							for (n in this._autoRotate = c ? c instanceof Array ? c : [
									["x", "y", "rotation", !0 === c ? 0 : Number(c) || 0]
								] : null, u) this._props.push(n);
							for (o = this._props.length; --o > -1;) n = this._props[o], this._overwriteProps.push(n), s = this._func[n] = "function" == typeof t[n], h[n] = s ? t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)]() : parseFloat(t[n]), a || h[n] !== l[0][n] && (a = h);
							if (this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? A(l, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, a) : function(t, e, i) {
									var n, s, o, r, a, l, h, u, c, d, p, _ = {},
										m = "cubic" === (e = e || "soft") ? 3 : 2,
										g = "soft" === e,
										f = [];
									if (g && i && (t = [i].concat(t)), null == t || t.length < m + 1) throw "invalid Bezier data";
									for (c in t[0]) f.push(c);
									for (l = f.length; --l > -1;) {
										for (_[c = f[l]] = a = [], d = 0, u = t.length, h = 0; h < u; h++) n = null == i ? t[h][c] : "string" == typeof(p = t[h][c]) && "=" === p.charAt(1) ? i[c] + Number(p.charAt(0) + p.substr(2)) : Number(p), g && h > 1 && h < u - 1 && (a[d++] = (n + a[d - 2]) / 2), a[d++] = n;
										for (u = d - m + 1, d = 0, h = 0; h < u; h += m) n = a[h], s = a[h + 1], o = a[h + 2], r = 2 === m ? 0 : a[h + 3], a[d++] = p = 3 === m ? new v(n, s, o, r) : new v(n, (2 * s + n) / 3, (2 * s + o) / 3, o);
										a.length = d
									}
									return _
								}(l, e.type, h), this._segCount = this._beziers[n].length, this._timeRes) {
								var d = function(t, e) {
									var i, n, s, o, r = [],
										a = [],
										l = 0,
										h = 0,
										u = (e = 0 | e || 6) - 1,
										c = [],
										d = [];
									for (i in t) P(t[i], r, e);
									for (s = r.length, n = 0; n < s; n++) l += Math.sqrt(r[n]), d[o = n % e] = l, o === u && (h += l, c[o = n / e | 0] = d, a[o] = h, l = 0, d = []);
									return {
										length: h,
										lengths: a,
										segments: c
									}
								}(this._beziers, this._timeRes);
								this._length = d.length, this._lengths = d.lengths, this._segments = d.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length
							}
							if (c = this._autoRotate)
								for (this._initialRotations = [], c[0] instanceof Array || (this._autoRotate = c = [c]), o = c.length; --o > -1;) {
									for (r = 0; r < 3; r++) n = c[o][r], this._func[n] = "function" == typeof t[n] && t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)];
									n = c[o][2], this._initialRotations[o] = (this._func[n] ? this._func[n].call(this._target) : this._target[n]) || 0, this._overwriteProps.push(n)
								}
							return this._startRatio = i.vars.runBackwards ? 1 : 0, !0
						},
						set: function(t) {
							var e, i, n, s, o, r, a, l, h, u, c = this._segCount,
								d = this._func,
								p = this._target,
								m = t !== this._startRatio;
							if (this._timeRes) {
								if (h = this._lengths, u = this._curSeg, t *= this._length, n = this._li, t > this._l2 && n < c - 1) {
									for (l = c - 1; n < l && (this._l2 = h[++n]) <= t;);
									this._l1 = h[n - 1], this._li = n, this._curSeg = u = this._segments[n], this._s2 = u[this._s1 = this._si = 0]
								} else if (t < this._l1 && n > 0) {
									for (; n > 0 && (this._l1 = h[--n]) >= t;);
									0 === n && t < this._l1 ? this._l1 = 0 : n++, this._l2 = h[n], this._li = n, this._curSeg = u = this._segments[n], this._s1 = u[(this._si = u.length - 1) - 1] || 0, this._s2 = u[this._si]
								}
								if (e = n, t -= this._l1, n = this._si, t > this._s2 && n < u.length - 1) {
									for (l = u.length - 1; n < l && (this._s2 = u[++n]) <= t;);
									this._s1 = u[n - 1], this._si = n
								} else if (t < this._s1 && n > 0) {
									for (; n > 0 && (this._s1 = u[--n]) >= t;);
									0 === n && t < this._s1 ? this._s1 = 0 : n++, this._s2 = u[n], this._si = n
								}
								r = (n + (t - this._s1) / (this._s2 - this._s1)) * this._prec || 0
							} else r = (t - (e = t < 0 ? 0 : t >= 1 ? c - 1 : c * t | 0) * (1 / c)) * c;
							for (i = 1 - r, n = this._props.length; --n > -1;) s = this._props[n], a = (r * r * (o = this._beziers[s][e]).da + 3 * i * (r * o.ca + i * o.ba)) * r + o.a, this._mod[s] && (a = this._mod[s](a, p)), d[s] ? p[s](a) : p[s] = a;
							if (this._autoRotate) {
								var g, f, S, y, v, T, E, b = this._autoRotate;
								for (n = b.length; --n > -1;) s = b[n][2], T = b[n][3] || 0, E = !0 === b[n][4] ? 1 : _, o = this._beziers[b[n][0]], g = this._beziers[b[n][1]], o && g && (o = o[e], g = g[e], f = o.a + (o.b - o.a) * r, f += ((y = o.b + (o.c - o.b) * r) - f) * r, y += (o.c + (o.d - o.c) * r - y) * r, S = g.a + (g.b - g.a) * r, S += ((v = g.b + (g.c - g.b) * r) - S) * r, v += (g.c + (g.d - g.c) * r - v) * r, a = m ? Math.atan2(v - S, y - f) * E + T : this._initialRotations[n], this._mod[s] && (a = this._mod[s](a, p)), d[s] ? p[s](a) : p[s] = a)
							}
						}
					}),
					w = I.prototype;
				I.bezierThrough = A, I.cubicToQuadratic = T, I._autoCSS = !0, I.quadraticToCubic = function(t, e, i) {
					return new v(t, (2 * e + t) / 3, (2 * e + i) / 3, i)
				}, I._cssRegister = function() {
					var t = y.CSSPlugin;
					if (t) {
						var e = t._internals,
							i = e._parseToProxy,
							n = e._setPluginRatio,
							s = e.CSSPropTween;
						e._registerComplexSpecialProp("bezier", {
							parser: function(t, e, o, r, a, l) {
								e instanceof Array && (e = {
									values: e
								}), l = new I;
								var h, u, c, d = e.values,
									p = d.length - 1,
									_ = [],
									m = {};
								if (p < 0) return a;
								for (h = 0; h <= p; h++) c = i(t, d[h], r, a, l, p !== h), _[h] = c.end;
								for (u in e) m[u] = e[u];
								return m.values = _, (a = new s(t, "bezier", 0, 0, c.pt, 2)).data = c, a.plugin = l, a.setRatio = n, 0 === m.autoRotate && (m.autoRotate = !0), !m.autoRotate || m.autoRotate instanceof Array || (h = !0 === m.autoRotate ? 0 : Number(m.autoRotate), m.autoRotate = null != c.end.left ? [
									["left", "top", "rotation", h, !1]
								] : null != c.end.x && [
									["x", "y", "rotation", h, !1]
								]), m.autoRotate && (r._transform || r._enableTransforms(!1), c.autoRotate = r._target._gsTransform, c.proxy.rotation = c.autoRotate.rotation || 0, r._overwriteProps.push("rotation")), l._onInitTween(c.proxy, m, r._tween), a
							}
						})
					}
				}, w._mod = function(t) {
					for (var e, i = this._overwriteProps, n = i.length; --n > -1;)(e = t[i[n]]) && "function" == typeof e && (this._mod[i[n]] = e)
				}, w._kill = function(t) {
					var e, i, n = this._props;
					for (e in this._beziers)
						if (e in t)
							for (delete this._beziers[e], delete this._func[e], i = n.length; --i > -1;) n[i] === e && n.splice(i, 1);
					if (n = this._autoRotate)
						for (i = n.length; --i > -1;) t[n[i][2]] && n.splice(i, 1);
					return this._super._kill.call(this, t)
				}, n.uW._gsDefine("easing.Back", ["easing.Ease"], (function() {
					var t, e, i, s, o = n.uW.GreenSockGlobals || n.uW,
						r = o.com.greensock,
						a = 2 * Math.PI,
						l = Math.PI / 2,
						h = r._class,
						u = function(t, e) {
							var i = h("easing." + t, (function() {}), !0),
								s = i.prototype = new n.zM;
							return s.constructor = i, s.getRatio = e, i
						},
						c = n.zM.register || function() {},
						d = function(t, e, i, n, s) {
							var o = h("easing." + t, {
								easeOut: new e,
								easeIn: new i,
								easeInOut: new n
							}, !0);
							return c(o, t), o
						},
						p = function(t, e, i) {
							this.t = t, this.v = e, i && (this.next = i, i.prev = this, this.c = i.v - e, this.gap = i.t - t)
						},
						_ = function(t, e) {
							var i = h("easing." + t, (function(t) {
									this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1
								}), !0),
								s = i.prototype = new n.zM;
							return s.constructor = i, s.getRatio = e, s.config = function(t) {
								return new i(t)
							}, i
						},
						m = d("Back", _("BackOut", (function(t) {
							return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1
						})), _("BackIn", (function(t) {
							return t * t * ((this._p1 + 1) * t - this._p1)
						})), _("BackInOut", (function(t) {
							return (t *= 2) < 1 ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2)
						}))),
						g = h("easing.SlowMo", (function(t, e, i) {
							e = e || 0 === e ? e : .7, null == t ? t = .7 : t > 1 && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = !0 === i
						}), !0),
						f = g.prototype = new n.zM;
					return f.constructor = g, f.getRatio = function(t) {
						var e = t + (.5 - t) * this._p;
						return t < this._p1 ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 === t ? 0 : 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e
					}, g.ease = new g(.7, .7), f.config = g.config = function(t, e, i) {
						return new g(t, e, i)
					}, (f = (t = h("easing.SteppedEase", (function(t, e) {
						t = t || 1, this._p1 = 1 / t, this._p2 = t + (e ? 0 : 1), this._p3 = e ? 1 : 0
					}), !0)).prototype = new n.zM).constructor = t, f.getRatio = function(t) {
						return t < 0 ? t = 0 : t >= 1 && (t = .999999999), ((this._p2 * t | 0) + this._p3) * this._p1
					}, f.config = t.config = function(e, i) {
						return new t(e, i)
					}, (f = (e = h("easing.ExpoScaleEase", (function(t, e, i) {
						this._p1 = Math.log(e / t), this._p2 = e - t, this._p3 = t, this._ease = i
					}), !0)).prototype = new n.zM).constructor = e, f.getRatio = function(t) {
						return this._ease && (t = this._ease.getRatio(t)), (this._p3 * Math.exp(this._p1 * t) - this._p3) / this._p2
					}, f.config = e.config = function(t, i, n) {
						return new e(t, i, n)
					}, (f = (i = h("easing.RoughEase", (function(t) {
						for (var e, i, s, o, r, a, l = (t = t || {}).taper || "none", h = [], u = 0, c = 0 | (t.points || 20), d = c, _ = !1 !== t.randomize, m = !0 === t.clamp, g = t.template instanceof n.zM ? t.template : null, f = "number" == typeof t.strength ? .4 * t.strength : .4; --d > -1;) e = _ ? Math.random() : 1 / c * d, i = g ? g.getRatio(e) : e, s = "none" === l ? f : "out" === l ? (o = 1 - e) * o * f : "in" === l ? e * e * f : e < .5 ? (o = 2 * e) * o * .5 * f : (o = 2 * (1 - e)) * o * .5 * f, _ ? i += Math.random() * s - .5 * s : d % 2 ? i += .5 * s : i -= .5 * s, m && (i > 1 ? i = 1 : i < 0 && (i = 0)), h[u++] = {
							x: e,
							y: i
						};
						for (h.sort((function(t, e) {
								return t.x - e.x
							})), a = new p(1, 1, null), d = c; --d > -1;) r = h[d], a = new p(r.x, r.y, a);
						this._prev = new p(0, 0, 0 !== a.t ? a : a.next)
					}), !0)).prototype = new n.zM).constructor = i, f.getRatio = function(t) {
						var e = this._prev;
						if (t > e.t) {
							for (; e.next && t >= e.t;) e = e.next;
							e = e.prev
						} else
							for (; e.prev && t <= e.t;) e = e.prev;
						return this._prev = e, e.v + (t - e.t) / e.gap * e.c
					}, f.config = function(t) {
						return new i(t)
					}, i.ease = new i, d("Bounce", u("BounceOut", (function(t) {
						return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
					})), u("BounceIn", (function(t) {
						return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : t < 2 / 2.75 ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : t < 2.5 / 2.75 ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375)
					})), u("BounceInOut", (function(t) {
						var e = t < .5;
						return (t = e ? 1 - 2 * t : 2 * t - 1) < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5
					}))), d("Circ", u("CircOut", (function(t) {
						return Math.sqrt(1 - (t -= 1) * t)
					})), u("CircIn", (function(t) {
						return -(Math.sqrt(1 - t * t) - 1)
					})), u("CircInOut", (function(t) {
						return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
					}))), s = function(t, e, i) {
						var s = h("easing." + t, (function(t, e) {
								this._p1 = t >= 1 ? t : 1, this._p2 = (e || i) / (t < 1 ? t : 1), this._p3 = this._p2 / a * (Math.asin(1 / this._p1) || 0), this._p2 = a / this._p2
							}), !0),
							o = s.prototype = new n.zM;
						return o.constructor = s, o.getRatio = e, o.config = function(t, e) {
							return new s(t, e)
						}, s
					}, d("Elastic", s("ElasticOut", (function(t) {
						return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * this._p2) + 1
					}), .3), s("ElasticIn", (function(t) {
						return -this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2)
					}), .3), s("ElasticInOut", (function(t) {
						return (t *= 2) < 1 ? this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * -.5 : this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * .5 + 1
					}), .45)), d("Expo", u("ExpoOut", (function(t) {
						return 1 - Math.pow(2, -10 * t)
					})), u("ExpoIn", (function(t) {
						return Math.pow(2, 10 * (t - 1)) - .001
					})), u("ExpoInOut", (function(t) {
						return (t *= 2) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
					}))), d("Sine", u("SineOut", (function(t) {
						return Math.sin(t * l)
					})), u("SineIn", (function(t) {
						return 1 - Math.cos(t * l)
					})), u("SineInOut", (function(t) {
						return -.5 * (Math.cos(Math.PI * t) - 1)
					}))), h("easing.EaseLookup", {
						find: function(t) {
							return n.zM.map[t]
						}
					}, !0), c(o.SlowMo, "SlowMo", "ease,"), c(i, "RoughEase", "ease,"), c(t, "SteppedEase", "ease,"), m
				}), !0);
				var L = n.zQ.Back,
					C = n.zQ.Elastic,
					x = n.zQ.Bounce,
					B = n.zQ.RoughEase,
					O = n.zQ.SlowMo,
					N = n.zQ.SteppedEase,
					M = n.zQ.Circ,
					R = n.zQ.Expo,
					D = n.zQ.Sine,
					k = n.zQ.ExpoScaleEase,
					F = r;
				F._autoActivated = [s, o, a, l, I, h, p, L, C, x, B, O, N, M, R, D, k]
			},
			23684: function(t, e, i) {
				var n;
				! function(i, s) {
					"use strict";
					var o = {},
						r = i.document,
						a = i.GreenSockGlobals = i.GreenSockGlobals || i,
						l = a[s];
					if (l) return t.exports && (t.exports = l), l;
					var h, u, c, d, p, _, m, g = function(t) {
							var e, i = t.split("."),
								n = a;
							for (e = 0; e < i.length; e++) n[i[e]] = n = n[i[e]] || {};
							return n
						},
						f = g("com.greensock"),
						S = 1e-10,
						y = function(t) {
							var e, i = [],
								n = t.length;
							for (e = 0; e !== n; i.push(t[e++]));
							return i
						},
						v = function() {},
						T = (_ = Object.prototype.toString, m = _.call([]), function(t) {
							return null != t && (t instanceof Array || "object" == typeof t && !!t.push && _.call(t) === m)
						}),
						E = {},
						b = function(i, r, l, h) {
							this.sc = E[i] ? E[i].sc : [], E[i] = this, this.gsClass = null, this.func = l;
							var u = [];
							this.check = function(c) {
								for (var d, p, _, m, f = r.length, S = f; --f > -1;)(d = E[r[f]] || new b(r[f], [])).gsClass ? (u[f] = d.gsClass, S--) : c && d.sc.push(this);
								if (0 === S && l) {
									if (_ = (p = ("com.greensock." + i).split(".")).pop(), m = g(p.join("."))[_] = this.gsClass = l.apply(l, u), h)
										if (a[_] = o[_] = m, t.exports)
											if (i === s)
												for (f in t.exports = o[s] = m, o) m[f] = o[f];
											else o[s] && (o[s][_] = m);
									else void 0 === (n = function() {
										return m
									}.apply(e, [])) || (t.exports = n);
									for (f = 0; f < this.sc.length; f++) this.sc[f].check()
								}
							}, this.check(!0)
						},
						A = i._gsDefine = function(t, e, i, n) {
							return new b(t, e, i, n)
						},
						P = f._class = function(t, e, i) {
							return e = e || function() {}, A(t, [], (function() {
								return e
							}), i), e
						};
					A.globals = a;
					var I = [0, 0, 1, 1],
						w = P("easing.Ease", (function(t, e, i, n) {
							this._func = t, this._type = i || 0, this._power = n || 0, this._params = e ? I.concat(e) : I
						}), !0),
						L = w.map = {},
						C = w.register = function(t, e, i, n) {
							for (var s, o, r, a, l = e.split(","), h = l.length, u = (i || "easeIn,easeOut,easeInOut").split(","); --h > -1;)
								for (o = l[h], s = n ? P("easing." + o, null, !0) : f.easing[o] || {}, r = u.length; --r > -1;) a = u[r], L[o + "." + a] = L[a + o] = s[a] = t.getRatio ? t : t[a] || new t
						};
					for ((c = w.prototype)._calcEnd = !1, c.getRatio = function(t) {
							if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
							var e = this._type,
								i = this._power,
								n = 1 === e ? 1 - t : 2 === e ? t : t < .5 ? 2 * t : 2 * (1 - t);
							return 1 === i ? n *= n : 2 === i ? n *= n * n : 3 === i ? n *= n * n * n : 4 === i && (n *= n * n * n * n), 1 === e ? 1 - n : 2 === e ? n : t < .5 ? n / 2 : 1 - n / 2
						}, u = (h = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"]).length; --u > -1;) c = h[u] + ",Power" + u, C(new w(null, null, 1, u), c, "easeOut", !0), C(new w(null, null, 2, u), c, "easeIn" + (0 === u ? ",easeNone" : "")), C(new w(null, null, 3, u), c, "easeInOut");
					L.linear = f.easing.Linear.easeIn, L.swing = f.easing.Quad.easeInOut;
					var x = P("events.EventDispatcher", (function(t) {
						this._listeners = {}, this._eventTarget = t || this
					}));
					(c = x.prototype).addEventListener = function(t, e, i, n, s) {
						s = s || 0;
						var o, r, a = this._listeners[t],
							l = 0;
						for (this !== d || p || d.wake(), null == a && (this._listeners[t] = a = []), r = a.length; --r > -1;)(o = a[r]).c === e && o.s === i ? a.splice(r, 1) : 0 === l && o.pr < s && (l = r + 1);
						a.splice(l, 0, {
							c: e,
							s: i,
							up: n,
							pr: s
						})
					}, c.removeEventListener = function(t, e) {
						var i, n = this._listeners[t];
						if (n)
							for (i = n.length; --i > -1;)
								if (n[i].c === e) return void n.splice(i, 1)
					}, c.dispatchEvent = function(t) {
						var e, i, n, s = this._listeners[t];
						if (s)
							for ((e = s.length) > 1 && (s = s.slice(0)), i = this._eventTarget; --e > -1;)(n = s[e]) && (n.up ? n.c.call(n.s || i, {
								type: t,
								target: i
							}) : n.c.call(n.s || i))
					};
					var B = i.requestAnimationFrame,
						O = i.cancelAnimationFrame,
						N = Date.now || function() {
							return (new Date).getTime()
						},
						M = N();
					for (u = (h = ["ms", "moz", "webkit", "o"]).length; --u > -1 && !B;) B = i[h[u] + "RequestAnimationFrame"], O = i[h[u] + "CancelAnimationFrame"] || i[h[u] + "CancelRequestAnimationFrame"];
					P("Ticker", (function(t, e) {
						var i, n, s, o, a, l = this,
							h = N(),
							u = !(!1 === e || !B) && "auto",
							c = 500,
							_ = 33,
							m = function(t) {
								var e, r, u = N() - M;
								u > c && (h += u - _), M += u, l.time = (M - h) / 1e3, e = l.time - a, (!i || e > 0 || !0 === t) && (l.frame++, a += e + (e >= o ? .004 : o - e), r = !0), !0 !== t && (s = n(m)), r && l.dispatchEvent("tick")
							};
						x.call(l), l.time = l.frame = 0, l.tick = function() {
							m(!0)
						}, l.lagSmoothing = function(t, e) {
							if (!arguments.length) return c < 1 / S;
							c = t || 1 / S, _ = Math.min(e, c, 0)
						}, l.sleep = function() {
							null != s && (u && O ? O(s) : clearTimeout(s), n = v, s = null, l === d && (p = !1))
						}, l.wake = function(t) {
							null !== s ? l.sleep() : t ? h += -M + (M = N()) : l.frame > 10 && (M = N() - c + 5), n = 0 === i ? v : u && B ? B : function(t) {
								return setTimeout(t, 1e3 * (a - l.time) + 1 | 0)
							}, l === d && (p = !0), m(2)
						}, l.fps = function(t) {
							if (!arguments.length) return i;
							o = 1 / ((i = t) || 60), a = this.time + o, l.wake()
						}, l.useRAF = function(t) {
							if (!arguments.length) return u;
							l.sleep(), u = t, l.fps(i)
						}, l.fps(t), setTimeout((function() {
							"auto" === u && l.frame < 5 && "hidden" !== (r || {}).visibilityState && l.useRAF(!1)
						}), 1500)
					})), (c = f.Ticker.prototype = new f.events.EventDispatcher).constructor = f.Ticker;
					var R = P("core.Animation", (function(t, e) {
						if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = !0 === e.immediateRender, this.data = e.data, this._reversed = !0 === e.reversed, tt) {
							p || d.wake();
							var i = this.vars.useFrames ? J : tt;
							i.add(this, i._time), this.vars.paused && this.paused(!0)
						}
					}));
					d = R.ticker = new f.Ticker, (c = R.prototype)._dirty = c._gc = c._initted = c._paused = !1, c._totalTime = c._time = 0, c._rawPrevTime = -1, c._next = c._last = c._onUpdate = c._timeline = c.timeline = null, c._paused = !1;
					var D = function() {
						p && N() - M > 2e3 && ("hidden" !== (r || {}).visibilityState || !d.lagSmoothing()) && d.wake();
						var t = setTimeout(D, 2e3);
						t.unref && t.unref()
					};
					D(), c.play = function(t, e) {
						return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
					}, c.pause = function(t, e) {
						return null != t && this.seek(t, e), this.paused(!0)
					}, c.resume = function(t, e) {
						return null != t && this.seek(t, e), this.paused(!1)
					}, c.seek = function(t, e) {
						return this.totalTime(Number(t), !1 !== e)
					}, c.restart = function(t, e) {
						return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, !1 !== e, !0)
					}, c.reverse = function(t, e) {
						return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
					}, c.render = function(t, e, i) {}, c.invalidate = function() {
						return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this
					}, c.isActive = function() {
						var t, e = this._timeline,
							i = this._startTime;
						return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime(!0)) >= i && t < i + this.totalDuration() / this._timeScale - 1e-7
					}, c._enabled = function(t, e) {
						return p || d.wake(), this._gc = !t, this._active = this.isActive(), !0 !== e && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1
					}, c._kill = function(t, e) {
						return this._enabled(!1, !1)
					}, c.kill = function(t, e) {
						return this._kill(t, e), this
					}, c._uncache = function(t) {
						for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;
						return this
					}, c._swapSelfInParams = function(t) {
						for (var e = t.length, i = t.concat(); --e > -1;) "{self}" === t[e] && (i[e] = this);
						return i
					}, c._callback = function(t) {
						var e = this.vars,
							i = e[t],
							n = e[t + "Params"],
							s = e[t + "Scope"] || e.callbackScope || this;
						switch (n ? n.length : 0) {
							case 0:
								i.call(s);
								break;
							case 1:
								i.call(s, n[0]);
								break;
							case 2:
								i.call(s, n[0], n[1]);
								break;
							default:
								i.apply(s, n)
						}
					}, c.eventCallback = function(t, e, i, n) {
						if ("on" === (t || "").substr(0, 2)) {
							var s = this.vars;
							if (1 === arguments.length) return s[t];
							null == e ? delete s[t] : (s[t] = e, s[t + "Params"] = T(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, s[t + "Scope"] = n), "onUpdate" === t && (this._onUpdate = e)
						}
						return this
					}, c.delay = function(t) {
						return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay
					}, c.duration = function(t) {
						return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration)
					}, c.totalDuration = function(t) {
						return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration
					}, c.time = function(t, e) {
						return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
					}, c.totalTime = function(t, e, i) {
						if (p || d.wake(), !arguments.length) return this._totalTime;
						if (this._timeline) {
							if (t < 0 && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
								this._dirty && this.totalDuration();
								var n = this._totalDuration,
									s = this._timeline;
								if (t > n && !i && (t = n), this._startTime = (this._paused ? this._pauseTime : s._time) - (this._reversed ? n - t : t) / this._timeScale, s._dirty || this._uncache(!1), s._timeline)
									for (; s._timeline;) s._timeline._time !== (s._startTime + s._totalTime) / s._timeScale && s.totalTime(s._totalTime, !0), s = s._timeline
							}
							this._gc && this._enabled(!0, !1), this._totalTime === t && 0 !== this._duration || (U.length && it(), this.render(t, e, !1), U.length && it())
						}
						return this
					}, c.progress = c.totalProgress = function(t, e) {
						var i = this.duration();
						return arguments.length ? this.totalTime(i * t, e) : i ? this._time / i : this.ratio
					}, c.startTime = function(t) {
						return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime
					}, c.endTime = function(t) {
						return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale
					}, c.timeScale = function(t) {
						if (!arguments.length) return this._timeScale;
						var e, i;
						for (t = t || S, this._timeline && this._timeline.smoothChildTiming && (i = (e = this._pauseTime) || 0 === e ? e : this._timeline.totalTime(), this._startTime = i - (i - this._startTime) * this._timeScale / t), this._timeScale = t, i = this.timeline; i && i.timeline;) i._dirty = !0, i.totalDuration(), i = i.timeline;
						return this
					}, c.reversed = function(t) {
						return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
					}, c.paused = function(t) {
						if (!arguments.length) return this._paused;
						var e, i, n = this._timeline;
						return t != this._paused && n && (p || t || d.wake(), i = (e = n.rawTime()) - this._pauseTime, !t && n.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && 0 !== i && this._initted && this.duration() && (e = n.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, this.render(e, e === this._totalTime, !0))), this._gc && !t && this._enabled(!0, !1), this
					};
					var k = P("core.SimpleTimeline", (function(t) {
						R.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0
					}));
					(c = k.prototype = new R).constructor = k, c.kill()._gc = !1, c._first = c._last = c._recent = null, c._sortChildren = !1, c.add = c.insert = function(t, e, i, n) {
						var s, o;
						if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = this.rawTime() - (t._timeline.rawTime() - t._pauseTime)), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), s = this._last, this._sortChildren)
							for (o = t._startTime; s && s._startTime > o;) s = s._prev;
						return s ? (t._next = s._next, s._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = s, this._recent = t, this._timeline && this._uncache(!0), this
					}, c._remove = function(t, e) {
						return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
					}, c.render = function(t, e, i) {
						var n, s = this._first;
						for (this._totalTime = this._time = this._rawPrevTime = t; s;) n = s._next, (s._active || t >= s._startTime && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = n
					}, c.rawTime = function() {
						return p || d.wake(), this._totalTime
					};
					var F = P("TweenLite", (function(t, e, n) {
							if (R.call(this, e, n), this.render = F.prototype.render, null == t) throw "Cannot tween a null target.";
							this.target = t = "string" != typeof t ? t : F.selector(t) || t;
							var s, o, r, a = t.jquery || t.length && t !== i && t[0] && (t[0] === i || t[0].nodeType && t[0].style && !t.nodeType),
								l = this.vars.overwrite;
							if (this._overwrite = l = null == l ? Q[F.defaultOverwrite] : "number" == typeof l ? 0 | l : Q[l], (a || t instanceof Array || t.push && T(t)) && "number" != typeof t[0])
								for (this._targets = r = y(t), this._propLookup = [], this._siblings = [], s = 0; s < r.length; s++)(o = r[s]) ? "string" != typeof o ? o.length && o !== i && o[0] && (o[0] === i || o[0].nodeType && o[0].style && !o.nodeType) ? (r.splice(s--, 1), this._targets = r = r.concat(y(o))) : (this._siblings[s] = nt(o, this, !1), 1 === l && this._siblings[s].length > 1 && ot(o, this, null, 1, this._siblings[s])) : "string" == typeof(o = r[s--] = F.selector(o)) && r.splice(s + 1, 1) : r.splice(s--, 1);
							else this._propLookup = {}, this._siblings = nt(t, this, !1), 1 === l && this._siblings.length > 1 && ot(t, this, null, 1, this._siblings);
							(this.vars.immediateRender || 0 === e && 0 === this._delay && !1 !== this.vars.immediateRender) && (this._time = -1e-10, this.render(Math.min(0, -this._delay)))
						}), !0),
						G = function(t) {
							return t && t.length && t !== i && t[0] && (t[0] === i || t[0].nodeType && t[0].style && !t.nodeType)
						};
					(c = F.prototype = new R).constructor = F, c.kill()._gc = !1, c.ratio = 0, c._firstPT = c._targets = c._overwrittenProps = c._startAt = null, c._notifyPluginsOfEnabled = c._lazy = !1, F.version = "2.0.2", F.defaultEase = c._ease = new w(null, null, 1, 1), F.defaultOverwrite = "auto", F.ticker = d, F.autoSleep = 120, F.lagSmoothing = function(t, e) {
						d.lagSmoothing(t, e)
					}, F.selector = i.$ || i.jQuery || function(t) {
						var e = i.$ || i.jQuery;
						return e ? (F.selector = e, e(t)) : (r || (r = i.document), r ? r.querySelectorAll ? r.querySelectorAll(t) : r.getElementById("#" === t.charAt(0) ? t.substr(1) : t) : t)
					};
					var U = [],
						W = {},
						H = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
						V = /[\+-]=-?[\.\d]/,
						X = function(t) {
							for (var e, i = this._firstPT, n = 1e-6; i;) e = i.blob ? 1 === t && null != this.end ? this.end : t ? this.join("") : this.start : i.c * t + i.s, i.m ? e = i.m.call(this._tween, e, this._target || i.t, this._tween) : e < n && e > -n && !i.blob && (e = 0), i.f ? i.fp ? i.t[i.p](i.fp, e) : i.t[i.p](e) : i.t[i.p] = e, i = i._next
						},
						Y = function(t, e, i, n) {
							var s, o, r, a, l, h, u, c = [],
								d = 0,
								p = "",
								_ = 0;
							for (c.start = t, c.end = e, t = c[0] = t + "", e = c[1] = e + "", i && (i(c), t = c[0], e = c[1]), c.length = 0, s = t.match(H) || [], o = e.match(H) || [], n && (n._next = null, n.blob = 1, c._firstPT = c._applyPT = n), l = o.length, a = 0; a < l; a++) u = o[a], p += (h = e.substr(d, e.indexOf(u, d) - d)) || !a ? h : ",", d += h.length, _ ? _ = (_ + 1) % 5 : "rgba(" === h.substr(-5) && (_ = 1), u === s[a] || s.length <= a ? p += u : (p && (c.push(p), p = ""), r = parseFloat(s[a]), c.push(r), c._firstPT = {
								_next: c._firstPT,
								t: c,
								p: c.length - 1,
								s: r,
								c: ("=" === u.charAt(1) ? parseInt(u.charAt(0) + "1", 10) * parseFloat(u.substr(2)) : parseFloat(u) - r) || 0,
								f: 0,
								m: _ && _ < 4 ? Math.round : 0
							}), d += u.length;
							return (p += e.substr(d)) && c.push(p), c.setRatio = X, V.test(e) && (c.end = null), c
						},
						z = function(t, e, i, n, s, o, r, a, l) {
							"function" == typeof n && (n = n(l || 0, t));
							var h = typeof t[e],
								u = "function" !== h ? "" : e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3),
								c = "get" !== i ? i : u ? r ? t[u](r) : t[u]() : t[e],
								d = "string" == typeof n && "=" === n.charAt(1),
								p = {
									t,
									p: e,
									s: c,
									f: "function" === h,
									pg: 0,
									n: s || e,
									m: o ? "function" == typeof o ? o : Math.round : 0,
									pr: 0,
									c: d ? parseInt(n.charAt(0) + "1", 10) * parseFloat(n.substr(2)) : parseFloat(n) - c || 0
								};
							if (("number" != typeof c || "number" != typeof n && !d) && (r || isNaN(c) || !d && isNaN(n) || "boolean" == typeof c || "boolean" == typeof n ? (p.fp = r, p = {
									t: Y(c, d ? parseFloat(p.s) + p.c + (p.s + "").replace(/[0-9\-\.]/g, "") : n, a || F.defaultStringFilter, p),
									p: "setRatio",
									s: 0,
									c: 1,
									f: 2,
									pg: 0,
									n: s || e,
									pr: 0,
									m: 0
								}) : (p.s = parseFloat(c), d || (p.c = parseFloat(n) - p.s || 0))), p.c) return (p._next = this._firstPT) && (p._next._prev = p), this._firstPT = p, p
						},
						j = F._internals = {
							isArray: T,
							isSelector: G,
							lazyTweens: U,
							blobDif: Y
						},
						K = F._plugins = {},
						q = j.tweenLookup = {},
						Z = 0,
						$ = j.reservedProps = {
							ease: 1,
							delay: 1,
							overwrite: 1,
							onComplete: 1,
							onCompleteParams: 1,
							onCompleteScope: 1,
							useFrames: 1,
							runBackwards: 1,
							startAt: 1,
							onUpdate: 1,
							onUpdateParams: 1,
							onUpdateScope: 1,
							onStart: 1,
							onStartParams: 1,
							onStartScope: 1,
							onReverseComplete: 1,
							onReverseCompleteParams: 1,
							onReverseCompleteScope: 1,
							onRepeat: 1,
							onRepeatParams: 1,
							onRepeatScope: 1,
							easeParams: 1,
							yoyo: 1,
							immediateRender: 1,
							repeat: 1,
							repeatDelay: 1,
							data: 1,
							paused: 1,
							reversed: 1,
							autoCSS: 1,
							lazy: 1,
							onOverwrite: 1,
							callbackScope: 1,
							stringFilter: 1,
							id: 1,
							yoyoEase: 1
						},
						Q = {
							none: 0,
							all: 1,
							auto: 2,
							concurrent: 3,
							allOnStart: 4,
							preexisting: 5,
							true: 1,
							false: 0
						},
						J = R._rootFramesTimeline = new k,
						tt = R._rootTimeline = new k,
						et = 30,
						it = j.lazyRender = function() {
							var t, e = U.length;
							for (W = {}; --e > -1;)(t = U[e]) && !1 !== t._lazy && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1);
							U.length = 0
						};
					tt._startTime = d.time, J._startTime = d.frame, tt._active = J._active = !0, setTimeout(it, 1), R._updateRoot = F.render = function() {
						var t, e, i;
						if (U.length && it(), tt.render((d.time - tt._startTime) * tt._timeScale, !1, !1), J.render((d.frame - J._startTime) * J._timeScale, !1, !1), U.length && it(), d.frame >= et) {
							for (i in et = d.frame + (parseInt(F.autoSleep, 10) || 120), q) {
								for (t = (e = q[i].tweens).length; --t > -1;) e[t]._gc && e.splice(t, 1);
								0 === e.length && delete q[i]
							}
							if ((!(i = tt._first) || i._paused) && F.autoSleep && !J._first && 1 === d._listeners.tick.length) {
								for (; i && i._paused;) i = i._next;
								i || d.sleep()
							}
						}
					}, d.addEventListener("tick", R._updateRoot);
					var nt = function(t, e, i) {
							var n, s, o = t._gsTweenID;
							if (q[o || (t._gsTweenID = o = "t" + Z++)] || (q[o] = {
									target: t,
									tweens: []
								}), e && ((n = q[o].tweens)[s = n.length] = e, i))
								for (; --s > -1;) n[s] === e && n.splice(s, 1);
							return q[o].tweens
						},
						st = function(t, e, i, n) {
							var s, o, r = t.vars.onOverwrite;
							return r && (s = r(t, e, i, n)), (r = F.onOverwrite) && (o = r(t, e, i, n)), !1 !== s && !1 !== o
						},
						ot = function(t, e, i, n, s) {
							var o, r, a, l;
							if (1 === n || n >= 4) {
								for (l = s.length, o = 0; o < l; o++)
									if ((a = s[o]) !== e) a._gc || a._kill(null, t, e) && (r = !0);
									else if (5 === n) break;
								return r
							}
							var h, u = e._startTime + S,
								c = [],
								d = 0,
								p = 0 === e._duration;
							for (o = s.length; --o > -1;)(a = s[o]) === e || a._gc || a._paused || (a._timeline !== e._timeline ? (h = h || rt(e, 0, p), 0 === rt(a, h, p) && (c[d++] = a)) : a._startTime <= u && a._startTime + a.totalDuration() / a._timeScale > u && ((p || !a._initted) && u - a._startTime <= 2e-10 || (c[d++] = a)));
							for (o = d; --o > -1;)
								if (l = (a = c[o])._firstPT, 2 === n && a._kill(i, t, e) && (r = !0), 2 !== n || !a._firstPT && a._initted && l) {
									if (2 !== n && !st(a, e)) continue;
									a._enabled(!1, !1) && (r = !0)
								} return r
						},
						rt = function(t, e, i) {
							for (var n = t._timeline, s = n._timeScale, o = t._startTime; n._timeline;) {
								if (o += n._startTime, s *= n._timeScale, n._paused) return -100;
								n = n._timeline
							}
							return (o /= s) > e ? o - e : i && o === e || !t._initted && o - e < 2e-10 ? S : (o += t.totalDuration() / t._timeScale / s) > e + S ? 0 : o - e - S
						};
					c._init = function() {
						var t, e, i, n, s, o, r = this.vars,
							a = this._overwrittenProps,
							l = this._duration,
							h = !!r.immediateRender,
							u = r.ease;
						if (r.startAt) {
							for (n in this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), s = {}, r.startAt) s[n] = r.startAt[n];
							if (s.data = "isStart", s.overwrite = !1, s.immediateRender = !0, s.lazy = h && !1 !== r.lazy, s.startAt = s.delay = null, s.onUpdate = r.onUpdate, s.onUpdateParams = r.onUpdateParams, s.onUpdateScope = r.onUpdateScope || r.callbackScope || this, this._startAt = F.to(this.target || {}, 0, s), h)
								if (this._time > 0) this._startAt = null;
								else if (0 !== l) return
						} else if (r.runBackwards && 0 !== l)
							if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
							else {
								for (n in 0 !== this._time && (h = !1), i = {}, r) $[n] && "autoCSS" !== n || (i[n] = r[n]);
								if (i.overwrite = 0, i.data = "isFromStart", i.lazy = h && !1 !== r.lazy, i.immediateRender = h, this._startAt = F.to(this.target, 0, i), h) {
									if (0 === this._time) return
								} else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
							} if (this._ease = u = u ? u instanceof w ? u : "function" == typeof u ? new w(u, r.easeParams) : L[u] || F.defaultEase : F.defaultEase, r.easeParams instanceof Array && u.config && (this._ease = u.config.apply(u, r.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
							for (o = this._targets.length, t = 0; t < o; t++) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], a ? a[t] : null, t) && (e = !0);
						else e = this._initProps(this.target, this._propLookup, this._siblings, a, 0);
						if (e && F._onPluginEvent("_onInitAllProps", this), a && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), r.runBackwards)
							for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
						this._onUpdate = r.onUpdate, this._initted = !0
					}, c._initProps = function(t, e, n, s, o) {
						var r, a, l, h, u, c;
						if (null == t) return !1;
						for (r in W[t._gsTweenID] && it(), this.vars.css || t.style && t !== i && t.nodeType && K.css && !1 !== this.vars.autoCSS && function(t, e) {
								var i, n = {};
								for (i in t) $[i] || i in e && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!K[i] || K[i] && K[i]._autoCSS) || (n[i] = t[i], delete t[i]);
								t.css = n
							}(this.vars, t), this.vars)
							if (c = this.vars[r], $[r]) c && (c instanceof Array || c.push && T(c)) && -1 !== c.join("").indexOf("{self}") && (this.vars[r] = c = this._swapSelfInParams(c, this));
							else if (K[r] && (h = new K[r])._onInitTween(t, this.vars[r], this, o)) {
							for (this._firstPT = u = {
									_next: this._firstPT,
									t: h,
									p: "setRatio",
									s: 0,
									c: 1,
									f: 1,
									n: r,
									pg: 1,
									pr: h._priority,
									m: 0
								}, a = h._overwriteProps.length; --a > -1;) e[h._overwriteProps[a]] = this._firstPT;
							(h._priority || h._onInitAllProps) && (l = !0), (h._onDisable || h._onEnable) && (this._notifyPluginsOfEnabled = !0), u._next && (u._next._prev = u)
						} else e[r] = z.call(this, t, r, "get", c, r, 0, null, this.vars.stringFilter, o);
						return s && this._kill(s, t) ? this._initProps(t, e, n, s, o) : this._overwrite > 1 && this._firstPT && n.length > 1 && ot(t, this, e, this._overwrite, n) ? (this._kill(e, t), this._initProps(t, e, n, s, o)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (W[t._gsTweenID] = !0), l)
					}, c.render = function(t, e, i) {
						var n, s, o, r, a = this._time,
							l = this._duration,
							h = this._rawPrevTime;
						if (t >= l - 1e-7 && t >= 0) this._totalTime = this._time = l, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (n = !0, s = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === l && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (h < 0 || t <= 0 && t >= -1e-7 || h === S && "isPause" !== this.data) && h !== t && (i = !0, h > S && (s = "onReverseComplete")), this._rawPrevTime = r = !e || t || h === t ? t : S);
						else if (t < 1e-7) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== a || 0 === l && h > 0) && (s = "onReverseComplete", n = this._reversed), t < 0 && (this._active = !1, 0 === l && (this._initted || !this.vars.lazy || i) && (h >= 0 && (h !== S || "isPause" !== this.data) && (i = !0), this._rawPrevTime = r = !e || t || h === t ? t : S)), (!this._initted || this._startAt && this._startAt.progress()) && (i = !0);
						else if (this._totalTime = this._time = t, this._easeType) {
							var u = t / l,
								c = this._easeType,
								d = this._easePower;
							(1 === c || 3 === c && u >= .5) && (u = 1 - u), 3 === c && (u *= 2), 1 === d ? u *= u : 2 === d ? u *= u * u : 3 === d ? u *= u * u * u : 4 === d && (u *= u * u * u * u), this.ratio = 1 === c ? 1 - u : 2 === c ? u : t / l < .5 ? u / 2 : 1 - u / 2
						} else this.ratio = this._ease.getRatio(t / l);
						if (this._time !== a || i) {
							if (!this._initted) {
								if (this._init(), !this._initted || this._gc) return;
								if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = a, this._rawPrevTime = h, U.push(this), void(this._lazy = [t, e]);
								this._time && !n ? this.ratio = this._ease.getRatio(this._time / l) : n && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
							}
							for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== a && t >= 0 && (this._active = !0), 0 === a && (this._startAt && (t >= 0 ? this._startAt.render(t, !0, i) : s || (s = "_dummyGS")), this.vars.onStart && (0 === this._time && 0 !== l || e || this._callback("onStart"))), o = this._firstPT; o;) o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next;
							this._onUpdate && (t < 0 && this._startAt && -1e-4 !== t && this._startAt.render(t, !0, i), e || (this._time !== a || n || i) && this._callback("onUpdate")), s && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && -1e-4 !== t && this._startAt.render(t, !0, i), n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[s] && this._callback(s), 0 === l && this._rawPrevTime === S && r !== S && (this._rawPrevTime = 0)))
						}
					}, c._kill = function(t, e, i) {
						if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1);
						e = "string" != typeof e ? e || this._targets || this.target : F.selector(e) || e;
						var n, s, o, r, a, l, h, u, c, d = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline,
							p = this._firstPT;
						if ((T(e) || G(e)) && "number" != typeof e[0])
							for (n = e.length; --n > -1;) this._kill(t, e[n], i) && (l = !0);
						else {
							if (this._targets) {
								for (n = this._targets.length; --n > -1;)
									if (e === this._targets[n]) {
										a = this._propLookup[n] || {}, this._overwrittenProps = this._overwrittenProps || [], s = this._overwrittenProps[n] = t ? this._overwrittenProps[n] || {} : "all";
										break
									}
							} else {
								if (e !== this.target) return !1;
								a = this._propLookup, s = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
							}
							if (a) {
								if (h = t || a, u = t !== s && "all" !== s && t !== a && ("object" != typeof t || !t._tempKill), i && (F.onOverwrite || this.vars.onOverwrite)) {
									for (o in h) a[o] && (c || (c = []), c.push(o));
									if ((c || !t) && !st(this, i, e, c)) return !1
								}
								for (o in h)(r = a[o]) && (d && (r.f ? r.t[r.p](r.s) : r.t[r.p] = r.s, l = !0), r.pg && r.t._kill(h) && (l = !0), r.pg && 0 !== r.t._overwriteProps.length || (r._prev ? r._prev._next = r._next : r === this._firstPT && (this._firstPT = r._next), r._next && (r._next._prev = r._prev), r._next = r._prev = null), delete a[o]), u && (s[o] = 1);
								!this._firstPT && this._initted && p && this._enabled(!1, !1)
							}
						}
						return l
					}, c.invalidate = function() {
						return this._notifyPluginsOfEnabled && F._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], R.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -1e-10, this.render(Math.min(0, -this._delay))), this
					}, c._enabled = function(t, e) {
						if (p || d.wake(), t && this._gc) {
							var i, n = this._targets;
							if (n)
								for (i = n.length; --i > -1;) this._siblings[i] = nt(n[i], this, !0);
							else this._siblings = nt(this.target, this, !0)
						}
						return R.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && F._onPluginEvent(t ? "_onEnable" : "_onDisable", this)
					}, F.to = function(t, e, i) {
						return new F(t, e, i)
					}, F.from = function(t, e, i) {
						return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new F(t, e, i)
					}, F.fromTo = function(t, e, i, n) {
						return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new F(t, e, n)
					}, F.delayedCall = function(t, e, i, n, s) {
						return new F(e, 0, {
							delay: t,
							onComplete: e,
							onCompleteParams: i,
							callbackScope: n,
							onReverseComplete: e,
							onReverseCompleteParams: i,
							immediateRender: !1,
							lazy: !1,
							useFrames: s,
							overwrite: 0
						})
					}, F.set = function(t, e) {
						return new F(t, 0, e)
					}, F.getTweensOf = function(t, e) {
						if (null == t) return [];
						var i, n, s, o;
						if (t = "string" != typeof t ? t : F.selector(t) || t, (T(t) || G(t)) && "number" != typeof t[0]) {
							for (i = t.length, n = []; --i > -1;) n = n.concat(F.getTweensOf(t[i], e));
							for (i = n.length; --i > -1;)
								for (o = n[i], s = i; --s > -1;) o === n[s] && n.splice(i, 1)
						} else if (t._gsTweenID)
							for (i = (n = nt(t).concat()).length; --i > -1;)(n[i]._gc || e && !n[i].isActive()) && n.splice(i, 1);
						return n || []
					}, F.killTweensOf = F.killDelayedCallsTo = function(t, e, i) {
						"object" == typeof e && (i = e, e = !1);
						for (var n = F.getTweensOf(t, e), s = n.length; --s > -1;) n[s]._kill(i, t)
					};
					var at = P("plugins.TweenPlugin", (function(t, e) {
						this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = at.prototype
					}), !0);
					if (c = at.prototype, at.version = "1.19.0", at.API = 2, c._firstPT = null, c._addTween = z, c.setRatio = X, c._kill = function(t) {
							var e, i = this._overwriteProps,
								n = this._firstPT;
							if (null != t[this._propName]) this._overwriteProps = [];
							else
								for (e = i.length; --e > -1;) null != t[i[e]] && i.splice(e, 1);
							for (; n;) null != t[n.n] && (n._next && (n._next._prev = n._prev), n._prev ? (n._prev._next = n._next, n._prev = null) : this._firstPT === n && (this._firstPT = n._next)), n = n._next;
							return !1
						}, c._mod = c._roundProps = function(t) {
							for (var e, i = this._firstPT; i;)(e = t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")]) && "function" == typeof e && (2 === i.f ? i.t._applyPT.m = e : i.m = e), i = i._next
						}, F._onPluginEvent = function(t, e) {
							var i, n, s, o, r, a = e._firstPT;
							if ("_onInitAllProps" === t) {
								for (; a;) {
									for (r = a._next, n = s; n && n.pr > a.pr;) n = n._next;
									(a._prev = n ? n._prev : o) ? a._prev._next = a: s = a, (a._next = n) ? n._prev = a : o = a, a = r
								}
								a = e._firstPT = s
							}
							for (; a;) a.pg && "function" == typeof a.t[t] && a.t[t]() && (i = !0), a = a._next;
							return i
						}, at.activate = function(t) {
							for (var e = t.length; --e > -1;) t[e].API === at.API && (K[(new t[e])._propName] = t[e]);
							return !0
						}, A.plugin = function(t) {
							if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition.";
							var e, i = t.propName,
								n = t.priority || 0,
								s = t.overwriteProps,
								o = {
									init: "_onInitTween",
									set: "setRatio",
									kill: "_kill",
									round: "_mod",
									mod: "_mod",
									initAll: "_onInitAllProps"
								},
								r = P("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", (function() {
									at.call(this, i, n), this._overwriteProps = s || []
								}), !0 === t.global),
								a = r.prototype = new at(i);
							for (e in a.constructor = r, r.API = t.API, o) "function" == typeof t[e] && (a[o[e]] = t[e]);
							return r.version = t.version, at.activate([r]), r
						}, h = i._gsQueue) {
						for (u = 0; u < h.length; u++) h[u]();
						for (c in E) E[c].func || i.console.log("GSAP encountered missing dependency: " + c)
					}
					p = !1
				}(t.exports && void 0 !== i.g ? i.g : this || window, "TweenLite")
			},
			30592: (t, e, i) => {
				"use strict";
				var n = i(30655),
					s = function() {
						return !!n
					};
				s.hasArrayLengthDefineBug = function() {
					if (!n) return null;
					try {
						return 1 !== n([], "length", {
							value: 1
						}).length
					} catch (t) {
						return !0
					}
				}, t.exports = s
			},
			80024: t => {
				"use strict";
				var e = {
						__proto__: null,
						foo: {}
					},
					i = Object;
				t.exports = function() {
					return {
						__proto__: e
					}.foo === e.foo && !(e instanceof i)
				}
			},
			64039: (t, e, i) => {
				"use strict";
				var n = "undefined" != typeof Symbol && Symbol,
					s = i(41333);
				t.exports = function() {
					return "function" == typeof n && "function" == typeof Symbol && "symbol" == typeof n("foo") && "symbol" == typeof Symbol("bar") && s()
				}
			},
			41333: t => {
				"use strict";
				t.exports = function() {
					if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols) return !1;
					if ("symbol" == typeof Symbol.iterator) return !0;
					var t = {},
						e = Symbol("test"),
						i = Object(e);
					if ("string" == typeof e) return !1;
					if ("[object Symbol]" !== Object.prototype.toString.call(e)) return !1;
					if ("[object Symbol]" !== Object.prototype.toString.call(i)) return !1;
					for (e in t[e] = 42, t) return !1;
					if ("function" == typeof Object.keys && 0 !== Object.keys(t).length) return !1;
					if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(t).length) return !1;
					var n = Object.getOwnPropertySymbols(t);
					if (1 !== n.length || n[0] !== e) return !1;
					if (!Object.prototype.propertyIsEnumerable.call(t, e)) return !1;
					if ("function" == typeof Object.getOwnPropertyDescriptor) {
						var s = Object.getOwnPropertyDescriptor(t, e);
						if (42 !== s.value || !0 !== s.enumerable) return !1
					}
					return !0
				}
			},
			9957: (t, e, i) => {
				"use strict";
				var n = Function.prototype.call,
					s = Object.prototype.hasOwnProperty,
					o = i(66743);
				t.exports = o.call(n, s)
			},
			29110: (t, e) => {
				! function(t) {
					var e = /\S/,
						i = /\"/g,
						n = /\n/g,
						s = /\r/g,
						o = /\\/g,
						r = /\u2028/,
						a = /\u2029/;

					function l(t) {
						return t.trim ? t.trim() : t.replace(/^\s*|\s*$/g, "")
					}

					function h(t, e, i) {
						if (e.charAt(i) != t.charAt(0)) return !1;
						for (var n = 1, s = t.length; n < s; n++)
							if (e.charAt(i + n) != t.charAt(n)) return !1;
						return !0
					}
					t.tags = {
						"#": 1,
						"^": 2,
						"<": 3,
						$: 4,
						"/": 5,
						"!": 6,
						">": 7,
						"=": 8,
						_v: 9,
						"{": 10,
						"&": 11,
						_t: 12
					}, t.scan = function(i, n) {
						var s, o = i.length,
							r = 0,
							a = null,
							u = null,
							c = "",
							d = [],
							p = !1,
							_ = 0,
							m = 0,
							g = "{{",
							f = "}}";

						function S() {
							c.length > 0 && (d.push({
								tag: "_t",
								text: new String(c)
							}), c = "")
						}

						function y(i, n) {
							if (S(), i && function() {
									for (var i = !0, n = m; n < d.length; n++)
										if (!(i = t.tags[d[n].tag] < t.tags._v || "_t" == d[n].tag && null === d[n].text.match(e))) return !1;
									return i
								}())
								for (var s, o = m; o < d.length; o++) d[o].text && ((s = d[o + 1]) && ">" == s.tag && (s.indent = d[o].text.toString()), d.splice(o, 1));
							else n || d.push({
								tag: "\n"
							});
							p = !1, m = d.length
						}

						function v(t, e) {
							var i = "=" + f,
								n = t.indexOf(i, e),
								s = l(t.substring(t.indexOf("=", e) + 1, n)).split(" ");
							return g = s[0], f = s[s.length - 1], n + i.length - 1
						}
						for (n && (n = n.split(" "), g = n[0], f = n[1]), _ = 0; _ < o; _++) 0 == r ? h(g, i, _) ? (--_, S(), r = 1) : "\n" == i.charAt(_) ? y(p) : c += i.charAt(_) : 1 == r ? (_ += g.length - 1, "=" == (a = (u = t.tags[i.charAt(_ + 1)]) ? i.charAt(_ + 1) : "_v") ? (_ = v(i, _), r = 0) : (u && _++, r = 2), p = _) : h(f, i, _) ? (d.push({
							tag: a,
							n: l(c),
							otag: g,
							ctag: f,
							i: "/" == a ? p - g.length : _ + f.length
						}), c = "", _ += f.length - 1, r = 0, "{" == a && ("}}" == f ? _++ : "}" === (s = d[d.length - 1]).n.substr(s.n.length - 1) && (s.n = s.n.substring(0, s.n.length - 1)))) : c += i.charAt(_);
						return y(p, !0), d
					};
					var u = {
						_t: !0,
						"\n": !0,
						$: !0,
						"/": !0
					};

					function c(e, i, n, s) {
						var o, r = [],
							a = null,
							l = null;
						for (o = n[n.length - 1]; e.length > 0;) {
							if (l = e.shift(), o && "<" == o.tag && !(l.tag in u)) throw new Error("Illegal content in < super tag.");
							if (t.tags[l.tag] <= t.tags.$ || d(l, s)) n.push(l), l.nodes = c(e, l.tag, n, s);
							else {
								if ("/" == l.tag) {
									if (0 === n.length) throw new Error("Closing tag without opener: /" + l.n);
									if (a = n.pop(), l.n != a.n && !p(l.n, a.n, s)) throw new Error("Nesting error: " + a.n + " vs. " + l.n);
									return a.end = l.i, r
								}
								"\n" == l.tag && (l.last = 0 == e.length || "\n" == e[0].tag)
							}
							r.push(l)
						}
						if (n.length > 0) throw new Error("missing closing tag: " + n.pop().n);
						return r
					}

					function d(t, e) {
						for (var i = 0, n = e.length; i < n; i++)
							if (e[i].o == t.n) return t.tag = "#", !0
					}

					function p(t, e, i) {
						for (var n = 0, s = i.length; n < s; n++)
							if (i[n].c == t && i[n].o == e) return !0
					}

					function _(t) {
						var e = [];
						for (var i in t.partials) e.push('"' + g(i) + '":{name:"' + g(t.partials[i].name) + '", ' + _(t.partials[i]) + "}");
						return "partials: {" + e.join(",") + "}, subs: " + function(t) {
							var e = [];
							for (var i in t) e.push('"' + g(i) + '": function(c,p,t,i) {' + t[i] + "}");
							return "{ " + e.join(",") + " }"
						}(t.subs)
					}
					t.stringify = function(e, i, n) {
						return "{code: function (c,p,i) { " + t.wrapMain(e.code) + " }," + _(e) + "}"
					};
					var m = 0;

					function g(t) {
						return t.replace(o, "\\\\").replace(i, '\\"').replace(n, "\\n").replace(s, "\\r").replace(r, "\\u2028").replace(a, "\\u2029")
					}

					function f(t) {
						return ~t.indexOf(".") ? "d" : "f"
					}

					function S(t, e) {
						var i = "<" + (e.prefix || "") + t.n + m++;
						return e.partials[i] = {
							name: t.n,
							partials: {}
						}, e.code += 't.b(t.rp("' + g(i) + '",c,p,"' + (t.indent || "") + '"));', i
					}

					function y(t, e) {
						e.code += "t.b(t.t(t." + f(t.n) + '("' + g(t.n) + '",c,p,0)));'
					}

					function v(t) {
						return "t.b(" + t + ");"
					}
					t.generate = function(e, i, n) {
						m = 0;
						var s = {
							code: "",
							subs: {},
							partials: {}
						};
						return t.walk(e, s), n.asString ? this.stringify(s, i, n) : this.makeTemplate(s, i, n)
					}, t.wrapMain = function(t) {
						return 'var t=this;t.b(i=i||"");' + t + "return t.fl();"
					}, t.template = t.Template, t.makeTemplate = function(t, e, i) {
						var n = this.makePartials(t);
						return n.code = new Function("c", "p", "i", this.wrapMain(t.code)), new this.template(n, e, this, i)
					}, t.makePartials = function(t) {
						var e, i = {
							subs: {},
							partials: t.partials,
							name: t.name
						};
						for (e in i.partials) i.partials[e] = this.makePartials(i.partials[e]);
						for (e in t.subs) i.subs[e] = new Function("c", "p", "t", "i", t.subs[e]);
						return i
					}, t.codegen = {
						"#": function(e, i) {
							i.code += "if(t.s(t." + f(e.n) + '("' + g(e.n) + '",c,p,1),c,p,0,' + e.i + "," + e.end + ',"' + e.otag + " " + e.ctag + '")){t.rs(c,p,function(c,p,t){', t.walk(e.nodes, i), i.code += "});c.pop();}"
						},
						"^": function(e, i) {
							i.code += "if(!t.s(t." + f(e.n) + '("' + g(e.n) + '",c,p,1),c,p,1,0,0,"")){', t.walk(e.nodes, i), i.code += "};"
						},
						">": S,
						"<": function(e, i) {
							var n = {
								partials: {},
								code: "",
								subs: {},
								inPartial: !0
							};
							t.walk(e.nodes, n);
							var s = i.partials[S(e, i)];
							s.subs = n.subs, s.partials = n.partials
						},
						$: function(e, i) {
							var n = {
								subs: {},
								code: "",
								partials: i.partials,
								prefix: e.n
							};
							t.walk(e.nodes, n), i.subs[e.n] = n.code, i.inPartial || (i.code += 't.sub("' + g(e.n) + '",c,p,i);')
						},
						"\n": function(t, e) {
							e.code += v('"\\n"' + (t.last ? "" : " + i"))
						},
						_v: function(t, e) {
							e.code += "t.b(t.v(t." + f(t.n) + '("' + g(t.n) + '",c,p,0)));'
						},
						_t: function(t, e) {
							e.code += v('"' + g(t.text) + '"')
						},
						"{": y,
						"&": y
					}, t.walk = function(e, i) {
						for (var n, s = 0, o = e.length; s < o; s++)(n = t.codegen[e[s].tag]) && n(e[s], i);
						return i
					}, t.parse = function(t, e, i) {
						return c(t, 0, [], (i = i || {}).sectionTags || [])
					}, t.cache = {}, t.cacheKey = function(t, e) {
						return [t, !!e.asString, !!e.disableLambda, e.delimiters, !!e.modelGet].join("||")
					}, t.compile = function(e, i) {
						i = i || {};
						var n = t.cacheKey(e, i),
							s = this.cache[n];
						if (s) {
							var o = s.partials;
							for (var r in o) delete o[r].instance;
							return s
						}
						return s = this.generate(this.parse(this.scan(e, i.delimiters), e, i), e, i), this.cache[n] = s
					}
				}(e)
			},
			34714: (t, e, i) => {
				var n = i(29110);
				n.Template = i(59549).Template, n.template = n.Template, t.exports = n
			},
			59549: (t, e) => {
				! function(t) {
					function e(t, e, i) {
						var n;
						return e && "object" == typeof e && (void 0 !== e[t] ? n = e[t] : i && e.get && "function" == typeof e.get && (n = e.get(t))), n
					}
					t.Template = function(t, e, i, n) {
						t = t || {}, this.r = t.code || this.r, this.c = i, this.options = n || {}, this.text = e || "", this.partials = t.partials || {}, this.subs = t.subs || {}, this.buf = ""
					}, t.Template.prototype = {
						r: function(t, e, i) {
							return ""
						},
						v: function(t) {
							return t = l(t), a.test(t) ? t.replace(i, "&amp;").replace(n, "&lt;").replace(s, "&gt;").replace(o, "&#39;").replace(r, "&quot;") : t
						},
						t: l,
						render: function(t, e, i) {
							return this.ri([t], e || {}, i)
						},
						ri: function(t, e, i) {
							return this.r(t, e, i)
						},
						ep: function(t, e) {
							var i = this.partials[t],
								n = e[i.name];
							if (i.instance && i.base == n) return i.instance;
							if ("string" == typeof n) {
								if (!this.c) throw new Error("No compiler available.");
								n = this.c.compile(n, this.options)
							}
							if (!n) return null;
							if (this.partials[t].base = n, i.subs) {
								for (key in e.stackText || (e.stackText = {}), i.subs) e.stackText[key] || (e.stackText[key] = void 0 !== this.activeSub && e.stackText[this.activeSub] ? e.stackText[this.activeSub] : this.text);
								n = function(t, e, i, n, s, o) {
									function r() {}

									function a() {}
									var l;
									r.prototype = t, a.prototype = t.subs;
									var h = new r;
									for (l in h.subs = new a, h.subsText = {}, h.buf = "", n = n || {}, h.stackSubs = n, h.subsText = o, e) n[l] || (n[l] = e[l]);
									for (l in n) h.subs[l] = n[l];
									for (l in s = s || {}, h.stackPartials = s, i) s[l] || (s[l] = i[l]);
									for (l in s) h.partials[l] = s[l];
									return h
								}(n, i.subs, i.partials, this.stackSubs, this.stackPartials, e.stackText)
							}
							return this.partials[t].instance = n, n
						},
						rp: function(t, e, i, n) {
							var s = this.ep(t, i);
							return s ? s.ri(e, i, n) : ""
						},
						rs: function(t, e, i) {
							var n = t[t.length - 1];
							if (h(n))
								for (var s = 0; s < n.length; s++) t.push(n[s]), i(t, e, this), t.pop();
							else i(t, e, this)
						},
						s: function(t, e, i, n, s, o, r) {
							var a;
							return (!h(t) || 0 !== t.length) && ("function" == typeof t && (t = this.ms(t, e, i, n, s, o, r)), a = !!t, !n && a && e && e.push("object" == typeof t ? t : e[e.length - 1]), a)
						},
						d: function(t, i, n, s) {
							var o, r = t.split("."),
								a = this.f(r[0], i, n, s),
								l = this.options.modelGet,
								u = null;
							if ("." === t && h(i[i.length - 2])) a = i[i.length - 1];
							else
								for (var c = 1; c < r.length; c++) void 0 !== (o = e(r[c], a, l)) ? (u = a, a = o) : a = "";
							return !(s && !a) && (s || "function" != typeof a || (i.push(u), a = this.mv(a, i, n), i.pop()), a)
						},
						f: function(t, i, n, s) {
							for (var o = !1, r = !1, a = this.options.modelGet, l = i.length - 1; l >= 0; l--)
								if (void 0 !== (o = e(t, i[l], a))) {
									r = !0;
									break
								} return r ? (s || "function" != typeof o || (o = this.mv(o, i, n)), o) : !s && ""
						},
						ls: function(t, e, i, n, s) {
							var o = this.options.delimiters;
							return this.options.delimiters = s, this.b(this.ct(l(t.call(e, n)), e, i)), this.options.delimiters = o, !1
						},
						ct: function(t, e, i) {
							if (this.options.disableLambda) throw new Error("Lambda features disabled.");
							return this.c.compile(t, this.options).render(e, i)
						},
						b: function(t) {
							this.buf += t
						},
						fl: function() {
							var t = this.buf;
							return this.buf = "", t
						},
						ms: function(t, e, i, n, s, o, r) {
							var a, l = e[e.length - 1],
								h = t.call(l);
							return "function" == typeof h ? !!n || (a = this.activeSub && this.subsText && this.subsText[this.activeSub] ? this.subsText[this.activeSub] : this.text, this.ls(h, l, i, a.substring(s, o), r)) : h
						},
						mv: function(t, e, i) {
							var n = e[e.length - 1],
								s = t.call(n);
							return "function" == typeof s ? this.ct(l(s.call(n)), n, i) : s
						},
						sub: function(t, e, i, n) {
							var s = this.subs[t];
							s && (this.activeSub = t, s(e, i, this, n), this.activeSub = !1)
						}
					};
					var i = /&/g,
						n = /</g,
						s = />/g,
						o = /\'/g,
						r = /\"/g,
						a = /[&<>\"\']/;

					function l(t) {
						return String(null == t ? "" : t)
					}
					var h = Array.isArray || function(t) {
						return "[object Array]" === Object.prototype.toString.call(t)
					}
				}(e)
			},
			94196: (t, e, i) => {
				var n;
				! function() {
					"use strict";
					var s = function() {
						this.init()
					};
					s.prototype = {
						init: function() {
							var t = this || o;
							return t._counter = 1e3, t._html5AudioPool = [], t.html5PoolSize = 10, t._codecs = {}, t._howls = [], t._muted = !1, t._volume = 1, t._canPlayEvent = "canplaythrough", t._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null, t.masterGain = null, t.noAudio = !1, t.usingWebAudio = !0, t.autoSuspend = !0, t.ctx = null, t.autoUnlock = !0, t._setup(), t
						},
						volume: function(t) {
							var e = this || o;
							if (t = parseFloat(t), e.ctx || p(), void 0 !== t && t >= 0 && t <= 1) {
								if (e._volume = t, e._muted) return e;
								e.usingWebAudio && e.masterGain.gain.setValueAtTime(t, o.ctx.currentTime);
								for (var i = 0; i < e._howls.length; i++)
									if (!e._howls[i]._webAudio)
										for (var n = e._howls[i]._getSoundIds(), s = 0; s < n.length; s++) {
											var r = e._howls[i]._soundById(n[s]);
											r && r._node && (r._node.volume = r._volume * t)
										}
								return e
							}
							return e._volume
						},
						mute: function(t) {
							var e = this || o;
							e.ctx || p(), e._muted = t, e.usingWebAudio && e.masterGain.gain.setValueAtTime(t ? 0 : e._volume, o.ctx.currentTime);
							for (var i = 0; i < e._howls.length; i++)
								if (!e._howls[i]._webAudio)
									for (var n = e._howls[i]._getSoundIds(), s = 0; s < n.length; s++) {
										var r = e._howls[i]._soundById(n[s]);
										r && r._node && (r._node.muted = !!t || r._muted)
									}
							return e
						},
						stop: function() {
							for (var t = this || o, e = 0; e < t._howls.length; e++) t._howls[e].stop();
							return t
						},
						unload: function() {
							for (var t = this || o, e = t._howls.length - 1; e >= 0; e--) t._howls[e].unload();
							return t.usingWebAudio && t.ctx && void 0 !== t.ctx.close && (t.ctx.close(), t.ctx = null, p()), t
						},
						codecs: function(t) {
							return (this || o)._codecs[t.replace(/^x-/, "")]
						},
						_setup: function() {
							var t = this || o;
							if (t.state = t.ctx && t.ctx.state || "suspended", t._autoSuspend(), !t.usingWebAudio)
								if ("undefined" != typeof Audio) try {
									void 0 === (new Audio).oncanplaythrough && (t._canPlayEvent = "canplay")
								} catch (e) {
									t.noAudio = !0
								} else t.noAudio = !0;
							try {
								(new Audio).muted && (t.noAudio = !0)
							} catch (t) {}
							return t.noAudio || t._setupCodecs(), t
						},
						_setupCodecs: function() {
							var t = this || o,
								e = null;
							try {
								e = "undefined" != typeof Audio ? new Audio : null
							} catch (e) {
								return t
							}
							if (!e || "function" != typeof e.canPlayType) return t;
							var i = e.canPlayType("audio/mpeg;").replace(/^no$/, ""),
								n = t._navigator ? t._navigator.userAgent : "",
								s = n.match(/OPR\/(\d+)/g),
								r = s && parseInt(s[0].split("/")[1], 10) < 33,
								a = -1 !== n.indexOf("Safari") && -1 === n.indexOf("Chrome"),
								l = n.match(/Version\/(.*?) /),
								h = a && l && parseInt(l[1], 10) < 15;
							return t._codecs = {
								mp3: !(r || !i && !e.canPlayType("audio/mp3;").replace(/^no$/, "")),
								mpeg: !!i,
								opus: !!e.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
								ogg: !!e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
								oga: !!e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
								wav: !!(e.canPlayType('audio/wav; codecs="1"') || e.canPlayType("audio/wav")).replace(/^no$/, ""),
								aac: !!e.canPlayType("audio/aac;").replace(/^no$/, ""),
								caf: !!e.canPlayType("audio/x-caf;").replace(/^no$/, ""),
								m4a: !!(e.canPlayType("audio/x-m4a;") || e.canPlayType("audio/m4a;") || e.canPlayType("audio/aac;")).replace(/^no$/, ""),
								m4b: !!(e.canPlayType("audio/x-m4b;") || e.canPlayType("audio/m4b;") || e.canPlayType("audio/aac;")).replace(/^no$/, ""),
								mp4: !!(e.canPlayType("audio/x-mp4;") || e.canPlayType("audio/mp4;") || e.canPlayType("audio/aac;")).replace(/^no$/, ""),
								weba: !(h || !e.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
								webm: !(h || !e.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
								dolby: !!e.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
								flac: !!(e.canPlayType("audio/x-flac;") || e.canPlayType("audio/flac;")).replace(/^no$/, "")
							}, t
						},
						_unlockAudio: function() {
							var t = this || o;
							if (!t._audioUnlocked && t.ctx) {
								t._audioUnlocked = !1, t.autoUnlock = !1, t._mobileUnloaded || 44100 === t.ctx.sampleRate || (t._mobileUnloaded = !0, t.unload()), t._scratchBuffer = t.ctx.createBuffer(1, 1, 22050);
								var e = function(i) {
									for (; t._html5AudioPool.length < t.html5PoolSize;) try {
										var n = new Audio;
										n._unlocked = !0, t._releaseHtml5Audio(n)
									} catch (i) {
										t.noAudio = !0;
										break
									}
									for (var s = 0; s < t._howls.length; s++)
										if (!t._howls[s]._webAudio)
											for (var o = t._howls[s]._getSoundIds(), r = 0; r < o.length; r++) {
												var a = t._howls[s]._soundById(o[r]);
												a && a._node && !a._node._unlocked && (a._node._unlocked = !0, a._node.load())
											}
									t._autoResume();
									var l = t.ctx.createBufferSource();
									l.buffer = t._scratchBuffer, l.connect(t.ctx.destination), void 0 === l.start ? l.noteOn(0) : l.start(0), "function" == typeof t.ctx.resume && t.ctx.resume(), l.onended = function() {
										l.disconnect(0), t._audioUnlocked = !0, document.removeEventListener("touchstart", e, !0), document.removeEventListener("touchend", e, !0), document.removeEventListener("click", e, !0), document.removeEventListener("keydown", e, !0);
										for (var i = 0; i < t._howls.length; i++) t._howls[i]._emit("unlock")
									}
								};
								return document.addEventListener("touchstart", e, !0), document.addEventListener("touchend", e, !0), document.addEventListener("click", e, !0), document.addEventListener("keydown", e, !0), t
							}
						},
						_obtainHtml5Audio: function() {
							var t = this || o;
							if (t._html5AudioPool.length) return t._html5AudioPool.pop();
							var e = (new Audio).play();
							return e && "undefined" != typeof Promise && (e instanceof Promise || "function" == typeof e.then) && e.catch((function() {
								console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.")
							})), new Audio
						},
						_releaseHtml5Audio: function(t) {
							var e = this || o;
							return t._unlocked && e._html5AudioPool.push(t), e
						},
						_autoSuspend: function() {
							var t = this;
							if (t.autoSuspend && t.ctx && void 0 !== t.ctx.suspend && o.usingWebAudio) {
								for (var e = 0; e < t._howls.length; e++)
									if (t._howls[e]._webAudio)
										for (var i = 0; i < t._howls[e]._sounds.length; i++)
											if (!t._howls[e]._sounds[i]._paused) return t;
								return t._suspendTimer && clearTimeout(t._suspendTimer), t._suspendTimer = setTimeout((function() {
									if (t.autoSuspend) {
										t._suspendTimer = null, t.state = "suspending";
										var e = function() {
											t.state = "suspended", t._resumeAfterSuspend && (delete t._resumeAfterSuspend, t._autoResume())
										};
										t.ctx.suspend().then(e, e)
									}
								}), 3e4), t
							}
						},
						_autoResume: function() {
							var t = this;
							if (t.ctx && void 0 !== t.ctx.resume && o.usingWebAudio) return "running" === t.state && "interrupted" !== t.ctx.state && t._suspendTimer ? (clearTimeout(t._suspendTimer), t._suspendTimer = null) : "suspended" === t.state || "running" === t.state && "interrupted" === t.ctx.state ? (t.ctx.resume().then((function() {
								t.state = "running";
								for (var e = 0; e < t._howls.length; e++) t._howls[e]._emit("resume")
							})), t._suspendTimer && (clearTimeout(t._suspendTimer), t._suspendTimer = null)) : "suspending" === t.state && (t._resumeAfterSuspend = !0), t
						}
					};
					var o = new s,
						r = function(t) {
							t.src && 0 !== t.src.length ? this.init(t) : console.error("An array of source files must be passed with any new Howl.")
						};
					r.prototype = {
						init: function(t) {
							var e = this;
							return o.ctx || p(), e._autoplay = t.autoplay || !1, e._format = "string" != typeof t.format ? t.format : [t.format], e._html5 = t.html5 || !1, e._muted = t.mute || !1, e._loop = t.loop || !1, e._pool = t.pool || 5, e._preload = "boolean" != typeof t.preload && "metadata" !== t.preload || t.preload, e._rate = t.rate || 1, e._sprite = t.sprite || {}, e._src = "string" != typeof t.src ? t.src : [t.src], e._volume = void 0 !== t.volume ? t.volume : 1, e._xhr = {
								method: t.xhr && t.xhr.method ? t.xhr.method : "GET",
								headers: t.xhr && t.xhr.headers ? t.xhr.headers : null,
								withCredentials: !(!t.xhr || !t.xhr.withCredentials) && t.xhr.withCredentials
							}, e._duration = 0, e._state = "unloaded", e._sounds = [], e._endTimers = {}, e._queue = [], e._playLock = !1, e._onend = t.onend ? [{
								fn: t.onend
							}] : [], e._onfade = t.onfade ? [{
								fn: t.onfade
							}] : [], e._onload = t.onload ? [{
								fn: t.onload
							}] : [], e._onloaderror = t.onloaderror ? [{
								fn: t.onloaderror
							}] : [], e._onplayerror = t.onplayerror ? [{
								fn: t.onplayerror
							}] : [], e._onpause = t.onpause ? [{
								fn: t.onpause
							}] : [], e._onplay = t.onplay ? [{
								fn: t.onplay
							}] : [], e._onstop = t.onstop ? [{
								fn: t.onstop
							}] : [], e._onmute = t.onmute ? [{
								fn: t.onmute
							}] : [], e._onvolume = t.onvolume ? [{
								fn: t.onvolume
							}] : [], e._onrate = t.onrate ? [{
								fn: t.onrate
							}] : [], e._onseek = t.onseek ? [{
								fn: t.onseek
							}] : [], e._onunlock = t.onunlock ? [{
								fn: t.onunlock
							}] : [], e._onresume = [], e._webAudio = o.usingWebAudio && !e._html5, void 0 !== o.ctx && o.ctx && o.autoUnlock && o._unlockAudio(), o._howls.push(e), e._autoplay && e._queue.push({
								event: "play",
								action: function() {
									e.play()
								}
							}), e._preload && "none" !== e._preload && e.load(), e
						},
						load: function() {
							var t = this,
								e = null;
							if (o.noAudio) t._emit("loaderror", null, "No audio support.");
							else {
								"string" == typeof t._src && (t._src = [t._src]);
								for (var i = 0; i < t._src.length; i++) {
									var n, s;
									if (t._format && t._format[i]) n = t._format[i];
									else {
										if ("string" != typeof(s = t._src[i])) {
											t._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
											continue
										}(n = /^data:audio\/([^;,]+);/i.exec(s)) || (n = /\.([^.]+)$/.exec(s.split("?", 1)[0])), n && (n = n[1].toLowerCase())
									}
									if (n || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), n && o.codecs(n)) {
										e = t._src[i];
										break
									}
								}
								if (e) return t._src = e, t._state = "loading", "https:" === window.location.protocol && "http:" === e.slice(0, 5) && (t._html5 = !0, t._webAudio = !1), new a(t), t._webAudio && h(t), t;
								t._emit("loaderror", null, "No codec support for selected audio sources.")
							}
						},
						play: function(t, e) {
							var i = this,
								n = null;
							if ("number" == typeof t) n = t, t = null;
							else {
								if ("string" == typeof t && "loaded" === i._state && !i._sprite[t]) return null;
								if (void 0 === t && (t = "__default", !i._playLock)) {
									for (var s = 0, r = 0; r < i._sounds.length; r++) i._sounds[r]._paused && !i._sounds[r]._ended && (s++, n = i._sounds[r]._id);
									1 === s ? t = null : n = null
								}
							}
							var a = n ? i._soundById(n) : i._inactiveSound();
							if (!a) return null;
							if (n && !t && (t = a._sprite || "__default"), "loaded" !== i._state) {
								a._sprite = t, a._ended = !1;
								var l = a._id;
								return i._queue.push({
									event: "play",
									action: function() {
										i.play(l)
									}
								}), l
							}
							if (n && !a._paused) return e || i._loadQueue("play"), a._id;
							i._webAudio && o._autoResume();
							var h = Math.max(0, a._seek > 0 ? a._seek : i._sprite[t][0] / 1e3),
								u = Math.max(0, (i._sprite[t][0] + i._sprite[t][1]) / 1e3 - h),
								c = 1e3 * u / Math.abs(a._rate),
								d = i._sprite[t][0] / 1e3,
								p = (i._sprite[t][0] + i._sprite[t][1]) / 1e3;
							a._sprite = t, a._ended = !1;
							var _ = function() {
								a._paused = !1, a._seek = h, a._start = d, a._stop = p, a._loop = !(!a._loop && !i._sprite[t][2])
							};
							if (!(h >= p)) {
								var m = a._node;
								if (i._webAudio) {
									var g = function() {
										i._playLock = !1, _(), i._refreshBuffer(a);
										var t = a._muted || i._muted ? 0 : a._volume;
										m.gain.setValueAtTime(t, o.ctx.currentTime), a._playStart = o.ctx.currentTime, void 0 === m.bufferSource.start ? a._loop ? m.bufferSource.noteGrainOn(0, h, 86400) : m.bufferSource.noteGrainOn(0, h, u) : a._loop ? m.bufferSource.start(0, h, 86400) : m.bufferSource.start(0, h, u), c !== 1 / 0 && (i._endTimers[a._id] = setTimeout(i._ended.bind(i, a), c)), e || setTimeout((function() {
											i._emit("play", a._id), i._loadQueue()
										}), 0)
									};
									"running" === o.state && "interrupted" !== o.ctx.state ? g() : (i._playLock = !0, i.once("resume", g), i._clearTimer(a._id))
								} else {
									var f = function() {
										m.currentTime = h, m.muted = a._muted || i._muted || o._muted || m.muted, m.volume = a._volume * o.volume(), m.playbackRate = a._rate;
										try {
											var n = m.play();
											if (n && "undefined" != typeof Promise && (n instanceof Promise || "function" == typeof n.then) ? (i._playLock = !0, _(), n.then((function() {
													i._playLock = !1, m._unlocked = !0, e ? i._loadQueue() : i._emit("play", a._id)
												})).catch((function() {
													i._playLock = !1, i._emit("playerror", a._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), a._ended = !0, a._paused = !0
												}))) : e || (i._playLock = !1, _(), i._emit("play", a._id)), m.playbackRate = a._rate, m.paused) return void i._emit("playerror", a._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
											"__default" !== t || a._loop ? i._endTimers[a._id] = setTimeout(i._ended.bind(i, a), c) : (i._endTimers[a._id] = function() {
												i._ended(a), m.removeEventListener("ended", i._endTimers[a._id], !1)
											}, m.addEventListener("ended", i._endTimers[a._id], !1))
										} catch (t) {
											i._emit("playerror", a._id, t)
										}
									};
									"data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" === m.src && (m.src = i._src, m.load());
									var S = window && window.ejecta || !m.readyState && o._navigator.isCocoonJS;
									if (m.readyState >= 3 || S) f();
									else {
										i._playLock = !0, i._state = "loading";
										var y = function() {
											i._state = "loaded", f(), m.removeEventListener(o._canPlayEvent, y, !1)
										};
										m.addEventListener(o._canPlayEvent, y, !1), i._clearTimer(a._id)
									}
								}
								return a._id
							}
							i._ended(a)
						},
						pause: function(t) {
							var e = this;
							if ("loaded" !== e._state || e._playLock) return e._queue.push({
								event: "pause",
								action: function() {
									e.pause(t)
								}
							}), e;
							for (var i = e._getSoundIds(t), n = 0; n < i.length; n++) {
								e._clearTimer(i[n]);
								var s = e._soundById(i[n]);
								if (s && !s._paused && (s._seek = e.seek(i[n]), s._rateSeek = 0, s._paused = !0, e._stopFade(i[n]), s._node))
									if (e._webAudio) {
										if (!s._node.bufferSource) continue;
										void 0 === s._node.bufferSource.stop ? s._node.bufferSource.noteOff(0) : s._node.bufferSource.stop(0), e._cleanBuffer(s._node)
									} else isNaN(s._node.duration) && s._node.duration !== 1 / 0 || s._node.pause();
								arguments[1] || e._emit("pause", s ? s._id : null)
							}
							return e
						},
						stop: function(t, e) {
							var i = this;
							if ("loaded" !== i._state || i._playLock) return i._queue.push({
								event: "stop",
								action: function() {
									i.stop(t)
								}
							}), i;
							for (var n = i._getSoundIds(t), s = 0; s < n.length; s++) {
								i._clearTimer(n[s]);
								var o = i._soundById(n[s]);
								o && (o._seek = o._start || 0, o._rateSeek = 0, o._paused = !0, o._ended = !0, i._stopFade(n[s]), o._node && (i._webAudio ? o._node.bufferSource && (void 0 === o._node.bufferSource.stop ? o._node.bufferSource.noteOff(0) : o._node.bufferSource.stop(0), i._cleanBuffer(o._node)) : isNaN(o._node.duration) && o._node.duration !== 1 / 0 || (o._node.currentTime = o._start || 0, o._node.pause(), o._node.duration === 1 / 0 && i._clearSound(o._node))), e || i._emit("stop", o._id))
							}
							return i
						},
						mute: function(t, e) {
							var i = this;
							if ("loaded" !== i._state || i._playLock) return i._queue.push({
								event: "mute",
								action: function() {
									i.mute(t, e)
								}
							}), i;
							if (void 0 === e) {
								if ("boolean" != typeof t) return i._muted;
								i._muted = t
							}
							for (var n = i._getSoundIds(e), s = 0; s < n.length; s++) {
								var r = i._soundById(n[s]);
								r && (r._muted = t, r._interval && i._stopFade(r._id), i._webAudio && r._node ? r._node.gain.setValueAtTime(t ? 0 : r._volume, o.ctx.currentTime) : r._node && (r._node.muted = !!o._muted || t), i._emit("mute", r._id))
							}
							return i
						},
						volume: function() {
							var t, e, i, n = this,
								s = arguments;
							if (0 === s.length) return n._volume;
							if (1 === s.length || 2 === s.length && void 0 === s[1] ? n._getSoundIds().indexOf(s[0]) >= 0 ? e = parseInt(s[0], 10) : t = parseFloat(s[0]) : s.length >= 2 && (t = parseFloat(s[0]), e = parseInt(s[1], 10)), !(void 0 !== t && t >= 0 && t <= 1)) return (i = e ? n._soundById(e) : n._sounds[0]) ? i._volume : 0;
							if ("loaded" !== n._state || n._playLock) return n._queue.push({
								event: "volume",
								action: function() {
									n.volume.apply(n, s)
								}
							}), n;
							void 0 === e && (n._volume = t), e = n._getSoundIds(e);
							for (var r = 0; r < e.length; r++)(i = n._soundById(e[r])) && (i._volume = t, s[2] || n._stopFade(e[r]), n._webAudio && i._node && !i._muted ? i._node.gain.setValueAtTime(t, o.ctx.currentTime) : i._node && !i._muted && (i._node.volume = t * o.volume()), n._emit("volume", i._id));
							return n
						},
						fade: function(t, e, i, n) {
							var s = this;
							if ("loaded" !== s._state || s._playLock) return s._queue.push({
								event: "fade",
								action: function() {
									s.fade(t, e, i, n)
								}
							}), s;
							t = Math.min(Math.max(0, parseFloat(t)), 1), e = Math.min(Math.max(0, parseFloat(e)), 1), i = parseFloat(i), s.volume(t, n);
							for (var r = s._getSoundIds(n), a = 0; a < r.length; a++) {
								var l = s._soundById(r[a]);
								if (l) {
									if (n || s._stopFade(r[a]), s._webAudio && !l._muted) {
										var h = o.ctx.currentTime,
											u = h + i / 1e3;
										l._volume = t, l._node.gain.setValueAtTime(t, h), l._node.gain.linearRampToValueAtTime(e, u)
									}
									s._startFadeInterval(l, t, e, i, r[a], void 0 === n)
								}
							}
							return s
						},
						_startFadeInterval: function(t, e, i, n, s, o) {
							var r = this,
								a = e,
								l = i - e,
								h = Math.abs(l / .01),
								u = Math.max(4, h > 0 ? n / h : n),
								c = Date.now();
							t._fadeTo = i, t._interval = setInterval((function() {
								var s = (Date.now() - c) / n;
								c = Date.now(), a += l * s, a = Math.round(100 * a) / 100, a = l < 0 ? Math.max(i, a) : Math.min(i, a), r._webAudio ? t._volume = a : r.volume(a, t._id, !0), o && (r._volume = a), (i < e && a <= i || i > e && a >= i) && (clearInterval(t._interval), t._interval = null, t._fadeTo = null, r.volume(i, t._id), r._emit("fade", t._id))
							}), u)
						},
						_stopFade: function(t) {
							var e = this,
								i = e._soundById(t);
							return i && i._interval && (e._webAudio && i._node.gain.cancelScheduledValues(o.ctx.currentTime), clearInterval(i._interval), i._interval = null, e.volume(i._fadeTo, t), i._fadeTo = null, e._emit("fade", t)), e
						},
						loop: function() {
							var t, e, i, n = this,
								s = arguments;
							if (0 === s.length) return n._loop;
							if (1 === s.length) {
								if ("boolean" != typeof s[0]) return !!(i = n._soundById(parseInt(s[0], 10))) && i._loop;
								t = s[0], n._loop = t
							} else 2 === s.length && (t = s[0], e = parseInt(s[1], 10));
							for (var o = n._getSoundIds(e), r = 0; r < o.length; r++)(i = n._soundById(o[r])) && (i._loop = t, n._webAudio && i._node && i._node.bufferSource && (i._node.bufferSource.loop = t, t && (i._node.bufferSource.loopStart = i._start || 0, i._node.bufferSource.loopEnd = i._stop, n.playing(o[r]) && (n.pause(o[r], !0), n.play(o[r], !0)))));
							return n
						},
						rate: function() {
							var t, e, i, n = this,
								s = arguments;
							if (0 === s.length ? e = n._sounds[0]._id : 1 === s.length ? n._getSoundIds().indexOf(s[0]) >= 0 ? e = parseInt(s[0], 10) : t = parseFloat(s[0]) : 2 === s.length && (t = parseFloat(s[0]), e = parseInt(s[1], 10)), "number" != typeof t) return (i = n._soundById(e)) ? i._rate : n._rate;
							if ("loaded" !== n._state || n._playLock) return n._queue.push({
								event: "rate",
								action: function() {
									n.rate.apply(n, s)
								}
							}), n;
							void 0 === e && (n._rate = t), e = n._getSoundIds(e);
							for (var r = 0; r < e.length; r++)
								if (i = n._soundById(e[r])) {
									n.playing(e[r]) && (i._rateSeek = n.seek(e[r]), i._playStart = n._webAudio ? o.ctx.currentTime : i._playStart), i._rate = t, n._webAudio && i._node && i._node.bufferSource ? i._node.bufferSource.playbackRate.setValueAtTime(t, o.ctx.currentTime) : i._node && (i._node.playbackRate = t);
									var a = n.seek(e[r]),
										l = 1e3 * ((n._sprite[i._sprite][0] + n._sprite[i._sprite][1]) / 1e3 - a) / Math.abs(i._rate);
									!n._endTimers[e[r]] && i._paused || (n._clearTimer(e[r]), n._endTimers[e[r]] = setTimeout(n._ended.bind(n, i), l)), n._emit("rate", i._id)
								} return n
						},
						seek: function() {
							var t, e, i = this,
								n = arguments;
							if (0 === n.length ? i._sounds.length && (e = i._sounds[0]._id) : 1 === n.length ? i._getSoundIds().indexOf(n[0]) >= 0 ? e = parseInt(n[0], 10) : i._sounds.length && (e = i._sounds[0]._id, t = parseFloat(n[0])) : 2 === n.length && (t = parseFloat(n[0]), e = parseInt(n[1], 10)), void 0 === e) return 0;
							if ("number" == typeof t && ("loaded" !== i._state || i._playLock)) return i._queue.push({
								event: "seek",
								action: function() {
									i.seek.apply(i, n)
								}
							}), i;
							var s = i._soundById(e);
							if (s) {
								if (!("number" == typeof t && t >= 0)) {
									if (i._webAudio) {
										var r = i.playing(e) ? o.ctx.currentTime - s._playStart : 0,
											a = s._rateSeek ? s._rateSeek - s._seek : 0;
										return s._seek + (a + r * Math.abs(s._rate))
									}
									return s._node.currentTime
								}
								var l = i.playing(e);
								l && i.pause(e, !0), s._seek = t, s._ended = !1, i._clearTimer(e), i._webAudio || !s._node || isNaN(s._node.duration) || (s._node.currentTime = t);
								var h = function() {
									l && i.play(e, !0), i._emit("seek", e)
								};
								if (l && !i._webAudio) {
									var u = function() {
										i._playLock ? setTimeout(u, 0) : h()
									};
									setTimeout(u, 0)
								} else h()
							}
							return i
						},
						playing: function(t) {
							var e = this;
							if ("number" == typeof t) {
								var i = e._soundById(t);
								return !!i && !i._paused
							}
							for (var n = 0; n < e._sounds.length; n++)
								if (!e._sounds[n]._paused) return !0;
							return !1
						},
						duration: function(t) {
							var e = this,
								i = e._duration,
								n = e._soundById(t);
							return n && (i = e._sprite[n._sprite][1] / 1e3), i
						},
						state: function() {
							return this._state
						},
						unload: function() {
							for (var t = this, e = t._sounds, i = 0; i < e.length; i++) e[i]._paused || t.stop(e[i]._id), t._webAudio || (t._clearSound(e[i]._node), e[i]._node.removeEventListener("error", e[i]._errorFn, !1), e[i]._node.removeEventListener(o._canPlayEvent, e[i]._loadFn, !1), e[i]._node.removeEventListener("ended", e[i]._endFn, !1), o._releaseHtml5Audio(e[i]._node)), delete e[i]._node, t._clearTimer(e[i]._id);
							var n = o._howls.indexOf(t);
							n >= 0 && o._howls.splice(n, 1);
							var s = !0;
							for (i = 0; i < o._howls.length; i++)
								if (o._howls[i]._src === t._src || t._src.indexOf(o._howls[i]._src) >= 0) {
									s = !1;
									break
								} return l && s && delete l[t._src], o.noAudio = !1, t._state = "unloaded", t._sounds = [], t = null, null
						},
						on: function(t, e, i, n) {
							var s = this["_on" + t];
							return "function" == typeof e && s.push(n ? {
								id: i,
								fn: e,
								once: n
							} : {
								id: i,
								fn: e
							}), this
						},
						off: function(t, e, i) {
							var n = this,
								s = n["_on" + t],
								o = 0;
							if ("number" == typeof e && (i = e, e = null), e || i)
								for (o = 0; o < s.length; o++) {
									var r = i === s[o].id;
									if (e === s[o].fn && r || !e && r) {
										s.splice(o, 1);
										break
									}
								} else if (t) n["_on" + t] = [];
								else {
									var a = Object.keys(n);
									for (o = 0; o < a.length; o++) 0 === a[o].indexOf("_on") && Array.isArray(n[a[o]]) && (n[a[o]] = [])
								} return n
						},
						once: function(t, e, i) {
							return this.on(t, e, i, 1), this
						},
						_emit: function(t, e, i) {
							for (var n = this, s = n["_on" + t], o = s.length - 1; o >= 0; o--) s[o].id && s[o].id !== e && "load" !== t || (setTimeout(function(t) {
								t.call(this, e, i)
							}.bind(n, s[o].fn), 0), s[o].once && n.off(t, s[o].fn, s[o].id));
							return n._loadQueue(t), n
						},
						_loadQueue: function(t) {
							var e = this;
							if (e._queue.length > 0) {
								var i = e._queue[0];
								i.event === t && (e._queue.shift(), e._loadQueue()), t || i.action()
							}
							return e
						},
						_ended: function(t) {
							var e = this,
								i = t._sprite;
							if (!e._webAudio && t._node && !t._node.paused && !t._node.ended && t._node.currentTime < t._stop) return setTimeout(e._ended.bind(e, t), 100), e;
							var n = !(!t._loop && !e._sprite[i][2]);
							if (e._emit("end", t._id), !e._webAudio && n && e.stop(t._id, !0).play(t._id), e._webAudio && n) {
								e._emit("play", t._id), t._seek = t._start || 0, t._rateSeek = 0, t._playStart = o.ctx.currentTime;
								var s = 1e3 * (t._stop - t._start) / Math.abs(t._rate);
								e._endTimers[t._id] = setTimeout(e._ended.bind(e, t), s)
							}
							return e._webAudio && !n && (t._paused = !0, t._ended = !0, t._seek = t._start || 0, t._rateSeek = 0, e._clearTimer(t._id), e._cleanBuffer(t._node), o._autoSuspend()), e._webAudio || n || e.stop(t._id, !0), e
						},
						_clearTimer: function(t) {
							var e = this;
							if (e._endTimers[t]) {
								if ("function" != typeof e._endTimers[t]) clearTimeout(e._endTimers[t]);
								else {
									var i = e._soundById(t);
									i && i._node && i._node.removeEventListener("ended", e._endTimers[t], !1)
								}
								delete e._endTimers[t]
							}
							return e
						},
						_soundById: function(t) {
							for (var e = this, i = 0; i < e._sounds.length; i++)
								if (t === e._sounds[i]._id) return e._sounds[i];
							return null
						},
						_inactiveSound: function() {
							var t = this;
							t._drain();
							for (var e = 0; e < t._sounds.length; e++)
								if (t._sounds[e]._ended) return t._sounds[e].reset();
							return new a(t)
						},
						_drain: function() {
							var t = this,
								e = t._pool,
								i = 0,
								n = 0;
							if (!(t._sounds.length < e)) {
								for (n = 0; n < t._sounds.length; n++) t._sounds[n]._ended && i++;
								for (n = t._sounds.length - 1; n >= 0; n--) {
									if (i <= e) return;
									t._sounds[n]._ended && (t._webAudio && t._sounds[n]._node && t._sounds[n]._node.disconnect(0), t._sounds.splice(n, 1), i--)
								}
							}
						},
						_getSoundIds: function(t) {
							if (void 0 === t) {
								for (var e = [], i = 0; i < this._sounds.length; i++) e.push(this._sounds[i]._id);
								return e
							}
							return [t]
						},
						_refreshBuffer: function(t) {
							return t._node.bufferSource = o.ctx.createBufferSource(), t._node.bufferSource.buffer = l[this._src], t._panner ? t._node.bufferSource.connect(t._panner) : t._node.bufferSource.connect(t._node), t._node.bufferSource.loop = t._loop, t._loop && (t._node.bufferSource.loopStart = t._start || 0, t._node.bufferSource.loopEnd = t._stop || 0), t._node.bufferSource.playbackRate.setValueAtTime(t._rate, o.ctx.currentTime), this
						},
						_cleanBuffer: function(t) {
							var e = o._navigator && o._navigator.vendor.indexOf("Apple") >= 0;
							if (!t.bufferSource) return this;
							if (o._scratchBuffer && t.bufferSource && (t.bufferSource.onended = null, t.bufferSource.disconnect(0), e)) try {
								t.bufferSource.buffer = o._scratchBuffer
							} catch (t) {}
							return t.bufferSource = null, this
						},
						_clearSound: function(t) {
							/MSIE |Trident\//.test(o._navigator && o._navigator.userAgent) || (t.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")
						}
					};
					var a = function(t) {
						this._parent = t, this.init()
					};
					a.prototype = {
						init: function() {
							var t = this,
								e = t._parent;
							return t._muted = e._muted, t._loop = e._loop, t._volume = e._volume, t._rate = e._rate, t._seek = 0, t._paused = !0, t._ended = !0, t._sprite = "__default", t._id = ++o._counter, e._sounds.push(t), t.create(), t
						},
						create: function() {
							var t = this,
								e = t._parent,
								i = o._muted || t._muted || t._parent._muted ? 0 : t._volume;
							return e._webAudio ? (t._node = void 0 === o.ctx.createGain ? o.ctx.createGainNode() : o.ctx.createGain(), t._node.gain.setValueAtTime(i, o.ctx.currentTime), t._node.paused = !0, t._node.connect(o.masterGain)) : o.noAudio || (t._node = o._obtainHtml5Audio(), t._errorFn = t._errorListener.bind(t), t._node.addEventListener("error", t._errorFn, !1), t._loadFn = t._loadListener.bind(t), t._node.addEventListener(o._canPlayEvent, t._loadFn, !1), t._endFn = t._endListener.bind(t), t._node.addEventListener("ended", t._endFn, !1), t._node.src = e._src, t._node.preload = !0 === e._preload ? "auto" : e._preload, t._node.volume = i * o.volume(), t._node.load()), t
						},
						reset: function() {
							var t = this,
								e = t._parent;
							return t._muted = e._muted, t._loop = e._loop, t._volume = e._volume, t._rate = e._rate, t._seek = 0, t._rateSeek = 0, t._paused = !0, t._ended = !0, t._sprite = "__default", t._id = ++o._counter, t
						},
						_errorListener: function() {
							var t = this;
							t._parent._emit("loaderror", t._id, t._node.error ? t._node.error.code : 0), t._node.removeEventListener("error", t._errorFn, !1)
						},
						_loadListener: function() {
							var t = this,
								e = t._parent;
							e._duration = Math.ceil(10 * t._node.duration) / 10, 0 === Object.keys(e._sprite).length && (e._sprite = {
								__default: [0, 1e3 * e._duration]
							}), "loaded" !== e._state && (e._state = "loaded", e._emit("load"), e._loadQueue()), t._node.removeEventListener(o._canPlayEvent, t._loadFn, !1)
						},
						_endListener: function() {
							var t = this,
								e = t._parent;
							e._duration === 1 / 0 && (e._duration = Math.ceil(10 * t._node.duration) / 10, e._sprite.__default[1] === 1 / 0 && (e._sprite.__default[1] = 1e3 * e._duration), e._ended(t)), t._node.removeEventListener("ended", t._endFn, !1)
						}
					};
					var l = {},
						h = function(t) {
							var e = t._src;
							if (l[e]) return t._duration = l[e].duration, void d(t);
							if (/^data:[^;]+;base64,/.test(e)) {
								for (var i = atob(e.split(",")[1]), n = new Uint8Array(i.length), s = 0; s < i.length; ++s) n[s] = i.charCodeAt(s);
								c(n.buffer, t)
							} else {
								var o = new XMLHttpRequest;
								o.open(t._xhr.method, e, !0), o.withCredentials = t._xhr.withCredentials, o.responseType = "arraybuffer", t._xhr.headers && Object.keys(t._xhr.headers).forEach((function(e) {
									o.setRequestHeader(e, t._xhr.headers[e])
								})), o.onload = function() {
									var e = (o.status + "")[0];
									"0" === e || "2" === e || "3" === e ? c(o.response, t) : t._emit("loaderror", null, "Failed loading audio file with status: " + o.status + ".")
								}, o.onerror = function() {
									t._webAudio && (t._html5 = !0, t._webAudio = !1, t._sounds = [], delete l[e], t.load())
								}, u(o)
							}
						},
						u = function(t) {
							try {
								t.send()
							} catch (e) {
								t.onerror()
							}
						},
						c = function(t, e) {
							var i = function() {
									e._emit("loaderror", null, "Decoding audio data failed.")
								},
								n = function(t) {
									t && e._sounds.length > 0 ? (l[e._src] = t, d(e, t)) : i()
								};
							"undefined" != typeof Promise && 1 === o.ctx.decodeAudioData.length ? o.ctx.decodeAudioData(t).then(n).catch(i) : o.ctx.decodeAudioData(t, n, i)
						},
						d = function(t, e) {
							e && !t._duration && (t._duration = e.duration), 0 === Object.keys(t._sprite).length && (t._sprite = {
								__default: [0, 1e3 * t._duration]
							}), "loaded" !== t._state && (t._state = "loaded", t._emit("load"), t._loadQueue())
						},
						p = function() {
							if (o.usingWebAudio) {
								try {
									"undefined" != typeof AudioContext ? o.ctx = new AudioContext : "undefined" != typeof webkitAudioContext ? o.ctx = new webkitAudioContext : o.usingWebAudio = !1
								} catch (t) {
									o.usingWebAudio = !1
								}
								o.ctx || (o.usingWebAudio = !1);
								var t = /iP(hone|od|ad)/.test(o._navigator && o._navigator.platform),
									e = o._navigator && o._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
									i = e ? parseInt(e[1], 10) : null;
								if (t && i && i < 9) {
									var n = /safari/.test(o._navigator && o._navigator.userAgent.toLowerCase());
									o._navigator && !n && (o.usingWebAudio = !1)
								}
								o.usingWebAudio && (o.masterGain = void 0 === o.ctx.createGain ? o.ctx.createGainNode() : o.ctx.createGain(), o.masterGain.gain.setValueAtTime(o._muted ? 0 : o._volume, o.ctx.currentTime), o.masterGain.connect(o.ctx.destination)), o._setup()
							}
						};
					void 0 === (n = function() {
						return {
							Howler: o,
							Howl: r
						}
					}.apply(e, [])) || (t.exports = n), e.Howler = o, e.Howl = r, void 0 !== i.g ? (i.g.HowlerGlobal = s, i.g.Howler = o, i.g.Howl = r, i.g.Sound = a) : "undefined" != typeof window && (window.HowlerGlobal = s, window.Howler = o, window.Howl = r, window.Sound = a)
				}(),
				function() {
					"use strict";
					var t;
					HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function(t) {
						var e = this;
						if (!e.ctx || !e.ctx.listener) return e;
						for (var i = e._howls.length - 1; i >= 0; i--) e._howls[i].stereo(t);
						return e
					}, HowlerGlobal.prototype.pos = function(t, e, i) {
						var n = this;
						return n.ctx && n.ctx.listener ? (e = "number" != typeof e ? n._pos[1] : e, i = "number" != typeof i ? n._pos[2] : i, "number" != typeof t ? n._pos : (n._pos = [t, e, i], void 0 !== n.ctx.listener.positionX ? (n.ctx.listener.positionX.setTargetAtTime(n._pos[0], Howler.ctx.currentTime, .1), n.ctx.listener.positionY.setTargetAtTime(n._pos[1], Howler.ctx.currentTime, .1), n.ctx.listener.positionZ.setTargetAtTime(n._pos[2], Howler.ctx.currentTime, .1)) : n.ctx.listener.setPosition(n._pos[0], n._pos[1], n._pos[2]), n)) : n
					}, HowlerGlobal.prototype.orientation = function(t, e, i, n, s, o) {
						var r = this;
						if (!r.ctx || !r.ctx.listener) return r;
						var a = r._orientation;
						return e = "number" != typeof e ? a[1] : e, i = "number" != typeof i ? a[2] : i, n = "number" != typeof n ? a[3] : n, s = "number" != typeof s ? a[4] : s, o = "number" != typeof o ? a[5] : o, "number" != typeof t ? a : (r._orientation = [t, e, i, n, s, o], void 0 !== r.ctx.listener.forwardX ? (r.ctx.listener.forwardX.setTargetAtTime(t, Howler.ctx.currentTime, .1), r.ctx.listener.forwardY.setTargetAtTime(e, Howler.ctx.currentTime, .1), r.ctx.listener.forwardZ.setTargetAtTime(i, Howler.ctx.currentTime, .1), r.ctx.listener.upX.setTargetAtTime(n, Howler.ctx.currentTime, .1), r.ctx.listener.upY.setTargetAtTime(s, Howler.ctx.currentTime, .1), r.ctx.listener.upZ.setTargetAtTime(o, Howler.ctx.currentTime, .1)) : r.ctx.listener.setOrientation(t, e, i, n, s, o), r)
					}, Howl.prototype.init = (t = Howl.prototype.init, function(e) {
						var i = this;
						return i._orientation = e.orientation || [1, 0, 0], i._stereo = e.stereo || null, i._pos = e.pos || null, i._pannerAttr = {
							coneInnerAngle: void 0 !== e.coneInnerAngle ? e.coneInnerAngle : 360,
							coneOuterAngle: void 0 !== e.coneOuterAngle ? e.coneOuterAngle : 360,
							coneOuterGain: void 0 !== e.coneOuterGain ? e.coneOuterGain : 0,
							distanceModel: void 0 !== e.distanceModel ? e.distanceModel : "inverse",
							maxDistance: void 0 !== e.maxDistance ? e.maxDistance : 1e4,
							panningModel: void 0 !== e.panningModel ? e.panningModel : "HRTF",
							refDistance: void 0 !== e.refDistance ? e.refDistance : 1,
							rolloffFactor: void 0 !== e.rolloffFactor ? e.rolloffFactor : 1
						}, i._onstereo = e.onstereo ? [{
							fn: e.onstereo
						}] : [], i._onpos = e.onpos ? [{
							fn: e.onpos
						}] : [], i._onorientation = e.onorientation ? [{
							fn: e.onorientation
						}] : [], t.call(this, e)
					}), Howl.prototype.stereo = function(t, i) {
						var n = this;
						if (!n._webAudio) return n;
						if ("loaded" !== n._state) return n._queue.push({
							event: "stereo",
							action: function() {
								n.stereo(t, i)
							}
						}), n;
						var s = void 0 === Howler.ctx.createStereoPanner ? "spatial" : "stereo";
						if (void 0 === i) {
							if ("number" != typeof t) return n._stereo;
							n._stereo = t, n._pos = [t, 0, 0]
						}
						for (var o = n._getSoundIds(i), r = 0; r < o.length; r++) {
							var a = n._soundById(o[r]);
							if (a) {
								if ("number" != typeof t) return a._stereo;
								a._stereo = t, a._pos = [t, 0, 0], a._node && (a._pannerAttr.panningModel = "equalpower", a._panner && a._panner.pan || e(a, s), "spatial" === s ? void 0 !== a._panner.positionX ? (a._panner.positionX.setValueAtTime(t, Howler.ctx.currentTime), a._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), a._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : a._panner.setPosition(t, 0, 0) : a._panner.pan.setValueAtTime(t, Howler.ctx.currentTime)), n._emit("stereo", a._id)
							}
						}
						return n
					}, Howl.prototype.pos = function(t, i, n, s) {
						var o = this;
						if (!o._webAudio) return o;
						if ("loaded" !== o._state) return o._queue.push({
							event: "pos",
							action: function() {
								o.pos(t, i, n, s)
							}
						}), o;
						if (i = "number" != typeof i ? 0 : i, n = "number" != typeof n ? -.5 : n, void 0 === s) {
							if ("number" != typeof t) return o._pos;
							o._pos = [t, i, n]
						}
						for (var r = o._getSoundIds(s), a = 0; a < r.length; a++) {
							var l = o._soundById(r[a]);
							if (l) {
								if ("number" != typeof t) return l._pos;
								l._pos = [t, i, n], l._node && (l._panner && !l._panner.pan || e(l, "spatial"), void 0 !== l._panner.positionX ? (l._panner.positionX.setValueAtTime(t, Howler.ctx.currentTime), l._panner.positionY.setValueAtTime(i, Howler.ctx.currentTime), l._panner.positionZ.setValueAtTime(n, Howler.ctx.currentTime)) : l._panner.setPosition(t, i, n)), o._emit("pos", l._id)
							}
						}
						return o
					}, Howl.prototype.orientation = function(t, i, n, s) {
						var o = this;
						if (!o._webAudio) return o;
						if ("loaded" !== o._state) return o._queue.push({
							event: "orientation",
							action: function() {
								o.orientation(t, i, n, s)
							}
						}), o;
						if (i = "number" != typeof i ? o._orientation[1] : i, n = "number" != typeof n ? o._orientation[2] : n, void 0 === s) {
							if ("number" != typeof t) return o._orientation;
							o._orientation = [t, i, n]
						}
						for (var r = o._getSoundIds(s), a = 0; a < r.length; a++) {
							var l = o._soundById(r[a]);
							if (l) {
								if ("number" != typeof t) return l._orientation;
								l._orientation = [t, i, n], l._node && (l._panner || (l._pos || (l._pos = o._pos || [0, 0, -.5]), e(l, "spatial")), void 0 !== l._panner.orientationX ? (l._panner.orientationX.setValueAtTime(t, Howler.ctx.currentTime), l._panner.orientationY.setValueAtTime(i, Howler.ctx.currentTime), l._panner.orientationZ.setValueAtTime(n, Howler.ctx.currentTime)) : l._panner.setOrientation(t, i, n)), o._emit("orientation", l._id)
							}
						}
						return o
					}, Howl.prototype.pannerAttr = function() {
						var t, i, n, s = this,
							o = arguments;
						if (!s._webAudio) return s;
						if (0 === o.length) return s._pannerAttr;
						if (1 === o.length) {
							if ("object" != typeof o[0]) return (n = s._soundById(parseInt(o[0], 10))) ? n._pannerAttr : s._pannerAttr;
							t = o[0], void 0 === i && (t.pannerAttr || (t.pannerAttr = {
								coneInnerAngle: t.coneInnerAngle,
								coneOuterAngle: t.coneOuterAngle,
								coneOuterGain: t.coneOuterGain,
								distanceModel: t.distanceModel,
								maxDistance: t.maxDistance,
								refDistance: t.refDistance,
								rolloffFactor: t.rolloffFactor,
								panningModel: t.panningModel
							}), s._pannerAttr = {
								coneInnerAngle: void 0 !== t.pannerAttr.coneInnerAngle ? t.pannerAttr.coneInnerAngle : s._coneInnerAngle,
								coneOuterAngle: void 0 !== t.pannerAttr.coneOuterAngle ? t.pannerAttr.coneOuterAngle : s._coneOuterAngle,
								coneOuterGain: void 0 !== t.pannerAttr.coneOuterGain ? t.pannerAttr.coneOuterGain : s._coneOuterGain,
								distanceModel: void 0 !== t.pannerAttr.distanceModel ? t.pannerAttr.distanceModel : s._distanceModel,
								maxDistance: void 0 !== t.pannerAttr.maxDistance ? t.pannerAttr.maxDistance : s._maxDistance,
								refDistance: void 0 !== t.pannerAttr.refDistance ? t.pannerAttr.refDistance : s._refDistance,
								rolloffFactor: void 0 !== t.pannerAttr.rolloffFactor ? t.pannerAttr.rolloffFactor : s._rolloffFactor,
								panningModel: void 0 !== t.pannerAttr.panningModel ? t.pannerAttr.panningModel : s._panningModel
							})
						} else 2 === o.length && (t = o[0], i = parseInt(o[1], 10));
						for (var r = s._getSoundIds(i), a = 0; a < r.length; a++)
							if (n = s._soundById(r[a])) {
								var l = n._pannerAttr;
								l = {
									coneInnerAngle: void 0 !== t.coneInnerAngle ? t.coneInnerAngle : l.coneInnerAngle,
									coneOuterAngle: void 0 !== t.coneOuterAngle ? t.coneOuterAngle : l.coneOuterAngle,
									coneOuterGain: void 0 !== t.coneOuterGain ? t.coneOuterGain : l.coneOuterGain,
									distanceModel: void 0 !== t.distanceModel ? t.distanceModel : l.distanceModel,
									maxDistance: void 0 !== t.maxDistance ? t.maxDistance : l.maxDistance,
									refDistance: void 0 !== t.refDistance ? t.refDistance : l.refDistance,
									rolloffFactor: void 0 !== t.rolloffFactor ? t.rolloffFactor : l.rolloffFactor,
									panningModel: void 0 !== t.panningModel ? t.panningModel : l.panningModel
								};
								var h = n._panner;
								h || (n._pos || (n._pos = s._pos || [0, 0, -.5]), e(n, "spatial"), h = n._panner), h.coneInnerAngle = l.coneInnerAngle, h.coneOuterAngle = l.coneOuterAngle, h.coneOuterGain = l.coneOuterGain, h.distanceModel = l.distanceModel, h.maxDistance = l.maxDistance, h.refDistance = l.refDistance, h.rolloffFactor = l.rolloffFactor, h.panningModel = l.panningModel
							} return s
					}, Sound.prototype.init = function(t) {
						return function() {
							var e = this,
								i = e._parent;
							e._orientation = i._orientation, e._stereo = i._stereo, e._pos = i._pos, e._pannerAttr = i._pannerAttr, t.call(this), e._stereo ? i.stereo(e._stereo) : e._pos && i.pos(e._pos[0], e._pos[1], e._pos[2], e._id)
						}
					}(Sound.prototype.init), Sound.prototype.reset = function(t) {
						return function() {
							var e = this,
								i = e._parent;
							return e._orientation = i._orientation, e._stereo = i._stereo, e._pos = i._pos, e._pannerAttr = i._pannerAttr, e._stereo ? i.stereo(e._stereo) : e._pos ? i.pos(e._pos[0], e._pos[1], e._pos[2], e._id) : e._panner && (e._panner.disconnect(0), e._panner = void 0, i._refreshBuffer(e)), t.call(this)
						}
					}(Sound.prototype.reset);
					var e = function(t, e) {
						"spatial" === (e = e || "spatial") ? (t._panner = Howler.ctx.createPanner(), t._panner.coneInnerAngle = t._pannerAttr.coneInnerAngle, t._panner.coneOuterAngle = t._pannerAttr.coneOuterAngle, t._panner.coneOuterGain = t._pannerAttr.coneOuterGain, t._panner.distanceModel = t._pannerAttr.distanceModel, t._panner.maxDistance = t._pannerAttr.maxDistance, t._panner.refDistance = t._pannerAttr.refDistance, t._panner.rolloffFactor = t._pannerAttr.rolloffFactor, t._panner.panningModel = t._pannerAttr.panningModel, void 0 !== t._panner.positionX ? (t._panner.positionX.setValueAtTime(t._pos[0], Howler.ctx.currentTime), t._panner.positionY.setValueAtTime(t._pos[1], Howler.ctx.currentTime), t._panner.positionZ.setValueAtTime(t._pos[2], Howler.ctx.currentTime)) : t._panner.setPosition(t._pos[0], t._pos[1], t._pos[2]), void 0 !== t._panner.orientationX ? (t._panner.orientationX.setValueAtTime(t._orientation[0], Howler.ctx.currentTime), t._panner.orientationY.setValueAtTime(t._orientation[1], Howler.ctx.currentTime), t._panner.orientationZ.setValueAtTime(t._orientation[2], Howler.ctx.currentTime)) : t._panner.setOrientation(t._orientation[0], t._orientation[1], t._orientation[2])) : (t._panner = Howler.ctx.createStereoPanner(), t._panner.pan.setValueAtTime(t._stereo, Howler.ctx.currentTime)), t._panner.connect(t._node), t._paused || t._parent.pause(t._id, !0).play(t._id, !0)
					}
				}()
			},
			87128: (t, e, i) => {
				"use strict";
				var n = i(13798);

				function s(t) {
					return !0 === n(t) && "[object Object]" === Object.prototype.toString.call(t)
				}
				t.exports = function(t) {
					var e, i;
					return !1 !== s(t) && "function" == typeof(e = t.constructor) && !1 !== s(i = e.prototype) && !1 !== i.hasOwnProperty("isPrototypeOf")
				}
			},
			13798: t => {
				"use strict";
				t.exports = function(t) {
					return null != t && "object" == typeof t && !1 === Array.isArray(t)
				}
			},
			12215: (t, e, i) => {
				var n, s, o;
				void 0 === (s = "function" == typeof(n = o = function() {
					function t() {
						for (var t = 0, e = {}; t < arguments.length; t++) {
							var i = arguments[t];
							for (var n in i) e[n] = i[n]
						}
						return e
					}

					function e(t) {
						return t.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent)
					}
					return function i(n) {
						function s() {}

						function o(e, i, o) {
							if ("undefined" != typeof document) {
								"number" == typeof(o = t({
									path: "/"
								}, s.defaults, o)).expires && (o.expires = new Date(1 * new Date + 864e5 * o.expires)), o.expires = o.expires ? o.expires.toUTCString() : "";
								try {
									var r = JSON.stringify(i);
									/^[\{\[]/.test(r) && (i = r)
								} catch (t) {}
								i = n.write ? n.write(i, e) : encodeURIComponent(String(i)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent), e = encodeURIComponent(String(e)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
								var a = "";
								for (var l in o) o[l] && (a += "; " + l, !0 !== o[l] && (a += "=" + o[l].split(";")[0]));
								return document.cookie = e + "=" + i + a
							}
						}

						function r(t, i) {
							if ("undefined" != typeof document) {
								for (var s = {}, o = document.cookie ? document.cookie.split("; ") : [], r = 0; r < o.length; r++) {
									var a = o[r].split("="),
										l = a.slice(1).join("=");
									i || '"' !== l.charAt(0) || (l = l.slice(1, -1));
									try {
										var h = e(a[0]);
										if (l = (n.read || n)(l, h) || e(l), i) try {
											l = JSON.parse(l)
										} catch (t) {}
										if (s[h] = l, t === h) break
									} catch (t) {}
								}
								return t ? s[t] : s
							}
						}
						return s.set = o, s.get = function(t) {
							return r(t, !1)
						}, s.getJSON = function(t) {
							return r(t, !0)
						}, s.remove = function(e, i) {
							o(e, "", t(i, {
								expires: -1
							}))
						}, s.defaults = {}, s.withConverter = i, s
					}((function() {}))
				}) ? n.call(e, i, e, t) : n) || (t.exports = s), t.exports = o()
			},
			41169: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				});
				class i extends Error {}
				class n extends i {
					constructor(t) {
						super(`Invalid DateTime: ${t.toMessage()}`)
					}
				}
				class s extends i {
					constructor(t) {
						super(`Invalid Interval: ${t.toMessage()}`)
					}
				}
				class o extends i {
					constructor(t) {
						super(`Invalid Duration: ${t.toMessage()}`)
					}
				}
				class r extends i {}
				class a extends i {
					constructor(t) {
						super(`Invalid unit ${t}`)
					}
				}
				class l extends i {}
				class h extends i {
					constructor() {
						super("Zone is an abstract class")
					}
				}
				const u = "numeric",
					c = "short",
					d = "long",
					p = {
						year: u,
						month: u,
						day: u
					},
					_ = {
						year: u,
						month: c,
						day: u
					},
					m = {
						year: u,
						month: c,
						day: u,
						weekday: c
					},
					g = {
						year: u,
						month: d,
						day: u
					},
					f = {
						year: u,
						month: d,
						day: u,
						weekday: d
					},
					S = {
						hour: u,
						minute: u
					},
					y = {
						hour: u,
						minute: u,
						second: u
					},
					v = {
						hour: u,
						minute: u,
						second: u,
						timeZoneName: c
					},
					T = {
						hour: u,
						minute: u,
						second: u,
						timeZoneName: d
					},
					E = {
						hour: u,
						minute: u,
						hourCycle: "h23"
					},
					b = {
						hour: u,
						minute: u,
						second: u,
						hourCycle: "h23"
					},
					A = {
						hour: u,
						minute: u,
						second: u,
						hourCycle: "h23",
						timeZoneName: c
					},
					P = {
						hour: u,
						minute: u,
						second: u,
						hourCycle: "h23",
						timeZoneName: d
					},
					I = {
						year: u,
						month: u,
						day: u,
						hour: u,
						minute: u
					},
					w = {
						year: u,
						month: u,
						day: u,
						hour: u,
						minute: u,
						second: u
					},
					L = {
						year: u,
						month: c,
						day: u,
						hour: u,
						minute: u
					},
					C = {
						year: u,
						month: c,
						day: u,
						hour: u,
						minute: u,
						second: u
					},
					x = {
						year: u,
						month: c,
						day: u,
						weekday: c,
						hour: u,
						minute: u
					},
					B = {
						year: u,
						month: d,
						day: u,
						hour: u,
						minute: u,
						timeZoneName: c
					},
					O = {
						year: u,
						month: d,
						day: u,
						hour: u,
						minute: u,
						second: u,
						timeZoneName: c
					},
					N = {
						year: u,
						month: d,
						day: u,
						weekday: d,
						hour: u,
						minute: u,
						timeZoneName: d
					},
					M = {
						year: u,
						month: d,
						day: u,
						weekday: d,
						hour: u,
						minute: u,
						second: u,
						timeZoneName: d
					};
				class R {
					get type() {
						throw new h
					}
					get name() {
						throw new h
					}
					get ianaName() {
						return this.name
					}
					get isUniversal() {
						throw new h
					}
					offsetName(t, e) {
						throw new h
					}
					formatOffset(t, e) {
						throw new h
					}
					offset(t) {
						throw new h
					}
					equals(t) {
						throw new h
					}
					get isValid() {
						throw new h
					}
				}
				let D = null;
				class k extends R {
					static get instance() {
						return null === D && (D = new k), D
					}
					get type() {
						return "system"
					}
					get name() {
						return (new Intl.DateTimeFormat).resolvedOptions().timeZone
					}
					get isUniversal() {
						return !1
					}
					offsetName(t, {
						format: e,
						locale: i
					}) {
						return Ct(t, e, i)
					}
					formatOffset(t, e) {
						return Nt(this.offset(t), e)
					}
					offset(t) {
						return -new Date(t).getTimezoneOffset()
					}
					equals(t) {
						return "system" === t.type
					}
					get isValid() {
						return !0
					}
				}
				let F = {};
				const G = {
					year: 0,
					month: 1,
					day: 2,
					era: 3,
					hour: 4,
					minute: 5,
					second: 6
				};
				let U = {};
				class W extends R {
					static create(t) {
						return U[t] || (U[t] = new W(t)), U[t]
					}
					static resetCache() {
						U = {}, F = {}
					}
					static isValidSpecifier(t) {
						return this.isValidZone(t)
					}
					static isValidZone(t) {
						if (!t) return !1;
						try {
							return new Intl.DateTimeFormat("en-US", {
								timeZone: t
							}).format(), !0
						} catch (t) {
							return !1
						}
					}
					constructor(t) {
						super(), this.zoneName = t, this.valid = W.isValidZone(t)
					}
					get type() {
						return "iana"
					}
					get name() {
						return this.zoneName
					}
					get isUniversal() {
						return !1
					}
					offsetName(t, {
						format: e,
						locale: i
					}) {
						return Ct(t, e, i, this.name)
					}
					formatOffset(t, e) {
						return Nt(this.offset(t), e)
					}
					offset(t) {
						const e = new Date(t);
						if (isNaN(e)) return NaN;
						const i = (n = this.name, F[n] || (F[n] = new Intl.DateTimeFormat("en-US", {
							hour12: !1,
							timeZone: n,
							year: "numeric",
							month: "2-digit",
							day: "2-digit",
							hour: "2-digit",
							minute: "2-digit",
							second: "2-digit",
							era: "short"
						})), F[n]);
						var n;
						let [s, o, r, a, l, h, u] = i.formatToParts ? function(t, e) {
							const i = t.formatToParts(e),
								n = [];
							for (let t = 0; t < i.length; t++) {
								const {
									type: e,
									value: s
								} = i[t], o = G[e];
								"era" === e ? n[o] = s : ct(o) || (n[o] = parseInt(s, 10))
							}
							return n
						}(i, e) : function(t, e) {
							const i = t.format(e).replace(/\u200E/g, ""),
								n = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(i),
								[, s, o, r, a, l, h, u] = n;
							return [r, s, o, a, l, h, u]
						}(i, e);
						"BC" === a && (s = 1 - Math.abs(s));
						let c = +e;
						const d = c % 1e3;
						return c -= d >= 0 ? d : 1e3 + d, (It({
							year: s,
							month: o,
							day: r,
							hour: 24 === l ? 0 : l,
							minute: h,
							second: u,
							millisecond: 0
						}) - c) / 6e4
					}
					equals(t) {
						return "iana" === t.type && t.name === this.name
					}
					get isValid() {
						return this.valid
					}
				}
				let H = {},
					V = {};

				function X(t, e = {}) {
					const i = JSON.stringify([t, e]);
					let n = V[i];
					return n || (n = new Intl.DateTimeFormat(t, e), V[i] = n), n
				}
				let Y = {},
					z = {},
					j = null;

				function K(t, e, i, n, s) {
					const o = t.listingMode(i);
					return "error" === o ? null : "en" === o ? n(e) : s(e)
				}
				class q {
					constructor(t, e, i) {
						this.padTo = i.padTo || 0, this.floor = i.floor || !1;
						const {
							padTo: n,
							floor: s,
							...o
						} = i;
						if (!e || Object.keys(o).length > 0) {
							const e = {
								useGrouping: !1,
								...i
							};
							i.padTo > 0 && (e.minimumIntegerDigits = i.padTo), this.inf = function(t, e = {}) {
								const i = JSON.stringify([t, e]);
								let n = Y[i];
								return n || (n = new Intl.NumberFormat(t, e), Y[i] = n), n
							}(t, e)
						}
					}
					format(t) {
						if (this.inf) {
							const e = this.floor ? Math.floor(t) : t;
							return this.inf.format(e)
						}
						return St(this.floor ? Math.floor(t) : Et(t, 3), this.padTo)
					}
				}
				class Z {
					constructor(t, e, i) {
						let n;
						if (this.opts = i, this.originalZone = void 0, this.opts.timeZone) this.dt = t;
						else if ("fixed" === t.zone.type) {
							const e = t.offset / 60 * -1,
								i = e >= 0 ? `Etc/GMT+${e}` : `Etc/GMT${e}`;
							0 !== t.offset && W.create(i).valid ? (n = i, this.dt = t) : (n = "UTC", this.dt = 0 === t.offset ? t : t.setZone("UTC").plus({
								minutes: t.offset
							}), this.originalZone = t.zone)
						} else "system" === t.zone.type ? this.dt = t : "iana" === t.zone.type ? (this.dt = t, n = t.zone.name) : (n = "UTC", this.dt = t.setZone("UTC").plus({
							minutes: t.offset
						}), this.originalZone = t.zone);
						const s = {
							...this.opts
						};
						s.timeZone = s.timeZone || n, this.dtf = X(e, s)
					}
					format() {
						return this.originalZone ? this.formatToParts().map((({
							value: t
						}) => t)).join("") : this.dtf.format(this.dt.toJSDate())
					}
					formatToParts() {
						const t = this.dtf.formatToParts(this.dt.toJSDate());
						return this.originalZone ? t.map((t => {
							if ("timeZoneName" === t.type) {
								const e = this.originalZone.offsetName(this.dt.ts, {
									locale: this.dt.locale,
									format: this.opts.timeZoneName
								});
								return {
									...t,
									value: e
								}
							}
							return t
						})) : t
					}
					resolvedOptions() {
						return this.dtf.resolvedOptions()
					}
				}
				class $ {
					constructor(t, e, i) {
						this.opts = {
							style: "long",
							...i
						}, !e && _t() && (this.rtf = function(t, e = {}) {
							const {
								base: i,
								...n
							} = e, s = JSON.stringify([t, n]);
							let o = z[s];
							return o || (o = new Intl.RelativeTimeFormat(t, e), z[s] = o), o
						}(t, i))
					}
					format(t, e) {
						return this.rtf ? this.rtf.format(t, e) : function(t, e, i = "always", n = !1) {
							const s = {
									years: ["year", "yr."],
									quarters: ["quarter", "qtr."],
									months: ["month", "mo."],
									weeks: ["week", "wk."],
									days: ["day", "day", "days"],
									hours: ["hour", "hr."],
									minutes: ["minute", "min."],
									seconds: ["second", "sec."]
								},
								o = -1 === ["hours", "minutes", "seconds"].indexOf(t);
							if ("auto" === i && o) {
								const i = "days" === t;
								switch (e) {
									case 1:
										return i ? "tomorrow" : `next ${s[t][0]}`;
									case -1:
										return i ? "yesterday" : `last ${s[t][0]}`;
									case 0:
										return i ? "today" : `this ${s[t][0]}`
								}
							}
							const r = Object.is(e, -0) || e < 0,
								a = Math.abs(e),
								l = 1 === a,
								h = s[t],
								u = n ? l ? h[1] : h[2] || h[1] : l ? s[t][0] : t;
							return r ? `${a} ${u} ago` : `in ${a} ${u}`
						}(e, t, this.opts.numeric, "long" !== this.opts.style)
					}
					formatToParts(t, e) {
						return this.rtf ? this.rtf.formatToParts(t, e) : []
					}
				}
				class Q {
					static fromOpts(t) {
						return Q.create(t.locale, t.numberingSystem, t.outputCalendar, t.defaultToEN)
					}
					static create(t, e, i, n = !1) {
						const s = t || ut.defaultLocale,
							o = s || (n ? "en-US" : j || (j = (new Intl.DateTimeFormat).resolvedOptions().locale, j)),
							r = e || ut.defaultNumberingSystem,
							a = i || ut.defaultOutputCalendar;
						return new Q(o, r, a, s)
					}
					static resetCache() {
						j = null, V = {}, Y = {}, z = {}
					}
					static fromObject({
						locale: t,
						numberingSystem: e,
						outputCalendar: i
					} = {}) {
						return Q.create(t, e, i)
					}
					constructor(t, e, i, n) {
						const [s, o, r] = function(t) {
							const e = t.indexOf("-x-"); - 1 !== e && (t = t.substring(0, e));
							const i = t.indexOf("-u-");
							if (-1 === i) return [t];
							{
								let e, n;
								try {
									e = X(t).resolvedOptions(), n = t
								} catch (s) {
									const o = t.substring(0, i);
									e = X(o).resolvedOptions(), n = o
								}
								const {
									numberingSystem: s,
									calendar: o
								} = e;
								return [n, s, o]
							}
						}(t);
						this.locale = s, this.numberingSystem = e || o || null, this.outputCalendar = i || r || null, this.intl = function(t, e, i) {
							return i || e ? (t.includes("-u-") || (t += "-u"), i && (t += `-ca-${i}`), e && (t += `-nu-${e}`), t) : t
						}(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = {
							format: {},
							standalone: {}
						}, this.monthsCache = {
							format: {},
							standalone: {}
						}, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = n, this.fastNumbersCached = null
					}
					get fastNumbers() {
						var t;
						return null == this.fastNumbersCached && (this.fastNumbersCached = (!(t = this).numberingSystem || "latn" === t.numberingSystem) && ("latn" === t.numberingSystem || !t.locale || t.locale.startsWith("en") || "latn" === new Intl.DateTimeFormat(t.intl).resolvedOptions().numberingSystem)), this.fastNumbersCached
					}
					listingMode() {
						const t = this.isEnglish(),
							e = !(null !== this.numberingSystem && "latn" !== this.numberingSystem || null !== this.outputCalendar && "gregory" !== this.outputCalendar);
						return t && e ? "en" : "intl"
					}
					clone(t) {
						return t && 0 !== Object.getOwnPropertyNames(t).length ? Q.create(t.locale || this.specifiedLocale, t.numberingSystem || this.numberingSystem, t.outputCalendar || this.outputCalendar, t.defaultToEN || !1) : this
					}
					redefaultToEN(t = {}) {
						return this.clone({
							...t,
							defaultToEN: !0
						})
					}
					redefaultToSystem(t = {}) {
						return this.clone({
							...t,
							defaultToEN: !1
						})
					}
					months(t, e = !1, i = !0) {
						return K(this, t, i, Ft, (() => {
							const i = e ? {
									month: t,
									day: "numeric"
								} : {
									month: t
								},
								n = e ? "format" : "standalone";
							return this.monthsCache[n][t] || (this.monthsCache[n][t] = function(t) {
								const e = [];
								for (let i = 1; i <= 12; i++) {
									const n = qi.utc(2016, i, 1);
									e.push(t(n))
								}
								return e
							}((t => this.extract(t, i, "month")))), this.monthsCache[n][t]
						}))
					}
					weekdays(t, e = !1, i = !0) {
						return K(this, t, i, Ht, (() => {
							const i = e ? {
									weekday: t,
									year: "numeric",
									month: "long",
									day: "numeric"
								} : {
									weekday: t
								},
								n = e ? "format" : "standalone";
							return this.weekdaysCache[n][t] || (this.weekdaysCache[n][t] = function(t) {
								const e = [];
								for (let i = 1; i <= 7; i++) {
									const n = qi.utc(2016, 11, 13 + i);
									e.push(t(n))
								}
								return e
							}((t => this.extract(t, i, "weekday")))), this.weekdaysCache[n][t]
						}))
					}
					meridiems(t = !0) {
						return K(this, void 0, t, (() => Vt), (() => {
							if (!this.meridiemCache) {
								const t = {
									hour: "numeric",
									hourCycle: "h12"
								};
								this.meridiemCache = [qi.utc(2016, 11, 13, 9), qi.utc(2016, 11, 13, 19)].map((e => this.extract(e, t, "dayperiod")))
							}
							return this.meridiemCache
						}))
					}
					eras(t, e = !0) {
						return K(this, t, e, jt, (() => {
							const e = {
								era: t
							};
							return this.eraCache[t] || (this.eraCache[t] = [qi.utc(-40, 1, 1), qi.utc(2017, 1, 1)].map((t => this.extract(t, e, "era")))), this.eraCache[t]
						}))
					}
					extract(t, e, i) {
						const n = this.dtFormatter(t, e).formatToParts().find((t => t.type.toLowerCase() === i));
						return n ? n.value : null
					}
					numberFormatter(t = {}) {
						return new q(this.intl, t.forceSimple || this.fastNumbers, t)
					}
					dtFormatter(t, e = {}) {
						return new Z(t, this.intl, e)
					}
					relFormatter(t = {}) {
						return new $(this.intl, this.isEnglish(), t)
					}
					listFormatter(t = {}) {
						return function(t, e = {}) {
							const i = JSON.stringify([t, e]);
							let n = H[i];
							return n || (n = new Intl.ListFormat(t, e), H[i] = n), n
						}(this.intl, t)
					}
					isEnglish() {
						return "en" === this.locale || "en-us" === this.locale.toLowerCase() || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us")
					}
					equals(t) {
						return this.locale === t.locale && this.numberingSystem === t.numberingSystem && this.outputCalendar === t.outputCalendar
					}
				}
				let J = null;
				class tt extends R {
					static get utcInstance() {
						return null === J && (J = new tt(0)), J
					}
					static instance(t) {
						return 0 === t ? tt.utcInstance : new tt(t)
					}
					static parseSpecifier(t) {
						if (t) {
							const e = t.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
							if (e) return new tt(xt(e[1], e[2]))
						}
						return null
					}
					constructor(t) {
						super(), this.fixed = t
					}
					get type() {
						return "fixed"
					}
					get name() {
						return 0 === this.fixed ? "UTC" : `UTC${Nt(this.fixed,"narrow")}`
					}
					get ianaName() {
						return 0 === this.fixed ? "Etc/UTC" : `Etc/GMT${Nt(-this.fixed,"narrow")}`
					}
					offsetName() {
						return this.name
					}
					formatOffset(t, e) {
						return Nt(this.fixed, e)
					}
					get isUniversal() {
						return !0
					}
					offset() {
						return this.fixed
					}
					equals(t) {
						return "fixed" === t.type && t.fixed === this.fixed
					}
					get isValid() {
						return !0
					}
				}
				class et extends R {
					constructor(t) {
						super(), this.zoneName = t
					}
					get type() {
						return "invalid"
					}
					get name() {
						return this.zoneName
					}
					get isUniversal() {
						return !1
					}
					offsetName() {
						return null
					}
					formatOffset() {
						return ""
					}
					offset() {
						return NaN
					}
					equals() {
						return !1
					}
					get isValid() {
						return !1
					}
				}

				function it(t, e) {
					if (ct(t) || null === t) return e;
					if (t instanceof R) return t;
					if ("string" == typeof t) {
						const i = t.toLowerCase();
						return "default" === i ? e : "local" === i || "system" === i ? k.instance : "utc" === i || "gmt" === i ? tt.utcInstance : tt.parseSpecifier(i) || W.create(t)
					}
					return dt(t) ? tt.instance(t) : "object" == typeof t && t.offset && "number" == typeof t.offset ? t : new et(t)
				}
				let nt, st = () => Date.now(),
					ot = "system",
					rt = null,
					at = null,
					lt = null,
					ht = 60;
				class ut {
					static get now() {
						return st
					}
					static set now(t) {
						st = t
					}
					static set defaultZone(t) {
						ot = t
					}
					static get defaultZone() {
						return it(ot, k.instance)
					}
					static get defaultLocale() {
						return rt
					}
					static set defaultLocale(t) {
						rt = t
					}
					static get defaultNumberingSystem() {
						return at
					}
					static set defaultNumberingSystem(t) {
						at = t
					}
					static get defaultOutputCalendar() {
						return lt
					}
					static set defaultOutputCalendar(t) {
						lt = t
					}
					static get twoDigitCutoffYear() {
						return ht
					}
					static set twoDigitCutoffYear(t) {
						ht = t % 100
					}
					static get throwOnInvalid() {
						return nt
					}
					static set throwOnInvalid(t) {
						nt = t
					}
					static resetCaches() {
						Q.resetCache(), W.resetCache()
					}
				}

				function ct(t) {
					return void 0 === t
				}

				function dt(t) {
					return "number" == typeof t
				}

				function pt(t) {
					return "number" == typeof t && t % 1 == 0
				}

				function _t() {
					try {
						return "undefined" != typeof Intl && !!Intl.RelativeTimeFormat
					} catch (t) {
						return !1
					}
				}

				function mt(t, e, i) {
					if (0 !== t.length) return t.reduce(((t, n) => {
						const s = [e(n), n];
						return t && i(t[0], s[0]) === t[0] ? t : s
					}), null)[1]
				}

				function gt(t, e) {
					return Object.prototype.hasOwnProperty.call(t, e)
				}

				function ft(t, e, i) {
					return pt(t) && t >= e && t <= i
				}

				function St(t, e = 2) {
					let i;
					return i = t < 0 ? "-" + ("" + -t).padStart(e, "0") : ("" + t).padStart(e, "0"), i
				}

				function yt(t) {
					return ct(t) || null === t || "" === t ? void 0 : parseInt(t, 10)
				}

				function vt(t) {
					return ct(t) || null === t || "" === t ? void 0 : parseFloat(t)
				}

				function Tt(t) {
					if (!ct(t) && null !== t && "" !== t) {
						const e = 1e3 * parseFloat("0." + t);
						return Math.floor(e)
					}
				}

				function Et(t, e, i = !1) {
					const n = 10 ** e;
					return (i ? Math.trunc : Math.round)(t * n) / n
				}

				function bt(t) {
					return t % 4 == 0 && (t % 100 != 0 || t % 400 == 0)
				}

				function At(t) {
					return bt(t) ? 366 : 365
				}

				function Pt(t, e) {
					const i = (n = e - 1) - 12 * Math.floor(n / 12) + 1;
					var n;
					return 2 === i ? bt(t + (e - i) / 12) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][i - 1]
				}

				function It(t) {
					let e = Date.UTC(t.year, t.month - 1, t.day, t.hour, t.minute, t.second, t.millisecond);
					return t.year < 100 && t.year >= 0 && (e = new Date(e), e.setUTCFullYear(t.year, t.month - 1, t.day)), +e
				}

				function wt(t) {
					const e = (t + Math.floor(t / 4) - Math.floor(t / 100) + Math.floor(t / 400)) % 7,
						i = t - 1,
						n = (i + Math.floor(i / 4) - Math.floor(i / 100) + Math.floor(i / 400)) % 7;
					return 4 === e || 3 === n ? 53 : 52
				}

				function Lt(t) {
					return t > 99 ? t : t > ut.twoDigitCutoffYear ? 1900 + t : 2e3 + t
				}

				function Ct(t, e, i, n = null) {
					const s = new Date(t),
						o = {
							hourCycle: "h23",
							year: "numeric",
							month: "2-digit",
							day: "2-digit",
							hour: "2-digit",
							minute: "2-digit"
						};
					n && (o.timeZone = n);
					const r = {
							timeZoneName: e,
							...o
						},
						a = new Intl.DateTimeFormat(i, r).formatToParts(s).find((t => "timezonename" === t.type.toLowerCase()));
					return a ? a.value : null
				}

				function xt(t, e) {
					let i = parseInt(t, 10);
					Number.isNaN(i) && (i = 0);
					const n = parseInt(e, 10) || 0;
					return 60 * i + (i < 0 || Object.is(i, -0) ? -n : n)
				}

				function Bt(t) {
					const e = Number(t);
					if ("boolean" == typeof t || "" === t || Number.isNaN(e)) throw new l(`Invalid unit value ${t}`);
					return e
				}

				function Ot(t, e) {
					const i = {};
					for (const n in t)
						if (gt(t, n)) {
							const s = t[n];
							if (null == s) continue;
							i[e(n)] = Bt(s)
						} return i
				}

				function Nt(t, e) {
					const i = Math.trunc(Math.abs(t / 60)),
						n = Math.trunc(Math.abs(t % 60)),
						s = t >= 0 ? "+" : "-";
					switch (e) {
						case "short":
							return `${s}${St(i,2)}:${St(n,2)}`;
						case "narrow":
							return `${s}${i}${n>0?`:${n}`:""}`;
						case "techie":
							return `${s}${St(i,2)}${St(n,2)}`;
						default:
							throw new RangeError(`Value format ${e} is out of range for property format`)
					}
				}

				function Mt(t) {
					return function(t, e) {
						return ["hour", "minute", "second", "millisecond"].reduce(((e, i) => (e[i] = t[i], e)), {})
					}(t)
				}
				const Rt = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
					Dt = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
					kt = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];

				function Ft(t) {
					switch (t) {
						case "narrow":
							return [...kt];
						case "short":
							return [...Dt];
						case "long":
							return [...Rt];
						case "numeric":
							return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
						case "2-digit":
							return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
						default:
							return null
					}
				}
				const Gt = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
					Ut = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
					Wt = ["M", "T", "W", "T", "F", "S", "S"];

				function Ht(t) {
					switch (t) {
						case "narrow":
							return [...Wt];
						case "short":
							return [...Ut];
						case "long":
							return [...Gt];
						case "numeric":
							return ["1", "2", "3", "4", "5", "6", "7"];
						default:
							return null
					}
				}
				const Vt = ["AM", "PM"],
					Xt = ["Before Christ", "Anno Domini"],
					Yt = ["BC", "AD"],
					zt = ["B", "A"];

				function jt(t) {
					switch (t) {
						case "narrow":
							return [...zt];
						case "short":
							return [...Yt];
						case "long":
							return [...Xt];
						default:
							return null
					}
				}

				function Kt(t, e) {
					let i = "";
					for (const n of t) n.literal ? i += n.val : i += e(n.val);
					return i
				}
				const qt = {
					D: p,
					DD: _,
					DDD: g,
					DDDD: f,
					t: S,
					tt: y,
					ttt: v,
					tttt: T,
					T: E,
					TT: b,
					TTT: A,
					TTTT: P,
					f: I,
					ff: L,
					fff: B,
					ffff: N,
					F: w,
					FF: C,
					FFF: O,
					FFFF: M
				};
				class Zt {
					static create(t, e = {}) {
						return new Zt(t, e)
					}
					static parseFormat(t) {
						let e = null,
							i = "",
							n = !1;
						const s = [];
						for (let o = 0; o < t.length; o++) {
							const r = t.charAt(o);
							"'" === r ? (i.length > 0 && s.push({
								literal: n || /^\s+$/.test(i),
								val: i
							}), e = null, i = "", n = !n) : n || r === e ? i += r : (i.length > 0 && s.push({
								literal: /^\s+$/.test(i),
								val: i
							}), i = r, e = r)
						}
						return i.length > 0 && s.push({
							literal: n || /^\s+$/.test(i),
							val: i
						}), s
					}
					static macroTokenToFormatOpts(t) {
						return qt[t]
					}
					constructor(t, e) {
						this.opts = e, this.loc = t, this.systemLoc = null
					}
					formatWithSystemDefault(t, e) {
						return null === this.systemLoc && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(t, {
							...this.opts,
							...e
						}).format()
					}
					formatDateTime(t, e = {}) {
						return this.loc.dtFormatter(t, {
							...this.opts,
							...e
						}).format()
					}
					formatDateTimeParts(t, e = {}) {
						return this.loc.dtFormatter(t, {
							...this.opts,
							...e
						}).formatToParts()
					}
					formatInterval(t, e = {}) {
						return this.loc.dtFormatter(t.start, {
							...this.opts,
							...e
						}).dtf.formatRange(t.start.toJSDate(), t.end.toJSDate())
					}
					resolvedOptions(t, e = {}) {
						return this.loc.dtFormatter(t, {
							...this.opts,
							...e
						}).resolvedOptions()
					}
					num(t, e = 0) {
						if (this.opts.forceSimple) return St(t, e);
						const i = {
							...this.opts
						};
						return e > 0 && (i.padTo = e), this.loc.numberFormatter(i).format(t)
					}
					formatDateTimeFromString(t, e) {
						const i = "en" === this.loc.listingMode(),
							n = this.loc.outputCalendar && "gregory" !== this.loc.outputCalendar,
							s = (e, i) => this.loc.extract(t, e, i),
							o = e => t.isOffsetFixed && 0 === t.offset && e.allowZ ? "Z" : t.isValid ? t.zone.formatOffset(t.ts, e.format) : "",
							r = (e, n) => i ? function(t, e) {
								return Ft(e)[t.month - 1]
							}(t, e) : s(n ? {
								month: e
							} : {
								month: e,
								day: "numeric"
							}, "month"),
							a = (e, n) => i ? function(t, e) {
								return Ht(e)[t.weekday - 1]
							}(t, e) : s(n ? {
								weekday: e
							} : {
								weekday: e,
								month: "long",
								day: "numeric"
							}, "weekday"),
							l = e => {
								const i = Zt.macroTokenToFormatOpts(e);
								return i ? this.formatWithSystemDefault(t, i) : e
							},
							h = e => i ? function(t, e) {
								return jt(e)[t.year < 0 ? 0 : 1]
							}(t, e) : s({
								era: e
							}, "era");
						return Kt(Zt.parseFormat(e), (e => {
							switch (e) {
								case "S":
									return this.num(t.millisecond);
								case "u":
								case "SSS":
									return this.num(t.millisecond, 3);
								case "s":
									return this.num(t.second);
								case "ss":
									return this.num(t.second, 2);
								case "uu":
									return this.num(Math.floor(t.millisecond / 10), 2);
								case "uuu":
									return this.num(Math.floor(t.millisecond / 100));
								case "m":
									return this.num(t.minute);
								case "mm":
									return this.num(t.minute, 2);
								case "h":
									return this.num(t.hour % 12 == 0 ? 12 : t.hour % 12);
								case "hh":
									return this.num(t.hour % 12 == 0 ? 12 : t.hour % 12, 2);
								case "H":
									return this.num(t.hour);
								case "HH":
									return this.num(t.hour, 2);
								case "Z":
									return o({
										format: "narrow",
										allowZ: this.opts.allowZ
									});
								case "ZZ":
									return o({
										format: "short",
										allowZ: this.opts.allowZ
									});
								case "ZZZ":
									return o({
										format: "techie",
										allowZ: this.opts.allowZ
									});
								case "ZZZZ":
									return t.zone.offsetName(t.ts, {
										format: "short",
										locale: this.loc.locale
									});
								case "ZZZZZ":
									return t.zone.offsetName(t.ts, {
										format: "long",
										locale: this.loc.locale
									});
								case "z":
									return t.zoneName;
								case "a":
									return i ? function(t) {
										return Vt[t.hour < 12 ? 0 : 1]
									}(t) : s({
										hour: "numeric",
										hourCycle: "h12"
									}, "dayperiod");
								case "d":
									return n ? s({
										day: "numeric"
									}, "day") : this.num(t.day);
								case "dd":
									return n ? s({
										day: "2-digit"
									}, "day") : this.num(t.day, 2);
								case "c":
								case "E":
									return this.num(t.weekday);
								case "ccc":
									return a("short", !0);
								case "cccc":
									return a("long", !0);
								case "ccccc":
									return a("narrow", !0);
								case "EEE":
									return a("short", !1);
								case "EEEE":
									return a("long", !1);
								case "EEEEE":
									return a("narrow", !1);
								case "L":
									return n ? s({
										month: "numeric",
										day: "numeric"
									}, "month") : this.num(t.month);
								case "LL":
									return n ? s({
										month: "2-digit",
										day: "numeric"
									}, "month") : this.num(t.month, 2);
								case "LLL":
									return r("short", !0);
								case "LLLL":
									return r("long", !0);
								case "LLLLL":
									return r("narrow", !0);
								case "M":
									return n ? s({
										month: "numeric"
									}, "month") : this.num(t.month);
								case "MM":
									return n ? s({
										month: "2-digit"
									}, "month") : this.num(t.month, 2);
								case "MMM":
									return r("short", !1);
								case "MMMM":
									return r("long", !1);
								case "MMMMM":
									return r("narrow", !1);
								case "y":
									return n ? s({
										year: "numeric"
									}, "year") : this.num(t.year);
								case "yy":
									return n ? s({
										year: "2-digit"
									}, "year") : this.num(t.year.toString().slice(-2), 2);
								case "yyyy":
									return n ? s({
										year: "numeric"
									}, "year") : this.num(t.year, 4);
								case "yyyyyy":
									return n ? s({
										year: "numeric"
									}, "year") : this.num(t.year, 6);
								case "G":
									return h("short");
								case "GG":
									return h("long");
								case "GGGGG":
									return h("narrow");
								case "kk":
									return this.num(t.weekYear.toString().slice(-2), 2);
								case "kkkk":
									return this.num(t.weekYear, 4);
								case "W":
									return this.num(t.weekNumber);
								case "WW":
									return this.num(t.weekNumber, 2);
								case "o":
									return this.num(t.ordinal);
								case "ooo":
									return this.num(t.ordinal, 3);
								case "q":
									return this.num(t.quarter);
								case "qq":
									return this.num(t.quarter, 2);
								case "X":
									return this.num(Math.floor(t.ts / 1e3));
								case "x":
									return this.num(t.ts);
								default:
									return l(e)
							}
						}))
					}
					formatDurationFromString(t, e) {
						const i = t => {
								switch (t[0]) {
									case "S":
										return "millisecond";
									case "s":
										return "second";
									case "m":
										return "minute";
									case "h":
										return "hour";
									case "d":
										return "day";
									case "w":
										return "week";
									case "M":
										return "month";
									case "y":
										return "year";
									default:
										return null
								}
							},
							n = Zt.parseFormat(e),
							s = n.reduce(((t, {
								literal: e,
								val: i
							}) => e ? t : t.concat(i)), []);
						return Kt(n, (t => e => {
							const n = i(e);
							return n ? this.num(t.get(n), e.length) : e
						})(t.shiftTo(...s.map(i).filter((t => t)))))
					}
				}
				class $t {
					constructor(t, e) {
						this.reason = t, this.explanation = e
					}
					toMessage() {
						return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason
					}
				}
				const Qt = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;

				function Jt(...t) {
					const e = t.reduce(((t, e) => t + e.source), "");
					return RegExp(`^${e}$`)
				}

				function te(...t) {
					return e => t.reduce((([t, i, n], s) => {
						const [o, r, a] = s(e, n);
						return [{
							...t,
							...o
						}, r || i, a]
					}), [{}, null, 1]).slice(0, 2)
				}

				function ee(t, ...e) {
					if (null == t) return [null, null];
					for (const [i, n] of e) {
						const e = i.exec(t);
						if (e) return n(e)
					}
					return [null, null]
				}

				function ie(...t) {
					return (e, i) => {
						const n = {};
						let s;
						for (s = 0; s < t.length; s++) n[t[s]] = yt(e[i + s]);
						return [n, null, i + s]
					}
				}
				const ne = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/,
					se = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/,
					oe = RegExp(`${se.source}(?:${ne.source}?(?:\\[(${Qt.source})\\])?)?`),
					re = RegExp(`(?:T${oe.source})?`),
					ae = ie("weekYear", "weekNumber", "weekDay"),
					le = ie("year", "ordinal"),
					he = RegExp(`${se.source} ?(?:${ne.source}|(${Qt.source}))?`),
					ue = RegExp(`(?: ${he.source})?`);

				function ce(t, e, i) {
					const n = t[e];
					return ct(n) ? i : yt(n)
				}

				function de(t, e) {
					return [{
						hours: ce(t, e, 0),
						minutes: ce(t, e + 1, 0),
						seconds: ce(t, e + 2, 0),
						milliseconds: Tt(t[e + 3])
					}, null, e + 4]
				}

				function pe(t, e) {
					const i = !t[e] && !t[e + 1],
						n = xt(t[e + 1], t[e + 2]);
					return [{}, i ? null : tt.instance(n), e + 3]
				}

				function _e(t, e) {
					return [{}, t[e] ? W.create(t[e]) : null, e + 1]
				}
				const me = RegExp(`^T?${se.source}$`),
					ge = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;

				function fe(t) {
					const [e, i, n, s, o, r, a, l, h] = t, u = "-" === e[0], c = l && "-" === l[0], d = (t, e = !1) => void 0 !== t && (e || t && u) ? -t : t;
					return [{
						years: d(vt(i)),
						months: d(vt(n)),
						weeks: d(vt(s)),
						days: d(vt(o)),
						hours: d(vt(r)),
						minutes: d(vt(a)),
						seconds: d(vt(l), "-0" === l),
						milliseconds: d(Tt(h), c)
					}]
				}
				const Se = {
					GMT: 0,
					EDT: -240,
					EST: -300,
					CDT: -300,
					CST: -360,
					MDT: -360,
					MST: -420,
					PDT: -420,
					PST: -480
				};

				function ye(t, e, i, n, s, o, r) {
					const a = {
						year: 2 === e.length ? Lt(yt(e)) : yt(e),
						month: Dt.indexOf(i) + 1,
						day: yt(n),
						hour: yt(s),
						minute: yt(o)
					};
					return r && (a.second = yt(r)), t && (a.weekday = t.length > 3 ? Gt.indexOf(t) + 1 : Ut.indexOf(t) + 1), a
				}
				const ve = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;

				function Te(t) {
					const [, e, i, n, s, o, r, a, l, h, u, c] = t, d = ye(e, s, n, i, o, r, a);
					let p;
					return p = l ? Se[l] : h ? 0 : xt(u, c), [d, new tt(p)]
				}
				const Ee = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,
					be = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,
					Ae = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;

				function Pe(t) {
					const [, e, i, n, s, o, r, a] = t;
					return [ye(e, s, n, i, o, r, a), tt.utcInstance]
				}

				function Ie(t) {
					const [, e, i, n, s, o, r, a] = t;
					return [ye(e, a, i, n, s, o, r), tt.utcInstance]
				}
				const we = Jt(/([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, re),
					Le = Jt(/(\d{4})-?W(\d\d)(?:-?(\d))?/, re),
					Ce = Jt(/(\d{4})-?(\d{3})/, re),
					xe = Jt(oe),
					Be = te((function(t, e) {
						return [{
							year: ce(t, e),
							month: ce(t, e + 1, 1),
							day: ce(t, e + 2, 1)
						}, null, e + 3]
					}), de, pe, _e),
					Oe = te(ae, de, pe, _e),
					Ne = te(le, de, pe, _e),
					Me = te(de, pe, _e),
					Re = te(de),
					De = Jt(/(\d{4})-(\d\d)-(\d\d)/, ue),
					ke = Jt(he),
					Fe = te(de, pe, _e),
					Ge = {
						weeks: {
							days: 7,
							hours: 168,
							minutes: 10080,
							seconds: 604800,
							milliseconds: 6048e5
						},
						days: {
							hours: 24,
							minutes: 1440,
							seconds: 86400,
							milliseconds: 864e5
						},
						hours: {
							minutes: 60,
							seconds: 3600,
							milliseconds: 36e5
						},
						minutes: {
							seconds: 60,
							milliseconds: 6e4
						},
						seconds: {
							milliseconds: 1e3
						}
					},
					Ue = {
						years: {
							quarters: 4,
							months: 12,
							weeks: 52,
							days: 365,
							hours: 8760,
							minutes: 525600,
							seconds: 31536e3,
							milliseconds: 31536e6
						},
						quarters: {
							months: 3,
							weeks: 13,
							days: 91,
							hours: 2184,
							minutes: 131040,
							seconds: 7862400,
							milliseconds: 78624e5
						},
						months: {
							weeks: 4,
							days: 30,
							hours: 720,
							minutes: 43200,
							seconds: 2592e3,
							milliseconds: 2592e6
						},
						...Ge
					},
					We = {
						years: {
							quarters: 4,
							months: 12,
							weeks: 52.1775,
							days: 365.2425,
							hours: 8765.82,
							minutes: 525949.2,
							seconds: 525949.2 * 60,
							milliseconds: 525949.2 * 60 * 1e3
						},
						quarters: {
							months: 3,
							weeks: 13.044375,
							days: 91.310625,
							hours: 2191.455,
							minutes: 131487.3,
							seconds: 525949.2 * 60 / 4,
							milliseconds: 7889237999.999999
						},
						months: {
							weeks: 4.3481250000000005,
							days: 30.436875,
							hours: 730.485,
							minutes: 43829.1,
							seconds: 2629746,
							milliseconds: 2629746e3
						},
						...Ge
					},
					He = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"],
					Ve = He.slice(0).reverse();

				function Xe(t, e, i = !1) {
					const n = {
						values: i ? e.values : {
							...t.values,
							...e.values || {}
						},
						loc: t.loc.clone(e.loc),
						conversionAccuracy: e.conversionAccuracy || t.conversionAccuracy,
						matrix: e.matrix || t.matrix
					};
					return new ze(n)
				}

				function Ye(t, e, i, n, s) {
					const o = t[s][i],
						r = e[i] / o,
						a = Math.sign(r) !== Math.sign(n[s]) && 0 !== n[s] && Math.abs(r) <= 1 ? function(t) {
							return t < 0 ? Math.floor(t) : Math.ceil(t)
						}(r) : Math.trunc(r);
					n[s] += a, e[i] -= a * o
				}
				class ze {
					constructor(t) {
						const e = "longterm" === t.conversionAccuracy || !1;
						let i = e ? We : Ue;
						t.matrix && (i = t.matrix), this.values = t.values, this.loc = t.loc || Q.create(), this.conversionAccuracy = e ? "longterm" : "casual", this.invalid = t.invalid || null, this.matrix = i, this.isLuxonDuration = !0
					}
					static fromMillis(t, e) {
						return ze.fromObject({
							milliseconds: t
						}, e)
					}
					static fromObject(t, e = {}) {
						if (null == t || "object" != typeof t) throw new l("Duration.fromObject: argument expected to be an object, got " + (null === t ? "null" : typeof t));
						return new ze({
							values: Ot(t, ze.normalizeUnit),
							loc: Q.fromObject(e),
							conversionAccuracy: e.conversionAccuracy,
							matrix: e.matrix
						})
					}
					static fromDurationLike(t) {
						if (dt(t)) return ze.fromMillis(t);
						if (ze.isDuration(t)) return t;
						if ("object" == typeof t) return ze.fromObject(t);
						throw new l(`Unknown duration argument ${t} of type ${typeof t}`)
					}
					static fromISO(t, e) {
						const [i] = function(t) {
							return ee(t, [ge, fe])
						}(t);
						return i ? ze.fromObject(i, e) : ze.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`)
					}
					static fromISOTime(t, e) {
						const [i] = function(t) {
							return ee(t, [me, Re])
						}(t);
						return i ? ze.fromObject(i, e) : ze.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`)
					}
					static invalid(t, e = null) {
						if (!t) throw new l("need to specify a reason the Duration is invalid");
						const i = t instanceof $t ? t : new $t(t, e);
						if (ut.throwOnInvalid) throw new o(i);
						return new ze({
							invalid: i
						})
					}
					static normalizeUnit(t) {
						const e = {
							year: "years",
							years: "years",
							quarter: "quarters",
							quarters: "quarters",
							month: "months",
							months: "months",
							week: "weeks",
							weeks: "weeks",
							day: "days",
							days: "days",
							hour: "hours",
							hours: "hours",
							minute: "minutes",
							minutes: "minutes",
							second: "seconds",
							seconds: "seconds",
							millisecond: "milliseconds",
							milliseconds: "milliseconds"
						} [t ? t.toLowerCase() : t];
						if (!e) throw new a(t);
						return e
					}
					static isDuration(t) {
						return t && t.isLuxonDuration || !1
					}
					get locale() {
						return this.isValid ? this.loc.locale : null
					}
					get numberingSystem() {
						return this.isValid ? this.loc.numberingSystem : null
					}
					toFormat(t, e = {}) {
						const i = {
							...e,
							floor: !1 !== e.round && !1 !== e.floor
						};
						return this.isValid ? Zt.create(this.loc, i).formatDurationFromString(this, t) : "Invalid Duration"
					}
					toHuman(t = {}) {
						const e = He.map((e => {
							const i = this.values[e];
							return ct(i) ? null : this.loc.numberFormatter({
								style: "unit",
								unitDisplay: "long",
								...t,
								unit: e.slice(0, -1)
							}).format(i)
						})).filter((t => t));
						return this.loc.listFormatter({
							type: "conjunction",
							style: t.listStyle || "narrow",
							...t
						}).format(e)
					}
					toObject() {
						return this.isValid ? {
							...this.values
						} : {}
					}
					toISO() {
						if (!this.isValid) return null;
						let t = "P";
						return 0 !== this.years && (t += this.years + "Y"), 0 === this.months && 0 === this.quarters || (t += this.months + 3 * this.quarters + "M"), 0 !== this.weeks && (t += this.weeks + "W"), 0 !== this.days && (t += this.days + "D"), 0 === this.hours && 0 === this.minutes && 0 === this.seconds && 0 === this.milliseconds || (t += "T"), 0 !== this.hours && (t += this.hours + "H"), 0 !== this.minutes && (t += this.minutes + "M"), 0 === this.seconds && 0 === this.milliseconds || (t += Et(this.seconds + this.milliseconds / 1e3, 3) + "S"), "P" === t && (t += "T0S"), t
					}
					toISOTime(t = {}) {
						if (!this.isValid) return null;
						const e = this.toMillis();
						if (e < 0 || e >= 864e5) return null;
						t = {
							suppressMilliseconds: !1,
							suppressSeconds: !1,
							includePrefix: !1,
							format: "extended",
							...t
						};
						const i = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
						let n = "basic" === t.format ? "hhmm" : "hh:mm";
						t.suppressSeconds && 0 === i.seconds && 0 === i.milliseconds || (n += "basic" === t.format ? "ss" : ":ss", t.suppressMilliseconds && 0 === i.milliseconds || (n += ".SSS"));
						let s = i.toFormat(n);
						return t.includePrefix && (s = "T" + s), s
					}
					toJSON() {
						return this.toISO()
					}
					toString() {
						return this.toISO()
					}
					toMillis() {
						return this.as("milliseconds")
					}
					valueOf() {
						return this.toMillis()
					}
					plus(t) {
						if (!this.isValid) return this;
						const e = ze.fromDurationLike(t),
							i = {};
						for (const t of He)(gt(e.values, t) || gt(this.values, t)) && (i[t] = e.get(t) + this.get(t));
						return Xe(this, {
							values: i
						}, !0)
					}
					minus(t) {
						if (!this.isValid) return this;
						const e = ze.fromDurationLike(t);
						return this.plus(e.negate())
					}
					mapUnits(t) {
						if (!this.isValid) return this;
						const e = {};
						for (const i of Object.keys(this.values)) e[i] = Bt(t(this.values[i], i));
						return Xe(this, {
							values: e
						}, !0)
					}
					get(t) {
						return this[ze.normalizeUnit(t)]
					}
					set(t) {
						return this.isValid ? Xe(this, {
							values: {
								...this.values,
								...Ot(t, ze.normalizeUnit)
							}
						}) : this
					}
					reconfigure({
						locale: t,
						numberingSystem: e,
						conversionAccuracy: i,
						matrix: n
					} = {}) {
						return Xe(this, {
							loc: this.loc.clone({
								locale: t,
								numberingSystem: e
							}),
							matrix: n,
							conversionAccuracy: i
						})
					}
					as(t) {
						return this.isValid ? this.shiftTo(t).get(t) : NaN
					}
					normalize() {
						if (!this.isValid) return this;
						const t = this.toObject();
						return function(t, e) {
							Ve.reduce(((i, n) => ct(e[n]) ? i : (i && Ye(t, e, i, e, n), n)), null)
						}(this.matrix, t), Xe(this, {
							values: t
						}, !0)
					}
					rescale() {
						return this.isValid ? Xe(this, {
							values: function(t) {
								const e = {};
								for (const [i, n] of Object.entries(t)) 0 !== n && (e[i] = n);
								return e
							}(this.normalize().shiftToAll().toObject())
						}, !0) : this
					}
					shiftTo(...t) {
						if (!this.isValid) return this;
						if (0 === t.length) return this;
						t = t.map((t => ze.normalizeUnit(t)));
						const e = {},
							i = {},
							n = this.toObject();
						let s;
						for (const o of He)
							if (t.indexOf(o) >= 0) {
								s = o;
								let t = 0;
								for (const e in i) t += this.matrix[e][o] * i[e], i[e] = 0;
								dt(n[o]) && (t += n[o]);
								const r = Math.trunc(t);
								e[o] = r, i[o] = (1e3 * t - 1e3 * r) / 1e3;
								for (const t in n) He.indexOf(t) > He.indexOf(o) && Ye(this.matrix, n, t, e, o)
							} else dt(n[o]) && (i[o] = n[o]);
						for (const t in i) 0 !== i[t] && (e[s] += t === s ? i[t] : i[t] / this.matrix[s][t]);
						return Xe(this, {
							values: e
						}, !0).normalize()
					}
					shiftToAll() {
						return this.isValid ? this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds") : this
					}
					negate() {
						if (!this.isValid) return this;
						const t = {};
						for (const e of Object.keys(this.values)) t[e] = 0 === this.values[e] ? 0 : -this.values[e];
						return Xe(this, {
							values: t
						}, !0)
					}
					get years() {
						return this.isValid ? this.values.years || 0 : NaN
					}
					get quarters() {
						return this.isValid ? this.values.quarters || 0 : NaN
					}
					get months() {
						return this.isValid ? this.values.months || 0 : NaN
					}
					get weeks() {
						return this.isValid ? this.values.weeks || 0 : NaN
					}
					get days() {
						return this.isValid ? this.values.days || 0 : NaN
					}
					get hours() {
						return this.isValid ? this.values.hours || 0 : NaN
					}
					get minutes() {
						return this.isValid ? this.values.minutes || 0 : NaN
					}
					get seconds() {
						return this.isValid ? this.values.seconds || 0 : NaN
					}
					get milliseconds() {
						return this.isValid ? this.values.milliseconds || 0 : NaN
					}
					get isValid() {
						return null === this.invalid
					}
					get invalidReason() {
						return this.invalid ? this.invalid.reason : null
					}
					get invalidExplanation() {
						return this.invalid ? this.invalid.explanation : null
					}
					equals(t) {
						if (!this.isValid || !t.isValid) return !1;
						if (!this.loc.equals(t.loc)) return !1;
						for (const n of He)
							if (e = this.values[n], i = t.values[n], !(void 0 === e || 0 === e ? void 0 === i || 0 === i : e === i)) return !1;
						var e, i;
						return !0
					}
				}
				const je = "Invalid Interval";
				class Ke {
					constructor(t) {
						this.s = t.start, this.e = t.end, this.invalid = t.invalid || null, this.isLuxonInterval = !0
					}
					static invalid(t, e = null) {
						if (!t) throw new l("need to specify a reason the Interval is invalid");
						const i = t instanceof $t ? t : new $t(t, e);
						if (ut.throwOnInvalid) throw new s(i);
						return new Ke({
							invalid: i
						})
					}
					static fromDateTimes(t, e) {
						const i = Zi(t),
							n = Zi(e),
							s = function(t, e) {
								return t && t.isValid ? e && e.isValid ? e < t ? Ke.invalid("end before start", `The end of an interval must be after its start, but you had start=${t.toISO()} and end=${e.toISO()}`) : null : Ke.invalid("missing or invalid end") : Ke.invalid("missing or invalid start")
							}(i, n);
						return null == s ? new Ke({
							start: i,
							end: n
						}) : s
					}
					static after(t, e) {
						const i = ze.fromDurationLike(e),
							n = Zi(t);
						return Ke.fromDateTimes(n, n.plus(i))
					}
					static before(t, e) {
						const i = ze.fromDurationLike(e),
							n = Zi(t);
						return Ke.fromDateTimes(n.minus(i), n)
					}
					static fromISO(t, e) {
						const [i, n] = (t || "").split("/", 2);
						if (i && n) {
							let t, s, o, r;
							try {
								t = qi.fromISO(i, e), s = t.isValid
							} catch (n) {
								s = !1
							}
							try {
								o = qi.fromISO(n, e), r = o.isValid
							} catch (n) {
								r = !1
							}
							if (s && r) return Ke.fromDateTimes(t, o);
							if (s) {
								const i = ze.fromISO(n, e);
								if (i.isValid) return Ke.after(t, i)
							} else if (r) {
								const t = ze.fromISO(i, e);
								if (t.isValid) return Ke.before(o, t)
							}
						}
						return Ke.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`)
					}
					static isInterval(t) {
						return t && t.isLuxonInterval || !1
					}
					get start() {
						return this.isValid ? this.s : null
					}
					get end() {
						return this.isValid ? this.e : null
					}
					get isValid() {
						return null === this.invalidReason
					}
					get invalidReason() {
						return this.invalid ? this.invalid.reason : null
					}
					get invalidExplanation() {
						return this.invalid ? this.invalid.explanation : null
					}
					length(t = "milliseconds") {
						return this.isValid ? this.toDuration(t).get(t) : NaN
					}
					count(t = "milliseconds") {
						if (!this.isValid) return NaN;
						const e = this.start.startOf(t),
							i = this.end.startOf(t);
						return Math.floor(i.diff(e, t).get(t)) + (i.valueOf() !== this.end.valueOf())
					}
					hasSame(t) {
						return !!this.isValid && (this.isEmpty() || this.e.minus(1).hasSame(this.s, t))
					}
					isEmpty() {
						return this.s.valueOf() === this.e.valueOf()
					}
					isAfter(t) {
						return !!this.isValid && this.s > t
					}
					isBefore(t) {
						return !!this.isValid && this.e <= t
					}
					contains(t) {
						return !!this.isValid && this.s <= t && this.e > t
					}
					set({
						start: t,
						end: e
					} = {}) {
						return this.isValid ? Ke.fromDateTimes(t || this.s, e || this.e) : this
					}
					splitAt(...t) {
						if (!this.isValid) return [];
						const e = t.map(Zi).filter((t => this.contains(t))).sort(),
							i = [];
						let {
							s: n
						} = this, s = 0;
						for (; n < this.e;) {
							const t = e[s] || this.e,
								o = +t > +this.e ? this.e : t;
							i.push(Ke.fromDateTimes(n, o)), n = o, s += 1
						}
						return i
					}
					splitBy(t) {
						const e = ze.fromDurationLike(t);
						if (!this.isValid || !e.isValid || 0 === e.as("milliseconds")) return [];
						let i, {
								s: n
							} = this,
							s = 1;
						const o = [];
						for (; n < this.e;) {
							const t = this.start.plus(e.mapUnits((t => t * s)));
							i = +t > +this.e ? this.e : t, o.push(Ke.fromDateTimes(n, i)), n = i, s += 1
						}
						return o
					}
					divideEqually(t) {
						return this.isValid ? this.splitBy(this.length() / t).slice(0, t) : []
					}
					overlaps(t) {
						return this.e > t.s && this.s < t.e
					}
					abutsStart(t) {
						return !!this.isValid && +this.e == +t.s
					}
					abutsEnd(t) {
						return !!this.isValid && +t.e == +this.s
					}
					engulfs(t) {
						return !!this.isValid && this.s <= t.s && this.e >= t.e
					}
					equals(t) {
						return !(!this.isValid || !t.isValid) && this.s.equals(t.s) && this.e.equals(t.e)
					}
					intersection(t) {
						if (!this.isValid) return this;
						const e = this.s > t.s ? this.s : t.s,
							i = this.e < t.e ? this.e : t.e;
						return e >= i ? null : Ke.fromDateTimes(e, i)
					}
					union(t) {
						if (!this.isValid) return this;
						const e = this.s < t.s ? this.s : t.s,
							i = this.e > t.e ? this.e : t.e;
						return Ke.fromDateTimes(e, i)
					}
					static merge(t) {
						const [e, i] = t.sort(((t, e) => t.s - e.s)).reduce((([t, e], i) => e ? e.overlaps(i) || e.abutsStart(i) ? [t, e.union(i)] : [t.concat([e]), i] : [t, i]), [
							[], null
						]);
						return i && e.push(i), e
					}
					static xor(t) {
						let e = null,
							i = 0;
						const n = [],
							s = t.map((t => [{
								time: t.s,
								type: "s"
							}, {
								time: t.e,
								type: "e"
							}])),
							o = Array.prototype.concat(...s).sort(((t, e) => t.time - e.time));
						for (const t of o) i += "s" === t.type ? 1 : -1, 1 === i ? e = t.time : (e && +e != +t.time && n.push(Ke.fromDateTimes(e, t.time)), e = null);
						return Ke.merge(n)
					}
					difference(...t) {
						return Ke.xor([this].concat(t)).map((t => this.intersection(t))).filter((t => t && !t.isEmpty()))
					}
					toString() {
						return this.isValid ? `[${this.s.toISO()}  ${this.e.toISO()})` : je
					}
					toLocaleString(t = p, e = {}) {
						return this.isValid ? Zt.create(this.s.loc.clone(e), t).formatInterval(this) : je
					}
					toISO(t) {
						return this.isValid ? `${this.s.toISO(t)}/${this.e.toISO(t)}` : je
					}
					toISODate() {
						return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : je
					}
					toISOTime(t) {
						return this.isValid ? `${this.s.toISOTime(t)}/${this.e.toISOTime(t)}` : je
					}
					toFormat(t, {
						separator: e = "  "
					} = {}) {
						return this.isValid ? `${this.s.toFormat(t)}${e}${this.e.toFormat(t)}` : je
					}
					toDuration(t, e) {
						return this.isValid ? this.e.diff(this.s, t, e) : ze.invalid(this.invalidReason)
					}
					mapEndpoints(t) {
						return Ke.fromDateTimes(t(this.s), t(this.e))
					}
				}
				class qe {
					static hasDST(t = ut.defaultZone) {
						const e = qi.now().setZone(t).set({
							month: 12
						});
						return !t.isUniversal && e.offset !== e.set({
							month: 6
						}).offset
					}
					static isValidIANAZone(t) {
						return W.isValidZone(t)
					}
					static normalizeZone(t) {
						return it(t, ut.defaultZone)
					}
					static months(t = "long", {
						locale: e = null,
						numberingSystem: i = null,
						locObj: n = null,
						outputCalendar: s = "gregory"
					} = {}) {
						return (n || Q.create(e, i, s)).months(t)
					}
					static monthsFormat(t = "long", {
						locale: e = null,
						numberingSystem: i = null,
						locObj: n = null,
						outputCalendar: s = "gregory"
					} = {}) {
						return (n || Q.create(e, i, s)).months(t, !0)
					}
					static weekdays(t = "long", {
						locale: e = null,
						numberingSystem: i = null,
						locObj: n = null
					} = {}) {
						return (n || Q.create(e, i, null)).weekdays(t)
					}
					static weekdaysFormat(t = "long", {
						locale: e = null,
						numberingSystem: i = null,
						locObj: n = null
					} = {}) {
						return (n || Q.create(e, i, null)).weekdays(t, !0)
					}
					static meridiems({
						locale: t = null
					} = {}) {
						return Q.create(t).meridiems()
					}
					static eras(t = "short", {
						locale: e = null
					} = {}) {
						return Q.create(e, null, "gregory").eras(t)
					}
					static features() {
						return {
							relative: _t()
						}
					}
				}

				function Ze(t, e) {
					const i = t => t.toUTC(0, {
							keepLocalTime: !0
						}).startOf("day").valueOf(),
						n = i(e) - i(t);
					return Math.floor(ze.fromMillis(n).as("days"))
				}
				const $e = {
						arab: "[ -]",
						arabext: "[-]",
						bali: "[-]",
						beng: "[-]",
						deva: "[-]",
						fullwide: "[-]",
						gujr: "[-]",
						hanidec: "[|||||||||]",
						khmr: "[ -]",
						knda: "[-]",
						laoo: "[-]",
						limb: "[-]",
						mlym: "[-]",
						mong: "[ - ]",
						mymr: "[-]",
						orya: "[-]",
						tamldec: "[-]",
						telu: "[-]",
						thai: "[-]",
						tibt: "[ -]",
						latn: "\\d"
					},
					Qe = {
						arab: [1632, 1641],
						arabext: [1776, 1785],
						bali: [6992, 7001],
						beng: [2534, 2543],
						deva: [2406, 2415],
						fullwide: [65296, 65303],
						gujr: [2790, 2799],
						khmr: [6112, 6121],
						knda: [3302, 3311],
						laoo: [3792, 3801],
						limb: [6470, 6479],
						mlym: [3430, 3439],
						mong: [6160, 6169],
						mymr: [4160, 4169],
						orya: [2918, 2927],
						tamldec: [3046, 3055],
						telu: [3174, 3183],
						thai: [3664, 3673],
						tibt: [3872, 3881]
					},
					Je = $e.hanidec.replace(/[\[|\]]/g, "").split("");

				function ti({
					numberingSystem: t
				}, e = "") {
					return new RegExp(`${$e[t||"latn"]}${e}`)
				}

				function ei(t, e = (t => t)) {
					return {
						regex: t,
						deser: ([t]) => e(function(t) {
							let e = parseInt(t, 10);
							if (isNaN(e)) {
								e = "";
								for (let i = 0; i < t.length; i++) {
									const n = t.charCodeAt(i);
									if (-1 !== t[i].search($e.hanidec)) e += Je.indexOf(t[i]);
									else
										for (const t in Qe) {
											const [i, s] = Qe[t];
											n >= i && n <= s && (e += n - i)
										}
								}
								return parseInt(e, 10)
							}
							return e
						}(t))
					}
				}
				const ii = `[ ${String.fromCharCode(160)}]`,
					ni = new RegExp(ii, "g");

				function si(t) {
					return t.replace(/\./g, "\\.?").replace(ni, ii)
				}

				function oi(t) {
					return t.replace(/\./g, "").replace(ni, " ").toLowerCase()
				}

				function ri(t, e) {
					return null === t ? null : {
						regex: RegExp(t.map(si).join("|")),
						deser: ([i]) => t.findIndex((t => oi(i) === oi(t))) + e
					}
				}

				function ai(t, e) {
					return {
						regex: t,
						deser: ([, t, e]) => xt(t, e),
						groups: e
					}
				}

				function li(t) {
					return {
						regex: t,
						deser: ([t]) => t
					}
				}
				const hi = {
					year: {
						"2-digit": "yy",
						numeric: "yyyyy"
					},
					month: {
						numeric: "M",
						"2-digit": "MM",
						short: "MMM",
						long: "MMMM"
					},
					day: {
						numeric: "d",
						"2-digit": "dd"
					},
					weekday: {
						short: "EEE",
						long: "EEEE"
					},
					dayperiod: "a",
					dayPeriod: "a",
					hour: {
						numeric: "h",
						"2-digit": "hh"
					},
					minute: {
						numeric: "m",
						"2-digit": "mm"
					},
					second: {
						numeric: "s",
						"2-digit": "ss"
					},
					timeZoneName: {
						long: "ZZZZZ",
						short: "ZZZ"
					}
				};
				let ui = null;

				function ci(t, e) {
					return Array.prototype.concat(...t.map((t => function(t, e) {
						if (t.literal) return t;
						const i = pi(Zt.macroTokenToFormatOpts(t.val), e);
						return null == i || i.includes(void 0) ? t : i
					}(t, e))))
				}

				function di(t, e, i) {
					const n = ci(Zt.parseFormat(i), t),
						s = n.map((e => function(t, e) {
							const i = ti(e),
								n = ti(e, "{2}"),
								s = ti(e, "{3}"),
								o = ti(e, "{4}"),
								r = ti(e, "{6}"),
								a = ti(e, "{1,2}"),
								l = ti(e, "{1,3}"),
								h = ti(e, "{1,6}"),
								u = ti(e, "{1,9}"),
								c = ti(e, "{2,4}"),
								d = ti(e, "{4,6}"),
								p = t => {
									return {
										regex: RegExp((e = t.val, e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"))),
										deser: ([t]) => t,
										literal: !0
									};
									var e
								},
								_ = (_ => {
									if (t.literal) return p(_);
									switch (_.val) {
										case "G":
											return ri(e.eras("short", !1), 0);
										case "GG":
											return ri(e.eras("long", !1), 0);
										case "y":
											return ei(h);
										case "yy":
										case "kk":
											return ei(c, Lt);
										case "yyyy":
										case "kkkk":
											return ei(o);
										case "yyyyy":
											return ei(d);
										case "yyyyyy":
											return ei(r);
										case "M":
										case "L":
										case "d":
										case "H":
										case "h":
										case "m":
										case "q":
										case "s":
										case "W":
											return ei(a);
										case "MM":
										case "LL":
										case "dd":
										case "HH":
										case "hh":
										case "mm":
										case "qq":
										case "ss":
										case "WW":
											return ei(n);
										case "MMM":
											return ri(e.months("short", !0, !1), 1);
										case "MMMM":
											return ri(e.months("long", !0, !1), 1);
										case "LLL":
											return ri(e.months("short", !1, !1), 1);
										case "LLLL":
											return ri(e.months("long", !1, !1), 1);
										case "o":
										case "S":
											return ei(l);
										case "ooo":
										case "SSS":
											return ei(s);
										case "u":
											return li(u);
										case "uu":
											return li(a);
										case "uuu":
										case "E":
										case "c":
											return ei(i);
										case "a":
											return ri(e.meridiems(), 0);
										case "EEE":
											return ri(e.weekdays("short", !1, !1), 1);
										case "EEEE":
											return ri(e.weekdays("long", !1, !1), 1);
										case "ccc":
											return ri(e.weekdays("short", !0, !1), 1);
										case "cccc":
											return ri(e.weekdays("long", !0, !1), 1);
										case "Z":
										case "ZZ":
											return ai(new RegExp(`([+-]${a.source})(?::(${n.source}))?`), 2);
										case "ZZZ":
											return ai(new RegExp(`([+-]${a.source})(${n.source})?`), 2);
										case "z":
											return li(/[a-z_+-/]{1,256}?/i);
										case " ":
											return li(/[^\S\n\r]/);
										default:
											return p(_)
									}
								})(t) || {
									invalidReason: "missing Intl.DateTimeFormat.formatToParts support"
								};
							return _.token = t, _
						}(e, t))),
						o = s.find((t => t.invalidReason));
					if (o) return {
						input: e,
						tokens: n,
						invalidReason: o.invalidReason
					};
					{
						const [t, i] = function(t) {
							return [`^${t.map((t=>t.regex)).reduce(((t,e)=>`${t}(${e.source})`),"")}$`, t]
						}(s), o = RegExp(t, "i"), [a, l] = function(t, e, i) {
							const n = t.match(e);
							if (n) {
								const t = {};
								let e = 1;
								for (const s in i)
									if (gt(i, s)) {
										const o = i[s],
											r = o.groups ? o.groups + 1 : 1;
										!o.literal && o.token && (t[o.token.val[0]] = o.deser(n.slice(e, e + r))), e += r
									} return [n, t]
							}
							return [n, {}]
						}(e, o, i), [h, u, c] = l ? function(t) {
							let e, i = null;
							return ct(t.z) || (i = W.create(t.z)), ct(t.Z) || (i || (i = new tt(t.Z)), e = t.Z), ct(t.q) || (t.M = 3 * (t.q - 1) + 1), ct(t.h) || (t.h < 12 && 1 === t.a ? t.h += 12 : 12 === t.h && 0 === t.a && (t.h = 0)), 0 === t.G && t.y && (t.y = -t.y), ct(t.u) || (t.S = Tt(t.u)), [Object.keys(t).reduce(((e, i) => {
								const n = (t => {
									switch (t) {
										case "S":
											return "millisecond";
										case "s":
											return "second";
										case "m":
											return "minute";
										case "h":
										case "H":
											return "hour";
										case "d":
											return "day";
										case "o":
											return "ordinal";
										case "L":
										case "M":
											return "month";
										case "y":
											return "year";
										case "E":
										case "c":
											return "weekday";
										case "W":
											return "weekNumber";
										case "k":
											return "weekYear";
										case "q":
											return "quarter";
										default:
											return null
									}
								})(i);
								return n && (e[n] = t[i]), e
							}), {}), i, e]
						}(l) : [null, null, void 0];
						if (gt(l, "a") && gt(l, "H")) throw new r("Can't include meridiem when specifying 24-hour format");
						return {
							input: e,
							tokens: n,
							regex: o,
							rawMatches: a,
							matches: l,
							result: h,
							zone: u,
							specificOffset: c
						}
					}
				}

				function pi(t, e) {
					return t ? Zt.create(e, t).formatDateTimeParts((ui || (ui = qi.fromMillis(1555555555555)), ui)).map((e => function(t, e) {
						const {
							type: i,
							value: n
						} = t;
						if ("literal" === i) {
							const t = /^\s+$/.test(n);
							return {
								literal: !t,
								val: t ? " " : n
							}
						}
						const s = e[i];
						let o = hi[i];
						if ("object" == typeof o && (o = o[s]), o) return {
							literal: !1,
							val: o
						}
					}(e, t))) : null
				}
				const _i = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
					mi = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];

				function gi(t, e) {
					return new $t("unit out of range", `you specified ${e} (of type ${typeof e}) as a ${t}, which is invalid`)
				}

				function fi(t, e, i) {
					const n = new Date(Date.UTC(t, e - 1, i));
					t < 100 && t >= 0 && n.setUTCFullYear(n.getUTCFullYear() - 1900);
					const s = n.getUTCDay();
					return 0 === s ? 7 : s
				}

				function Si(t, e, i) {
					return i + (bt(t) ? mi : _i)[e - 1]
				}

				function yi(t, e) {
					const i = bt(t) ? mi : _i,
						n = i.findIndex((t => t < e));
					return {
						month: n + 1,
						day: e - i[n]
					}
				}

				function vi(t) {
					const {
						year: e,
						month: i,
						day: n
					} = t, s = Si(e, i, n), o = fi(e, i, n);
					let r, a = Math.floor((s - o + 10) / 7);
					return a < 1 ? (r = e - 1, a = wt(r)) : a > wt(e) ? (r = e + 1, a = 1) : r = e, {
						weekYear: r,
						weekNumber: a,
						weekday: o,
						...Mt(t)
					}
				}

				function Ti(t) {
					const {
						weekYear: e,
						weekNumber: i,
						weekday: n
					} = t, s = fi(e, 1, 4), o = At(e);
					let r, a = 7 * i + n - s - 3;
					a < 1 ? (r = e - 1, a += At(r)) : a > o ? (r = e + 1, a -= At(e)) : r = e;
					const {
						month: l,
						day: h
					} = yi(r, a);
					return {
						year: r,
						month: l,
						day: h,
						...Mt(t)
					}
				}

				function Ei(t) {
					const {
						year: e,
						month: i,
						day: n
					} = t;
					return {
						year: e,
						ordinal: Si(e, i, n),
						...Mt(t)
					}
				}

				function bi(t) {
					const {
						year: e,
						ordinal: i
					} = t, {
						month: n,
						day: s
					} = yi(e, i);
					return {
						year: e,
						month: n,
						day: s,
						...Mt(t)
					}
				}

				function Ai(t) {
					const e = pt(t.year),
						i = ft(t.month, 1, 12),
						n = ft(t.day, 1, Pt(t.year, t.month));
					return e ? i ? !n && gi("day", t.day) : gi("month", t.month) : gi("year", t.year)
				}

				function Pi(t) {
					const {
						hour: e,
						minute: i,
						second: n,
						millisecond: s
					} = t, o = ft(e, 0, 23) || 24 === e && 0 === i && 0 === n && 0 === s, r = ft(i, 0, 59), a = ft(n, 0, 59), l = ft(s, 0, 999);
					return o ? r ? a ? !l && gi("millisecond", s) : gi("second", n) : gi("minute", i) : gi("hour", e)
				}
				const Ii = "Invalid DateTime",
					wi = 864e13;

				function Li(t) {
					return new $t("unsupported zone", `the zone "${t.name}" is not supported`)
				}

				function Ci(t) {
					return null === t.weekData && (t.weekData = vi(t.c)), t.weekData
				}

				function xi(t, e) {
					const i = {
						ts: t.ts,
						zone: t.zone,
						c: t.c,
						o: t.o,
						loc: t.loc,
						invalid: t.invalid
					};
					return new qi({
						...i,
						...e,
						old: i
					})
				}

				function Bi(t, e, i) {
					let n = t - 60 * e * 1e3;
					const s = i.offset(n);
					if (e === s) return [n, e];
					n -= 60 * (s - e) * 1e3;
					const o = i.offset(n);
					return s === o ? [n, s] : [t - 60 * Math.min(s, o) * 1e3, Math.max(s, o)]
				}

				function Oi(t, e) {
					const i = new Date(t += 60 * e * 1e3);
					return {
						year: i.getUTCFullYear(),
						month: i.getUTCMonth() + 1,
						day: i.getUTCDate(),
						hour: i.getUTCHours(),
						minute: i.getUTCMinutes(),
						second: i.getUTCSeconds(),
						millisecond: i.getUTCMilliseconds()
					}
				}

				function Ni(t, e, i) {
					return Bi(It(t), e, i)
				}

				function Mi(t, e) {
					const i = t.o,
						n = t.c.year + Math.trunc(e.years),
						s = t.c.month + Math.trunc(e.months) + 3 * Math.trunc(e.quarters),
						o = {
							...t.c,
							year: n,
							month: s,
							day: Math.min(t.c.day, Pt(n, s)) + Math.trunc(e.days) + 7 * Math.trunc(e.weeks)
						},
						r = ze.fromObject({
							years: e.years - Math.trunc(e.years),
							quarters: e.quarters - Math.trunc(e.quarters),
							months: e.months - Math.trunc(e.months),
							weeks: e.weeks - Math.trunc(e.weeks),
							days: e.days - Math.trunc(e.days),
							hours: e.hours,
							minutes: e.minutes,
							seconds: e.seconds,
							milliseconds: e.milliseconds
						}).as("milliseconds"),
						a = It(o);
					let [l, h] = Bi(a, i, t.zone);
					return 0 !== r && (l += r, h = t.zone.offset(l)), {
						ts: l,
						o: h
					}
				}

				function Ri(t, e, i, n, s, o) {
					const {
						setZone: r,
						zone: a
					} = i;
					if (t && 0 !== Object.keys(t).length || e) {
						const n = e || a,
							s = qi.fromObject(t, {
								...i,
								zone: n,
								specificOffset: o
							});
						return r ? s : s.setZone(a)
					}
					return qi.invalid(new $t("unparsable", `the input "${s}" can't be parsed as ${n}`))
				}

				function Di(t, e, i = !0) {
					return t.isValid ? Zt.create(Q.create("en-US"), {
						allowZ: i,
						forceSimple: !0
					}).formatDateTimeFromString(t, e) : null
				}

				function ki(t, e) {
					const i = t.c.year > 9999 || t.c.year < 0;
					let n = "";
					return i && t.c.year >= 0 && (n += "+"), n += St(t.c.year, i ? 6 : 4), e ? (n += "-", n += St(t.c.month), n += "-", n += St(t.c.day)) : (n += St(t.c.month), n += St(t.c.day)), n
				}

				function Fi(t, e, i, n, s, o) {
					let r = St(t.c.hour);
					return e ? (r += ":", r += St(t.c.minute), 0 === t.c.second && i || (r += ":")) : r += St(t.c.minute), 0 === t.c.second && i || (r += St(t.c.second), 0 === t.c.millisecond && n || (r += ".", r += St(t.c.millisecond, 3))), s && (t.isOffsetFixed && 0 === t.offset && !o ? r += "Z" : t.o < 0 ? (r += "-", r += St(Math.trunc(-t.o / 60)), r += ":", r += St(Math.trunc(-t.o % 60))) : (r += "+", r += St(Math.trunc(t.o / 60)), r += ":", r += St(Math.trunc(t.o % 60)))), o && (r += "[" + t.zone.ianaName + "]"), r
				}
				const Gi = {
						month: 1,
						day: 1,
						hour: 0,
						minute: 0,
						second: 0,
						millisecond: 0
					},
					Ui = {
						weekNumber: 1,
						weekday: 1,
						hour: 0,
						minute: 0,
						second: 0,
						millisecond: 0
					},
					Wi = {
						ordinal: 1,
						hour: 0,
						minute: 0,
						second: 0,
						millisecond: 0
					},
					Hi = ["year", "month", "day", "hour", "minute", "second", "millisecond"],
					Vi = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"],
					Xi = ["year", "ordinal", "hour", "minute", "second", "millisecond"];

				function Yi(t) {
					const e = {
						year: "year",
						years: "year",
						month: "month",
						months: "month",
						day: "day",
						days: "day",
						hour: "hour",
						hours: "hour",
						minute: "minute",
						minutes: "minute",
						quarter: "quarter",
						quarters: "quarter",
						second: "second",
						seconds: "second",
						millisecond: "millisecond",
						milliseconds: "millisecond",
						weekday: "weekday",
						weekdays: "weekday",
						weeknumber: "weekNumber",
						weeksnumber: "weekNumber",
						weeknumbers: "weekNumber",
						weekyear: "weekYear",
						weekyears: "weekYear",
						ordinal: "ordinal"
					} [t.toLowerCase()];
					if (!e) throw new a(t);
					return e
				}

				function zi(t, e) {
					const i = it(e.zone, ut.defaultZone),
						n = Q.fromObject(e),
						s = ut.now();
					let o, r;
					if (ct(t.year)) o = s;
					else {
						for (const e of Hi) ct(t[e]) && (t[e] = Gi[e]);
						const e = Ai(t) || Pi(t);
						if (e) return qi.invalid(e);
						const n = i.offset(s);
						[o, r] = Ni(t, n, i)
					}
					return new qi({
						ts: o,
						zone: i,
						loc: n,
						o: r
					})
				}

				function ji(t, e, i) {
					const n = !!ct(i.round) || i.round,
						s = (t, s) => (t = Et(t, n || i.calendary ? 0 : 2, !0), e.loc.clone(i).relFormatter(i).format(t, s)),
						o = n => i.calendary ? e.hasSame(t, n) ? 0 : e.startOf(n).diff(t.startOf(n), n).get(n) : e.diff(t, n).get(n);
					if (i.unit) return s(o(i.unit), i.unit);
					for (const t of i.units) {
						const e = o(t);
						if (Math.abs(e) >= 1) return s(e, t)
					}
					return s(t > e ? -0 : 0, i.units[i.units.length - 1])
				}

				function Ki(t) {
					let e, i = {};
					return t.length > 0 && "object" == typeof t[t.length - 1] ? (i = t[t.length - 1], e = Array.from(t).slice(0, t.length - 1)) : e = Array.from(t), [i, e]
				}
				class qi {
					constructor(t) {
						const e = t.zone || ut.defaultZone;
						let i = t.invalid || (Number.isNaN(t.ts) ? new $t("invalid input") : null) || (e.isValid ? null : Li(e));
						this.ts = ct(t.ts) ? ut.now() : t.ts;
						let n = null,
							s = null;
						if (!i)
							if (t.old && t.old.ts === this.ts && t.old.zone.equals(e))[n, s] = [t.old.c, t.old.o];
							else {
								const t = e.offset(this.ts);
								n = Oi(this.ts, t), i = Number.isNaN(n.year) ? new $t("invalid input") : null, n = i ? null : n, s = i ? null : t
							} this._zone = e, this.loc = t.loc || Q.create(), this.invalid = i, this.weekData = null, this.c = n, this.o = s, this.isLuxonDateTime = !0
					}
					static now() {
						return new qi({})
					}
					static local() {
						const [t, e] = Ki(arguments), [i, n, s, o, r, a, l] = e;
						return zi({
							year: i,
							month: n,
							day: s,
							hour: o,
							minute: r,
							second: a,
							millisecond: l
						}, t)
					}
					static utc() {
						const [t, e] = Ki(arguments), [i, n, s, o, r, a, l] = e;
						return t.zone = tt.utcInstance, zi({
							year: i,
							month: n,
							day: s,
							hour: o,
							minute: r,
							second: a,
							millisecond: l
						}, t)
					}
					static fromJSDate(t, e = {}) {
						const i = (n = t, "[object Date]" === Object.prototype.toString.call(n) ? t.valueOf() : NaN);
						var n;
						if (Number.isNaN(i)) return qi.invalid("invalid input");
						const s = it(e.zone, ut.defaultZone);
						return s.isValid ? new qi({
							ts: i,
							zone: s,
							loc: Q.fromObject(e)
						}) : qi.invalid(Li(s))
					}
					static fromMillis(t, e = {}) {
						if (dt(t)) return t < -wi || t > wi ? qi.invalid("Timestamp out of range") : new qi({
							ts: t,
							zone: it(e.zone, ut.defaultZone),
							loc: Q.fromObject(e)
						});
						throw new l(`fromMillis requires a numerical input, but received a ${typeof t} with value ${t}`)
					}
					static fromSeconds(t, e = {}) {
						if (dt(t)) return new qi({
							ts: 1e3 * t,
							zone: it(e.zone, ut.defaultZone),
							loc: Q.fromObject(e)
						});
						throw new l("fromSeconds requires a numerical input")
					}
					static fromObject(t, e = {}) {
						t = t || {};
						const i = it(e.zone, ut.defaultZone);
						if (!i.isValid) return qi.invalid(Li(i));
						const n = ut.now(),
							s = ct(e.specificOffset) ? i.offset(n) : e.specificOffset,
							o = Ot(t, Yi),
							a = !ct(o.ordinal),
							l = !ct(o.year),
							h = !ct(o.month) || !ct(o.day),
							u = l || h,
							c = o.weekYear || o.weekNumber,
							d = Q.fromObject(e);
						if ((u || a) && c) throw new r("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
						if (h && a) throw new r("Can't mix ordinal dates with month/day");
						const p = c || o.weekday && !u;
						let _, m, g = Oi(n, s);
						p ? (_ = Vi, m = Ui, g = vi(g)) : a ? (_ = Xi, m = Wi, g = Ei(g)) : (_ = Hi, m = Gi);
						let f = !1;
						for (const t of _) ct(o[t]) ? o[t] = f ? m[t] : g[t] : f = !0;
						const S = p ? function(t) {
								const e = pt(t.weekYear),
									i = ft(t.weekNumber, 1, wt(t.weekYear)),
									n = ft(t.weekday, 1, 7);
								return e ? i ? !n && gi("weekday", t.weekday) : gi("week", t.week) : gi("weekYear", t.weekYear)
							}(o) : a ? function(t) {
								const e = pt(t.year),
									i = ft(t.ordinal, 1, At(t.year));
								return e ? !i && gi("ordinal", t.ordinal) : gi("year", t.year)
							}(o) : Ai(o),
							y = S || Pi(o);
						if (y) return qi.invalid(y);
						const v = p ? Ti(o) : a ? bi(o) : o,
							[T, E] = Ni(v, s, i),
							b = new qi({
								ts: T,
								zone: i,
								o: E,
								loc: d
							});
						return o.weekday && u && t.weekday !== b.weekday ? qi.invalid("mismatched weekday", `you can't specify both a weekday of ${o.weekday} and a date of ${b.toISO()}`) : b
					}
					static fromISO(t, e = {}) {
						const [i, n] = function(t) {
							return ee(t, [we, Be], [Le, Oe], [Ce, Ne], [xe, Me])
						}(t);
						return Ri(i, n, e, "ISO 8601", t)
					}
					static fromRFC2822(t, e = {}) {
						const [i, n] = function(t) {
							return ee(function(t) {
								return t.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim()
							}(t), [ve, Te])
						}(t);
						return Ri(i, n, e, "RFC 2822", t)
					}
					static fromHTTP(t, e = {}) {
						const [i, n] = function(t) {
							return ee(t, [Ee, Pe], [be, Pe], [Ae, Ie])
						}(t);
						return Ri(i, n, e, "HTTP", e)
					}
					static fromFormat(t, e, i = {}) {
						if (ct(t) || ct(e)) throw new l("fromFormat requires an input string and a format");
						const {
							locale: n = null,
							numberingSystem: s = null
						} = i, o = Q.fromOpts({
							locale: n,
							numberingSystem: s,
							defaultToEN: !0
						}), [r, a, h, u] = function(t, e, i) {
							const {
								result: n,
								zone: s,
								specificOffset: o,
								invalidReason: r
							} = di(t, e, i);
							return [n, s, o, r]
						}(o, t, e);
						return u ? qi.invalid(u) : Ri(r, a, i, `format ${e}`, t, h)
					}
					static fromString(t, e, i = {}) {
						return qi.fromFormat(t, e, i)
					}
					static fromSQL(t, e = {}) {
						const [i, n] = function(t) {
							return ee(t, [De, Be], [ke, Fe])
						}(t);
						return Ri(i, n, e, "SQL", t)
					}
					static invalid(t, e = null) {
						if (!t) throw new l("need to specify a reason the DateTime is invalid");
						const i = t instanceof $t ? t : new $t(t, e);
						if (ut.throwOnInvalid) throw new n(i);
						return new qi({
							invalid: i
						})
					}
					static isDateTime(t) {
						return t && t.isLuxonDateTime || !1
					}
					static parseFormatForOpts(t, e = {}) {
						const i = pi(t, Q.fromObject(e));
						return i ? i.map((t => t ? t.val : null)).join("") : null
					}
					static expandFormat(t, e = {}) {
						return ci(Zt.parseFormat(t), Q.fromObject(e)).map((t => t.val)).join("")
					}
					get(t) {
						return this[t]
					}
					get isValid() {
						return null === this.invalid
					}
					get invalidReason() {
						return this.invalid ? this.invalid.reason : null
					}
					get invalidExplanation() {
						return this.invalid ? this.invalid.explanation : null
					}
					get locale() {
						return this.isValid ? this.loc.locale : null
					}
					get numberingSystem() {
						return this.isValid ? this.loc.numberingSystem : null
					}
					get outputCalendar() {
						return this.isValid ? this.loc.outputCalendar : null
					}
					get zone() {
						return this._zone
					}
					get zoneName() {
						return this.isValid ? this.zone.name : null
					}
					get year() {
						return this.isValid ? this.c.year : NaN
					}
					get quarter() {
						return this.isValid ? Math.ceil(this.c.month / 3) : NaN
					}
					get month() {
						return this.isValid ? this.c.month : NaN
					}
					get day() {
						return this.isValid ? this.c.day : NaN
					}
					get hour() {
						return this.isValid ? this.c.hour : NaN
					}
					get minute() {
						return this.isValid ? this.c.minute : NaN
					}
					get second() {
						return this.isValid ? this.c.second : NaN
					}
					get millisecond() {
						return this.isValid ? this.c.millisecond : NaN
					}
					get weekYear() {
						return this.isValid ? Ci(this).weekYear : NaN
					}
					get weekNumber() {
						return this.isValid ? Ci(this).weekNumber : NaN
					}
					get weekday() {
						return this.isValid ? Ci(this).weekday : NaN
					}
					get ordinal() {
						return this.isValid ? Ei(this.c).ordinal : NaN
					}
					get monthShort() {
						return this.isValid ? qe.months("short", {
							locObj: this.loc
						})[this.month - 1] : null
					}
					get monthLong() {
						return this.isValid ? qe.months("long", {
							locObj: this.loc
						})[this.month - 1] : null
					}
					get weekdayShort() {
						return this.isValid ? qe.weekdays("short", {
							locObj: this.loc
						})[this.weekday - 1] : null
					}
					get weekdayLong() {
						return this.isValid ? qe.weekdays("long", {
							locObj: this.loc
						})[this.weekday - 1] : null
					}
					get offset() {
						return this.isValid ? +this.o : NaN
					}
					get offsetNameShort() {
						return this.isValid ? this.zone.offsetName(this.ts, {
							format: "short",
							locale: this.locale
						}) : null
					}
					get offsetNameLong() {
						return this.isValid ? this.zone.offsetName(this.ts, {
							format: "long",
							locale: this.locale
						}) : null
					}
					get isOffsetFixed() {
						return this.isValid ? this.zone.isUniversal : null
					}
					get isInDST() {
						return !this.isOffsetFixed && (this.offset > this.set({
							month: 1,
							day: 1
						}).offset || this.offset > this.set({
							month: 5
						}).offset)
					}
					get isInLeapYear() {
						return bt(this.year)
					}
					get daysInMonth() {
						return Pt(this.year, this.month)
					}
					get daysInYear() {
						return this.isValid ? At(this.year) : NaN
					}
					get weeksInWeekYear() {
						return this.isValid ? wt(this.weekYear) : NaN
					}
					resolvedLocaleOptions(t = {}) {
						const {
							locale: e,
							numberingSystem: i,
							calendar: n
						} = Zt.create(this.loc.clone(t), t).resolvedOptions(this);
						return {
							locale: e,
							numberingSystem: i,
							outputCalendar: n
						}
					}
					toUTC(t = 0, e = {}) {
						return this.setZone(tt.instance(t), e)
					}
					toLocal() {
						return this.setZone(ut.defaultZone)
					}
					setZone(t, {
						keepLocalTime: e = !1,
						keepCalendarTime: i = !1
					} = {}) {
						if ((t = it(t, ut.defaultZone)).equals(this.zone)) return this;
						if (t.isValid) {
							let n = this.ts;
							if (e || i) {
								const e = t.offset(this.ts),
									i = this.toObject();
								[n] = Ni(i, e, t)
							}
							return xi(this, {
								ts: n,
								zone: t
							})
						}
						return qi.invalid(Li(t))
					}
					reconfigure({
						locale: t,
						numberingSystem: e,
						outputCalendar: i
					} = {}) {
						return xi(this, {
							loc: this.loc.clone({
								locale: t,
								numberingSystem: e,
								outputCalendar: i
							})
						})
					}
					setLocale(t) {
						return this.reconfigure({
							locale: t
						})
					}
					set(t) {
						if (!this.isValid) return this;
						const e = Ot(t, Yi),
							i = !ct(e.weekYear) || !ct(e.weekNumber) || !ct(e.weekday),
							n = !ct(e.ordinal),
							s = !ct(e.year),
							o = !ct(e.month) || !ct(e.day),
							a = s || o,
							l = e.weekYear || e.weekNumber;
						if ((a || n) && l) throw new r("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
						if (o && n) throw new r("Can't mix ordinal dates with month/day");
						let h;
						i ? h = Ti({
							...vi(this.c),
							...e
						}) : ct(e.ordinal) ? (h = {
							...this.toObject(),
							...e
						}, ct(e.day) && (h.day = Math.min(Pt(h.year, h.month), h.day))) : h = bi({
							...Ei(this.c),
							...e
						});
						const [u, c] = Ni(h, this.o, this.zone);
						return xi(this, {
							ts: u,
							o: c
						})
					}
					plus(t) {
						return this.isValid ? xi(this, Mi(this, ze.fromDurationLike(t))) : this
					}
					minus(t) {
						return this.isValid ? xi(this, Mi(this, ze.fromDurationLike(t).negate())) : this
					}
					startOf(t) {
						if (!this.isValid) return this;
						const e = {},
							i = ze.normalizeUnit(t);
						switch (i) {
							case "years":
								e.month = 1;
							case "quarters":
							case "months":
								e.day = 1;
							case "weeks":
							case "days":
								e.hour = 0;
							case "hours":
								e.minute = 0;
							case "minutes":
								e.second = 0;
							case "seconds":
								e.millisecond = 0
						}
						if ("weeks" === i && (e.weekday = 1), "quarters" === i) {
							const t = Math.ceil(this.month / 3);
							e.month = 3 * (t - 1) + 1
						}
						return this.set(e)
					}
					endOf(t) {
						return this.isValid ? this.plus({
							[t]: 1
						}).startOf(t).minus(1) : this
					}
					toFormat(t, e = {}) {
						return this.isValid ? Zt.create(this.loc.redefaultToEN(e)).formatDateTimeFromString(this, t) : Ii
					}
					toLocaleString(t = p, e = {}) {
						return this.isValid ? Zt.create(this.loc.clone(e), t).formatDateTime(this) : Ii
					}
					toLocaleParts(t = {}) {
						return this.isValid ? Zt.create(this.loc.clone(t), t).formatDateTimeParts(this) : []
					}
					toISO({
						format: t = "extended",
						suppressSeconds: e = !1,
						suppressMilliseconds: i = !1,
						includeOffset: n = !0,
						extendedZone: s = !1
					} = {}) {
						if (!this.isValid) return null;
						const o = "extended" === t;
						let r = ki(this, o);
						return r += "T", r += Fi(this, o, e, i, n, s), r
					}
					toISODate({
						format: t = "extended"
					} = {}) {
						return this.isValid ? ki(this, "extended" === t) : null
					}
					toISOWeekDate() {
						return Di(this, "kkkk-'W'WW-c")
					}
					toISOTime({
						suppressMilliseconds: t = !1,
						suppressSeconds: e = !1,
						includeOffset: i = !0,
						includePrefix: n = !1,
						extendedZone: s = !1,
						format: o = "extended"
					} = {}) {
						return this.isValid ? (n ? "T" : "") + Fi(this, "extended" === o, e, t, i, s) : null
					}
					toRFC2822() {
						return Di(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1)
					}
					toHTTP() {
						return Di(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'")
					}
					toSQLDate() {
						return this.isValid ? ki(this, !0) : null
					}
					toSQLTime({
						includeOffset: t = !0,
						includeZone: e = !1,
						includeOffsetSpace: i = !0
					} = {}) {
						let n = "HH:mm:ss.SSS";
						return (e || t) && (i && (n += " "), e ? n += "z" : t && (n += "ZZ")), Di(this, n, !0)
					}
					toSQL(t = {}) {
						return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(t)}` : null
					}
					toString() {
						return this.isValid ? this.toISO() : Ii
					}
					valueOf() {
						return this.toMillis()
					}
					toMillis() {
						return this.isValid ? this.ts : NaN
					}
					toSeconds() {
						return this.isValid ? this.ts / 1e3 : NaN
					}
					toUnixInteger() {
						return this.isValid ? Math.floor(this.ts / 1e3) : NaN
					}
					toJSON() {
						return this.toISO()
					}
					toBSON() {
						return this.toJSDate()
					}
					toObject(t = {}) {
						if (!this.isValid) return {};
						const e = {
							...this.c
						};
						return t.includeConfig && (e.outputCalendar = this.outputCalendar, e.numberingSystem = this.loc.numberingSystem, e.locale = this.loc.locale), e
					}
					toJSDate() {
						return new Date(this.isValid ? this.ts : NaN)
					}
					diff(t, e = "milliseconds", i = {}) {
						if (!this.isValid || !t.isValid) return ze.invalid("created by diffing an invalid DateTime");
						const n = {
								locale: this.locale,
								numberingSystem: this.numberingSystem,
								...i
							},
							s = (a = e, Array.isArray(a) ? a : [a]).map(ze.normalizeUnit),
							o = t.valueOf() > this.valueOf(),
							r = function(t, e, i, n) {
								let [s, o, r, a] = function(t, e, i) {
									const n = [
											["years", (t, e) => e.year - t.year],
											["quarters", (t, e) => e.quarter - t.quarter + 4 * (e.year - t.year)],
											["months", (t, e) => e.month - t.month + 12 * (e.year - t.year)],
											["weeks", (t, e) => {
												const i = Ze(t, e);
												return (i - i % 7) / 7
											}],
											["days", Ze]
										],
										s = {},
										o = t;
									let r, a;
									for (const [l, h] of n) i.indexOf(l) >= 0 && (r = l, s[l] = h(t, e), a = o.plus(s), a > e ? (s[l]--, t = o.plus(s)) : t = a);
									return [t, s, a, r]
								}(t, e, i);
								const l = e - s,
									h = i.filter((t => ["hours", "minutes", "seconds", "milliseconds"].indexOf(t) >= 0));
								0 === h.length && (r < e && (r = s.plus({
									[a]: 1
								})), r !== s && (o[a] = (o[a] || 0) + l / (r - s)));
								const u = ze.fromObject(o, n);
								return h.length > 0 ? ze.fromMillis(l, n).shiftTo(...h).plus(u) : u
							}(o ? this : t, o ? t : this, s, n);
						var a;
						return o ? r.negate() : r
					}
					diffNow(t = "milliseconds", e = {}) {
						return this.diff(qi.now(), t, e)
					}
					until(t) {
						return this.isValid ? Ke.fromDateTimes(this, t) : this
					}
					hasSame(t, e) {
						if (!this.isValid) return !1;
						const i = t.valueOf(),
							n = this.setZone(t.zone, {
								keepLocalTime: !0
							});
						return n.startOf(e) <= i && i <= n.endOf(e)
					}
					equals(t) {
						return this.isValid && t.isValid && this.valueOf() === t.valueOf() && this.zone.equals(t.zone) && this.loc.equals(t.loc)
					}
					toRelative(t = {}) {
						if (!this.isValid) return null;
						const e = t.base || qi.fromObject({}, {
								zone: this.zone
							}),
							i = t.padding ? this < e ? -t.padding : t.padding : 0;
						let n = ["years", "months", "days", "hours", "minutes", "seconds"],
							s = t.unit;
						return Array.isArray(t.unit) && (n = t.unit, s = void 0), ji(e, this.plus(i), {
							...t,
							numeric: "always",
							units: n,
							unit: s
						})
					}
					toRelativeCalendar(t = {}) {
						return this.isValid ? ji(t.base || qi.fromObject({}, {
							zone: this.zone
						}), this, {
							...t,
							numeric: "auto",
							units: ["years", "months", "days"],
							calendary: !0
						}) : null
					}
					static min(...t) {
						if (!t.every(qi.isDateTime)) throw new l("min requires all arguments be DateTimes");
						return mt(t, (t => t.valueOf()), Math.min)
					}
					static max(...t) {
						if (!t.every(qi.isDateTime)) throw new l("max requires all arguments be DateTimes");
						return mt(t, (t => t.valueOf()), Math.max)
					}
					static fromFormatExplain(t, e, i = {}) {
						const {
							locale: n = null,
							numberingSystem: s = null
						} = i;
						return di(Q.fromOpts({
							locale: n,
							numberingSystem: s,
							defaultToEN: !0
						}), t, e)
					}
					static fromStringExplain(t, e, i = {}) {
						return qi.fromFormatExplain(t, e, i)
					}
					static get DATE_SHORT() {
						return p
					}
					static get DATE_MED() {
						return _
					}
					static get DATE_MED_WITH_WEEKDAY() {
						return m
					}
					static get DATE_FULL() {
						return g
					}
					static get DATE_HUGE() {
						return f
					}
					static get TIME_SIMPLE() {
						return S
					}
					static get TIME_WITH_SECONDS() {
						return y
					}
					static get TIME_WITH_SHORT_OFFSET() {
						return v
					}
					static get TIME_WITH_LONG_OFFSET() {
						return T
					}
					static get TIME_24_SIMPLE() {
						return E
					}
					static get TIME_24_WITH_SECONDS() {
						return b
					}
					static get TIME_24_WITH_SHORT_OFFSET() {
						return A
					}
					static get TIME_24_WITH_LONG_OFFSET() {
						return P
					}
					static get DATETIME_SHORT() {
						return I
					}
					static get DATETIME_SHORT_WITH_SECONDS() {
						return w
					}
					static get DATETIME_MED() {
						return L
					}
					static get DATETIME_MED_WITH_SECONDS() {
						return C
					}
					static get DATETIME_MED_WITH_WEEKDAY() {
						return x
					}
					static get DATETIME_FULL() {
						return B
					}
					static get DATETIME_FULL_WITH_SECONDS() {
						return O
					}
					static get DATETIME_HUGE() {
						return N
					}
					static get DATETIME_HUGE_WITH_SECONDS() {
						return M
					}
				}

				function Zi(t) {
					if (qi.isDateTime(t)) return t;
					if (t && t.valueOf && dt(t.valueOf())) return qi.fromJSDate(t);
					if (t && "object" == typeof t) return qi.fromObject(t);
					throw new l(`Unknown datetime argument: ${t}, of type ${typeof t}`)
				}
				e.DateTime = qi, e.Duration = ze, e.FixedOffsetZone = tt, e.IANAZone = W, e.Info = qe, e.Interval = Ke, e.InvalidZone = et, e.Settings = ut, e.SystemZone = k, e.VERSION = "3.3.0", e.Zone = R
			},
			6755: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				});
				var i = function() {
					function t(t, e) {
						for (var i = 0; i < e.length; i++) {
							var n = e[i];
							n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
						}
					}
					return function(e, i, n) {
						return i && t(e.prototype, i), n && t(e, n), e
					}
				}();

				function n(t, e) {
					if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
				}
				var s = function() {
					function t(e, i, s) {
						void 0 === i && (i = !1), n(this, t), this._fn = e, this._once = i, this._thisArg = s, this._next = this._prev = this._owner = null
					}
					return i(t, [{
						key: "detach",
						value: function() {
							return null !== this._owner && (this._owner.detach(this), !0)
						}
					}]), t
				}();

				function o(t, e) {
					return t._head ? (t._tail._next = e, e._prev = t._tail, t._tail = e) : (t._head = e, t._tail = e), e._owner = t, e
				}
				var r = function() {
					function t() {
						n(this, t), this._head = this._tail = void 0
					}
					return i(t, [{
						key: "handlers",
						value: function() {
							var t = !(arguments.length <= 0 || void 0 === arguments[0]) && arguments[0],
								e = this._head;
							if (t) return !!e;
							for (var i = []; e;) i.push(e), e = e._next;
							return i
						}
					}, {
						key: "has",
						value: function(t) {
							if (!(t instanceof s)) throw new Error("MiniSignal#has(): First arg must be a MiniSignalBinding object.");
							return t._owner === this
						}
					}, {
						key: "dispatch",
						value: function() {
							var t = this._head;
							if (!t) return !1;
							for (; t;) t._once && this.detach(t), t._fn.apply(t._thisArg, arguments), t = t._next;
							return !0
						}
					}, {
						key: "add",
						value: function(t) {
							var e = arguments.length <= 1 || void 0 === arguments[1] ? null : arguments[1];
							if ("function" != typeof t) throw new Error("MiniSignal#add(): First arg must be a Function.");
							return o(this, new s(t, !1, e))
						}
					}, {
						key: "once",
						value: function(t) {
							var e = arguments.length <= 1 || void 0 === arguments[1] ? null : arguments[1];
							if ("function" != typeof t) throw new Error("MiniSignal#once(): First arg must be a Function.");
							return o(this, new s(t, !0, e))
						}
					}, {
						key: "detach",
						value: function(t) {
							if (!(t instanceof s)) throw new Error("MiniSignal#detach(): First arg must be a MiniSignalBinding object.");
							return t._owner !== this || (t._prev && (t._prev._next = t._next), t._next && (t._next._prev = t._prev), t === this._head ? (this._head = t._next, null === t._next && (this._tail = null)) : t === this._tail && (this._tail = t._prev, this._tail._next = null), t._owner = null), this
						}
					}, {
						key: "detachAll",
						value: function() {
							var t = this._head;
							if (!t) return this;
							for (this._head = this._tail = null; t;) t._owner = null, t = t._next;
							return this
						}
					}]), t
				}();
				r.MiniSignalBinding = s, e.default = r, t.exports = e.default
			},
			17862: (t, e, i) => {
				var n = i(34714);
				t.exports = new n.Template({
					code: function(t, e, i) {
						var n = this;
						return n.b(i = i || ""), n.b('<div class="nolimit container loading">'), n.b("\n" + i), n.b('    <div class="fun" style="display: none;">'), n.s(n.f("tr", t, e, 1), t, e, 0, 91, 106, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("PLAYING FOR FUN")
						})), t.pop()), n.b("</div>"), n.b("\n" + i), n.b('    <div class="replay" style="display: none;">R</div>'), n.b("\n" + i), n.b('    <div class="overlay"></div>'), n.b("\n" + i), n.b('    <div class="hidden" style="position:absolute;"></div>'), n.b("\n" + i), n.b('    <div class="game"></div>'), n.b("\n" + i), n.b('    <div id="game-name-version">'), n.b(n.v(n.f("game", t, e, 0))), n.b("</div>"), n.b("\n" + i), n.b('    <div id="net-position"></div>'), n.b("\n" + i), n.b("</div>"), n.b("\n"), n.fl()
					},
					partials: {},
					subs: {}
				}, '<div class="nolimit container loading">\n    <div class="fun" style="display: none;">{{#tr}}PLAYING FOR FUN{{/tr}}</div>\n    <div class="replay" style="display: none;">R</div>\n    <div class="overlay"></div>\n    <div class="hidden" style="position:absolute;"></div>\n    <div class="game"></div>\n    <div id="game-name-version">{{game}}</div>\n    <div id="net-position"></div>\n</div>\n', n)
			},
			69950: (t, e, i) => {
				var n = i(34714);
				t.exports = new n.Template({
					code: function(t, e, i) {
						var n = this;
						return n.b(i = i || ""), n.b("<h1>"), n.s(n.f("tr", t, e, 1), t, e, 0, 11, 38, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Oops, something went wrong!")
						})), t.pop()), n.b("</h1>"), n.b("\n" + i), n.b("<p>"), n.s(n.f("tr", t, e, 1), t, e, 0, 61, 144, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("The location associated with your IP is not permitted to access the requested game.")
						})), t.pop()), n.b("</p>"), n.b("\n"), n.fl()
					},
					partials: {},
					subs: {}
				}, "<h1>{{#tr}}Oops, something went wrong!{{/tr}}</h1>\n<p>{{#tr}}The location associated with your IP is not permitted to access the requested game.{{/tr}}</p>\n", n)
			},
			157: (t, e, i) => {
				var n = i(34714);
				t.exports = new n.Template({
					code: function(t, e, i) {
						var n = this;
						return n.b(i = i || ""), n.s(n.f("title", t, e, 1), t, e, 0, 10, 28, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("<h1>"), i.b(i.v(i.f("title", t, e, 0))), i.b("</h1>")
						})), t.pop()), n.b("\n" + i), n.s(n.f("title", t, e, 1), t, e, 1, 0, 0, "") || (n.b("<h1>"), n.s(n.f("tr", t, e, 1), t, e, 0, 60, 87, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Oops, something went wrong!")
						})), t.pop()), n.b("</h1>")), n.b("\n" + i), n.s(n.f("message", t, e, 1), t, e, 0, 122, 140, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("<p>"), i.b(i.v(i.f("message", t, e, 0))), i.b("</p>")
						})), t.pop()), n.b("\n" + i), n.s(n.f("mobile", t, e, 1), t, e, 0, 164, 324, "{{ }}") && (n.rs(t, e, (function(t, e, n) {
							n.b("<div>"), n.b("\n" + i), n.b('    <button type="button" class="exit">'), n.s(n.f("tr", t, e, 1), t, e, 0, 217, 219, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
								i.b("OK")
							})), t.pop()), n.b("</button>"), n.b("\n" + i), n.b('    <button type="button" class="support">'), n.s(n.f("tr", t, e, 1), t, e, 0, 285, 300, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
								i.b("Contact support")
							})), t.pop()), n.b("</button>"), n.b("\n" + i), n.b("</div>"), n.b("\n" + i)
						})), t.pop()), n.s(n.f("desktop", t, e, 1), t, e, 0, 348, 430, "{{ }}") && (n.rs(t, e, (function(t, e, n) {
							n.b('    <button type="button" class="support">'), n.s(n.f("tr", t, e, 1), t, e, 0, 398, 413, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
								i.b("Contact support")
							})), t.pop()), n.b("</button>"), n.b("\n" + i)
						})), t.pop()), n.fl()
					},
					partials: {},
					subs: {}
				}, '{{#title}}<h1>{{title}}</h1>{{/title}}\n{{^title}}<h1>{{#tr}}Oops, something went wrong!{{/tr}}</h1>{{/title}}\n{{#message}}<p>{{message}}</p>{{/message}}\n{{#mobile}}\n<div>\n    <button type="button" class="exit">{{#tr}}OK{{/tr}}</button>\n    <button type="button" class="support">{{#tr}}Contact support{{/tr}}</button>\n</div>\n{{/mobile}}\n{{#desktop}}\n    <button type="button" class="support">{{#tr}}Contact support{{/tr}}</button>\n{{/desktop}}\n', n)
			},
			16379: (t, e, i) => {
				var n = i(34714);
				t.exports = new n.Template({
					code: function(t, e, i) {
						var n = this;
						return n.b(i = i || ""), n.b('<p style="color: #9afb00">'), n.b(n.v(n.f("flash", t, e, 0))), n.b("</p>"), n.b("\n"), n.fl()
					},
					partials: {},
					subs: {}
				}, '<p style="color: #9afb00">{{flash}}</p>\n', n)
			},
			80820: (t, e, i) => {
				var n = i(34714);
				t.exports = new n.Template({
					code: function(t, e, i) {
						var n = this;
						return n.b(i = i || ""), n.b("<p>"), n.b(n.v(n.f("message", t, e, 0))), n.b("</p>"), n.b("\n" + i), n.s(n.f("mobile", t, e, 1), t, e, 0, 30, 121, "{{ }}") && (n.rs(t, e, (function(t, e, n) {
							n.b("    <div>"), n.b("\n" + i), n.b('        <button type="button" class="exit">'), n.s(n.f("tr", t, e, 1), t, e, 0, 91, 93, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
								i.b("OK")
							})), t.pop()), n.b("</button>"), n.b("\n" + i), n.b("    </div>"), n.b("\n" + i)
						})), t.pop()), n.s(n.f("desktop", t, e, 1), t, e, 0, 145, 252, "{{ }}") && (n.rs(t, e, (function(t, e, n) {
							n.b("    <div>"), n.b("\n" + i), n.b('        <button type="button" class="support">'), n.s(n.f("tr", t, e, 1), t, e, 0, 209, 224, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
								i.b("Contact support")
							})), t.pop()), n.b("</button>"), n.b("\n" + i), n.b("    </div>"), n.b("\n" + i)
						})), t.pop()), n.fl()
					},
					partials: {},
					subs: {}
				}, '<p>{{message}}</p>\n{{#mobile}}\n    <div>\n        <button type="button" class="exit">{{#tr}}OK{{/tr}}</button>\n    </div>\n{{/mobile}}\n{{#desktop}}\n    <div>\n        <button type="button" class="support">{{#tr}}Contact support{{/tr}}</button>\n    </div>\n{{/desktop}}\n', n)
			},
			82331: (t, e, i) => {
				var n = i(34714);
				t.exports = new n.Template({
					code: function(t, e, i) {
						var n = this;
						return n.b(i = i || ""), n.b("<h1>"), n.s(n.f("tr", t, e, 1), t, e, 0, 11, 38, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Oops, something went wrong!")
						})), t.pop()), n.b("</h1>"), n.b("\n" + i), n.s(n.f("message", t, e, 1), t, e, 0, 63, 81, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("<p>"), i.b(i.v(i.f("message", t, e, 0))), i.b("</p>")
						})), t.pop()), n.b("\n" + i), n.b("<p>"), n.s(n.f("tr", t, e, 1), t, e, 0, 104, 194, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Don't worry, you haven't lost any money! If the problem continues, please contact support.")
						})), t.pop()), n.b("</p>"), n.b("\n" + i), n.s(n.f("mobile", t, e, 1), t, e, 0, 217, 377, "{{ }}") && (n.rs(t, e, (function(t, e, n) {
							n.b("<div>"), n.b("\n" + i), n.b('    <button type="button" class="exit">'), n.s(n.f("tr", t, e, 1), t, e, 0, 270, 272, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
								i.b("OK")
							})), t.pop()), n.b("</button>"), n.b("\n" + i), n.b('    <button type="button" class="support">'), n.s(n.f("tr", t, e, 1), t, e, 0, 338, 353, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
								i.b("Contact support")
							})), t.pop()), n.b("</button>"), n.b("\n" + i), n.b("</div>"), n.b("\n" + i)
						})), t.pop()), n.s(n.f("desktop", t, e, 1), t, e, 0, 401, 483, "{{ }}") && (n.rs(t, e, (function(t, e, n) {
							n.b('    <button type="button" class="support">'), n.s(n.f("tr", t, e, 1), t, e, 0, 451, 466, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
								i.b("Contact support")
							})), t.pop()), n.b("</button>"), n.b("\n" + i)
						})), t.pop()), n.fl()
					},
					partials: {},
					subs: {}
				}, '<h1>{{#tr}}Oops, something went wrong!{{/tr}}</h1>\n{{#message}}<p>{{message}}</p>{{/message}}\n<p>{{#tr}}Don\'t worry, you haven\'t lost any money! If the problem continues, please contact support.{{/tr}}</p>\n{{#mobile}}\n<div>\n    <button type="button" class="exit">{{#tr}}OK{{/tr}}</button>\n    <button type="button" class="support">{{#tr}}Contact support{{/tr}}</button>\n</div>\n{{/mobile}}\n{{#desktop}}\n    <button type="button" class="support">{{#tr}}Contact support{{/tr}}</button>\n{{/desktop}}\n', n)
			},
			40858: (t, e, i) => {
				var n = i(34714);
				t.exports = new n.Template({
					code: function(t, e, i) {
						var n = this;
						return n.b(i = i || ""), n.s(n.f("title", t, e, 1), t, e, 0, 10, 28, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("<h1>"), i.b(i.v(i.f("title", t, e, 0))), i.b("</h1>")
						})), t.pop()), n.b("\n" + i), n.b("<p>"), n.b(n.v(n.f("message", t, e, 0))), n.b("</p>"), n.b("\n" + i), n.b("<div>"), n.b("\n" + i), n.b('    <button type="button" class="close">'), n.s(n.f("tr", t, e, 1), t, e, 0, 111, 113, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("OK")
						})), t.pop()), n.b("</button>"), n.b("\n" + i), n.b("</div>"), n.b("\n"), n.fl()
					},
					partials: {},
					subs: {}
				}, '{{#title}}<h1>{{title}}</h1>{{/title}}\n<p>{{message}}</p>\n<div>\n    <button type="button" class="close">{{#tr}}OK{{/tr}}</button>\n</div>\n', n)
			},
			90381: (t, e, i) => {
				var n = i(34714);
				t.exports = new n.Template({
					code: function(t, e, i) {
						var n = this;
						return n.b(i = i || ""), n.b("<h1>"), n.s(n.f("tr", t, e, 1), t, e, 0, 11, 29, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Insufficient funds")
						})), t.pop()), n.b("</h1>"), n.b("\n" + i), n.s(n.f("deposit", t, e, 1), t, e, 0, 54, 278, "{{ }}") && (n.rs(t, e, (function(t, e, n) {
							n.b("    <p>"), n.s(n.f("tr", t, e, 1), t, e, 0, 69, 118, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
								i.b("Would you like to open the operator cashier page?")
							})), t.pop()), n.b("</p>"), n.b("\n" + i), n.b('    <div><button type="button" class="deposit close">'), n.s(n.f("tr", t, e, 1), t, e, 0, 190, 193, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
								i.b("YES")
							})), t.pop()), n.b('</button> <button type="button" class="close">'), n.s(n.f("tr", t, e, 1), t, e, 0, 253, 255, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
								i.b("NO")
							})), t.pop()), n.b("</button></div>"), n.b("\n" + i)
						})), t.pop()), n.s(n.f("deposit", t, e, 1), t, e, 1, 0, 0, "") || (n.b("    <p>"), n.s(n.f("tr", t, e, 1), t, e, 0, 318, 407, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Please go through the deposit flow to deposit more money if you wish to continue playing!")
						})), t.pop()), n.b("</p>"), n.b("\n" + i), n.b('    <div><button type="button" class="close">'), n.s(n.f("tr", t, e, 1), t, e, 0, 471, 473, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("OK")
						})), t.pop()), n.b("</button></div>"), n.b("\n" + i)), n.fl()
					},
					partials: {},
					subs: {}
				}, '<h1>{{#tr}}Insufficient funds{{/tr}}</h1>\n{{#deposit}}\n    <p>{{#tr}}Would you like to open the operator cashier page?{{/tr}}</p>\n    <div><button type="button" class="deposit close">{{#tr}}YES{{/tr}}</button> <button type="button" class="close">{{#tr}}NO{{/tr}}</button></div>\n{{/deposit}}\n{{^deposit}}\n    <p>{{#tr}}Please go through the deposit flow to deposit more money if you wish to continue playing!{{/tr}}</p>\n    <div><button type="button" class="close">{{#tr}}OK{{/tr}}</button></div>\n{{/deposit}}\n', n)
			},
			72421: (t, e, i) => {
				var n = i(34714);
				t.exports = new n.Template({
					code: function(t, e, i) {
						var n = this;
						return n.b(i = i || ""), n.b("<h1>"), n.s(n.f("tr", t, e, 1), t, e, 0, 11, 29, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Breaking the bank!")
						})), t.pop()), n.b("</h1>"), n.b("\n" + i), n.b("<p>"), n.s(n.f("tr", t, e, 1), t, e, 0, 52, 127, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Congrats! You're insanely lucky - you just won the maximum possible amount!")
						})), t.pop()), n.b("</p>"), n.b("\n" + i), n.b("<p>"), n.b(n.v(n.f("amount", t, e, 0))), n.b("</p>"), n.b("\n" + i), n.s(n.f("mobile", t, e, 1), t, e, 0, 168, 261, "{{ }}") && (n.rs(t, e, (function(t, e, n) {
							n.b("<div>"), n.b("\n" + i), n.b('    <button type="button" class="exit">'), n.s(n.f("tr", t, e, 1), t, e, 0, 221, 237, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
								i.b("End Game Session")
							})), t.pop()), n.b("</button>"), n.b("\n" + i), n.b("</div>"), n.b("\n" + i)
						})), t.pop()), n.fl()
					},
					partials: {},
					subs: {}
				}, '<h1>{{#tr}}Breaking the bank!{{/tr}}</h1>\n<p>{{#tr}}Congrats! You\'re insanely lucky - you just won the maximum possible amount!{{/tr}}</p>\n<p>{{amount}}</p>\n{{#mobile}}\n<div>\n    <button type="button" class="exit">{{#tr}}End Game Session{{/tr}}</button>\n</div>\n{{/mobile}}\n', n)
			},
			84066: (t, e, i) => {
				var n = i(34714);
				t.exports = new n.Template({
					code: function(t, e, i) {
						var n = this;
						return n.b(i = i || ""), n.s(n.f("title", t, e, 1), t, e, 0, 10, 28, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("<h1>"), i.b(i.v(i.f("title", t, e, 0))), i.b("</h1>")
						})), t.pop()), n.b("\n" + i), n.b("<p>"), n.b(n.v(n.f("text", t, e, 0))), n.b("</p>"), n.b("\n" + i), n.b("<div>"), n.b("\n"), n.b("\n" + i), n.s(n.f("continue", t, e, 1), t, e, 0, 79, 231, "{{ }}") && (n.rs(t, e, (function(t, e, n) {
							n.b('        <button type="button" class="stop">'), n.s(n.f("tr", t, e, 1), t, e, 0, 130, 134, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
								i.b("STOP")
							})), t.pop()), n.b("</button>"), n.b("\n" + i), n.b('        <button type="button" class="close">'), n.s(n.f("tr", t, e, 1), t, e, 0, 202, 210, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
								i.b("CONTINUE")
							})), t.pop()), n.b("</button>"), n.b("\n" + i)
						})), t.pop()), n.s(n.f("continue", t, e, 1), t, e, 1, 0, 0, "") || (n.b('        <button type="button" class="stop">'), n.s(n.f("tr", t, e, 1), t, e, 0, 313, 315, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("OK")
						})), t.pop()), n.b("</button>"), n.b("\n" + i)), n.b("</div>"), n.b("\n"), n.fl()
					},
					partials: {},
					subs: {}
				}, '{{#title}}<h1>{{title}}</h1>{{/title}}\n<p>{{text}}</p>\n<div>\n\n    {{#continue}}\n        <button type="button" class="stop">{{#tr}}STOP{{/tr}}</button>\n        <button type="button" class="close">{{#tr}}CONTINUE{{/tr}}</button>\n    {{/continue}}\n    {{^continue}}\n        <button type="button" class="stop">{{#tr}}OK{{/tr}}</button>\n    {{/continue}}\n</div>\n', n)
			},
			64462: (t, e, i) => {
				var n = i(34714);
				t.exports = new n.Template({
					code: function(t, e, i) {
						var n = this;
						return n.b(i = i || ""), n.b("<h1>"), n.s(n.f("tr", t, e, 1), t, e, 0, 11, 29, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Insufficient funds")
						})), t.pop()), n.b("</h1>"), n.b("\n" + i), n.b("<p>"), n.s(n.f("tr", t, e, 1), t, e, 0, 52, 141, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Please go through the deposit flow to deposit more money if you wish to continue playing!")
						})), t.pop()), n.b("</p>"), n.b("\n" + i), n.b("<div>"), n.b("\n" + i), n.s(n.f("continue", t, e, 1), t, e, 0, 176, 251, "{{ }}") && (n.rs(t, e, (function(t, e, n) {
							n.b('        <button type="button" class="close">'), n.s(n.f("tr", t, e, 1), t, e, 0, 228, 230, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
								i.b("OK")
							})), t.pop()), n.b("</button>"), n.b("\n" + i)
						})), t.pop()), n.s(n.f("continue", t, e, 1), t, e, 1, 0, 0, "") || (n.b('        <button type="button" class="stop">'), n.s(n.f("tr", t, e, 1), t, e, 0, 333, 335, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("OK")
						})), t.pop()), n.b("</button>"), n.b("\n" + i)), n.b("</div>"), n.b("\n"), n.fl()
					},
					partials: {},
					subs: {}
				}, '<h1>{{#tr}}Insufficient funds{{/tr}}</h1>\n<p>{{#tr}}Please go through the deposit flow to deposit more money if you wish to continue playing!{{/tr}}</p>\n<div>\n    {{#continue}}\n        <button type="button" class="close">{{#tr}}OK{{/tr}}</button>\n    {{/continue}}\n    {{^continue}}\n        <button type="button" class="stop">{{#tr}}OK{{/tr}}</button>\n    {{/continue}}\n</div>\n', n)
			},
			41840: (t, e, i) => {
				var n = i(34714);
				t.exports = new n.Template({
					code: function(t, e, i) {
						var n = this;
						return n.b(i = i || ""), n.b("<h1>"), n.s(n.f("tr", t, e, 1), t, e, 0, 11, 29, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Responsible Gaming")
						})), t.pop()), n.b("</h1>"), n.b("\n" + i), n.b("<p>"), n.s(n.f("tr", t, e, 1), t, e, 0, 52, 166, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Your gaming session is now ended for this time, you have to close the game manually to proceed with other actions!")
						})), t.pop()), n.b("</p>"), n.b("\n"), n.fl()
					},
					partials: {},
					subs: {}
				}, "<h1>{{#tr}}Responsible Gaming{{/tr}}</h1>\n<p>{{#tr}}Your gaming session is now ended for this time, you have to close the game manually to proceed with other actions!{{/tr}}</p>\n", n)
			},
			35814: (t, e, i) => {
				var n = i(34714);
				t.exports = new n.Template({
					code: function(t, e, i) {
						var n = this;
						return n.b(i = i || ""), n.b("<h1>"), n.s(n.f("tr", t, e, 1), t, e, 0, 11, 29, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Responsible Gaming")
						})), t.pop()), n.b("</h1>"), n.b("\n" + i), n.b("<p>"), n.b(n.v(n.f("message", t, e, 0))), n.b("</p>"), n.b("\n" + i), n.b("<p>"), n.s(n.f("tr", t, e, 1), t, e, 0, 71, 185, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Your gaming session is now ended for this time, you have to close the game manually to proceed with other actions!")
						})), t.pop()), n.b("</p>"), n.b("\n" + i), n.s(n.f("mobile", t, e, 1), t, e, 0, 208, 341, "{{ }}") && (n.rs(t, e, (function(t, e, n) {
							n.b('<div style="margin-bottom: 1rem;"><a style="color: white;" href="javascript:" class="exit">'), n.s(n.f("tr", t, e, 1), t, e, 0, 307, 323, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
								i.b("End Game Session")
							})), t.pop()), n.b("</a></div>"), n.b("\n" + i)
						})), t.pop()), n.fl()
					},
					partials: {},
					subs: {}
				}, '<h1>{{#tr}}Responsible Gaming{{/tr}}</h1>\n<p>{{message}}</p>\n<p>{{#tr}}Your gaming session is now ended for this time, you have to close the game manually to proceed with other actions!{{/tr}}</p>\n{{#mobile}}\n<div style="margin-bottom: 1rem;"><a style="color: white;" href="javascript:" class="exit">{{#tr}}End Game Session{{/tr}}</a></div>\n{{/mobile}}\n', n)
			},
			47466: (t, e, i) => {
				var n = i(34714);
				t.exports = new n.Template({
					code: function(t, e, i) {
						var n = this;
						return n.b(i = i || ""), n.s(n.f("title", t, e, 1), t, e, 0, 10, 28, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("<h1>"), i.b(i.v(i.f("title", t, e, 0))), i.b("</h1>")
						})), t.pop()), n.b("\n" + i), n.b("<p>"), n.b(n.v(n.f("text", t, e, 0))), n.b("</p>"), n.b("\n" + i), n.b("<div>"), n.b("\n" + i), n.b('    <button type="button" class="close">'), n.s(n.f("tr", t, e, 1), t, e, 0, 108, 110, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("OK")
						})), t.pop()), n.b("</button>"), n.b("\n" + i), n.s(n.f("buttons", t, e, 1), t, e, 0, 143, 713, "{{ }}") && (n.rs(t, e, (function(t, e, n) {
							n.b('        <button type="button" class="'), n.b(n.v(n.f("action", t, e, 0))), n.b('"'), n.b("\n" + i), n.s(n.f("link", t, e, 1), t, e, 0, 214, 681, "{{ }}") && (n.rs(t, e, (function(t, e, n) {
								n.s(n.f("linkType", t, e, 1), t, e, 0, 244, 655, "{{ }}") && (n.rs(t, e, (function(t, e, n) {
									n.b("                    "), n.s(n.f("REDIRECT", t, e, 1), t, e, 0, 278, 316, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
										i.b(" onclick=\"window.location='"), i.b(i.v(i.f("link", t, e, 0))), i.b("'\" ")
									})), t.pop()), n.b("\n" + i), n.b("                    "), n.s(n.f("NEW_WINDOW", t, e, 1), t, e, 0, 365, 400, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
										i.b(" onclick=\"window.open('"), i.b(i.v(i.f("link", t, e, 0))), i.b("')\" ")
									})), t.pop()), n.b("\n" + i), n.b("                    "), n.s(n.f("REQUEST", t, e, 1), t, e, 0, 448, 479, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
										i.b(" onclick=\"request('"), i.b(i.v(i.f("link", t, e, 0))), i.b("')\" ")
									})), t.pop()), n.b("\n" + i), n.b("                    "), n.s(n.f("NOTIFY", t, e, 1), t, e, 0, 523, 553, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
										i.b(" onclick=\"notify('"), i.b(i.v(i.f("link", t, e, 0))), i.b("')\" ")
									})), t.pop()), n.b("\n" + i), n.b("                    "), n.s(n.f("EVENT", t, e, 1), t, e, 0, 595, 628, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
										i.b(" onclick=\"sendEvent('"), i.b(i.v(i.f("link", t, e, 0))), i.b("')\" ")
									})), t.pop()), n.b("\n" + i)
								})), t.pop()), n.b("            ")
							})), t.pop()), n.b(">"), n.b(n.v(n.f("text", t, e, 0))), n.b("</button>"), n.b("\n" + i)
						})), t.pop()), n.b("</div>"), n.b("\n"), n.fl()
					},
					partials: {},
					subs: {}
				}, '{{#title}}<h1>{{title}}</h1>{{/title}}\n<p>{{text}}</p>\n<div>\n    <button type="button" class="close">{{#tr}}OK{{/tr}}</button>\n    {{#buttons}}\n        <button type="button" class="{{action}}"\n            {{#link}}\n                {{#linkType}}\n                    {{#REDIRECT}} onclick="window.location=\'{{link}}\'" {{/REDIRECT}}\n                    {{#NEW_WINDOW}} onclick="window.open(\'{{link}}\')" {{/NEW_WINDOW}}\n                    {{#REQUEST}} onclick="request(\'{{link}}\')" {{/REQUEST}}\n                    {{#NOTIFY}} onclick="notify(\'{{link}}\')" {{/NOTIFY}}\n                    {{#EVENT}} onclick="sendEvent(\'{{link}}\')" {{/EVENT}}\n                {{/linkType}}\n            {{/link}}>{{text}}</button>\n    {{/buttons}}\n</div>\n', n)
			},
			43729: (t, e, i) => {
				var n = i(34714);
				t.exports = new n.Template({
					code: function(t, e, i) {
						var n = this;
						return n.b(i = i || ""), n.b("<h1>"), n.s(n.f("tr", t, e, 1), t, e, 0, 11, 29, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Responsible Gaming")
						})), t.pop()), n.b("</h1>"), n.b("\n" + i), n.b('<p><span id="rc-message">'), n.b(n.v(n.f("message", t, e, 0))), n.b("</span></p>"), n.b("\n" + i), n.b('<ul class="responsible standings">'), n.b("\n" + i), n.b("    <li>"), n.s(n.f("tr", t, e, 1), t, e, 0, 140, 152, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Elapsed time")
						})), t.pop()), n.b(': <span id="rc-hours">'), n.b(n.v(n.f("hours", t, e, 0))), n.b("</span>"), n.b("\n" + i), n.b("    <li>"), n.s(n.f("tr", t, e, 1), t, e, 0, 213, 224, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Total Bets:")
						})), t.pop()), n.b(" "), n.b(n.v(n.f("bets", t, e, 0))), n.b("\n" + i), n.b("    <li>"), n.s(n.f("tr", t, e, 1), t, e, 0, 256, 266, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Total Win:")
						})), t.pop()), n.b(' <span id="rc-winnings">'), n.b(n.v(n.f("winnings", t, e, 0))), n.b("</span>"), n.b("\n" + i), n.b("    <li>"), n.s(n.f("tr", t, e, 1), t, e, 0, 332, 345, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Total Profit:")
						})), t.pop()), n.b(' <span id="rc-profit">'), n.b(n.v(n.f("profit", t, e, 0))), n.b("</span>"), n.b("\n" + i), n.b("</ul>"), n.b("\n" + i), n.b('<div><button type="button" class="close">'), n.s(n.f("tr", t, e, 1), t, e, 0, 446, 448, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("OK")
						})), t.pop()), n.b("</button></div>"), n.b("\n" + i), n.b('<div style="margin-bottom: 1rem;" class="account-history"><a style="color: white; opacity: 0.6;" href="javascript:">'), n.s(n.f("tr", t, e, 1), t, e, 0, 594, 609, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Account history")
						})), t.pop()), n.b("</a></div>"), n.b("\n" + i), n.b('<div style="margin-bottom: 1rem;" class="end-session"><a style="color: white; opacity: 0.6;" href="javascript:">'), n.s(n.f("tr", t, e, 1), t, e, 0, 746, 762, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("End Game Session")
						})), t.pop()), n.b("</a></div>"), n.b("\n"), n.fl()
					},
					partials: {},
					subs: {}
				}, '<h1>{{#tr}}Responsible Gaming{{/tr}}</h1>\n<p><span id="rc-message">{{message}}</span></p>\n<ul class="responsible standings">\n    <li>{{#tr}}Elapsed time{{/tr}}: <span id="rc-hours">{{hours}}</span>\n    <li>{{#tr}}Total Bets:{{/tr}} {{bets}}\n    <li>{{#tr}}Total Win:{{/tr}} <span id="rc-winnings">{{winnings}}</span>\n    <li>{{#tr}}Total Profit:{{/tr}} <span id="rc-profit">{{profit}}</span>\n</ul>\n<div><button type="button" class="close">{{#tr}}OK{{/tr}}</button></div>\n<div style="margin-bottom: 1rem;" class="account-history"><a style="color: white; opacity: 0.6;" href="javascript:">{{#tr}}Account history{{/tr}}</a></div>\n<div style="margin-bottom: 1rem;" class="end-session"><a style="color: white; opacity: 0.6;" href="javascript:">{{#tr}}End Game Session{{/tr}}</a></div>\n', n)
			},
			69315: (t, e, i) => {
				var n = i(34714);
				t.exports = new n.Template({
					code: function(t, e, i) {
						var n = this;
						return n.b(i = i || ""), n.s(n.f("title", t, e, 1), t, e, 0, 10, 28, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("<h1>"), i.b(i.v(i.f("title", t, e, 0))), i.b("</h1>")
						})), t.pop()), n.b("\n" + i), n.b("<p>"), n.b(n.t(n.f("message", t, e, 0))), n.b("</p>"), n.b("\n" + i), n.b("<div>"), n.b("\n" + i), n.s(n.f("buttons", t, e, 1), t, e, 0, 82, 582, "{{ }}") && (n.rs(t, e, (function(t, e, n) {
							n.b('        <button type="button" class="'), n.b(n.v(n.f("action", t, e, 0))), n.b('"'), n.b("\n" + i), n.s(n.f("link", t, e, 1), t, e, 0, 149, 550, "{{ }}") && (n.rs(t, e, (function(t, e, n) {
								n.s(n.f("linkType", t, e, 1), t, e, 0, 173, 528, "{{ }}") && (n.rs(t, e, (function(t, e, n) {
									n.b("            "), n.s(n.f("REDIRECT", t, e, 1), t, e, 0, 199, 237, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
										i.b(" onclick=\"window.location='"), i.b(i.v(i.f("link", t, e, 0))), i.b("'\" ")
									})), t.pop()), n.b("\n" + i), n.b("            "), n.s(n.f("NEW_WINDOW", t, e, 1), t, e, 0, 278, 313, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
										i.b(" onclick=\"window.open('"), i.b(i.v(i.f("link", t, e, 0))), i.b("')\" ")
									})), t.pop()), n.b("\n" + i), n.b("            "), n.s(n.f("REQUEST", t, e, 1), t, e, 0, 353, 384, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
										i.b(" onclick=\"request('"), i.b(i.v(i.f("link", t, e, 0))), i.b("')\" ")
									})), t.pop()), n.b("\n" + i), n.b("            "), n.s(n.f("NOTIFY", t, e, 1), t, e, 0, 420, 450, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
										i.b(" onclick=\"notify('"), i.b(i.v(i.f("link", t, e, 0))), i.b("')\" ")
									})), t.pop()), n.b("\n" + i), n.b("            "), n.s(n.f("EVENT", t, e, 1), t, e, 0, 484, 507, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
										i.b(" data-event='"), i.b(i.v(i.f("link", t, e, 0))), i.b("' ")
									})), t.pop()), n.b("\n" + i)
								})), t.pop()), n.b("        ")
							})), t.pop()), n.b(">"), n.b(n.v(n.f("text", t, e, 0))), n.b("</button>"), n.b("\n" + i)
						})), t.pop()), n.b("</div>"), n.b("\n"), n.fl()
					},
					partials: {},
					subs: {}
				}, '{{#title}}<h1>{{title}}</h1>{{/title}}\n<p>{{{message}}}</p>\n<div>\n    {{#buttons}}\n        <button type="button" class="{{action}}"\n        {{#link}}\n          {{#linkType}}\n            {{#REDIRECT}} onclick="window.location=\'{{link}}\'" {{/REDIRECT}}\n            {{#NEW_WINDOW}} onclick="window.open(\'{{link}}\')" {{/NEW_WINDOW}}\n            {{#REQUEST}} onclick="request(\'{{link}}\')" {{/REQUEST}}\n            {{#NOTIFY}} onclick="notify(\'{{link}}\')" {{/NOTIFY}}\n            {{#EVENT}} data-event=\'{{link}}\' {{/EVENT}}\n          {{/linkType}}\n        {{/link}}>{{text}}</button>\n    {{/buttons}}\n</div>\n', n)
			},
			49315: (t, e, i) => {
				var n = i(34714);
				t.exports = new n.Template({
					code: function(t, e, i) {
						var n = this;
						return n.b(i = i || ""), n.b("<h1>"), n.s(n.f("tr", t, e, 1), t, e, 0, 11, 37, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Your session has timed out")
						})), t.pop()), n.b("</h1>"), n.b("\n" + i), n.b("<p>"), n.s(n.f("tr", t, e, 1), t, e, 0, 60, 96, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
							i.b("Please reload the game to try again.")
						})), t.pop()), n.b("</p>"), n.b("\n" + i), n.s(n.f("mobile", t, e, 1), t, e, 0, 119, 210, "{{ }}") && (n.rs(t, e, (function(t, e, n) {
							n.b("    <div>"), n.b("\n" + i), n.b('        <button type="button" class="exit">'), n.s(n.f("tr", t, e, 1), t, e, 0, 180, 182, "{{ }}") && (n.rs(t, e, (function(t, e, i) {
								i.b("OK")
							})), t.pop()), n.b("</button>"), n.b("\n" + i), n.b("    </div>"), n.b("\n" + i)
						})), t.pop()), n.fl()
					},
					partials: {},
					subs: {}
				}, '<h1>{{#tr}}Your session has timed out{{/tr}}</h1>\n<p>{{#tr}}Please reload the game to try again.{{/tr}}</p>\n{{#mobile}}\n    <div>\n        <button type="button" class="exit">{{#tr}}OK{{/tr}}</button>\n    </div>\n{{/mobile}}\n', n)
			},
			45228: t => {
				"use strict";
				var e = Object.getOwnPropertySymbols,
					i = Object.prototype.hasOwnProperty,
					n = Object.prototype.propertyIsEnumerable;
				t.exports = function() {
					try {
						if (!Object.assign) return !1;
						var t = new String("abc");
						if (t[5] = "de", "5" === Object.getOwnPropertyNames(t)[0]) return !1;
						for (var e = {}, i = 0; i < 10; i++) e["_" + String.fromCharCode(i)] = i;
						if ("0123456789" !== Object.getOwnPropertyNames(e).map((function(t) {
								return e[t]
							})).join("")) return !1;
						var n = {};
						return "abcdefghijklmnopqrst".split("").forEach((function(t) {
							n[t] = t
						})), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, n)).join("")
					} catch (t) {
						return !1
					}
				}() ? Object.assign : function(t, s) {
					for (var o, r, a = function(t) {
							if (null == t) throw new TypeError("Object.assign cannot be called with null or undefined");
							return Object(t)
						}(t), l = 1; l < arguments.length; l++) {
						for (var h in o = Object(arguments[l])) i.call(o, h) && (a[h] = o[h]);
						if (e) {
							r = e(o);
							for (var u = 0; u < r.length; u++) n.call(o, r[u]) && (a[r[u]] = o[r[u]])
						}
					}
					return a
				}
			},
			58859: (t, e, i) => {
				var n = "function" == typeof Map && Map.prototype,
					s = Object.getOwnPropertyDescriptor && n ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null,
					o = n && s && "function" == typeof s.get ? s.get : null,
					r = n && Map.prototype.forEach,
					a = "function" == typeof Set && Set.prototype,
					l = Object.getOwnPropertyDescriptor && a ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null,
					h = a && l && "function" == typeof l.get ? l.get : null,
					u = a && Set.prototype.forEach,
					c = "function" == typeof WeakMap && WeakMap.prototype ? WeakMap.prototype.has : null,
					d = "function" == typeof WeakSet && WeakSet.prototype ? WeakSet.prototype.has : null,
					p = "function" == typeof WeakRef && WeakRef.prototype ? WeakRef.prototype.deref : null,
					_ = Boolean.prototype.valueOf,
					m = Object.prototype.toString,
					g = Function.prototype.toString,
					f = String.prototype.match,
					S = String.prototype.slice,
					y = String.prototype.replace,
					v = String.prototype.toUpperCase,
					T = String.prototype.toLowerCase,
					E = RegExp.prototype.test,
					b = Array.prototype.concat,
					A = Array.prototype.join,
					P = Array.prototype.slice,
					I = Math.floor,
					w = "function" == typeof BigInt ? BigInt.prototype.valueOf : null,
					L = Object.getOwnPropertySymbols,
					C = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? Symbol.prototype.toString : null,
					x = "function" == typeof Symbol && "object" == typeof Symbol.iterator,
					B = "function" == typeof Symbol && Symbol.toStringTag && (Symbol.toStringTag, 1) ? Symbol.toStringTag : null,
					O = Object.prototype.propertyIsEnumerable,
					N = ("function" == typeof Reflect ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(t) {
						return t.__proto__
					} : null);

				function M(t, e) {
					if (t === 1 / 0 || t === -1 / 0 || t != t || t && t > -1e3 && t < 1e3 || E.call(/e/, e)) return e;
					var i = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
					if ("number" == typeof t) {
						var n = t < 0 ? -I(-t) : I(t);
						if (n !== t) {
							var s = String(n),
								o = S.call(e, s.length + 1);
							return y.call(s, i, "$&_") + "." + y.call(y.call(o, /([0-9]{3})/g, "$&_"), /_$/, "")
						}
					}
					return y.call(e, i, "$&_")
				}
				var R = i(42634),
					D = R.custom,
					k = H(D) ? D : null;

				function F(t, e, i) {
					var n = "double" === (i.quoteStyle || e) ? '"' : "'";
					return n + t + n
				}

				function G(t) {
					return y.call(String(t), /"/g, "&quot;")
				}

				function U(t) {
					return !("[object Array]" !== Y(t) || B && "object" == typeof t && B in t)
				}

				function W(t) {
					return !("[object RegExp]" !== Y(t) || B && "object" == typeof t && B in t)
				}

				function H(t) {
					if (x) return t && "object" == typeof t && t instanceof Symbol;
					if ("symbol" == typeof t) return !0;
					if (!t || "object" != typeof t || !C) return !1;
					try {
						return C.call(t), !0
					} catch (t) {}
					return !1
				}
				t.exports = function t(e, n, s, a) {
					var l = n || {};
					if (X(l, "quoteStyle") && "single" !== l.quoteStyle && "double" !== l.quoteStyle) throw new TypeError('option "quoteStyle" must be "single" or "double"');
					if (X(l, "maxStringLength") && ("number" == typeof l.maxStringLength ? l.maxStringLength < 0 && l.maxStringLength !== 1 / 0 : null !== l.maxStringLength)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
					var m = !X(l, "customInspect") || l.customInspect;
					if ("boolean" != typeof m && "symbol" !== m) throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
					if (X(l, "indent") && null !== l.indent && "\t" !== l.indent && !(parseInt(l.indent, 10) === l.indent && l.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
					if (X(l, "numericSeparator") && "boolean" != typeof l.numericSeparator) throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
					var v = l.numericSeparator;
					if (void 0 === e) return "undefined";
					if (null === e) return "null";
					if ("boolean" == typeof e) return e ? "true" : "false";
					if ("string" == typeof e) return j(e, l);
					if ("number" == typeof e) {
						if (0 === e) return 1 / 0 / e > 0 ? "0" : "-0";
						var E = String(e);
						return v ? M(e, E) : E
					}
					if ("bigint" == typeof e) {
						var I = String(e) + "n";
						return v ? M(e, I) : I
					}
					var L = void 0 === l.depth ? 5 : l.depth;
					if (void 0 === s && (s = 0), s >= L && L > 0 && "object" == typeof e) return U(e) ? "[Array]" : "[Object]";
					var D, V = function(t, e) {
						var i;
						if ("\t" === t.indent) i = "\t";
						else {
							if (!("number" == typeof t.indent && t.indent > 0)) return null;
							i = A.call(Array(t.indent + 1), " ")
						}
						return {
							base: i,
							prev: A.call(Array(e + 1), i)
						}
					}(l, s);
					if (void 0 === a) a = [];
					else if (z(a, e) >= 0) return "[Circular]";

					function K(e, i, n) {
						if (i && (a = P.call(a)).push(i), n) {
							var o = {
								depth: l.depth
							};
							return X(l, "quoteStyle") && (o.quoteStyle = l.quoteStyle), t(e, o, s + 1, a)
						}
						return t(e, l, s + 1, a)
					}
					if ("function" == typeof e && !W(e)) {
						var tt = function(t) {
								if (t.name) return t.name;
								var e = f.call(g.call(t), /^function\s*([\w$]+)/);
								return e ? e[1] : null
							}(e),
							et = J(e, K);
						return "[Function" + (tt ? ": " + tt : " (anonymous)") + "]" + (et.length > 0 ? " { " + A.call(et, ", ") + " }" : "")
					}
					if (H(e)) {
						var it = x ? y.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : C.call(e);
						return "object" != typeof e || x ? it : q(it)
					}
					if ((D = e) && "object" == typeof D && ("undefined" != typeof HTMLElement && D instanceof HTMLElement || "string" == typeof D.nodeName && "function" == typeof D.getAttribute)) {
						for (var nt = "<" + T.call(String(e.nodeName)), st = e.attributes || [], ot = 0; ot < st.length; ot++) nt += " " + st[ot].name + "=" + F(G(st[ot].value), "double", l);
						return nt += ">", e.childNodes && e.childNodes.length && (nt += "..."), nt + "</" + T.call(String(e.nodeName)) + ">"
					}
					if (U(e)) {
						if (0 === e.length) return "[]";
						var rt = J(e, K);
						return V && ! function(t) {
							for (var e = 0; e < t.length; e++)
								if (z(t[e], "\n") >= 0) return !1;
							return !0
						}(rt) ? "[" + Q(rt, V) + "]" : "[ " + A.call(rt, ", ") + " ]"
					}
					if (function(t) {
							return !("[object Error]" !== Y(t) || B && "object" == typeof t && B in t)
						}(e)) {
						var at = J(e, K);
						return "cause" in Error.prototype || !("cause" in e) || O.call(e, "cause") ? 0 === at.length ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + A.call(at, ", ") + " }" : "{ [" + String(e) + "] " + A.call(b.call("[cause]: " + K(e.cause), at), ", ") + " }"
					}
					if ("object" == typeof e && m) {
						if (k && "function" == typeof e[k] && R) return R(e, {
							depth: L - s
						});
						if ("symbol" !== m && "function" == typeof e.inspect) return e.inspect()
					}
					if (function(t) {
							if (!o || !t || "object" != typeof t) return !1;
							try {
								o.call(t);
								try {
									h.call(t)
								} catch (t) {
									return !0
								}
								return t instanceof Map
							} catch (t) {}
							return !1
						}(e)) {
						var lt = [];
						return r && r.call(e, (function(t, i) {
							lt.push(K(i, e, !0) + " => " + K(t, e))
						})), $("Map", o.call(e), lt, V)
					}
					if (function(t) {
							if (!h || !t || "object" != typeof t) return !1;
							try {
								h.call(t);
								try {
									o.call(t)
								} catch (t) {
									return !0
								}
								return t instanceof Set
							} catch (t) {}
							return !1
						}(e)) {
						var ht = [];
						return u && u.call(e, (function(t) {
							ht.push(K(t, e))
						})), $("Set", h.call(e), ht, V)
					}
					if (function(t) {
							if (!c || !t || "object" != typeof t) return !1;
							try {
								c.call(t, c);
								try {
									d.call(t, d)
								} catch (t) {
									return !0
								}
								return t instanceof WeakMap
							} catch (t) {}
							return !1
						}(e)) return Z("WeakMap");
					if (function(t) {
							if (!d || !t || "object" != typeof t) return !1;
							try {
								d.call(t, d);
								try {
									c.call(t, c)
								} catch (t) {
									return !0
								}
								return t instanceof WeakSet
							} catch (t) {}
							return !1
						}(e)) return Z("WeakSet");
					if (function(t) {
							if (!p || !t || "object" != typeof t) return !1;
							try {
								return p.call(t), !0
							} catch (t) {}
							return !1
						}(e)) return Z("WeakRef");
					if (function(t) {
							return !("[object Number]" !== Y(t) || B && "object" == typeof t && B in t)
						}(e)) return q(K(Number(e)));
					if (function(t) {
							if (!t || "object" != typeof t || !w) return !1;
							try {
								return w.call(t), !0
							} catch (t) {}
							return !1
						}(e)) return q(K(w.call(e)));
					if (function(t) {
							return !("[object Boolean]" !== Y(t) || B && "object" == typeof t && B in t)
						}(e)) return q(_.call(e));
					if (function(t) {
							return !("[object String]" !== Y(t) || B && "object" == typeof t && B in t)
						}(e)) return q(K(String(e)));
					if ("undefined" != typeof window && e === window) return "{ [object Window] }";
					if (e === i.g) return "{ [object globalThis] }";
					if (! function(t) {
							return !("[object Date]" !== Y(t) || B && "object" == typeof t && B in t)
						}(e) && !W(e)) {
						var ut = J(e, K),
							ct = N ? N(e) === Object.prototype : e instanceof Object || e.constructor === Object,
							dt = e instanceof Object ? "" : "null prototype",
							pt = !ct && B && Object(e) === e && B in e ? S.call(Y(e), 8, -1) : dt ? "Object" : "",
							_t = (ct || "function" != typeof e.constructor ? "" : e.constructor.name ? e.constructor.name + " " : "") + (pt || dt ? "[" + A.call(b.call([], pt || [], dt || []), ": ") + "] " : "");
						return 0 === ut.length ? _t + "{}" : V ? _t + "{" + Q(ut, V) + "}" : _t + "{ " + A.call(ut, ", ") + " }"
					}
					return String(e)
				};
				var V = Object.prototype.hasOwnProperty || function(t) {
					return t in this
				};

				function X(t, e) {
					return V.call(t, e)
				}

				function Y(t) {
					return m.call(t)
				}

				function z(t, e) {
					if (t.indexOf) return t.indexOf(e);
					for (var i = 0, n = t.length; i < n; i++)
						if (t[i] === e) return i;
					return -1
				}

				function j(t, e) {
					if (t.length > e.maxStringLength) {
						var i = t.length - e.maxStringLength,
							n = "... " + i + " more character" + (i > 1 ? "s" : "");
						return j(S.call(t, 0, e.maxStringLength), e) + n
					}
					return F(y.call(y.call(t, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, K), "single", e)
				}

				function K(t) {
					var e = t.charCodeAt(0),
						i = {
							8: "b",
							9: "t",
							10: "n",
							12: "f",
							13: "r"
						} [e];
					return i ? "\\" + i : "\\x" + (e < 16 ? "0" : "") + v.call(e.toString(16))
				}

				function q(t) {
					return "Object(" + t + ")"
				}

				function Z(t) {
					return t + " { ? }"
				}

				function $(t, e, i, n) {
					return t + " (" + e + ") {" + (n ? Q(i, n) : A.call(i, ", ")) + "}"
				}

				function Q(t, e) {
					if (0 === t.length) return "";
					var i = "\n" + e.prev + e.base;
					return i + A.call(t, "," + i) + "\n" + e.prev
				}

				function J(t, e) {
					var i = U(t),
						n = [];
					if (i) {
						n.length = t.length;
						for (var s = 0; s < t.length; s++) n[s] = X(t, s) ? e(t[s], t) : ""
					}
					var o, r = "function" == typeof L ? L(t) : [];
					if (x) {
						o = {};
						for (var a = 0; a < r.length; a++) o["$" + r[a]] = r[a]
					}
					for (var l in t) X(t, l) && (i && String(Number(l)) === l && l < t.length || x && o["$" + l] instanceof Symbol || (E.call(/[^\w$]/, l) ? n.push(e(l, t) + ": " + e(t[l], t)) : n.push(l + ": " + e(t[l], t))));
					if ("function" == typeof L)
						for (var h = 0; h < r.length; h++) O.call(t, r[h]) && n.push("[" + e(r[h]) + "]: " + e(t[r[h]], t));
					return n
				}
			},
			84678: t => {
				"use strict";
				t.exports = (t, e = {}) => {
					if (!t) return;
					const i = {
							key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
							q: {
								name: "queryKey",
								parser: /(?:^|&)([^&=]*)=?([^&]*)/g
							},
							parser: {
								strict: /^(?:([^:/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\d*))?))?((((?:[^?#/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
								loose: /^(?:(?![^:@]+:[^:@/]*@)([^:/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#/]*\.[^?#/.]+(?:[?#]|$)))*\/?)?([^?#/]*))(?:\?([^#]*))?(?:#(.*))?)/
							}
						},
						n = i.parser[e.strictMode ? "strict" : "loose"].exec(t),
						s = {};
					let o = 14;
					for (; o--;) s[i.key[o]] = n[o] || "";
					return s[i.q.name] = {}, s[i.key[12]].replace(i.q.parser, (function(t, e, n) {
						e && (s[i.q.name][e] = n)
					})), s
				}
			},
			7615: (t, e, i) => {
				"use strict";
				i.r(e), i.d(e, {
					AnimatedParticle: () => P,
					Emitter: () => v,
					Particle: () => g,
					ParticleUtils: () => n,
					PathParticle: () => A,
					PolygonalChain: () => f,
					PropertyList: () => l,
					PropertyNode: () => o
				});
				var n, s = i(82859),
					o = function() {
						function t(t, e, i) {
							this.value = t, this.time = e, this.next = null, this.isStepped = !1, this.ease = i ? "function" == typeof i ? i : n.generateEase(i) : null
						}
						return t.createList = function(e) {
							if ("list" in e) {
								var i = e.list,
									s = void 0,
									o = void 0,
									r = i[0],
									a = r.value,
									l = r.time;
								if (o = s = new t("string" == typeof a ? n.hexToRGB(a) : a, l, e.ease), i.length > 2 || 2 === i.length && i[1].value !== a)
									for (var h = 1; h < i.length; ++h) {
										var u = i[h],
											c = u.value,
											d = u.time;
										s.next = new t("string" == typeof c ? n.hexToRGB(c) : c, d), s = s.next
									}
								return o.isStepped = !!e.isStepped, o
							}
							var p = new t("string" == typeof e.start ? n.hexToRGB(e.start) : e.start, 0);
							return e.end !== e.start && (p.next = new t("string" == typeof e.end ? n.hexToRGB(e.end) : e.end, 1)), p
						}, t
					}();
				! function(t) {
					t.verbose = !1, t.DEG_TO_RADS = Math.PI / 180, t.rotatePoint = function(e, i) {
						if (e) {
							e *= t.DEG_TO_RADS;
							var n = Math.sin(e),
								s = Math.cos(e),
								o = i.x * s - i.y * n,
								r = i.x * n + i.y * s;
							i.x = o, i.y = r
						}
					}, t.combineRGBComponents = function(t, e, i) {
						return t << 16 | e << 8 | i
					}, t.normalize = function(e) {
						var i = 1 / t.length(e);
						e.x *= i, e.y *= i
					}, t.scaleBy = function(t, e) {
						t.x *= e, t.y *= e
					}, t.length = function(t) {
						return Math.sqrt(t.x * t.x + t.y * t.y)
					}, t.hexToRGB = function(t, e) {
						var i;
						return e || (e = {}), "#" == t.charAt(0) ? t = t.substr(1) : 0 === t.indexOf("0x") && (t = t.substr(2)), 8 == t.length && (i = t.substr(0, 2), t = t.substr(2)), e.r = parseInt(t.substr(0, 2), 16), e.g = parseInt(t.substr(2, 2), 16), e.b = parseInt(t.substr(4, 2), 16), i && (e.a = parseInt(i, 16)), e
					}, t.generateEase = function(t) {
						var e = t.length,
							i = 1 / e;
						return function(n) {
							var s, o, r = e * n | 0;
							return s = (n - r * i) * e, (o = t[r] || t[e - 1]).s + s * (2 * (1 - s) * (o.cp - o.s) + s * (o.e - o.s))
						}
					}, t.getBlendMode = function(t) {
						if (!t) return s.BLEND_MODES.NORMAL;
						for (t = t.toUpperCase(); t.indexOf(" ") >= 0;) t = t.replace(" ", "_");
						return s.BLEND_MODES[t] || s.BLEND_MODES.NORMAL
					}, t.createSteppedGradient = function(e, i) {
						void 0 === i && (i = 10), ("number" != typeof i || i <= 0) && (i = 10);
						var n = new o(t.hexToRGB(e[0].value), e[0].time);
						n.isStepped = !0;
						for (var s = n, r = e[0], a = 1, l = e[a], h = 1; h < i; ++h) {
							for (var u = h / i; u > l.time;) r = l, l = e[++a];
							u = (u - r.time) / (l.time - r.time);
							var c = t.hexToRGB(r.value),
								d = t.hexToRGB(l.value),
								p = {
									r: (d.r - c.r) * u + c.r,
									g: (d.g - c.g) * u + c.g,
									b: (d.b - c.b) * u + c.b
								};
							s.next = new o(p, h / i), s = s.next
						}
						return n
					}
				}(n || (n = {}));
				var r = function(t, e) {
					return r = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(t, e) {
						t.__proto__ = e
					} || function(t, e) {
						for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
					}, r(t, e)
				};

				function a(t, e) {
					function i() {
						this.constructor = t
					}
					r(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
				}
				var l = function() {
					function t(t) {
						void 0 === t && (t = !1), this.current = null, this.next = null, this.isColor = !!t, this.interpolate = null, this.ease = null
					}
					return t.prototype.reset = function(t) {
						this.current = t, this.next = t.next, this.next && this.next.time >= 1 ? this.interpolate = this.isColor ? u : h : t.isStepped ? this.interpolate = this.isColor ? _ : p : this.interpolate = this.isColor ? d : c, this.ease = this.current.ease
					}, t
				}();

				function h(t) {
					return this.ease && (t = this.ease(t)), (this.next.value - this.current.value) * t + this.current.value
				}

				function u(t) {
					this.ease && (t = this.ease(t));
					var e = this.current.value,
						i = this.next.value,
						s = (i.r - e.r) * t + e.r,
						o = (i.g - e.g) * t + e.g,
						r = (i.b - e.b) * t + e.b;
					return n.combineRGBComponents(s, o, r)
				}

				function c(t) {
					for (this.ease && (t = this.ease(t)); t > this.next.time;) this.current = this.next, this.next = this.next.next;
					return t = (t - this.current.time) / (this.next.time - this.current.time), (this.next.value - this.current.value) * t + this.current.value
				}

				function d(t) {
					for (this.ease && (t = this.ease(t)); t > this.next.time;) this.current = this.next, this.next = this.next.next;
					t = (t - this.current.time) / (this.next.time - this.current.time);
					var e = this.current.value,
						i = this.next.value,
						s = (i.r - e.r) * t + e.r,
						o = (i.g - e.g) * t + e.g,
						r = (i.b - e.b) * t + e.b;
					return n.combineRGBComponents(s, o, r)
				}

				function p(t) {
					for (this.ease && (t = this.ease(t)); this.next && t > this.next.time;) this.current = this.next, this.next = this.next.next;
					return this.current.value
				}

				function _(t) {
					for (this.ease && (t = this.ease(t)); this.next && t > this.next.time;) this.current = this.next, this.next = this.next.next;
					var e = this.current.value;
					return n.combineRGBComponents(e.r, e.g, e.b)
				}
				var m, g = function(t) {
						function e(i) {
							var n = t.call(this) || this;
							return n.emitter = i, n.anchor.x = n.anchor.y = .5, n.velocity = new s.Point, n.rotationSpeed = 0, n.rotationAcceleration = 0, n.maxLife = 0, n.age = 0, n.ease = null, n.extraData = null, n.alphaList = new l, n.speedList = new l, n.speedMultiplier = 1, n.acceleration = new s.Point, n.maxSpeed = NaN, n.scaleList = new l, n.scaleMultiplier = 1, n.colorList = new l(!0), n._doAlpha = !1, n._doScale = !1, n._doSpeed = !1, n._doAcceleration = !1, n._doColor = !1, n._doNormalMovement = !1, n._oneOverLife = 0, n.next = null, n.prev = null, n.init = n.init, n.Particle_init = e.prototype.init, n.update = n.update, n.Particle_update = e.prototype.update, n.Sprite_destroy = t.prototype.destroy, n.Particle_destroy = e.prototype.destroy, n.applyArt = n.applyArt, n.kill = n.kill, n
						}
						return a(e, t), e.prototype.init = function() {
							this.age = 0, this.velocity.x = this.speedList.current.value * this.speedMultiplier, this.velocity.y = 0, n.rotatePoint(this.rotation, this.velocity), this.noRotation ? this.rotation = 0 : this.rotation *= n.DEG_TO_RADS, this.rotationSpeed *= n.DEG_TO_RADS, this.rotationAcceleration *= n.DEG_TO_RADS, this.alpha = this.alphaList.current.value, this.scale.x = this.scale.y = this.scaleList.current.value, this._doAlpha = !!this.alphaList.current.next, this._doSpeed = !!this.speedList.current.next, this._doScale = !!this.scaleList.current.next, this._doColor = !!this.colorList.current.next, this._doAcceleration = 0 !== this.acceleration.x || 0 !== this.acceleration.y, this._doNormalMovement = this._doSpeed || 0 !== this.speedList.current.value || this._doAcceleration, this._oneOverLife = 1 / this.maxLife;
							var t = this.colorList.current.value;
							this.tint = n.combineRGBComponents(t.r, t.g, t.b), this.visible = !0
						}, e.prototype.applyArt = function(t) {
							this.texture = t || s.Texture.EMPTY
						}, e.prototype.update = function(t) {
							if (this.age += t, this.age >= this.maxLife || this.age < 0) return this.kill(), -1;
							var e = this.age * this._oneOverLife;
							if (this.ease && (e = 4 == this.ease.length ? this.ease(e, 0, 1, 1) : this.ease(e)), this._doAlpha && (this.alpha = this.alphaList.interpolate(e)), this._doScale) {
								var i = this.scaleList.interpolate(e) * this.scaleMultiplier;
								this.scale.x = this.scale.y = i
							}
							if (this._doNormalMovement) {
								var s = void 0,
									o = void 0;
								if (this._doSpeed) {
									var r = this.speedList.interpolate(e) * this.speedMultiplier;
									n.normalize(this.velocity), n.scaleBy(this.velocity, r), s = this.velocity.x * t, o = this.velocity.y * t
								} else if (this._doAcceleration) {
									var a = this.velocity.x,
										l = this.velocity.y;
									if (this.velocity.x += this.acceleration.x * t, this.velocity.y += this.acceleration.y * t, this.maxSpeed) {
										var h = n.length(this.velocity);
										h > this.maxSpeed && n.scaleBy(this.velocity, this.maxSpeed / h)
									}
									s = (a + this.velocity.x) / 2 * t, o = (l + this.velocity.y) / 2 * t
								} else s = this.velocity.x * t, o = this.velocity.y * t;
								this.position.x += s, this.position.y += o
							}
							if (this._doColor && (this.tint = this.colorList.interpolate(e)), 0 !== this.rotationAcceleration) {
								var u = this.rotationSpeed + this.rotationAcceleration * t;
								this.rotation += (this.rotationSpeed + u) / 2 * t, this.rotationSpeed = u
							} else 0 !== this.rotationSpeed ? this.rotation += this.rotationSpeed * t : this.acceleration && !this.noRotation && (this.rotation = Math.atan2(this.velocity.y, this.velocity.x));
							return e
						}, e.prototype.kill = function() {
							this.emitter.recycle(this)
						}, e.prototype.destroy = function() {
							this.parent && this.parent.removeChild(this), this.Sprite_destroy(), this.emitter = this.velocity = this.colorList = this.scaleList = this.alphaList = this.speedList = this.ease = this.next = this.prev = null
						}, e.parseArt = function(t) {
							var e;
							for (e = t.length; e >= 0; --e) "string" == typeof t[e] && (t[e] = s.Texture.fromImage(t[e]));
							if (n.verbose)
								for (e = t.length - 1; e > 0; --e)
									if (t[e].baseTexture != t[e - 1].baseTexture) {
										window.console && console.warn("PixiParticles: using particle textures from different images may hinder performance in WebGL");
										break
									} return t
						}, e.parseData = function(t) {
							return t
						}, e
					}(s.Sprite),
					f = function() {
						function t(t) {
							this.segments = [], this.countingLengths = [], this.totalLength = 0, this.init(t)
						}
						return t.prototype.init = function(t) {
							if (t && t.length)
								if (Array.isArray(t[0]))
									for (var e = 0; e < t.length; ++e)
										for (var i = t[e], n = i[0], s = 1; s < i.length; ++s) {
											var o = i[s];
											this.segments.push({
												p1: n,
												p2: o,
												l: 0
											}), n = o
										} else
											for (n = t[0], e = 1; e < t.length; ++e) o = t[e], this.segments.push({
												p1: n,
												p2: o,
												l: 0
											}), n = o;
								else this.segments.push({
									p1: {
										x: 0,
										y: 0
									},
									p2: {
										x: 0,
										y: 0
									},
									l: 0
								});
							for (e = 0; e < this.segments.length; ++e) {
								var r = this.segments[e],
									a = r.p1,
									l = r.p2,
									h = Math.sqrt((l.x - a.x) * (l.x - a.x) + (l.y - a.y) * (l.y - a.y));
								this.segments[e].l = h, this.totalLength += h, this.countingLengths.push(this.totalLength)
							}
						}, t.prototype.getRandomPoint = function(t) {
							var e, i, n = Math.random() * this.totalLength;
							if (1 === this.segments.length) e = this.segments[0], i = n;
							else
								for (var s = 0; s < this.countingLengths.length; ++s)
									if (n < this.countingLengths[s]) {
										e = this.segments[s], i = 0 === s ? n : n - this.countingLengths[s - 1];
										break
									} i /= e.l || 1;
							var o = e.p1,
								r = e.p2;
							t.x = o.x + i * (r.x - o.x), t.y = o.y + i * (r.y - o.y)
						}, t
					}(),
					S = s;
				m = parseInt(/^(\d+)\./.exec(s.VERSION)[1]) < 5 ? S.ticker.shared : S.Ticker.shared;
				var y = new s.Point,
					v = function() {
						function t(t, e, i) {
							this._particleConstructor = g, this.particleImages = null, this.startAlpha = null, this.startSpeed = null, this.minimumSpeedMultiplier = 1, this.acceleration = null, this.maxSpeed = NaN, this.startScale = null, this.minimumScaleMultiplier = 1, this.startColor = null, this.minLifetime = 0, this.maxLifetime = 0, this.minStartRotation = 0, this.maxStartRotation = 0, this.noRotation = !1, this.minRotationSpeed = 0, this.maxRotationSpeed = 0, this.particleBlendMode = 0, this.customEase = null, this.extraData = null, this._frequency = 1, this.spawnChance = 1, this.maxParticles = 1e3, this.emitterLifetime = -1, this.spawnPos = null, this.spawnType = null, this._spawnFunc = null, this.spawnRect = null, this.spawnCircle = null, this.spawnPolygonalChain = null, this.particlesPerWave = 1, this.particleSpacing = 0, this.angleStart = 0, this.rotation = 0, this.ownerPos = null, this._prevEmitterPos = null, this._prevPosIsValid = !1, this._posChanged = !1, this._parent = null, this.addAtBack = !1, this.particleCount = 0, this._emit = !1, this._spawnTimer = 0, this._emitterLife = -1, this._activeParticlesFirst = null, this._activeParticlesLast = null, this._poolFirst = null, this._origConfig = null, this._origArt = null, this._autoUpdate = !1, this._destroyWhenComplete = !1, this._completeCallback = null, this.parent = t, e && i && this.init(e, i), this.recycle = this.recycle, this.update = this.update, this.rotate = this.rotate, this.updateSpawnPos = this.updateSpawnPos, this.updateOwnerPos = this.updateOwnerPos
						}
						return Object.defineProperty(t.prototype, "frequency", {
							get: function() {
								return this._frequency
							},
							set: function(t) {
								this._frequency = "number" == typeof t && t > 0 ? t : 1
							},
							enumerable: !0,
							configurable: !0
						}), Object.defineProperty(t.prototype, "particleConstructor", {
							get: function() {
								return this._particleConstructor
							},
							set: function(t) {
								if (t != this._particleConstructor) {
									this._particleConstructor = t, this.cleanup();
									for (var e = this._poolFirst; e; e = e.next) e.destroy();
									this._poolFirst = null, this._origConfig && this._origArt && this.init(this._origArt, this._origConfig)
								}
							},
							enumerable: !0,
							configurable: !0
						}), Object.defineProperty(t.prototype, "parent", {
							get: function() {
								return this._parent
							},
							set: function(t) {
								this.cleanup(), this._parent = t
							},
							enumerable: !0,
							configurable: !0
						}), t.prototype.init = function(t, e) {
							if (t && e) {
								this.cleanup(), this._origConfig = e, this._origArt = t, t = Array.isArray(t) ? t.slice() : [t];
								var i = this._particleConstructor;
								this.particleImages = i.parseArt ? i.parseArt(t) : t, e.alpha ? this.startAlpha = o.createList(e.alpha) : this.startAlpha = new o(1, 0), e.speed ? (this.startSpeed = o.createList(e.speed), this.minimumSpeedMultiplier = ("minimumSpeedMultiplier" in e ? e.minimumSpeedMultiplier : e.speed.minimumSpeedMultiplier) || 1) : (this.minimumSpeedMultiplier = 1, this.startSpeed = new o(0, 0));
								var r, a = e.acceleration;
								switch (a && (a.x || a.y) ? (this.startSpeed.next = null, this.acceleration = new s.Point(a.x, a.y), this.maxSpeed = e.maxSpeed || NaN) : this.acceleration = new s.Point, e.scale ? (this.startScale = o.createList(e.scale), this.minimumScaleMultiplier = ("minimumScaleMultiplier" in e ? e.minimumScaleMultiplier : e.scale.minimumScaleMultiplier) || 1) : (this.startScale = new o(1, 0), this.minimumScaleMultiplier = 1), e.color ? this.startColor = o.createList(e.color) : this.startColor = new o({
										r: 255,
										g: 255,
										b: 255
									}, 0), e.startRotation ? (this.minStartRotation = e.startRotation.min, this.maxStartRotation = e.startRotation.max) : this.minStartRotation = this.maxStartRotation = 0, e.noRotation && (this.minStartRotation || this.maxStartRotation) ? this.noRotation = !!e.noRotation : this.noRotation = !1, e.rotationSpeed ? (this.minRotationSpeed = e.rotationSpeed.min, this.maxRotationSpeed = e.rotationSpeed.max) : this.minRotationSpeed = this.maxRotationSpeed = 0, this.rotationAcceleration = e.rotationAcceleration || 0, this.minLifetime = e.lifetime.min, this.maxLifetime = e.lifetime.max, this.particleBlendMode = n.getBlendMode(e.blendMode), e.ease ? this.customEase = "function" == typeof e.ease ? e.ease : n.generateEase(e.ease) : this.customEase = null, i.parseData ? this.extraData = i.parseData(e.extraData) : this.extraData = e.extraData || null, this.spawnRect = this.spawnCircle = null, this.particlesPerWave = 1, e.particlesPerWave && e.particlesPerWave > 1 && (this.particlesPerWave = e.particlesPerWave), this.particleSpacing = 0, this.angleStart = 0, e.spawnType) {
									case "rect":
										this.spawnType = "rect", this._spawnFunc = this._spawnRect;
										var l = e.spawnRect;
										this.spawnRect = new s.Rectangle(l.x, l.y, l.w, l.h);
										break;
									case "circle":
										this.spawnType = "circle", this._spawnFunc = this._spawnCircle, r = e.spawnCircle, this.spawnCircle = new s.Circle(r.x, r.y, r.r);
										break;
									case "ring":
										this.spawnType = "ring", this._spawnFunc = this._spawnRing, r = e.spawnCircle, this.spawnCircle = new s.Circle(r.x, r.y, r.r), this.spawnCircle.minRadius = r.minR;
										break;
									case "burst":
										this.spawnType = "burst", this._spawnFunc = this._spawnBurst, this.particleSpacing = e.particleSpacing, this.angleStart = e.angleStart ? e.angleStart : 0;
										break;
									case "point":
									default:
										this.spawnType = "point", this._spawnFunc = this._spawnPoint;
										break;
									case "polygonalChain":
										this.spawnType = "polygonalChain", this._spawnFunc = this._spawnPolygonalChain, this.spawnPolygonalChain = new f(e.spawnPolygon)
								}
								this.frequency = e.frequency, this.spawnChance = "number" == typeof e.spawnChance && e.spawnChance > 0 ? e.spawnChance : 1, this.emitterLifetime = e.emitterLifetime || -1, this.maxParticles = e.maxParticles > 0 ? e.maxParticles : 1e3, this.addAtBack = !!e.addAtBack, this.rotation = 0, this.ownerPos = new s.Point, this.spawnPos = new s.Point(e.pos.x, e.pos.y), this._prevEmitterPos = this.spawnPos.clone(), this._prevPosIsValid = !1, this._spawnTimer = 0, this.emit = void 0 === e.emit || !!e.emit, this.autoUpdate = !!e.autoUpdate
							}
						}, t.prototype.recycle = function(t) {
							t.next && (t.next.prev = t.prev), t.prev && (t.prev.next = t.next), t == this._activeParticlesLast && (this._activeParticlesLast = t.prev), t == this._activeParticlesFirst && (this._activeParticlesFirst = t.next), t.prev = null, t.next = this._poolFirst, this._poolFirst = t, t.parent && t.parent.removeChild(t), --this.particleCount
						}, t.prototype.rotate = function(t) {
							if (this.rotation != t) {
								var e = t - this.rotation;
								this.rotation = t, n.rotatePoint(e, this.spawnPos), this._posChanged = !0
							}
						}, t.prototype.updateSpawnPos = function(t, e) {
							this._posChanged = !0, this.spawnPos.x = t, this.spawnPos.y = e
						}, t.prototype.updateOwnerPos = function(t, e) {
							this._posChanged = !0, this.ownerPos.x = t, this.ownerPos.y = e
						}, t.prototype.resetPositionTracking = function() {
							this._prevPosIsValid = !1
						}, Object.defineProperty(t.prototype, "emit", {
							get: function() {
								return this._emit
							},
							set: function(t) {
								this._emit = !!t, this._emitterLife = this.emitterLifetime
							},
							enumerable: !0,
							configurable: !0
						}), Object.defineProperty(t.prototype, "autoUpdate", {
							get: function() {
								return this._autoUpdate
							},
							set: function(t) {
								this._autoUpdate && !t ? m.remove(this.update, this) : !this._autoUpdate && t && m.add(this.update, this), this._autoUpdate = !!t
							},
							enumerable: !0,
							configurable: !0
						}), t.prototype.playOnceAndDestroy = function(t) {
							this.autoUpdate = !0, this.emit = !0, this._destroyWhenComplete = !0, this._completeCallback = t
						}, t.prototype.playOnce = function(t) {
							this.emit = !0, this._completeCallback = t
						}, t.prototype.update = function(t) {
							if (this._autoUpdate && (t = t / s.settings.TARGET_FPMS / 1e3), this._parent) {
								var e, i, n, o, r;
								for (i = this._activeParticlesFirst; i; i = n) n = i.next, i.update(t);
								this._prevPosIsValid && (o = this._prevEmitterPos.x, r = this._prevEmitterPos.y);
								var a = this.ownerPos.x + this.spawnPos.x,
									l = this.ownerPos.y + this.spawnPos.y;
								if (this._emit)
									for (this._spawnTimer -= t < 0 ? 0 : t; this._spawnTimer <= 0;) {
										if (this._emitterLife > 0 && (this._emitterLife -= this._frequency, this._emitterLife <= 0)) {
											this._spawnTimer = 0, this._emitterLife = 0, this.emit = !1;
											break
										}
										if (this.particleCount >= this.maxParticles) this._spawnTimer += this._frequency;
										else {
											var h;
											if (h = this.minLifetime == this.maxLifetime ? this.minLifetime : Math.random() * (this.maxLifetime - this.minLifetime) + this.minLifetime, -this._spawnTimer < h) {
												var u = void 0,
													c = void 0;
												if (this._prevPosIsValid && this._posChanged) {
													var d = 1 + this._spawnTimer / t;
													u = (a - o) * d + o, c = (l - r) * d + r
												} else u = a, c = l;
												e = 0;
												for (var p = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount); e < p; ++e)
													if (!(this.spawnChance < 1 && Math.random() >= this.spawnChance)) {
														var _ = void 0;
														if (this._poolFirst ? (_ = this._poolFirst, this._poolFirst = this._poolFirst.next, _.next = null) : _ = new this.particleConstructor(this), this.particleImages.length > 1 ? _.applyArt(this.particleImages[Math.floor(Math.random() * this.particleImages.length)]) : _.applyArt(this.particleImages[0]), _.alphaList.reset(this.startAlpha), 1 != this.minimumSpeedMultiplier && (_.speedMultiplier = Math.random() * (1 - this.minimumSpeedMultiplier) + this.minimumSpeedMultiplier), _.speedList.reset(this.startSpeed), _.acceleration.x = this.acceleration.x, _.acceleration.y = this.acceleration.y, _.maxSpeed = this.maxSpeed, 1 != this.minimumScaleMultiplier && (_.scaleMultiplier = Math.random() * (1 - this.minimumScaleMultiplier) + this.minimumScaleMultiplier), _.scaleList.reset(this.startScale), _.colorList.reset(this.startColor), this.minRotationSpeed == this.maxRotationSpeed ? _.rotationSpeed = this.minRotationSpeed : _.rotationSpeed = Math.random() * (this.maxRotationSpeed - this.minRotationSpeed) + this.minRotationSpeed, _.rotationAcceleration = this.rotationAcceleration, _.noRotation = this.noRotation, _.maxLife = h, _.blendMode = this.particleBlendMode, _.ease = this.customEase, _.extraData = this.extraData, this._spawnFunc(_, u, c, e), _.init(), _.update(-this._spawnTimer), _.parent) {
															var m = this._parent.children;
															if (m[0] == _) m.shift();
															else if (m[m.length - 1] == _) m.pop();
															else {
																var g = m.indexOf(_);
																m.splice(g, 1)
															}
															this.addAtBack ? m.unshift(_) : m.push(_)
														} else this.addAtBack ? this._parent.addChildAt(_, 0) : this._parent.addChild(_);
														this._activeParticlesLast ? (this._activeParticlesLast.next = _, _.prev = this._activeParticlesLast, this._activeParticlesLast = _) : this._activeParticlesLast = this._activeParticlesFirst = _, ++this.particleCount
													}
											}
											this._spawnTimer += this._frequency
										}
									}
								if (this._posChanged && (this._prevEmitterPos.x = a, this._prevEmitterPos.y = l, this._prevPosIsValid = !0, this._posChanged = !1), !this._emit && !this._activeParticlesFirst) {
									if (this._completeCallback) {
										var f = this._completeCallback;
										this._completeCallback = null, f()
									}
									this._destroyWhenComplete && this.destroy()
								}
							}
						}, t.prototype._spawnPoint = function(t, e, i) {
							this.minStartRotation == this.maxStartRotation ? t.rotation = this.minStartRotation + this.rotation : t.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation, t.position.x = e, t.position.y = i
						}, t.prototype._spawnRect = function(t, e, i) {
							this.minStartRotation == this.maxStartRotation ? t.rotation = this.minStartRotation + this.rotation : t.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation, y.x = Math.random() * this.spawnRect.width + this.spawnRect.x, y.y = Math.random() * this.spawnRect.height + this.spawnRect.y, 0 !== this.rotation && n.rotatePoint(this.rotation, y), t.position.x = e + y.x, t.position.y = i + y.y
						}, t.prototype._spawnCircle = function(t, e, i) {
							this.minStartRotation == this.maxStartRotation ? t.rotation = this.minStartRotation + this.rotation : t.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation, y.x = Math.random() * this.spawnCircle.radius, y.y = 0, n.rotatePoint(360 * Math.random(), y), y.x += this.spawnCircle.x, y.y += this.spawnCircle.y, 0 !== this.rotation && n.rotatePoint(this.rotation, y), t.position.x = e + y.x, t.position.y = i + y.y
						}, t.prototype._spawnRing = function(t, e, i) {
							var s = this.spawnCircle;
							this.minStartRotation == this.maxStartRotation ? t.rotation = this.minStartRotation + this.rotation : t.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation, s.minRadius !== s.radius ? y.x = Math.random() * (s.radius - s.minRadius) + s.minRadius : y.x = s.radius, y.y = 0;
							var o = 360 * Math.random();
							t.rotation += o, n.rotatePoint(o, y), y.x += this.spawnCircle.x, y.y += this.spawnCircle.y, 0 !== this.rotation && n.rotatePoint(this.rotation, y), t.position.x = e + y.x, t.position.y = i + y.y
						}, t.prototype._spawnPolygonalChain = function(t, e, i) {
							this.minStartRotation == this.maxStartRotation ? t.rotation = this.minStartRotation + this.rotation : t.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation, this.spawnPolygonalChain.getRandomPoint(y), 0 !== this.rotation && n.rotatePoint(this.rotation, y), t.position.x = e + y.x, t.position.y = i + y.y
						}, t.prototype._spawnBurst = function(t, e, i, n) {
							0 === this.particleSpacing ? t.rotation = 360 * Math.random() : t.rotation = this.angleStart + this.particleSpacing * n + this.rotation, t.position.x = e, t.position.y = i
						}, t.prototype.cleanup = function() {
							var t, e;
							for (t = this._activeParticlesFirst; t; t = e) e = t.next, this.recycle(t), t.parent && t.parent.removeChild(t);
							this._activeParticlesFirst = this._activeParticlesLast = null, this.particleCount = 0
						}, t.prototype.destroy = function() {
							var t;
							this.autoUpdate = !1, this.cleanup();
							for (var e = this._poolFirst; e; e = t) t = e.next, e.destroy();
							this._poolFirst = this._parent = this.particleImages = this.spawnPos = this.ownerPos = this.startColor = this.startScale = this.startAlpha = this.startSpeed = this.customEase = this._completeCallback = null
						}, t
					}(),
					T = new s.Point,
					E = ["pow", "sqrt", "abs", "floor", "round", "ceil", "E", "PI", "sin", "cos", "tan", "asin", "acos", "atan", "atan2", "log"],
					b = new RegExp(["[01234567890\\.\\*\\-\\+\\/\\(\\)x ,]"].concat(E).join("|"), "g"),
					A = function(t) {
						function e(e) {
							var i = t.call(this, e) || this;
							return i.path = null, i.initialRotation = 0, i.initialPosition = new s.Point, i.movement = 0, i
						}
						return a(e, t), e.prototype.init = function() {
							this.initialRotation = this.rotation, this.Particle_init(), this.path = this.extraData.path, this._doNormalMovement = !this.path, this.movement = 0, this.initialPosition.x = this.position.x, this.initialPosition.y = this.position.y
						}, e.prototype.update = function(t) {
							var e = this.Particle_update(t);
							if (e >= 0 && this.path) {
								var i = this.speedList.interpolate(e) * this.speedMultiplier;
								this.movement += i * t, T.x = this.movement, T.y = this.path(this.movement), n.rotatePoint(this.initialRotation, T), this.position.x = this.initialPosition.x + T.x, this.position.y = this.initialPosition.y + T.y
							}
							return e
						}, e.prototype.destroy = function() {
							this.Particle_destroy(), this.path = this.initialPosition = null
						}, e.parseArt = function(t) {
							return g.parseArt(t)
						}, e.parseData = function(t) {
							var e = {};
							if (t && t.path) try {
								e.path = function(t) {
									for (var e = t.match(b), i = e.length - 1; i >= 0; --i) E.indexOf(e[i]) >= 0 && (e[i] = "Math." + e[i]);
									return t = e.join(""), new Function("x", "return " + t + ";")
								}(t.path)
							} catch (t) {
								n.verbose && console.error("PathParticle: error in parsing path expression"), e.path = null
							} else n.verbose && console.error("PathParticle requires a path string in extraData!"), e.path = null;
							return e
						}, e
					}(g),
					P = function(t) {
						function e(e) {
							var i = t.call(this, e) || this;
							return i.textures = null, i.duration = 0, i.framerate = 0, i.elapsed = 0, i.loop = !1, i
						}
						return a(e, t), e.prototype.init = function() {
							this.Particle_init(), this.elapsed = 0, this.framerate < 0 && (this.duration = this.maxLife, this.framerate = this.textures.length / this.duration)
						}, e.prototype.applyArt = function(t) {
							this.textures = t.textures, this.framerate = t.framerate, this.duration = t.duration, this.loop = t.loop
						}, e.prototype.update = function(t) {
							var e = this.Particle_update(t);
							if (e >= 0) {
								this.elapsed += t, this.elapsed > this.duration && (this.loop ? this.elapsed = this.elapsed % this.duration : this.elapsed = this.duration - 1e-6);
								var i = this.elapsed * this.framerate + 1e-7 | 0;
								this.texture = this.textures[i] || s.Texture.EMPTY
							}
							return e
						}, e.prototype.destroy = function() {
							this.Particle_destroy(), this.textures = null
						}, e.parseArt = function(t) {
							for (var e, i, n, o, r, a = [], l = 0; l < t.length; ++l) {
								e = t[l], a[l] = i = {}, i.textures = r = [], n = e.textures;
								for (var h = 0; h < n.length; ++h)
									if ("string" == typeof(o = n[h])) r.push(s.Texture.fromImage(o));
									else if (o instanceof s.Texture) r.push(o);
								else {
									var u = o.count || 1;
									for (o = "string" == typeof o.texture ? s.Texture.fromImage(o.texture) : o.texture; u > 0; --u) r.push(o)
								}
								"matchLife" == e.framerate ? (i.framerate = -1, i.duration = 0, i.loop = !1) : (i.loop = !!e.loop, i.framerate = e.framerate > 0 ? e.framerate : 60, i.duration = r.length / i.framerate)
							}
							return a
						}, e
					}(g)
			},
			77323: function() {
				var t, e, i, n = this && this.__extends || (t = function(e, i) {
					return t = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(t, e) {
						t.__proto__ = e
					} || function(t, e) {
						for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
					}, t(e, i)
				}, function(e, i) {
					function n() {
						this.constructor = e
					}
					t(e, i), e.prototype = null === i ? Object.create(i) : (n.prototype = i.prototype, new n)
				});
				! function(t) {
					! function(t) {
						var e, i, s, o = function() {
							function t(t, e, i) {
								if (null == t) throw new Error("name cannot be null.");
								if (null == e) throw new Error("timelines cannot be null.");
								this.name = t, this.timelines = e, this.duration = i
							}
							return t.prototype.apply = function(t, e, i, n, s, o, r, a) {
								if (null == t) throw new Error("skeleton cannot be null.");
								n && 0 != this.duration && (i %= this.duration, e > 0 && (e %= this.duration));
								for (var l = this.timelines, h = 0, u = l.length; h < u; h++) l[h].apply(t, e, i, s, o, r, a)
							}, t.binarySearch = function(t, e, i) {
								void 0 === i && (i = 1);
								var n = 0,
									s = t.length / i - 2;
								if (0 == s) return i;
								for (var o = s >>> 1;;) {
									if (t[(o + 1) * i] <= e ? n = o + 1 : s = o, n == s) return (n + 1) * i;
									o = n + s >>> 1
								}
							}, t.linearSearch = function(t, e, i) {
								for (var n = 0, s = t.length - i; n <= s; n += i)
									if (t[n] > e) return n;
								return -1
							}, t
						}();
						t.Animation = o,
							function(t) {
								t[t.setup = 0] = "setup", t[t.first = 1] = "first", t[t.replace = 2] = "replace", t[t.add = 3] = "add"
							}(e = t.MixBlend || (t.MixBlend = {})),
							function(t) {
								t[t.in = 0] = "in", t[t.out = 1] = "out"
							}(i = t.MixDirection || (t.MixDirection = {})),
							function(t) {
								t[t.rotate = 0] = "rotate", t[t.translate = 1] = "translate", t[t.scale = 2] = "scale", t[t.shear = 3] = "shear", t[t.attachment = 4] = "attachment", t[t.color = 5] = "color", t[t.deform = 6] = "deform", t[t.event = 7] = "event", t[t.drawOrder = 8] = "drawOrder", t[t.ikConstraint = 9] = "ikConstraint", t[t.transformConstraint = 10] = "transformConstraint", t[t.pathConstraintPosition = 11] = "pathConstraintPosition", t[t.pathConstraintSpacing = 12] = "pathConstraintSpacing", t[t.pathConstraintMix = 13] = "pathConstraintMix", t[t.twoColor = 14] = "twoColor"
							}(s = t.TimelineType || (t.TimelineType = {}));
						var r = function() {
							function e(i) {
								if (i <= 0) throw new Error("frameCount must be > 0: " + i);
								this.curves = t.Utils.newFloatArray((i - 1) * e.BEZIER_SIZE)
							}
							return e.prototype.getFrameCount = function() {
								return this.curves.length / e.BEZIER_SIZE + 1
							}, e.prototype.setLinear = function(t) {
								this.curves[t * e.BEZIER_SIZE] = e.LINEAR
							}, e.prototype.setStepped = function(t) {
								this.curves[t * e.BEZIER_SIZE] = e.STEPPED
							}, e.prototype.getCurveType = function(t) {
								var i = t * e.BEZIER_SIZE;
								if (i == this.curves.length) return e.LINEAR;
								var n = this.curves[i];
								return n == e.LINEAR ? e.LINEAR : n == e.STEPPED ? e.STEPPED : e.BEZIER
							}, e.prototype.setCurve = function(t, i, n, s, o) {
								var r = .03 * (2 * -i + s),
									a = .03 * (2 * -n + o),
									l = .006 * (3 * (i - s) + 1),
									h = .006 * (3 * (n - o) + 1),
									u = 2 * r + l,
									c = 2 * a + h,
									d = .3 * i + r + .16666667 * l,
									p = .3 * n + a + .16666667 * h,
									_ = t * e.BEZIER_SIZE,
									m = this.curves;
								m[_++] = e.BEZIER;
								for (var g = d, f = p, S = _ + e.BEZIER_SIZE - 1; _ < S; _ += 2) m[_] = g, m[_ + 1] = f, d += u, p += c, u += l, c += h, g += d, f += p
							}, e.prototype.getCurvePercent = function(i, n) {
								n = t.MathUtils.clamp(n, 0, 1);
								var s = this.curves,
									o = i * e.BEZIER_SIZE,
									r = s[o];
								if (r == e.LINEAR) return n;
								if (r == e.STEPPED) return 0;
								for (var a = 0, l = ++o, h = o + e.BEZIER_SIZE - 1; o < h; o += 2)
									if ((a = s[o]) >= n) {
										var u = void 0,
											c = void 0;
										return o == l ? (u = 0, c = 0) : (u = s[o - 2], c = s[o - 1]), c + (s[o + 1] - c) * (n - u) / (a - u)
									} var d = s[o - 1];
								return d + (1 - d) * (n - a) / (1 - a)
							}, e.LINEAR = 0, e.STEPPED = 1, e.BEZIER = 2, e.BEZIER_SIZE = 19, e
						}();
						t.CurveTimeline = r;
						var a = function(i) {
							function r(e) {
								var n = i.call(this, e) || this;
								return n.frames = t.Utils.newFloatArray(e << 1), n
							}
							return n(r, i), r.prototype.getPropertyId = function() {
								return (s.rotate << 24) + this.boneIndex
							}, r.prototype.setFrame = function(t, e, i) {
								t <<= 1, this.frames[t] = e, this.frames[t + r.ROTATION] = i
							}, r.prototype.apply = function(t, i, n, s, a, l, h) {
								var u = this.frames,
									c = t.bones[this.boneIndex];
								if (n < u[0]) switch (l) {
									case e.setup:
										return void(c.rotation = c.data.rotation);
									case e.first:
										var d = c.data.rotation - c.rotation;
										c.rotation += (d - 360 * (16384 - (16384.499999999996 - d / 360 | 0))) * a
								} else if (n >= u[u.length - r.ENTRIES]) {
									var p = u[u.length + r.PREV_ROTATION];
									switch (l) {
										case e.setup:
											c.rotation = c.data.rotation + p * a;
											break;
										case e.first:
										case e.replace:
											p += c.data.rotation - c.rotation, p -= 360 * (16384 - (16384.499999999996 - p / 360 | 0));
										case e.add:
											c.rotation += p * a
									}
								} else {
									var _ = o.binarySearch(u, n, r.ENTRIES),
										m = u[_ + r.PREV_ROTATION],
										g = u[_],
										f = this.getCurvePercent((_ >> 1) - 1, 1 - (n - g) / (u[_ + r.PREV_TIME] - g)),
										S = u[_ + r.ROTATION] - m;
									switch (S = m + (S - 360 * (16384 - (16384.499999999996 - S / 360 | 0))) * f, l) {
										case e.setup:
											c.rotation = c.data.rotation + (S - 360 * (16384 - (16384.499999999996 - S / 360 | 0))) * a;
											break;
										case e.first:
										case e.replace:
											S += c.data.rotation - c.rotation;
										case e.add:
											c.rotation += (S - 360 * (16384 - (16384.499999999996 - S / 360 | 0))) * a
									}
								}
							}, r.ENTRIES = 2, r.PREV_TIME = -2, r.PREV_ROTATION = -1, r.ROTATION = 1, r
						}(r);
						t.RotateTimeline = a;
						var l = function(i) {
							function r(e) {
								var n = i.call(this, e) || this;
								return n.frames = t.Utils.newFloatArray(e * r.ENTRIES), n
							}
							return n(r, i), r.prototype.getPropertyId = function() {
								return (s.translate << 24) + this.boneIndex
							}, r.prototype.setFrame = function(t, e, i, n) {
								t *= r.ENTRIES, this.frames[t] = e, this.frames[t + r.X] = i, this.frames[t + r.Y] = n
							}, r.prototype.apply = function(t, i, n, s, a, l, h) {
								var u = this.frames,
									c = t.bones[this.boneIndex];
								if (n < u[0]) switch (l) {
									case e.setup:
										return c.x = c.data.x, void(c.y = c.data.y);
									case e.first:
										c.x += (c.data.x - c.x) * a, c.y += (c.data.y - c.y) * a
								} else {
									var d = 0,
										p = 0;
									if (n >= u[u.length - r.ENTRIES]) d = u[u.length + r.PREV_X], p = u[u.length + r.PREV_Y];
									else {
										var _ = o.binarySearch(u, n, r.ENTRIES);
										d = u[_ + r.PREV_X], p = u[_ + r.PREV_Y];
										var m = u[_],
											g = this.getCurvePercent(_ / r.ENTRIES - 1, 1 - (n - m) / (u[_ + r.PREV_TIME] - m));
										d += (u[_ + r.X] - d) * g, p += (u[_ + r.Y] - p) * g
									}
									switch (l) {
										case e.setup:
											c.x = c.data.x + d * a, c.y = c.data.y + p * a;
											break;
										case e.first:
										case e.replace:
											c.x += (c.data.x + d - c.x) * a, c.y += (c.data.y + p - c.y) * a;
											break;
										case e.add:
											c.x += d * a, c.y += p * a
									}
								}
							}, r.ENTRIES = 3, r.PREV_TIME = -3, r.PREV_X = -2, r.PREV_Y = -1, r.X = 1, r.Y = 2, r
						}(r);
						t.TranslateTimeline = l;
						var h = function(r) {
							function a(t) {
								return r.call(this, t) || this
							}
							return n(a, r), a.prototype.getPropertyId = function() {
								return (s.scale << 24) + this.boneIndex
							}, a.prototype.apply = function(n, s, r, l, h, u, c) {
								var d = this.frames,
									p = n.bones[this.boneIndex];
								if (r < d[0]) switch (u) {
									case e.setup:
										return p.scaleX = p.data.scaleX, void(p.scaleY = p.data.scaleY);
									case e.first:
										p.scaleX += (p.data.scaleX - p.scaleX) * h, p.scaleY += (p.data.scaleY - p.scaleY) * h
								} else {
									var _ = 0,
										m = 0;
									if (r >= d[d.length - a.ENTRIES]) _ = d[d.length + a.PREV_X] * p.data.scaleX, m = d[d.length + a.PREV_Y] * p.data.scaleY;
									else {
										var g = o.binarySearch(d, r, a.ENTRIES);
										_ = d[g + a.PREV_X], m = d[g + a.PREV_Y];
										var f = d[g],
											S = this.getCurvePercent(g / a.ENTRIES - 1, 1 - (r - f) / (d[g + a.PREV_TIME] - f));
										_ = (_ + (d[g + a.X] - _) * S) * p.data.scaleX, m = (m + (d[g + a.Y] - m) * S) * p.data.scaleY
									}
									if (1 == h) u == e.add ? (p.scaleX += _ - p.data.scaleX, p.scaleY += m - p.data.scaleY) : (p.scaleX = _, p.scaleY = m);
									else {
										var y = 0,
											v = 0;
										if (c == i.out) switch (u) {
											case e.setup:
												y = p.data.scaleX, v = p.data.scaleY, p.scaleX = y + (Math.abs(_) * t.MathUtils.signum(y) - y) * h, p.scaleY = v + (Math.abs(m) * t.MathUtils.signum(v) - v) * h;
												break;
											case e.first:
											case e.replace:
												y = p.scaleX, v = p.scaleY, p.scaleX = y + (Math.abs(_) * t.MathUtils.signum(y) - y) * h, p.scaleY = v + (Math.abs(m) * t.MathUtils.signum(v) - v) * h;
												break;
											case e.add:
												y = p.scaleX, v = p.scaleY, p.scaleX = y + (Math.abs(_) * t.MathUtils.signum(y) - p.data.scaleX) * h, p.scaleY = v + (Math.abs(m) * t.MathUtils.signum(v) - p.data.scaleY) * h
										} else switch (u) {
											case e.setup:
												y = Math.abs(p.data.scaleX) * t.MathUtils.signum(_), v = Math.abs(p.data.scaleY) * t.MathUtils.signum(m), p.scaleX = y + (_ - y) * h, p.scaleY = v + (m - v) * h;
												break;
											case e.first:
											case e.replace:
												y = Math.abs(p.scaleX) * t.MathUtils.signum(_), v = Math.abs(p.scaleY) * t.MathUtils.signum(m), p.scaleX = y + (_ - y) * h, p.scaleY = v + (m - v) * h;
												break;
											case e.add:
												y = t.MathUtils.signum(_), v = t.MathUtils.signum(m), p.scaleX = Math.abs(p.scaleX) * y + (_ - Math.abs(p.data.scaleX) * y) * h, p.scaleY = Math.abs(p.scaleY) * v + (m - Math.abs(p.data.scaleY) * v) * h
										}
									}
								}
							}, a
						}(l);
						t.ScaleTimeline = h;
						var u = function(t) {
							function i(e) {
								return t.call(this, e) || this
							}
							return n(i, t), i.prototype.getPropertyId = function() {
								return (s.shear << 24) + this.boneIndex
							}, i.prototype.apply = function(t, n, s, r, a, l, h) {
								var u = this.frames,
									c = t.bones[this.boneIndex];
								if (s < u[0]) switch (l) {
									case e.setup:
										return c.shearX = c.data.shearX, void(c.shearY = c.data.shearY);
									case e.first:
										c.shearX += (c.data.shearX - c.shearX) * a, c.shearY += (c.data.shearY - c.shearY) * a
								} else {
									var d = 0,
										p = 0;
									if (s >= u[u.length - i.ENTRIES]) d = u[u.length + i.PREV_X], p = u[u.length + i.PREV_Y];
									else {
										var _ = o.binarySearch(u, s, i.ENTRIES);
										d = u[_ + i.PREV_X], p = u[_ + i.PREV_Y];
										var m = u[_],
											g = this.getCurvePercent(_ / i.ENTRIES - 1, 1 - (s - m) / (u[_ + i.PREV_TIME] - m));
										d += (u[_ + i.X] - d) * g, p += (u[_ + i.Y] - p) * g
									}
									switch (l) {
										case e.setup:
											c.shearX = c.data.shearX + d * a, c.shearY = c.data.shearY + p * a;
											break;
										case e.first:
										case e.replace:
											c.shearX += (c.data.shearX + d - c.shearX) * a, c.shearY += (c.data.shearY + p - c.shearY) * a;
											break;
										case e.add:
											c.shearX += d * a, c.shearY += p * a
									}
								}
							}, i
						}(l);
						t.ShearTimeline = u;
						var c = function(i) {
							function r(e) {
								var n = i.call(this, e) || this;
								return n.frames = t.Utils.newFloatArray(e * r.ENTRIES), n
							}
							return n(r, i), r.prototype.getPropertyId = function() {
								return (s.color << 24) + this.slotIndex
							}, r.prototype.setFrame = function(t, e, i, n, s, o) {
								t *= r.ENTRIES, this.frames[t] = e, this.frames[t + r.R] = i, this.frames[t + r.G] = n, this.frames[t + r.B] = s, this.frames[t + r.A] = o
							}, r.prototype.apply = function(t, i, n, s, a, l, h) {
								var u = t.slots[this.slotIndex],
									c = this.frames;
								if (n < c[0]) switch (l) {
									case e.setup:
										return void u.color.setFromColor(u.data.color);
									case e.first:
										var d = u.color,
											p = u.data.color;
										d.add((p.r - d.r) * a, (p.g - d.g) * a, (p.b - d.b) * a, (p.a - d.a) * a)
								} else {
									var _ = 0,
										m = 0,
										g = 0,
										f = 0;
									if (n >= c[c.length - r.ENTRIES]) {
										var S = c.length;
										_ = c[S + r.PREV_R], m = c[S + r.PREV_G], g = c[S + r.PREV_B], f = c[S + r.PREV_A]
									} else {
										var y = o.binarySearch(c, n, r.ENTRIES);
										_ = c[y + r.PREV_R], m = c[y + r.PREV_G], g = c[y + r.PREV_B], f = c[y + r.PREV_A];
										var v = c[y],
											T = this.getCurvePercent(y / r.ENTRIES - 1, 1 - (n - v) / (c[y + r.PREV_TIME] - v));
										_ += (c[y + r.R] - _) * T, m += (c[y + r.G] - m) * T, g += (c[y + r.B] - g) * T, f += (c[y + r.A] - f) * T
									}
									1 == a ? u.color.set(_, m, g, f) : (d = u.color, l == e.setup && d.setFromColor(u.data.color), d.add((_ - d.r) * a, (m - d.g) * a, (g - d.b) * a, (f - d.a) * a))
								}
							}, r.ENTRIES = 5, r.PREV_TIME = -5, r.PREV_R = -4, r.PREV_G = -3, r.PREV_B = -2, r.PREV_A = -1, r.R = 1, r.G = 2, r.B = 3, r.A = 4, r
						}(r);
						t.ColorTimeline = c;
						var d = function(i) {
							function r(e) {
								var n = i.call(this, e) || this;
								return n.frames = t.Utils.newFloatArray(e * r.ENTRIES), n
							}
							return n(r, i), r.prototype.getPropertyId = function() {
								return (s.twoColor << 24) + this.slotIndex
							}, r.prototype.setFrame = function(t, e, i, n, s, o, a, l, h) {
								t *= r.ENTRIES, this.frames[t] = e, this.frames[t + r.R] = i, this.frames[t + r.G] = n, this.frames[t + r.B] = s, this.frames[t + r.A] = o, this.frames[t + r.R2] = a, this.frames[t + r.G2] = l, this.frames[t + r.B2] = h
							}, r.prototype.apply = function(t, i, n, s, a, l, h) {
								var u = t.slots[this.slotIndex],
									c = this.frames;
								if (n < c[0]) switch (l) {
									case e.setup:
										return u.color.setFromColor(u.data.color), void u.darkColor.setFromColor(u.data.darkColor);
									case e.first:
										var d = u.color,
											p = u.darkColor,
											_ = u.data.color,
											m = u.data.darkColor;
										d.add((_.r - d.r) * a, (_.g - d.g) * a, (_.b - d.b) * a, (_.a - d.a) * a), p.add((m.r - p.r) * a, (m.g - p.g) * a, (m.b - p.b) * a, 0)
								} else {
									var g = 0,
										f = 0,
										S = 0,
										y = 0,
										v = 0,
										T = 0,
										E = 0;
									if (n >= c[c.length - r.ENTRIES]) {
										var b = c.length;
										g = c[b + r.PREV_R], f = c[b + r.PREV_G], S = c[b + r.PREV_B], y = c[b + r.PREV_A], v = c[b + r.PREV_R2], T = c[b + r.PREV_G2], E = c[b + r.PREV_B2]
									} else {
										var A = o.binarySearch(c, n, r.ENTRIES);
										g = c[A + r.PREV_R], f = c[A + r.PREV_G], S = c[A + r.PREV_B], y = c[A + r.PREV_A], v = c[A + r.PREV_R2], T = c[A + r.PREV_G2], E = c[A + r.PREV_B2];
										var P = c[A],
											I = this.getCurvePercent(A / r.ENTRIES - 1, 1 - (n - P) / (c[A + r.PREV_TIME] - P));
										g += (c[A + r.R] - g) * I, f += (c[A + r.G] - f) * I, S += (c[A + r.B] - S) * I, y += (c[A + r.A] - y) * I, v += (c[A + r.R2] - v) * I, T += (c[A + r.G2] - T) * I, E += (c[A + r.B2] - E) * I
									}
									1 == a ? (u.color.set(g, f, S, y), u.darkColor.set(v, T, E, 1)) : (d = u.color, p = u.darkColor, l == e.setup && (d.setFromColor(u.data.color), p.setFromColor(u.data.darkColor)), d.add((g - d.r) * a, (f - d.g) * a, (S - d.b) * a, (y - d.a) * a), p.add((v - p.r) * a, (T - p.g) * a, (E - p.b) * a, 0))
								}
							}, r.ENTRIES = 8, r.PREV_TIME = -8, r.PREV_R = -7, r.PREV_G = -6, r.PREV_B = -5, r.PREV_A = -4, r.PREV_R2 = -3, r.PREV_G2 = -2, r.PREV_B2 = -1, r.R = 1, r.G = 2, r.B = 3, r.A = 4, r.R2 = 5, r.G2 = 6, r.B2 = 7, r
						}(r);
						t.TwoColorTimeline = d;
						var p = function() {
							function n(e) {
								this.frames = t.Utils.newFloatArray(e), this.attachmentNames = new Array(e)
							}
							return n.prototype.getPropertyId = function() {
								return (s.attachment << 24) + this.slotIndex
							}, n.prototype.getFrameCount = function() {
								return this.frames.length
							}, n.prototype.setFrame = function(t, e, i) {
								this.frames[t] = e, this.attachmentNames[t] = i
							}, n.prototype.apply = function(t, n, s, r, a, l, h) {
								var u = t.slots[this.slotIndex];
								if (h != i.out || l != e.setup) {
									var c = this.frames;
									if (s < c[0]) {
										if (l == e.setup || l == e.first) {
											var d = u.data.attachmentName;
											u.setAttachment(null == d ? null : t.getAttachment(this.slotIndex, d))
										}
									} else {
										var p;
										p = s >= c[c.length - 1] ? c.length - 1 : o.binarySearch(c, s, 1) - 1;
										var _ = this.attachmentNames[p];
										t.slots[this.slotIndex].setAttachment(null == _ ? null : t.getAttachment(this.slotIndex, _))
									}
								} else {
									var m = u.data.attachmentName;
									u.setAttachment(null == m ? null : t.getAttachment(this.slotIndex, m))
								}
							}, n
						}();
						t.AttachmentTimeline = p;
						var _ = null,
							m = function(i) {
								function r(e) {
									var n = i.call(this, e) || this;
									return n.frames = t.Utils.newFloatArray(e), n.frameVertices = new Array(e), null == _ && (_ = t.Utils.newFloatArray(64)), n
								}
								return n(r, i), r.prototype.getPropertyId = function() {
									return (s.deform << 27) + +this.attachment.id + this.slotIndex
								}, r.prototype.setFrame = function(t, e, i) {
									this.frames[t] = e, this.frameVertices[t] = i
								}, r.prototype.apply = function(i, n, s, r, a, l, h) {
									var u = i.slots[this.slotIndex],
										c = u.getAttachment();
									if (c instanceof t.VertexAttachment && c.applyDeform(this.attachment)) {
										var d = u.attachmentVertices;
										0 == d.length && (l = e.setup);
										var p = this.frameVertices,
											_ = p[0].length,
											m = this.frames;
										if (s < m[0]) {
											var g = c;
											switch (l) {
												case e.setup:
													return void(d.length = 0);
												case e.first:
													if (1 == a) {
														d.length = 0;
														break
													}
													var f = t.Utils.setArraySize(d, _);
													if (null == g.bones)
														for (var S = g.vertices, y = 0; y < _; y++) f[y] += (S[y] - f[y]) * a;
													else
														for (a = 1 - a, y = 0; y < _; y++) f[y] *= a
											}
										} else {
											var v = t.Utils.setArraySize(d, _);
											if (s >= m[m.length - 1]) {
												var T = p[m.length - 1];
												if (1 == a)
													if (l == e.add)
														if (null == (g = c).bones)
															for (S = g.vertices, y = 0; y < _; y++) v[y] += T[y] - S[y];
														else
															for (y = 0; y < _; y++) v[y] += T[y];
												else t.Utils.arrayCopy(T, 0, v, 0, _);
												else switch (l) {
													case e.setup:
														var E = c;
														if (null == E.bones)
															for (S = E.vertices, y = 0; y < _; y++) {
																var b = S[y];
																v[y] = b + (T[y] - b) * a
															} else
																for (y = 0; y < _; y++) v[y] = T[y] * a;
														break;
													case e.first:
													case e.replace:
														for (y = 0; y < _; y++) v[y] += (T[y] - v[y]) * a;
													case e.add:
														if (null == (g = c).bones)
															for (S = g.vertices, y = 0; y < _; y++) v[y] += (T[y] - S[y]) * a;
														else
															for (y = 0; y < _; y++) v[y] += T[y] * a
												}
											} else {
												var A = o.binarySearch(m, s),
													P = p[A - 1],
													I = p[A],
													w = m[A],
													L = this.getCurvePercent(A - 1, 1 - (s - w) / (m[A - 1] - w));
												if (1 == a)
													if (l == e.add)
														if (null == (g = c).bones)
															for (S = g.vertices, y = 0; y < _; y++) {
																var C = P[y];
																v[y] += C + (I[y] - C) * L - S[y]
															} else
																for (y = 0; y < _; y++) C = P[y], v[y] += C + (I[y] - C) * L;
														else
															for (y = 0; y < _; y++) C = P[y], v[y] = C + (I[y] - C) * L;
												else switch (l) {
													case e.setup:
														var x = c;
														if (null == x.bones)
															for (S = x.vertices, y = 0; y < _; y++) C = P[y], b = S[y], v[y] = b + (C + (I[y] - C) * L - b) * a;
														else
															for (y = 0; y < _; y++) C = P[y], v[y] = (C + (I[y] - C) * L) * a;
														break;
													case e.first:
													case e.replace:
														for (y = 0; y < _; y++) C = P[y], v[y] += (C + (I[y] - C) * L - v[y]) * a;
														break;
													case e.add:
														if (null == (g = c).bones)
															for (S = g.vertices, y = 0; y < _; y++) C = P[y], v[y] += (C + (I[y] - C) * L - S[y]) * a;
														else
															for (y = 0; y < _; y++) C = P[y], v[y] += (C + (I[y] - C) * L) * a
												}
											}
										}
									}
								}, r
							}(r);
						t.DeformTimeline = m;
						var g = function() {
							function e(e) {
								this.frames = t.Utils.newFloatArray(e), this.events = new Array(e)
							}
							return e.prototype.getPropertyId = function() {
								return s.event << 24
							}, e.prototype.getFrameCount = function() {
								return this.frames.length
							}, e.prototype.setFrame = function(t, e) {
								this.frames[t] = e.time, this.events[t] = e
							}, e.prototype.apply = function(t, e, i, n, s, r, a) {
								if (null != n) {
									var l = this.frames,
										h = this.frames.length;
									if (e > i) this.apply(t, e, Number.MAX_VALUE, n, s, r, a), e = -1;
									else if (e >= l[h - 1]) return;
									if (!(i < l[0])) {
										var u = 0;
										if (e < l[0]) u = 0;
										else
											for (var c = l[u = o.binarySearch(l, e)]; u > 0 && l[u - 1] == c;) u--;
										for (; u < h && i >= l[u]; u++) n.push(this.events[u])
									}
								}
							}, e
						}();
						t.EventTimeline = g;
						var f = function() {
							function n(e) {
								this.frames = t.Utils.newFloatArray(e), this.drawOrders = new Array(e)
							}
							return n.prototype.getPropertyId = function() {
								return s.drawOrder << 24
							}, n.prototype.getFrameCount = function() {
								return this.frames.length
							}, n.prototype.setFrame = function(t, e, i) {
								this.frames[t] = e, this.drawOrders[t] = i
							}, n.prototype.apply = function(n, s, r, a, l, h, u) {
								var c = n.drawOrder,
									d = n.slots;
								if (u != i.out || h != e.setup) {
									var p = this.frames;
									if (r < p[0]) h != e.setup && h != e.first || t.Utils.arrayCopy(n.slots, 0, n.drawOrder, 0, n.slots.length);
									else {
										var _;
										_ = r >= p[p.length - 1] ? p.length - 1 : o.binarySearch(p, r) - 1;
										var m = this.drawOrders[_];
										if (null == m) t.Utils.arrayCopy(d, 0, c, 0, d.length);
										else
											for (var g = 0, f = m.length; g < f; g++) c[g] = d[m[g]]
									}
								} else t.Utils.arrayCopy(n.slots, 0, n.drawOrder, 0, n.slots.length)
							}, n
						}();
						t.DrawOrderTimeline = f;
						var S = function(r) {
							function a(e) {
								var i = r.call(this, e) || this;
								return i.frames = t.Utils.newFloatArray(e * a.ENTRIES), i
							}
							return n(a, r), a.prototype.getPropertyId = function() {
								return (s.ikConstraint << 24) + this.ikConstraintIndex
							}, a.prototype.setFrame = function(t, e, i, n, s, o) {
								t *= a.ENTRIES, this.frames[t] = e, this.frames[t + a.MIX] = i, this.frames[t + a.BEND_DIRECTION] = n, this.frames[t + a.COMPRESS] = s ? 1 : 0, this.frames[t + a.STRETCH] = o ? 1 : 0
							}, a.prototype.apply = function(t, n, s, r, l, h, u) {
								var c = this.frames,
									d = t.ikConstraints[this.ikConstraintIndex];
								if (s < c[0]) switch (h) {
										case e.setup:
											return d.mix = d.data.mix, d.bendDirection = d.data.bendDirection, d.compress = d.data.compress, void(d.stretch = d.data.stretch);
										case e.first:
											d.mix += (d.data.mix - d.mix) * l, d.bendDirection = d.data.bendDirection, d.compress = d.data.compress, d.stretch = d.data.stretch
									} else if (s >= c[c.length - a.ENTRIES]) h == e.setup ? (d.mix = d.data.mix + (c[c.length + a.PREV_MIX] - d.data.mix) * l, u == i.out ? (d.bendDirection = d.data.bendDirection, d.compress = d.data.compress, d.stretch = d.data.stretch) : (d.bendDirection = c[c.length + a.PREV_BEND_DIRECTION], d.compress = 0 != c[c.length + a.PREV_COMPRESS], d.stretch = 0 != c[c.length + a.PREV_STRETCH])) : (d.mix += (c[c.length + a.PREV_MIX] - d.mix) * l, u == i.in && (d.bendDirection = c[c.length + a.PREV_BEND_DIRECTION], d.compress = 0 != c[c.length + a.PREV_COMPRESS], d.stretch = 0 != c[c.length + a.PREV_STRETCH]));
									else {
										var p = o.binarySearch(c, s, a.ENTRIES),
											_ = c[p + a.PREV_MIX],
											m = c[p],
											g = this.getCurvePercent(p / a.ENTRIES - 1, 1 - (s - m) / (c[p + a.PREV_TIME] - m));
										h == e.setup ? (d.mix = d.data.mix + (_ + (c[p + a.MIX] - _) * g - d.data.mix) * l, u == i.out ? (d.bendDirection = d.data.bendDirection, d.compress = d.data.compress, d.stretch = d.data.stretch) : (d.bendDirection = c[p + a.PREV_BEND_DIRECTION], d.compress = 0 != c[p + a.PREV_COMPRESS], d.stretch = 0 != c[p + a.PREV_STRETCH])) : (d.mix += (_ + (c[p + a.MIX] - _) * g - d.mix) * l, u == i.in && (d.bendDirection = c[p + a.PREV_BEND_DIRECTION], d.compress = 0 != c[p + a.PREV_COMPRESS], d.stretch = 0 != c[p + a.PREV_STRETCH]))
									}
							}, a.ENTRIES = 5, a.PREV_TIME = -5, a.PREV_MIX = -4, a.PREV_BEND_DIRECTION = -3, a.PREV_COMPRESS = -2, a.PREV_STRETCH = -1, a.MIX = 1, a.BEND_DIRECTION = 2, a.COMPRESS = 3, a.STRETCH = 4, a
						}(r);
						t.IkConstraintTimeline = S;
						var y = function(i) {
							function r(e) {
								var n = i.call(this, e) || this;
								return n.frames = t.Utils.newFloatArray(e * r.ENTRIES), n
							}
							return n(r, i), r.prototype.getPropertyId = function() {
								return (s.transformConstraint << 24) + this.transformConstraintIndex
							}, r.prototype.setFrame = function(t, e, i, n, s, o) {
								t *= r.ENTRIES, this.frames[t] = e, this.frames[t + r.ROTATE] = i, this.frames[t + r.TRANSLATE] = n, this.frames[t + r.SCALE] = s, this.frames[t + r.SHEAR] = o
							}, r.prototype.apply = function(t, i, n, s, a, l, h) {
								var u = this.frames,
									c = t.transformConstraints[this.transformConstraintIndex];
								if (n < u[0]) {
									var d = c.data;
									switch (l) {
										case e.setup:
											return c.rotateMix = d.rotateMix, c.translateMix = d.translateMix, c.scaleMix = d.scaleMix, void(c.shearMix = d.shearMix);
										case e.first:
											c.rotateMix += (d.rotateMix - c.rotateMix) * a, c.translateMix += (d.translateMix - c.translateMix) * a, c.scaleMix += (d.scaleMix - c.scaleMix) * a, c.shearMix += (d.shearMix - c.shearMix) * a
									}
								} else {
									var p = 0,
										_ = 0,
										m = 0,
										g = 0;
									if (n >= u[u.length - r.ENTRIES]) {
										var f = u.length;
										p = u[f + r.PREV_ROTATE], _ = u[f + r.PREV_TRANSLATE], m = u[f + r.PREV_SCALE], g = u[f + r.PREV_SHEAR]
									} else {
										var S = o.binarySearch(u, n, r.ENTRIES);
										p = u[S + r.PREV_ROTATE], _ = u[S + r.PREV_TRANSLATE], m = u[S + r.PREV_SCALE], g = u[S + r.PREV_SHEAR];
										var y = u[S],
											v = this.getCurvePercent(S / r.ENTRIES - 1, 1 - (n - y) / (u[S + r.PREV_TIME] - y));
										p += (u[S + r.ROTATE] - p) * v, _ += (u[S + r.TRANSLATE] - _) * v, m += (u[S + r.SCALE] - m) * v, g += (u[S + r.SHEAR] - g) * v
									}
									l == e.setup ? (d = c.data, c.rotateMix = d.rotateMix + (p - d.rotateMix) * a, c.translateMix = d.translateMix + (_ - d.translateMix) * a, c.scaleMix = d.scaleMix + (m - d.scaleMix) * a, c.shearMix = d.shearMix + (g - d.shearMix) * a) : (c.rotateMix += (p - c.rotateMix) * a, c.translateMix += (_ - c.translateMix) * a, c.scaleMix += (m - c.scaleMix) * a, c.shearMix += (g - c.shearMix) * a)
								}
							}, r.ENTRIES = 5, r.PREV_TIME = -5, r.PREV_ROTATE = -4, r.PREV_TRANSLATE = -3, r.PREV_SCALE = -2, r.PREV_SHEAR = -1, r.ROTATE = 1, r.TRANSLATE = 2, r.SCALE = 3, r.SHEAR = 4, r
						}(r);
						t.TransformConstraintTimeline = y;
						var v = function(i) {
							function r(e) {
								var n = i.call(this, e) || this;
								return n.frames = t.Utils.newFloatArray(e * r.ENTRIES), n
							}
							return n(r, i), r.prototype.getPropertyId = function() {
								return (s.pathConstraintPosition << 24) + this.pathConstraintIndex
							}, r.prototype.setFrame = function(t, e, i) {
								t *= r.ENTRIES, this.frames[t] = e, this.frames[t + r.VALUE] = i
							}, r.prototype.apply = function(t, i, n, s, a, l, h) {
								var u = this.frames,
									c = t.pathConstraints[this.pathConstraintIndex];
								if (n < u[0]) switch (l) {
									case e.setup:
										return void(c.position = c.data.position);
									case e.first:
										c.position += (c.data.position - c.position) * a
								} else {
									var d = 0;
									if (n >= u[u.length - r.ENTRIES]) d = u[u.length + r.PREV_VALUE];
									else {
										var p = o.binarySearch(u, n, r.ENTRIES);
										d = u[p + r.PREV_VALUE];
										var _ = u[p],
											m = this.getCurvePercent(p / r.ENTRIES - 1, 1 - (n - _) / (u[p + r.PREV_TIME] - _));
										d += (u[p + r.VALUE] - d) * m
									}
									l == e.setup ? c.position = c.data.position + (d - c.data.position) * a : c.position += (d - c.position) * a
								}
							}, r.ENTRIES = 2, r.PREV_TIME = -2, r.PREV_VALUE = -1, r.VALUE = 1, r
						}(r);
						t.PathConstraintPositionTimeline = v;
						var T = function(t) {
							function i(e) {
								return t.call(this, e) || this
							}
							return n(i, t), i.prototype.getPropertyId = function() {
								return (s.pathConstraintSpacing << 24) + this.pathConstraintIndex
							}, i.prototype.apply = function(t, n, s, r, a, l, h) {
								var u = this.frames,
									c = t.pathConstraints[this.pathConstraintIndex];
								if (s < u[0]) switch (l) {
									case e.setup:
										return void(c.spacing = c.data.spacing);
									case e.first:
										c.spacing += (c.data.spacing - c.spacing) * a
								} else {
									var d = 0;
									if (s >= u[u.length - i.ENTRIES]) d = u[u.length + i.PREV_VALUE];
									else {
										var p = o.binarySearch(u, s, i.ENTRIES);
										d = u[p + i.PREV_VALUE];
										var _ = u[p],
											m = this.getCurvePercent(p / i.ENTRIES - 1, 1 - (s - _) / (u[p + i.PREV_TIME] - _));
										d += (u[p + i.VALUE] - d) * m
									}
									l == e.setup ? c.spacing = c.data.spacing + (d - c.data.spacing) * a : c.spacing += (d - c.spacing) * a
								}
							}, i
						}(v);
						t.PathConstraintSpacingTimeline = T;
						var E = function(i) {
							function r(e) {
								var n = i.call(this, e) || this;
								return n.frames = t.Utils.newFloatArray(e * r.ENTRIES), n
							}
							return n(r, i), r.prototype.getPropertyId = function() {
								return (s.pathConstraintMix << 24) + this.pathConstraintIndex
							}, r.prototype.setFrame = function(t, e, i, n) {
								t *= r.ENTRIES, this.frames[t] = e, this.frames[t + r.ROTATE] = i, this.frames[t + r.TRANSLATE] = n
							}, r.prototype.apply = function(t, i, n, s, a, l, h) {
								var u = this.frames,
									c = t.pathConstraints[this.pathConstraintIndex];
								if (n < u[0]) switch (l) {
									case e.setup:
										return c.rotateMix = c.data.rotateMix, void(c.translateMix = c.data.translateMix);
									case e.first:
										c.rotateMix += (c.data.rotateMix - c.rotateMix) * a, c.translateMix += (c.data.translateMix - c.translateMix) * a
								} else {
									var d = 0,
										p = 0;
									if (n >= u[u.length - r.ENTRIES]) d = u[u.length + r.PREV_ROTATE], p = u[u.length + r.PREV_TRANSLATE];
									else {
										var _ = o.binarySearch(u, n, r.ENTRIES);
										d = u[_ + r.PREV_ROTATE], p = u[_ + r.PREV_TRANSLATE];
										var m = u[_],
											g = this.getCurvePercent(_ / r.ENTRIES - 1, 1 - (n - m) / (u[_ + r.PREV_TIME] - m));
										d += (u[_ + r.ROTATE] - d) * g, p += (u[_ + r.TRANSLATE] - p) * g
									}
									l == e.setup ? (c.rotateMix = c.data.rotateMix + (d - c.data.rotateMix) * a, c.translateMix = c.data.translateMix + (p - c.data.translateMix) * a) : (c.rotateMix += (d - c.rotateMix) * a, c.translateMix += (p - c.translateMix) * a)
								}
							}, r.ENTRIES = 3, r.PREV_TIME = -3, r.PREV_ROTATE = -2, r.PREV_TRANSLATE = -1, r.ROTATE = 1, r.TRANSLATE = 2, r
						}(r);
						t.PathConstraintMixTimeline = E
					}(t.core || (t.core = {}))
				}(i || (i = {})),
				function(t) {
					! function(t) {
						var e = function() {
							function e(e) {
								this.tracks = new Array, this.events = new Array, this.listeners = new Array, this.queue = new s(this), this.propertyIDs = new t.IntSet, this.animationsChanged = !1, this.timeScale = 1, this.trackEntryPool = new t.Pool((function() {
									return new i
								})), this.data = e
							}
							return e.prototype.update = function(t) {
								t *= this.timeScale;
								for (var e = this.tracks, i = 0, n = e.length; i < n; i++) {
									var s = e[i];
									if (null != s) {
										s.animationLast = s.nextAnimationLast, s.trackLast = s.nextTrackLast;
										var o = t * s.timeScale;
										if (s.delay > 0) {
											if (s.delay -= o, s.delay > 0) continue;
											o = -s.delay, s.delay = 0
										}
										var r = s.next;
										if (null != r) {
											var a = s.trackLast - r.delay;
											if (a >= 0) {
												for (r.delay = 0, r.trackTime = 0 == s.timeScale ? 0 : (a / s.timeScale + t) * r.timeScale, s.trackTime += o, this.setCurrent(i, r, !0); null != r.mixingFrom;) r.mixTime += t, r = r.mixingFrom;
												continue
											}
										} else if (s.trackLast >= s.trackEnd && null == s.mixingFrom) {
											e[i] = null, this.queue.end(s), this.disposeNext(s);
											continue
										}
										if (null != s.mixingFrom && this.updateMixingFrom(s, t)) {
											var l = s.mixingFrom;
											for (s.mixingFrom = null, null != l && (l.mixingTo = null); null != l;) this.queue.end(l), l = l.mixingFrom
										}
										s.trackTime += o
									}
								}
								this.queue.drain()
							}, e.prototype.updateMixingFrom = function(t, e) {
								var i = t.mixingFrom;
								if (null == i) return !0;
								var n = this.updateMixingFrom(i, e);
								return i.animationLast = i.nextAnimationLast, i.trackLast = i.nextTrackLast, t.mixTime > 0 && t.mixTime >= t.mixDuration ? (0 != i.totalAlpha && 0 != t.mixDuration || (t.mixingFrom = i.mixingFrom, null != i.mixingFrom && (i.mixingFrom.mixingTo = t), t.interruptAlpha = i.interruptAlpha, this.queue.end(i)), n) : (i.trackTime += e * i.timeScale, t.mixTime += e, !1)
							}, e.prototype.apply = function(i) {
								if (null == i) throw new Error("skeleton cannot be null.");
								this.animationsChanged && this._animationsChanged();
								for (var n = this.events, s = this.tracks, o = !1, r = 0, a = s.length; r < a; r++) {
									var l = s[r];
									if (!(null == l || l.delay > 0)) {
										o = !0;
										var h = 0 == r ? t.MixBlend.first : l.mixBlend,
											u = l.alpha;
										null != l.mixingFrom ? u *= this.applyMixingFrom(l, i, h) : l.trackTime >= l.trackEnd && null == l.next && (u = 0);
										var c = l.animationLast,
											d = l.getAnimationTime(),
											p = l.animation.timelines.length,
											_ = l.animation.timelines;
										if (0 == r && 1 == u || h == t.MixBlend.add)
											for (var m = 0; m < p; m++) t.Utils.webkit602BugfixHelper(u, h), _[m].apply(i, c, d, n, u, h, t.MixDirection.in);
										else {
											var g = l.timelineMode,
												f = 0 == l.timelinesRotation.length;
											f && t.Utils.setArraySize(l.timelinesRotation, p << 1, null);
											var S = l.timelinesRotation;
											for (m = 0; m < p; m++) {
												var y = _[m],
													v = g[m] == e.SUBSEQUENT ? h : t.MixBlend.setup;
												y instanceof t.RotateTimeline ? this.applyRotateTimeline(y, i, d, u, v, S, m << 1, f) : (t.Utils.webkit602BugfixHelper(u, h), y.apply(i, c, d, n, u, v, t.MixDirection.in))
											}
										}
										this.queueEvents(l, d), n.length = 0, l.nextAnimationLast = d, l.nextTrackLast = l.trackTime
									}
								}
								return this.queue.drain(), o
							}, e.prototype.applyMixingFrom = function(i, n, s) {
								var o = i.mixingFrom;
								null != o.mixingFrom && this.applyMixingFrom(o, n, s);
								var r = 0;
								0 == i.mixDuration ? (r = 1, s == t.MixBlend.first && (s = t.MixBlend.setup)) : ((r = i.mixTime / i.mixDuration) > 1 && (r = 1), s != t.MixBlend.first && (s = o.mixBlend));
								var a = r < o.eventThreshold ? this.events : null,
									l = r < o.attachmentThreshold,
									h = r < o.drawOrderThreshold,
									u = o.animationLast,
									c = o.getAnimationTime(),
									d = o.animation.timelines.length,
									p = o.animation.timelines,
									_ = o.alpha * i.interruptAlpha,
									m = _ * (1 - r);
								if (s == t.MixBlend.add)
									for (var g = 0; g < d; g++) p[g].apply(n, u, c, a, m, s, t.MixDirection.out);
								else {
									var f = o.timelineMode,
										S = o.timelineHoldMix,
										y = 0 == o.timelinesRotation.length;
									y && t.Utils.setArraySize(o.timelinesRotation, d << 1, null);
									var v = o.timelinesRotation;
									for (o.totalAlpha = 0, g = 0; g < d; g++) {
										var T = p[g],
											E = t.MixDirection.out,
											b = void 0,
											A = 0;
										switch (f[g]) {
											case e.SUBSEQUENT:
												if (!l && T instanceof t.AttachmentTimeline) continue;
												if (!h && T instanceof t.DrawOrderTimeline) continue;
												b = s, A = m;
												break;
											case e.FIRST:
												b = t.MixBlend.setup, A = m;
												break;
											case e.HOLD:
												b = t.MixBlend.setup, A = _;
												break;
											default:
												b = t.MixBlend.setup;
												var P = S[g];
												A = _ * Math.max(0, 1 - P.mixTime / P.mixDuration)
										}
										o.totalAlpha += A, T instanceof t.RotateTimeline ? this.applyRotateTimeline(T, n, c, A, b, v, g << 1, y) : (t.Utils.webkit602BugfixHelper(A, s), b == t.MixBlend.setup && (T instanceof t.AttachmentTimeline ? l && (E = t.MixDirection.out) : T instanceof t.DrawOrderTimeline && h && (E = t.MixDirection.out)), T.apply(n, u, c, a, A, b, E))
									}
								}
								return i.mixDuration > 0 && this.queueEvents(o, c), this.events.length = 0, o.nextAnimationLast = c, o.nextTrackLast = o.trackTime, r
							}, e.prototype.applyRotateTimeline = function(e, i, n, s, o, r, a, l) {
								if (l && (r[a] = 0), 1 != s) {
									var h = e,
										u = h.frames,
										c = i.bones[h.boneIndex],
										d = 0,
										p = 0;
									if (n < u[0]) switch (o) {
											case t.MixBlend.setup:
												c.rotation = c.data.rotation;
											default:
												return;
											case t.MixBlend.first:
												d = c.rotation, p = c.data.rotation
										} else if (d = o == t.MixBlend.setup ? c.data.rotation : c.rotation, n >= u[u.length - t.RotateTimeline.ENTRIES]) p = c.data.rotation + u[u.length + t.RotateTimeline.PREV_ROTATION];
										else {
											var _ = t.Animation.binarySearch(u, n, t.RotateTimeline.ENTRIES),
												m = u[_ + t.RotateTimeline.PREV_ROTATION],
												g = u[_],
												f = h.getCurvePercent((_ >> 1) - 1, 1 - (n - g) / (u[_ + t.RotateTimeline.PREV_TIME] - g));
											p = u[_ + t.RotateTimeline.ROTATION] - m, p = m + (p -= 360 * (16384 - (16384.499999999996 - p / 360 | 0))) * f + c.data.rotation, p -= 360 * (16384 - (16384.499999999996 - p / 360 | 0))
										} var S = 0,
										y = p - d;
									if (0 == (y -= 360 * (16384 - (16384.499999999996 - y / 360 | 0)))) S = r[a];
									else {
										var v = 0,
											T = 0;
										l ? (v = 0, T = y) : (v = r[a], T = r[a + 1]);
										var E = y > 0,
											b = v >= 0;
										t.MathUtils.signum(T) != t.MathUtils.signum(y) && Math.abs(T) <= 90 && (Math.abs(v) > 180 && (v += 360 * t.MathUtils.signum(v)), b = E), S = y + v - v % 360, b != E && (S += 360 * t.MathUtils.signum(v)), r[a] = S
									}
									r[a + 1] = y, d += S * s, c.rotation = d - 360 * (16384 - (16384.499999999996 - d / 360 | 0))
								} else e.apply(i, 0, n, null, 1, o, t.MixDirection.in)
							}, e.prototype.queueEvents = function(t, e) {
								for (var i = t.animationStart, n = t.animationEnd, s = n - i, o = t.trackLast % s, r = this.events, a = 0, l = r.length; a < l; a++) {
									var h = r[a];
									if (h.time < o) break;
									h.time > n || this.queue.event(t, h)
								}
								for ((t.loop ? 0 == s || o > t.trackTime % s : e >= n && t.animationLast < n) && this.queue.complete(t); a < l; a++) r[a].time < i || this.queue.event(t, r[a])
							}, e.prototype.clearTracks = function() {
								var t = this.queue.drainDisabled;
								this.queue.drainDisabled = !0;
								for (var e = 0, i = this.tracks.length; e < i; e++) this.clearTrack(e);
								this.tracks.length = 0, this.queue.drainDisabled = t, this.queue.drain()
							}, e.prototype.clearTrack = function(t) {
								if (!(t >= this.tracks.length)) {
									var e = this.tracks[t];
									if (null != e) {
										this.queue.end(e), this.disposeNext(e);
										for (var i = e;;) {
											var n = i.mixingFrom;
											if (null == n) break;
											this.queue.end(n), i.mixingFrom = null, i.mixingTo = null, i = n
										}
										this.tracks[e.trackIndex] = null, this.queue.drain()
									}
								}
							}, e.prototype.setCurrent = function(t, e, i) {
								var n = this.expandToIndex(t);
								this.tracks[t] = e, null != n && (i && this.queue.interrupt(n), e.mixingFrom = n, n.mixingTo = e, e.mixTime = 0, null != n.mixingFrom && n.mixDuration > 0 && (e.interruptAlpha *= Math.min(1, n.mixTime / n.mixDuration)), n.timelinesRotation.length = 0), this.queue.start(e)
							}, e.prototype.setAnimation = function(t, e, i) {
								var n = this.data.skeletonData.findAnimation(e);
								if (null == n) throw new Error("Animation not found: " + e);
								return this.setAnimationWith(t, n, i)
							}, e.prototype.setAnimationWith = function(t, e, i) {
								if (null == e) throw new Error("animation cannot be null.");
								var n = !0,
									s = this.expandToIndex(t);
								null != s && (-1 == s.nextTrackLast ? (this.tracks[t] = s.mixingFrom, this.queue.interrupt(s), this.queue.end(s), this.disposeNext(s), s = s.mixingFrom, n = !1) : this.disposeNext(s));
								var o = this.trackEntry(t, e, i, s);
								return this.setCurrent(t, o, n), this.queue.drain(), o
							}, e.prototype.addAnimation = function(t, e, i, n) {
								var s = this.data.skeletonData.findAnimation(e);
								if (null == s) throw new Error("Animation not found: " + e);
								return this.addAnimationWith(t, s, i, n)
							}, e.prototype.addAnimationWith = function(t, e, i, n) {
								if (null == e) throw new Error("animation cannot be null.");
								var s = this.expandToIndex(t);
								if (null != s)
									for (; null != s.next;) s = s.next;
								var o = this.trackEntry(t, e, i, s);
								if (null == s) this.setCurrent(t, o, !0), this.queue.drain();
								else if (s.next = o, n <= 0) {
									var r = s.animationEnd - s.animationStart;
									0 != r ? (s.loop ? n += r * (1 + (s.trackTime / r | 0)) : n += Math.max(r, s.trackTime), n -= this.data.getMix(s.animation, e)) : n = s.trackTime
								}
								return o.delay = n, o
							}, e.prototype.setEmptyAnimation = function(t, i) {
								var n = this.setAnimationWith(t, e.emptyAnimation, !1);
								return n.mixDuration = i, n.trackEnd = i, n
							}, e.prototype.addEmptyAnimation = function(t, i, n) {
								n <= 0 && (n -= i);
								var s = this.addAnimationWith(t, e.emptyAnimation, !1, n);
								return s.mixDuration = i, s.trackEnd = i, s
							}, e.prototype.setEmptyAnimations = function(t) {
								var e = this.queue.drainDisabled;
								this.queue.drainDisabled = !0;
								for (var i = 0, n = this.tracks.length; i < n; i++) {
									var s = this.tracks[i];
									null != s && this.setEmptyAnimation(s.trackIndex, t)
								}
								this.queue.drainDisabled = e, this.queue.drain()
							}, e.prototype.expandToIndex = function(e) {
								return e < this.tracks.length ? this.tracks[e] : (t.Utils.ensureArrayCapacity(this.tracks, e - this.tracks.length + 1, null), this.tracks.length = e + 1, null)
							}, e.prototype.trackEntry = function(t, e, i, n) {
								var s = this.trackEntryPool.obtain();
								return s.trackIndex = t, s.animation = e, s.loop = i, s.holdPrevious = !1, s.eventThreshold = 0, s.attachmentThreshold = 0, s.drawOrderThreshold = 0, s.animationStart = 0, s.animationEnd = e.duration, s.animationLast = -1, s.nextAnimationLast = -1, s.delay = 0, s.trackTime = 0, s.trackLast = -1, s.nextTrackLast = -1, s.trackEnd = Number.MAX_VALUE, s.timeScale = 1, s.alpha = 1, s.interruptAlpha = 1, s.mixTime = 0, s.mixDuration = null == n ? 0 : this.data.getMix(n.animation, e), s
							}, e.prototype.disposeNext = function(t) {
								for (var e = t.next; null != e;) this.queue.dispose(e), e = e.next;
								t.next = null
							}, e.prototype._animationsChanged = function() {
								this.animationsChanged = !1, this.propertyIDs.clear();
								for (var e = 0, i = this.tracks.length; e < i; e++) {
									var n = this.tracks[e];
									if (null != n) {
										for (; null != n.mixingFrom;) n = n.mixingFrom;
										do {
											null != n.mixingFrom && n.mixBlend == t.MixBlend.add || this.setTimelineModes(n), n = n.mixingTo
										} while (null != n)
									}
								}
							}, e.prototype.setTimelineModes = function(i) {
								var n = i.mixingTo,
									s = i.animation.timelines,
									o = i.animation.timelines.length,
									r = t.Utils.setArraySize(i.timelineMode, o);
								i.timelineHoldMix.length = 0;
								var a = t.Utils.setArraySize(i.timelineHoldMix, o),
									l = this.propertyIDs;
								if (null != n && n.holdPrevious)
									for (var h = 0; h < o; h++) l.add(s[h].getPropertyId()), r[h] = e.HOLD;
								else t: for (h = 0; h < o; h++) {
									var u = s[h].getPropertyId();
									if (l.add(u))
										if (null != n && this.hasTimeline(n, u)) {
											for (var c = n.mixingTo; null != c; c = c.mixingTo)
												if (!this.hasTimeline(c, u)) {
													if (i.mixDuration > 0) {
														r[h] = e.HOLD_MIX, a[h] = c;
														continue t
													}
													break
												} r[h] = e.HOLD
										} else r[h] = e.FIRST;
									else r[h] = e.SUBSEQUENT
								}
							}, e.prototype.hasTimeline = function(t, e) {
								for (var i = t.animation.timelines, n = 0, s = i.length; n < s; n++)
									if (i[n].getPropertyId() == e) return !0;
								return !1
							}, e.prototype.getCurrent = function(t) {
								return t >= this.tracks.length ? null : this.tracks[t]
							}, e.prototype.addListener = function(t) {
								if (null == t) throw new Error("listener cannot be null.");
								this.listeners.push(t)
							}, e.prototype.removeListener = function(t) {
								var e = this.listeners.indexOf(t);
								e >= 0 && this.listeners.splice(e, 1)
							}, e.prototype.clearListeners = function() {
								this.listeners.length = 0
							}, e.prototype.clearListenerNotifications = function() {
								this.queue.clear()
							}, e.prototype.setAnimationByName = function(t, i, n) {
								e.deprecatedWarning1 || (e.deprecatedWarning1 = !0, console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")), this.setAnimation(t, i, n)
							}, e.prototype.addAnimationByName = function(t, i, n, s) {
								e.deprecatedWarning2 || (e.deprecatedWarning2 = !0, console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")), this.addAnimation(t, i, n, s)
							}, e.prototype.hasAnimation = function(t) {
								return null !== this.data.skeletonData.findAnimation(t)
							}, e.prototype.hasAnimationByName = function(t) {
								return e.deprecatedWarning3 || (e.deprecatedWarning3 = !0, console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")), this.hasAnimation(t)
							}, e.emptyAnimation = new t.Animation("<empty>", [], 0), e.SUBSEQUENT = 0, e.FIRST = 1, e.HOLD = 2, e.HOLD_MIX = 3, e.deprecatedWarning1 = !1, e.deprecatedWarning2 = !1, e.deprecatedWarning3 = !1, e
						}();
						t.AnimationState = e;
						var i = function() {
							function e() {
								this.mixBlend = t.MixBlend.replace, this.timelineMode = new Array, this.timelineHoldMix = new Array, this.timelinesRotation = new Array
							}
							return e.prototype.reset = function() {
								this.next = null, this.mixingFrom = null, this.mixingTo = null, this.animation = null, this.listener = null, this.timelineMode.length = 0, this.timelineHoldMix.length = 0, this.timelinesRotation.length = 0
							}, e.prototype.getAnimationTime = function() {
								if (this.loop) {
									var t = this.animationEnd - this.animationStart;
									return 0 == t ? this.animationStart : this.trackTime % t + this.animationStart
								}
								return Math.min(this.trackTime + this.animationStart, this.animationEnd)
							}, e.prototype.setAnimationLast = function(t) {
								this.animationLast = t, this.nextAnimationLast = t
							}, e.prototype.isComplete = function() {
								return this.trackTime >= this.animationEnd - this.animationStart
							}, e.prototype.resetRotationDirections = function() {
								this.timelinesRotation.length = 0
							}, Object.defineProperty(e.prototype, "time", {
								get: function() {
									return e.deprecatedWarning1 || (e.deprecatedWarning1 = !0, console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")), this.trackTime
								},
								set: function(t) {
									e.deprecatedWarning1 || (e.deprecatedWarning1 = !0, console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")), this.trackTime = t
								},
								enumerable: !0,
								configurable: !0
							}), Object.defineProperty(e.prototype, "endTime", {
								get: function() {
									return e.deprecatedWarning2 || (e.deprecatedWarning2 = !0, console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")), this.trackTime
								},
								set: function(t) {
									e.deprecatedWarning2 || (e.deprecatedWarning2 = !0, console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")), this.trackTime = t
								},
								enumerable: !0,
								configurable: !0
							}), e.prototype.loopsCount = function() {
								return Math.floor(this.trackTime / this.trackEnd)
							}, e.deprecatedWarning1 = !1, e.deprecatedWarning2 = !1, e
						}();
						t.TrackEntry = i;
						var n, s = function() {
							function e(t) {
								this.objects = [], this.drainDisabled = !1, this.animState = t
							}
							return e.prototype.start = function(t) {
								this.objects.push(n.start), this.objects.push(t), this.animState.animationsChanged = !0
							}, e.prototype.interrupt = function(t) {
								this.objects.push(n.interrupt), this.objects.push(t)
							}, e.prototype.end = function(t) {
								this.objects.push(n.end), this.objects.push(t), this.animState.animationsChanged = !0
							}, e.prototype.dispose = function(t) {
								this.objects.push(n.dispose), this.objects.push(t)
							}, e.prototype.complete = function(t) {
								this.objects.push(n.complete), this.objects.push(t)
							}, e.prototype.event = function(t, e) {
								this.objects.push(n.event), this.objects.push(t), this.objects.push(e)
							}, e.prototype.deprecateStuff = function() {
								return e.deprecatedWarning1 || (e.deprecatedWarning1 = !0, console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")), !0
							}, e.prototype.drain = function() {
								if (!this.drainDisabled) {
									this.drainDisabled = !0;
									for (var e = this.objects, i = this.animState.listeners, s = 0; s < e.length; s += 2) {
										var o = e[s],
											r = e[s + 1];
										switch (o) {
											case n.start:
												null != r.listener && r.listener.start && r.listener.start(r);
												for (var a = 0; a < i.length; a++) i[a].start && i[a].start(r);
												r.onStart && this.deprecateStuff() && r.onStart(r.trackIndex), this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(r.trackIndex);
												break;
											case n.interrupt:
												for (null != r.listener && r.listener.interrupt && r.listener.interrupt(r), a = 0; a < i.length; a++) i[a].interrupt && i[a].interrupt(r);
												break;
											case n.end:
												for (null != r.listener && r.listener.end && r.listener.end(r), a = 0; a < i.length; a++) i[a].end && i[a].end(r);
												r.onEnd && this.deprecateStuff() && r.onEnd(r.trackIndex), this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(r.trackIndex);
											case n.dispose:
												for (null != r.listener && r.listener.dispose && r.listener.dispose(r), a = 0; a < i.length; a++) i[a].dispose && i[a].dispose(r);
												this.animState.trackEntryPool.free(r);
												break;
											case n.complete:
												for (null != r.listener && r.listener.complete && r.listener.complete(r), a = 0; a < i.length; a++) i[a].complete && i[a].complete(r);
												var l = t.MathUtils.toInt(r.loopsCount());
												r.onComplete && this.deprecateStuff() && r.onComplete(r.trackIndex, l), this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(r.trackIndex, l);
												break;
											case n.event:
												var h = e[2 + s++];
												for (null != r.listener && r.listener.event && r.listener.event(r, h), a = 0; a < i.length; a++) i[a].event && i[a].event(r, h);
												r.onEvent && this.deprecateStuff() && r.onEvent(r.trackIndex, h), this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(r.trackIndex, h)
										}
									}
									this.clear(), this.drainDisabled = !1
								}
							}, e.prototype.clear = function() {
								this.objects.length = 0
							}, e.deprecatedWarning1 = !1, e
						}();
						t.EventQueue = s,
							function(t) {
								t[t.start = 0] = "start", t[t.interrupt = 1] = "interrupt", t[t.end = 2] = "end", t[t.dispose = 3] = "dispose", t[t.complete = 4] = "complete", t[t.event = 5] = "event"
							}(n = t.EventType || (t.EventType = {}));
						var o = function() {
							function t() {}
							return t.prototype.start = function(t) {}, t.prototype.interrupt = function(t) {}, t.prototype.end = function(t) {}, t.prototype.dispose = function(t) {}, t.prototype.complete = function(t) {}, t.prototype.event = function(t, e) {}, t
						}();
						t.AnimationStateAdapter2 = o
					}(t.core || (t.core = {}))
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), i = function() {
						function t(t) {
							if (this.animationToMixTime = {}, this.defaultMix = 0, null == t) throw new Error("skeletonData cannot be null.");
							this.skeletonData = t
						}
						return t.prototype.setMix = function(t, e, i) {
							var n = this.skeletonData.findAnimation(t);
							if (null == n) throw new Error("Animation not found: " + t);
							var s = this.skeletonData.findAnimation(e);
							if (null == s) throw new Error("Animation not found: " + e);
							this.setMixWith(n, s, i)
						}, t.prototype.setMixByName = function(e, i, n) {
							t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")), this.setMix(e, i, n)
						}, t.prototype.setMixWith = function(t, e, i) {
							if (null == t) throw new Error("from cannot be null.");
							if (null == e) throw new Error("to cannot be null.");
							var n = t.name + "." + e.name;
							this.animationToMixTime[n] = i
						}, t.prototype.getMix = function(t, e) {
							var i = t.name + "." + e.name,
								n = this.animationToMixTime[i];
							return void 0 === n ? this.defaultMix : n
						}, t.deprecatedWarning1 = !1, t
					}(), e.AnimationStateData = i
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), i = function() {
						function t(t) {
							this.atlas = t
						}
						return t.prototype.newRegionAttachment = function(t, i, n) {
							var s = this.atlas.findRegion(n);
							if (null == s) throw new Error("Region not found in atlas: " + n + " (region attachment: " + i + ")");
							var o = new e.RegionAttachment(i);
							return o.region = s, o
						}, t.prototype.newMeshAttachment = function(t, i, n) {
							var s = this.atlas.findRegion(n);
							if (null == s) throw new Error("Region not found in atlas: " + n + " (mesh attachment: " + i + ")");
							var o = new e.MeshAttachment(i);
							return o.region = s, o
						}, t.prototype.newBoundingBoxAttachment = function(t, i) {
							return new e.BoundingBoxAttachment(i)
						}, t.prototype.newPathAttachment = function(t, i) {
							return new e.PathAttachment(i)
						}, t.prototype.newPointAttachment = function(t, i) {
							return new e.PointAttachment(i)
						}, t.prototype.newClippingAttachment = function(t, i) {
							return new e.ClippingAttachment(i)
						}, t
					}(), e.AtlasAttachmentLoader = i
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), (i = e.BlendMode || (e.BlendMode = {}))[i.Normal = 0] = "Normal", i[i.Additive = 1] = "Additive", i[i.Multiply = 2] = "Multiply", i[i.Screen = 3] = "Screen"
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), i = function() {
						function t(t, e, i) {
							if (this.matrix = new PIXI.Matrix, this.children = new Array, this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 0, this.scaleY = 0, this.shearX = 0, this.shearY = 0, this.ax = 0, this.ay = 0, this.arotation = 0, this.ascaleX = 0, this.ascaleY = 0, this.ashearX = 0, this.ashearY = 0, this.appliedValid = !1, this.sorted = !1, null == t) throw new Error("data cannot be null.");
							if (null == e) throw new Error("skeleton cannot be null.");
							this.data = t, this.skeleton = e, this.parent = i, this.setToSetupPose()
						}
						return Object.defineProperty(t.prototype, "worldX", {
							get: function() {
								return this.matrix.tx
							},
							enumerable: !0,
							configurable: !0
						}), Object.defineProperty(t.prototype, "worldY", {
							get: function() {
								return this.matrix.ty
							},
							enumerable: !0,
							configurable: !0
						}), t.prototype.update = function() {
							this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
						}, t.prototype.updateWorldTransform = function() {
							this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
						}, t.prototype.updateWorldTransformWith = function(i, n, s, o, r, a, l) {
							this.ax = i, this.ay = n, this.arotation = s, this.ascaleX = o, this.ascaleY = r, this.ashearX = a, this.ashearY = l, this.appliedValid = !0;
							var h = this.parent,
								u = this.matrix,
								c = this.skeleton.scaleX,
								d = t.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;
							if (null == h) {
								var p = this.skeleton,
									_ = s + 90 + l;
								return u.a = e.MathUtils.cosDeg(s + a) * o * c, u.c = e.MathUtils.cosDeg(_) * r * c, u.b = e.MathUtils.sinDeg(s + a) * o * d, u.d = e.MathUtils.sinDeg(_) * r * d, u.tx = i * c + p.x, void(u.ty = n * d + p.y)
							}
							var m = h.matrix.a,
								g = h.matrix.c,
								f = h.matrix.b,
								S = h.matrix.d;
							switch (u.tx = m * i + g * n + h.matrix.tx, u.ty = f * i + S * n + h.matrix.ty, this.data.transformMode) {
								case e.TransformMode.Normal:
									_ = s + 90 + l;
									var y = e.MathUtils.cosDeg(s + a) * o,
										v = e.MathUtils.cosDeg(_) * r,
										T = e.MathUtils.sinDeg(s + a) * o,
										E = e.MathUtils.sinDeg(_) * r;
									return u.a = m * y + g * T, u.c = m * v + g * E, u.b = f * y + S * T, void(u.d = f * v + S * E);
								case e.TransformMode.OnlyTranslation:
									_ = s + 90 + l, u.a = e.MathUtils.cosDeg(s + a) * o, u.c = e.MathUtils.cosDeg(_) * r, u.b = e.MathUtils.sinDeg(s + a) * o, u.d = e.MathUtils.sinDeg(_) * r;
									break;
								case e.TransformMode.NoRotationOrReflection:
									var b = 0;
									(I = m * m + f * f) > 1e-4 ? (g = f * (I = Math.abs(m * S - g * f) / I), S = m * I, b = Math.atan2(f, m) * e.MathUtils.radDeg) : (m = 0, f = 0, b = 90 - Math.atan2(S, g) * e.MathUtils.radDeg);
									var A = s + a - b,
										P = s + l - b + 90;
									y = e.MathUtils.cosDeg(A) * o, v = e.MathUtils.cosDeg(P) * r, T = e.MathUtils.sinDeg(A) * o, E = e.MathUtils.sinDeg(P) * r, u.a = m * y - g * T, u.c = m * v - g * E, u.b = f * y + S * T, u.d = f * v + S * E;
									break;
								case e.TransformMode.NoScale:
								case e.TransformMode.NoScaleOrReflection:
									var I, w = e.MathUtils.cosDeg(s),
										L = e.MathUtils.sinDeg(s),
										C = (m * w + g * L) / c,
										x = (f * w + S * L) / d;
									(I = Math.sqrt(C * C + x * x)) > 1e-5 && (I = 1 / I), C *= I, x *= I, I = Math.sqrt(C * C + x * x), this.data.transformMode == e.TransformMode.NoScale && m * S - g * f < 0 != (t.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0) && (I = -I);
									var B = Math.PI / 2 + Math.atan2(x, C),
										O = Math.cos(B) * I,
										N = Math.sin(B) * I;
									y = e.MathUtils.cosDeg(a) * o, v = e.MathUtils.cosDeg(90 + l) * r, T = e.MathUtils.sinDeg(a) * o, E = e.MathUtils.sinDeg(90 + l) * r, u.a = C * y + O * T, u.c = C * v + O * E, u.b = x * y + N * T, u.d = x * v + N * E
							}
							u.a *= c, u.c *= c, u.b *= d, u.d *= d
						}, t.prototype.setToSetupPose = function() {
							var t = this.data;
							this.x = t.x, this.y = t.y, this.rotation = t.rotation, this.scaleX = t.scaleX, this.scaleY = t.scaleY, this.shearX = t.shearX, this.shearY = t.shearY
						}, t.prototype.getWorldRotationX = function() {
							return Math.atan2(this.matrix.b, this.matrix.a) * e.MathUtils.radDeg
						}, t.prototype.getWorldRotationY = function() {
							return Math.atan2(this.matrix.d, this.matrix.c) * e.MathUtils.radDeg
						}, t.prototype.getWorldScaleX = function() {
							var t = this.matrix;
							return Math.sqrt(t.a * t.a + t.c * t.c)
						}, t.prototype.getWorldScaleY = function() {
							var t = this.matrix;
							return Math.sqrt(t.b * t.b + t.d * t.d)
						}, t.prototype.updateAppliedTransform = function() {
							this.appliedValid = !0;
							var t = this.parent,
								i = this.matrix;
							if (null == t) return this.ax = i.tx, this.ay = i.ty, this.arotation = Math.atan2(i.b, i.a) * e.MathUtils.radDeg, this.ascaleX = Math.sqrt(i.a * i.a + i.b * i.b), this.ascaleY = Math.sqrt(i.c * i.c + i.d * i.d), this.ashearX = 0, void(this.ashearY = Math.atan2(i.a * i.c + i.b * i.d, i.a * i.d - i.b * i.c) * e.MathUtils.radDeg);
							var n = t.matrix,
								s = 1 / (n.a * n.d - n.b * n.c),
								o = i.tx - n.tx,
								r = i.ty - n.ty;
							this.ax = o * n.d * s - r * n.c * s, this.ay = r * n.a * s - o * n.b * s;
							var a = s * n.d,
								l = s * n.a,
								h = s * n.c,
								u = s * n.b,
								c = a * i.a - h * i.b,
								d = a * i.c - h * i.d,
								p = l * i.b - u * i.a,
								_ = l * i.d - u * i.c;
							if (this.ashearX = 0, this.ascaleX = Math.sqrt(c * c + p * p), this.ascaleX > 1e-4) {
								var m = c * _ - d * p;
								this.ascaleY = m / this.ascaleX, this.ashearY = Math.atan2(c * d + p * _, m) * e.MathUtils.radDeg, this.arotation = Math.atan2(p, c) * e.MathUtils.radDeg
							} else this.ascaleX = 0, this.ascaleY = Math.sqrt(d * d + _ * _), this.ashearY = 0, this.arotation = 90 - Math.atan2(_, d) * e.MathUtils.radDeg
						}, t.prototype.worldToLocal = function(t) {
							var e = this.matrix,
								i = e.a,
								n = e.c,
								s = e.b,
								o = e.d,
								r = 1 / (i * o - n * s),
								a = t.x - e.tx,
								l = t.y - e.ty;
							return t.x = a * o * r - l * n * r, t.y = l * i * r - a * s * r, t
						}, t.prototype.localToWorld = function(t) {
							var e = this.matrix,
								i = t.x,
								n = t.y;
							return t.x = i * e.a + n * e.c + e.tx, t.y = i * e.b + n * e.d + e.ty, t
						}, t.prototype.worldToLocalRotation = function(t) {
							var i = e.MathUtils.sinDeg(t),
								n = e.MathUtils.cosDeg(t),
								s = this.matrix;
							return Math.atan2(s.a * i - s.b * n, s.d * n - s.c * i) * e.MathUtils.radDeg
						}, t.prototype.localToWorldRotation = function(t) {
							var i = e.MathUtils.sinDeg(t),
								n = e.MathUtils.cosDeg(t),
								s = this.matrix;
							return Math.atan2(n * s.b + i * s.d, n * s.a + i * s.c) * e.MathUtils.radDeg
						}, t.prototype.rotateWorld = function(t) {
							var i = this.matrix,
								n = i.a,
								s = i.c,
								o = i.b,
								r = i.d,
								a = e.MathUtils.cosDeg(t),
								l = e.MathUtils.sinDeg(t);
							i.a = a * n - l * o, i.c = a * s - l * r, i.b = l * n + a * o, i.d = l * s + a * r, this.appliedValid = !1
						}, t.yDown = !1, t
					}(), e.Bone = i
				}(i || (i = {})),
				function(t) {
					var e, i;
					(e = t.core || (t.core = {})).BoneData = function(t, e, n) {
							if (this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 1, this.scaleY = 1, this.shearX = 0, this.shearY = 0, this.transformMode = i.Normal, t < 0) throw new Error("index must be >= 0.");
							if (null == e) throw new Error("name cannot be null.");
							this.index = t, this.name = e, this.parent = n
						},
						function(t) {
							t[t.Normal = 0] = "Normal", t[t.OnlyTranslation = 1] = "OnlyTranslation", t[t.NoRotationOrReflection = 2] = "NoRotationOrReflection", t[t.NoScale = 3] = "NoScale", t[t.NoScaleOrReflection = 4] = "NoScaleOrReflection"
						}(i = e.TransformMode || (e.TransformMode = {}))
				}(i || (i = {})),
				function(t) {
					(t.core || (t.core = {})).Event = function(t, e) {
						if (null == e) throw new Error("data cannot be null.");
						this.time = t, this.data = e
					}
				}(i || (i = {})),
				function(t) {
					(t.core || (t.core = {})).EventData = function(t) {
						this.name = t
					}
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), i = function() {
						function t(t, e) {
							if (this.bendDirection = 0, this.compress = !1, this.stretch = !1, this.mix = 1, null == t) throw new Error("data cannot be null.");
							if (null == e) throw new Error("skeleton cannot be null.");
							this.data = t, this.mix = t.mix, this.bendDirection = t.bendDirection, this.compress = t.compress, this.stretch = t.stretch, this.bones = new Array;
							for (var i = 0; i < t.bones.length; i++) this.bones.push(e.findBone(t.bones[i].name));
							this.target = e.findBone(t.target.name)
						}
						return t.prototype.getOrder = function() {
							return this.data.order
						}, t.prototype.apply = function() {
							this.update()
						}, t.prototype.update = function() {
							var t = this.target,
								e = this.bones;
							switch (e.length) {
								case 1:
									this.apply1(e[0], t.worldX, t.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
									break;
								case 2:
									this.apply2(e[0], e[1], t.worldX, t.worldY, this.bendDirection, this.stretch, this.mix)
							}
						}, t.prototype.apply1 = function(t, i, n, s, o, r, a) {
							t.appliedValid || t.updateAppliedTransform();
							var l = t.parent.matrix,
								h = 1 / (l.a * l.d - l.b * l.c),
								u = i - l.tx,
								c = n - l.ty,
								d = (u * l.d - c * l.c) * h - t.ax,
								p = (c * l.a - u * l.b) * h - t.ay,
								_ = Math.atan2(p, d) * e.MathUtils.radDeg - t.ashearX - t.arotation;
							t.ascaleX < 0 && (_ += 180), _ > 180 ? _ -= 360 : _ < -180 && (_ += 360);
							var m = t.ascaleX,
								g = t.ascaleY;
							if (s || o) {
								var f = t.data.length * m,
									S = Math.sqrt(d * d + p * p);
								if (s && S < f || o && S > f && f > 1e-4) {
									var y = (S / f - 1) * a + 1;
									m *= y, r && (g *= y)
								}
							}
							t.updateWorldTransformWith(t.ax, t.ay, t.arotation + _ * a, m, g, t.ashearX, t.ashearY)
						}, t.prototype.apply2 = function(t, i, n, s, o, r, a) {
							if (0 != a) {
								t.appliedValid || t.updateAppliedTransform(), i.appliedValid || i.updateAppliedTransform();
								var l = t.ax,
									h = t.ay,
									u = t.ascaleX,
									c = u,
									d = t.ascaleY,
									p = i.ascaleX,
									_ = t.matrix,
									m = 0,
									g = 0,
									f = 0;
								u < 0 ? (u = -u, m = 180, f = -1) : (m = 0, f = 1), d < 0 && (d = -d, f = -f), p < 0 ? (p = -p, g = 180) : g = 0;
								var S = i.ax,
									y = 0,
									v = 0,
									T = 0,
									E = _.a,
									b = _.c,
									A = _.b,
									P = _.d,
									I = Math.abs(u - d) <= 1e-4;
								I ? (v = E * S + b * (y = i.ay) + _.tx, T = A * S + P * y + _.ty) : (y = 0, v = E * S + _.tx, T = A * S + _.ty);
								var w = t.parent.matrix;
								E = w.a, b = w.c, A = w.b;
								var L = 1 / (E * (P = w.d) - b * A),
									C = n - w.tx,
									x = s - w.ty,
									B = (C * P - x * b) * L - l,
									O = (x * E - C * A) * L - h,
									N = B * B + O * O,
									M = ((C = v - w.tx) * P - (x = T - w.ty) * b) * L - l,
									R = (x * E - C * A) * L - h,
									D = Math.sqrt(M * M + R * R),
									k = i.data.length * p,
									F = 0,
									G = 0;
								t: if (I) {
									var U = (N - D * D - (k *= u) * k) / (2 * D * k);
									U < -1 ? U = -1 : U > 1 && (U = 1, r && D + k > 1e-4 && (c *= (Math.sqrt(N) / (D + k) - 1) * a + 1)), G = Math.acos(U) * o, E = D + k * U, b = k * Math.sin(G), F = Math.atan2(O * E - B * b, B * E + O * b)
								} else {
									var W = (E = u * k) * E,
										H = (b = d * k) * b,
										V = Math.atan2(O, B),
										X = -2 * H * D,
										Y = H - W;
									if ((P = X * X - 4 * Y * (A = H * D * D + W * N - W * H)) >= 0) {
										var z = Math.sqrt(P);
										X < 0 && (z = -z);
										var j = (z = -(X + z) / 2) / Y,
											K = A / z,
											q = Math.abs(j) < Math.abs(K) ? j : K;
										if (q * q <= N) {
											x = Math.sqrt(N - q * q) * o, F = V - Math.atan2(x, q), G = Math.atan2(x / d, (q - D) / u);
											break t
										}
									}
									var Z = e.MathUtils.PI,
										$ = D - E,
										Q = $ * $,
										J = 0,
										tt = 0,
										et = D + E,
										it = et * et,
										nt = 0;
									(A = -E * D / (W - H)) >= -1 && A <= 1 && (A = Math.acos(A), (P = (C = E * Math.cos(A) + D) * C + (x = b * Math.sin(A)) * x) < Q && (Z = A, Q = P, $ = C, J = x), P > it && (tt = A, it = P, et = C, nt = x)), N <= (Q + it) / 2 ? (F = V - Math.atan2(J * o, $), G = Z * o) : (F = V - Math.atan2(nt * o, et), G = tt * o)
								}
								var st = Math.atan2(y, S) * f,
									ot = t.arotation;
								(F = (F - st) * e.MathUtils.radDeg + m - ot) > 180 ? F -= 360 : F < -180 && (F += 360), t.updateWorldTransformWith(l, h, ot + F * a, c, t.ascaleY, 0, 0), ot = i.arotation, (G = ((G + st) * e.MathUtils.radDeg - i.ashearX) * f + g - ot) > 180 ? G -= 360 : G < -180 && (G += 360), i.updateWorldTransformWith(S, y, ot + G * a, i.ascaleX, i.ascaleY, i.ashearX, i.ashearY)
							} else i.updateWorldTransform()
						}, t
					}(), e.IkConstraint = i
				}(i || (i = {})),
				function(t) {
					(t.core || (t.core = {})).IkConstraintData = function(t) {
						this.order = 0, this.bones = new Array, this.bendDirection = 1, this.compress = !1, this.stretch = !1, this.uniform = !1, this.mix = 1, this.name = t
					}
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), i = function() {
						function t(t, e) {
							if (this.position = 0, this.spacing = 0, this.rotateMix = 0, this.translateMix = 0, this.spaces = new Array, this.positions = new Array, this.world = new Array, this.curves = new Array, this.lengths = new Array, this.segments = new Array, null == t) throw new Error("data cannot be null.");
							if (null == e) throw new Error("skeleton cannot be null.");
							this.data = t, this.bones = new Array;
							for (var i = 0, n = t.bones.length; i < n; i++) this.bones.push(e.findBone(t.bones[i].name));
							this.target = e.findSlot(t.target.name), this.position = t.position, this.spacing = t.spacing, this.rotateMix = t.rotateMix, this.translateMix = t.translateMix
						}
						return t.prototype.apply = function() {
							this.update()
						}, t.prototype.update = function() {
							var i = this.target.getAttachment();
							if (i instanceof e.PathAttachment) {
								var n = this.rotateMix,
									s = this.translateMix,
									o = n > 0;
								if (s > 0 || o) {
									var r = this.data,
										a = r.spacingMode,
										l = a == e.SpacingMode.Length,
										h = r.rotateMode,
										u = h == e.RotateMode.Tangent,
										c = h == e.RotateMode.ChainScale,
										d = this.bones.length,
										p = u ? d : d + 1,
										_ = this.bones,
										m = e.Utils.setArraySize(this.spaces, p),
										g = null,
										f = this.spacing;
									if (c || l) {
										c && (g = e.Utils.setArraySize(this.lengths, d));
										for (var S = 0, y = p - 1; S < y;) {
											var v = (x = _[S]).data.length;
											if (v < t.epsilon) c && (g[S] = 0), m[++S] = 0;
											else {
												var T = v * x.matrix.a,
													E = v * x.matrix.b,
													b = Math.sqrt(T * T + E * E);
												c && (g[S] = b), m[++S] = (l ? v + f : f) * b / v
											}
										}
									} else
										for (S = 1; S < p; S++) m[S] = f;
									var A = this.computeWorldPositions(i, p, u, r.positionMode == e.PositionMode.Percent, a == e.SpacingMode.Percent),
										P = A[0],
										I = A[1],
										w = r.offsetRotation,
										L = !1;
									0 == w ? L = h == e.RotateMode.Chain : (L = !1, w *= (C = this.target.bone.matrix).a * C.d - C.b * C.c > 0 ? e.MathUtils.degRad : -e.MathUtils.degRad), S = 0;
									for (var C = 3; S < d; S++, C += 3) {
										var x, B = (x = _[S]).matrix;
										B.tx += (P - B.tx) * s, B.ty += (I - B.ty) * s;
										var O = (T = A[C]) - P,
											N = (E = A[C + 1]) - I;
										if (c) {
											var M = g[S];
											if (0 != M) {
												var R = (Math.sqrt(O * O + N * N) / M - 1) * n + 1;
												B.a *= R, B.b *= R
											}
										}
										if (P = T, I = E, o) {
											var D = B.a,
												k = B.c,
												F = B.b,
												G = B.d,
												U = 0,
												W = 0,
												H = 0;
											if (U = u ? A[C - 1] : 0 == m[S + 1] ? A[C + 2] : Math.atan2(N, O), U -= Math.atan2(F, D), L) {
												W = Math.cos(U), H = Math.sin(U);
												var V = x.data.length;
												P += (V * (W * D - H * F) - O) * n, I += (V * (H * D + W * F) - N) * n
											} else U += w;
											U > e.MathUtils.PI ? U -= e.MathUtils.PI2 : U < -e.MathUtils.PI && (U += e.MathUtils.PI2), U *= n, W = Math.cos(U), H = Math.sin(U), B.a = W * D - H * F, B.c = W * k - H * G, B.b = H * D + W * F, B.d = H * k + W * G
										}
										x.appliedValid = !1
									}
								}
							}
						}, t.prototype.computeWorldPositions = function(i, n, s, o, r) {
							var a = this.target,
								l = this.position,
								h = this.spaces,
								u = e.Utils.setArraySize(this.positions, 3 * n + 2),
								c = null,
								d = i.closed,
								p = i.worldVerticesLength,
								_ = p / 6,
								m = t.NONE;
							if (!i.constantSpeed) {
								var g = i.lengths,
									f = g[_ -= d ? 1 : 2];
								if (o && (l *= f), r)
									for (var S = 0; S < n; S++) h[S] *= f;
								c = e.Utils.setArraySize(this.world, 8), S = 0;
								for (var y = 0, v = 0; S < n; S++, y += 3) {
									var T = l += Y = h[S];
									if (d)(T %= f) < 0 && (T += f), v = 0;
									else {
										if (T < 0) {
											m != t.BEFORE && (m = t.BEFORE, i.computeWorldVertices(a, 2, 4, c, 0, 2)), this.addBeforePosition(T, c, 0, u, y);
											continue
										}
										if (T > f) {
											m != t.AFTER && (m = t.AFTER, i.computeWorldVertices(a, p - 6, 4, c, 0, 2)), this.addAfterPosition(T - f, c, 0, u, y);
											continue
										}
									}
									for (;; v++) {
										var E = g[v];
										if (!(T > E)) {
											0 == v ? T /= E : T = (T - (q = g[v - 1])) / (E - q);
											break
										}
									}
									v != m && (m = v, d && v == _ ? (i.computeWorldVertices(a, p - 4, 4, c, 0, 2), i.computeWorldVertices(a, 0, 4, c, 4, 2)) : i.computeWorldVertices(a, 6 * v + 2, 8, c, 0, 2)), this.addCurvePosition(T, c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7], u, y, s || S > 0 && 0 == Y)
								}
								return u
							}
							d ? (p += 2, c = e.Utils.setArraySize(this.world, p), i.computeWorldVertices(a, 2, p - 4, c, 0, 2), i.computeWorldVertices(a, 0, 2, c, p - 4, 2), c[p - 2] = c[0], c[p - 1] = c[1]) : (_--, p -= 4, c = e.Utils.setArraySize(this.world, p), i.computeWorldVertices(a, 2, p, c, 0, 2));
							for (var b = e.Utils.setArraySize(this.curves, _), A = 0, P = c[0], I = c[1], w = 0, L = 0, C = 0, x = 0, B = 0, O = 0, N = 0, M = 0, R = 0, D = 0, k = 0, F = 0, G = 0, U = 0, W = (S = 0, 2); S < _; S++, W += 6) w = c[W], L = c[W + 1], C = c[W + 2], x = c[W + 3], k = 2 * (N = .1875 * (P - 2 * w + C)) + (R = .09375 * (3 * (w - C) - P + (B = c[W + 4]))), F = 2 * (M = .1875 * (I - 2 * L + x)) + (D = .09375 * (3 * (L - x) - I + (O = c[W + 5]))), G = .75 * (w - P) + N + .16666667 * R, U = .75 * (L - I) + M + .16666667 * D, A += Math.sqrt(G * G + U * U), G += k, U += F, k += R, F += D, A += Math.sqrt(G * G + U * U), G += k, U += F, A += Math.sqrt(G * G + U * U), G += k + R, U += F + D, A += Math.sqrt(G * G + U * U), b[S] = A, P = B, I = O;
							if (o && (l *= A), r)
								for (S = 0; S < n; S++) h[S] *= A;
							for (var H = this.segments, V = 0, X = (S = 0, y = 0, v = 0, 0); S < n; S++, y += 3) {
								var Y;
								if (T = l += Y = h[S], d)(T %= A) < 0 && (T += A), v = 0;
								else {
									if (T < 0) {
										this.addBeforePosition(T, c, 0, u, y);
										continue
									}
									if (T > A) {
										this.addAfterPosition(T - A, c, p - 4, u, y);
										continue
									}
								}
								for (;; v++) {
									var z = b[v];
									if (!(T > z)) {
										0 == v ? T /= z : T = (T - (q = b[v - 1])) / (z - q);
										break
									}
								}
								if (v != m) {
									m = v;
									var j = 6 * v;
									for (P = c[j], I = c[j + 1], w = c[j + 2], L = c[j + 3], C = c[j + 4], x = c[j + 5], k = 2 * (N = .03 * (P - 2 * w + C)) + (R = .006 * (3 * (w - C) - P + (B = c[j + 6]))), F = 2 * (M = .03 * (I - 2 * L + x)) + (D = .006 * (3 * (L - x) - I + (O = c[j + 7]))), G = .3 * (w - P) + N + .16666667 * R, U = .3 * (L - I) + M + .16666667 * D, V = Math.sqrt(G * G + U * U), H[0] = V, j = 1; j < 8; j++) G += k, U += F, k += R, F += D, V += Math.sqrt(G * G + U * U), H[j] = V;
									G += k, U += F, V += Math.sqrt(G * G + U * U), H[8] = V, G += k + R, U += F + D, V += Math.sqrt(G * G + U * U), H[9] = V, X = 0
								}
								for (T *= V;; X++) {
									var K = H[X];
									if (!(T > K)) {
										var q;
										0 == X ? T /= K : T = X + (T - (q = H[X - 1])) / (K - q);
										break
									}
								}
								this.addCurvePosition(.1 * T, P, I, w, L, C, x, B, O, u, y, s || S > 0 && 0 == Y)
							}
							return u
						}, t.prototype.addBeforePosition = function(t, e, i, n, s) {
							var o = e[i],
								r = e[i + 1],
								a = e[i + 2] - o,
								l = e[i + 3] - r,
								h = Math.atan2(l, a);
							n[s] = o + t * Math.cos(h), n[s + 1] = r + t * Math.sin(h), n[s + 2] = h
						}, t.prototype.addAfterPosition = function(t, e, i, n, s) {
							var o = e[i + 2],
								r = e[i + 3],
								a = o - e[i],
								l = r - e[i + 1],
								h = Math.atan2(l, a);
							n[s] = o + t * Math.cos(h), n[s + 1] = r + t * Math.sin(h), n[s + 2] = h
						}, t.prototype.addCurvePosition = function(t, e, i, n, s, o, r, a, l, h, u, c) {
							(0 == t || isNaN(t)) && (t = 1e-4);
							var d = t * t,
								p = d * t,
								_ = 1 - t,
								m = _ * _,
								g = m * _,
								f = _ * t,
								S = 3 * f,
								y = _ * S,
								v = S * t,
								T = e * g + n * y + o * v + a * p,
								E = i * g + s * y + r * v + l * p;
							h[u] = T, h[u + 1] = E, c && (h[u + 2] = Math.atan2(E - (i * m + s * f * 2 + r * d), T - (e * m + n * f * 2 + o * d)))
						}, t.prototype.getOrder = function() {
							return this.data.order
						}, t.NONE = -1, t.BEFORE = -2, t.AFTER = -3, t.epsilon = 1e-5, t
					}(), e.PathConstraint = i
				}(i || (i = {})),
				function(t) {
					var e, i, n, s;
					(e = t.core || (t.core = {})).PathConstraintData = function(t) {
						this.order = 0, this.bones = new Array, this.name = t
					}, (s = e.PositionMode || (e.PositionMode = {}))[s.Fixed = 0] = "Fixed", s[s.Percent = 1] = "Percent", (n = e.SpacingMode || (e.SpacingMode = {}))[n.Length = 0] = "Length", n[n.Fixed = 1] = "Fixed", n[n.Percent = 2] = "Percent", (i = e.RotateMode || (e.RotateMode = {}))[i.Tangent = 0] = "Tangent", i[i.Chain = 1] = "Chain", i[i.ChainScale = 2] = "ChainScale"
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), i = function() {
						function t(t) {
							if (this._updateCache = new Array, this.updateCacheReset = new Array, this.time = 0, this.scaleX = 1, this.scaleY = 1, this.x = 0, this.y = 0, null == t) throw new Error("data cannot be null.");
							this.data = t, this.bones = new Array;
							for (var i = 0; i < t.bones.length; i++) {
								var n = t.bones[i],
									s = void 0;
								if (null == n.parent) s = new e.Bone(n, this, null);
								else {
									var o = this.bones[n.parent.index];
									s = new e.Bone(n, this, o), o.children.push(s)
								}
								this.bones.push(s)
							}
							for (this.slots = new Array, this.drawOrder = new Array, i = 0; i < t.slots.length; i++) {
								var r = t.slots[i],
									a = (s = this.bones[r.boneData.index], new e.Slot(r, s));
								this.slots.push(a), this.drawOrder.push(a)
							}
							for (this.ikConstraints = new Array, i = 0; i < t.ikConstraints.length; i++) {
								var l = t.ikConstraints[i];
								this.ikConstraints.push(new e.IkConstraint(l, this))
							}
							for (this.transformConstraints = new Array, i = 0; i < t.transformConstraints.length; i++) {
								var h = t.transformConstraints[i];
								this.transformConstraints.push(new e.TransformConstraint(h, this))
							}
							for (this.pathConstraints = new Array, i = 0; i < t.pathConstraints.length; i++) {
								var u = t.pathConstraints[i];
								this.pathConstraints.push(new e.PathConstraint(u, this))
							}
							this.color = new e.Color(1, 1, 1, 1), this.updateCache()
						}
						return t.prototype.updateCache = function() {
							this._updateCache.length = 0, this.updateCacheReset.length = 0;
							for (var t = this.bones, e = 0, i = t.length; e < i; e++) t[e].sorted = !1;
							var n = this.ikConstraints,
								s = this.transformConstraints,
								o = this.pathConstraints,
								r = n.length,
								a = s.length,
								l = o.length,
								h = r + a + l;
							t: for (e = 0; e < h; e++) {
								for (var u = 0; u < r; u++)
									if ((c = n[u]).data.order == e) {
										this.sortIkConstraint(c);
										continue t
									} for (u = 0; u < a; u++)
									if ((c = s[u]).data.order == e) {
										this.sortTransformConstraint(c);
										continue t
									} for (u = 0; u < l; u++) {
									var c;
									if ((c = o[u]).data.order == e) {
										this.sortPathConstraint(c);
										continue t
									}
								}
							}
							for (e = 0, i = t.length; e < i; e++) this.sortBone(t[e])
						}, t.prototype.sortIkConstraint = function(t) {
							var e = t.target;
							this.sortBone(e);
							var i = t.bones,
								n = i[0];
							if (this.sortBone(n), i.length > 1) {
								var s = i[i.length - 1];
								this._updateCache.indexOf(s) > -1 || this.updateCacheReset.push(s)
							}
							this._updateCache.push(t), this.sortReset(n.children), i[i.length - 1].sorted = !0
						}, t.prototype.sortPathConstraint = function(t) {
							var i = t.target,
								n = i.data.index,
								s = i.bone;
							null != this.skin && this.sortPathConstraintAttachment(this.skin, n, s), null != this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, n, s);
							for (var o = 0, r = this.data.skins.length; o < r; o++) this.sortPathConstraintAttachment(this.data.skins[o], n, s);
							var a = i.getAttachment();
							a instanceof e.PathAttachment && this.sortPathConstraintAttachmentWith(a, s);
							var l = t.bones,
								h = l.length;
							for (o = 0; o < h; o++) this.sortBone(l[o]);
							for (this._updateCache.push(t), o = 0; o < h; o++) this.sortReset(l[o].children);
							for (o = 0; o < h; o++) l[o].sorted = !0
						}, t.prototype.sortTransformConstraint = function(t) {
							this.sortBone(t.target);
							var e = t.bones,
								i = e.length;
							if (t.data.local)
								for (var n = 0; n < i; n++) {
									var s = e[n];
									this.sortBone(s.parent), this._updateCache.indexOf(s) > -1 || this.updateCacheReset.push(s)
								} else
									for (n = 0; n < i; n++) this.sortBone(e[n]);
							this._updateCache.push(t);
							for (var o = 0; o < i; o++) this.sortReset(e[o].children);
							for (o = 0; o < i; o++) e[o].sorted = !0
						}, t.prototype.sortPathConstraintAttachment = function(t, e, i) {
							var n = t.attachments[e];
							if (n)
								for (var s in n) this.sortPathConstraintAttachmentWith(n[s], i)
						}, t.prototype.sortPathConstraintAttachmentWith = function(t, i) {
							if (t instanceof e.PathAttachment) {
								var n = t.bones;
								if (null == n) this.sortBone(i);
								else
									for (var s = this.bones, o = 0; o < n.length;)
										for (var r = n[o++], a = o + r; o < a; o++) {
											var l = n[o];
											this.sortBone(s[l])
										}
							}
						}, t.prototype.sortBone = function(t) {
							if (!t.sorted) {
								var e = t.parent;
								null != e && this.sortBone(e), t.sorted = !0, this._updateCache.push(t)
							}
						}, t.prototype.sortReset = function(t) {
							for (var e = 0, i = t.length; e < i; e++) {
								var n = t[e];
								n.sorted && this.sortReset(n.children), n.sorted = !1
							}
						}, t.prototype.updateWorldTransform = function() {
							for (var t = this.updateCacheReset, e = 0, i = t.length; e < i; e++) {
								var n = t[e];
								n.ax = n.x, n.ay = n.y, n.arotation = n.rotation, n.ascaleX = n.scaleX, n.ascaleY = n.scaleY, n.ashearX = n.shearX, n.ashearY = n.shearY, n.appliedValid = !0
							}
							var s = this._updateCache;
							for (e = 0, i = s.length; e < i; e++) s[e].update()
						}, t.prototype.setToSetupPose = function() {
							this.setBonesToSetupPose(), this.setSlotsToSetupPose()
						}, t.prototype.setBonesToSetupPose = function() {
							for (var t = this.bones, e = 0, i = t.length; e < i; e++) t[e].setToSetupPose();
							var n = this.ikConstraints;
							for (e = 0, i = n.length; e < i; e++)(a = n[e]).bendDirection = a.data.bendDirection, a.mix = a.data.mix;
							var s = this.transformConstraints;
							for (e = 0, i = s.length; e < i; e++) {
								var o = (a = s[e]).data;
								a.rotateMix = o.rotateMix, a.translateMix = o.translateMix, a.scaleMix = o.scaleMix, a.shearMix = o.shearMix
							}
							var r = this.pathConstraints;
							for (e = 0, i = r.length; e < i; e++) {
								var a;
								o = (a = r[e]).data, a.position = o.position, a.spacing = o.spacing, a.rotateMix = o.rotateMix, a.translateMix = o.translateMix
							}
						}, t.prototype.setSlotsToSetupPose = function() {
							var t = this.slots;
							e.Utils.arrayCopy(t, 0, this.drawOrder, 0, t.length);
							for (var i = 0, n = t.length; i < n; i++) t[i].setToSetupPose()
						}, t.prototype.getRootBone = function() {
							return 0 == this.bones.length ? null : this.bones[0]
						}, t.prototype.findBone = function(t) {
							if (null == t) throw new Error("boneName cannot be null.");
							for (var e = this.bones, i = 0, n = e.length; i < n; i++) {
								var s = e[i];
								if (s.data.name == t) return s
							}
							return null
						}, t.prototype.findBoneIndex = function(t) {
							if (null == t) throw new Error("boneName cannot be null.");
							for (var e = this.bones, i = 0, n = e.length; i < n; i++)
								if (e[i].data.name == t) return i;
							return -1
						}, t.prototype.findSlot = function(t) {
							if (null == t) throw new Error("slotName cannot be null.");
							for (var e = this.slots, i = 0, n = e.length; i < n; i++) {
								var s = e[i];
								if (s.data.name == t) return s
							}
							return null
						}, t.prototype.findSlotIndex = function(t) {
							if (null == t) throw new Error("slotName cannot be null.");
							for (var e = this.slots, i = 0, n = e.length; i < n; i++)
								if (e[i].data.name == t) return i;
							return -1
						}, t.prototype.setSkinByName = function(t) {
							var e = this.data.findSkin(t);
							if (null == e) throw new Error("Skin not found: " + t);
							this.setSkin(e)
						}, t.prototype.setSkin = function(t) {
							if (null != t)
								if (null != this.skin) t.attachAll(this, this.skin);
								else
									for (var e = this.slots, i = 0, n = e.length; i < n; i++) {
										var s = e[i],
											o = s.data.attachmentName;
										if (null != o) {
											var r = t.getAttachment(i, o);
											null != r && s.setAttachment(r)
										}
									}
							this.skin = t
						}, t.prototype.getAttachmentByName = function(t, e) {
							return this.getAttachment(this.data.findSlotIndex(t), e)
						}, t.prototype.getAttachment = function(t, e) {
							if (null == e) throw new Error("attachmentName cannot be null.");
							if (null != this.skin) {
								var i = this.skin.getAttachment(t, e);
								if (null != i) return i
							}
							return null != this.data.defaultSkin ? this.data.defaultSkin.getAttachment(t, e) : null
						}, t.prototype.setAttachment = function(t, e) {
							if (null == t) throw new Error("slotName cannot be null.");
							for (var i = this.slots, n = 0, s = i.length; n < s; n++) {
								var o = i[n];
								if (o.data.name == t) {
									var r = null;
									if (null != e && null == (r = this.getAttachment(n, e))) throw new Error("Attachment not found: " + e + ", for slot: " + t);
									return void o.setAttachment(r)
								}
							}
							throw new Error("Slot not found: " + t)
						}, t.prototype.findIkConstraint = function(t) {
							if (null == t) throw new Error("constraintName cannot be null.");
							for (var e = this.ikConstraints, i = 0, n = e.length; i < n; i++) {
								var s = e[i];
								if (s.data.name == t) return s
							}
							return null
						}, t.prototype.findTransformConstraint = function(t) {
							if (null == t) throw new Error("constraintName cannot be null.");
							for (var e = this.transformConstraints, i = 0, n = e.length; i < n; i++) {
								var s = e[i];
								if (s.data.name == t) return s
							}
							return null
						}, t.prototype.findPathConstraint = function(t) {
							if (null == t) throw new Error("constraintName cannot be null.");
							for (var e = this.pathConstraints, i = 0, n = e.length; i < n; i++) {
								var s = e[i];
								if (s.data.name == t) return s
							}
							return null
						}, t.prototype.getBounds = function(t, i, n) {
							if (null == t) throw new Error("offset cannot be null.");
							if (null == i) throw new Error("size cannot be null.");
							for (var s = this.drawOrder, o = Number.POSITIVE_INFINITY, r = Number.POSITIVE_INFINITY, a = Number.NEGATIVE_INFINITY, l = Number.NEGATIVE_INFINITY, h = 0, u = s.length; h < u; h++) {
								var c = s[h],
									d = 0,
									p = null,
									_ = c.getAttachment();
								if (_ instanceof e.RegionAttachment) d = 8, p = e.Utils.setArraySize(n, d, 0), _.computeWorldVertices(c.bone, p, 0, 2);
								else if (_ instanceof e.MeshAttachment) {
									var m = _;
									d = m.worldVerticesLength, p = e.Utils.setArraySize(n, d, 0), m.computeWorldVertices(c, 0, d, p, 0, 2)
								}
								if (null != p)
									for (var g = 0, f = p.length; g < f; g += 2) {
										var S = p[g],
											y = p[g + 1];
										o = Math.min(o, S), r = Math.min(r, y), a = Math.max(a, S), l = Math.max(l, y)
									}
							}
							t.set(o, r), i.set(a - o, l - r)
						}, t.prototype.update = function(t) {
							this.time += t
						}, Object.defineProperty(t.prototype, "flipX", {
							get: function() {
								return -1 == this.scaleX
							},
							set: function(e) {
								t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")), this.scaleX = e ? 1 : -1
							},
							enumerable: !0,
							configurable: !0
						}), Object.defineProperty(t.prototype, "flipY", {
							get: function() {
								return -1 == this.scaleY
							},
							set: function(e) {
								t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")), this.scaleY = e ? 1 : -1
							},
							enumerable: !0,
							configurable: !0
						}), t.deprecatedWarning1 = !1, t
					}(), e.Skeleton = i
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), i = function() {
						function t() {
							this.minX = 0, this.minY = 0, this.maxX = 0, this.maxY = 0, this.boundingBoxes = new Array, this.polygons = new Array, this.polygonPool = new e.Pool((function() {
								return e.Utils.newFloatArray(16)
							}))
						}
						return t.prototype.update = function(t, i) {
							if (null == t) throw new Error("skeleton cannot be null.");
							var n = this.boundingBoxes,
								s = this.polygons,
								o = this.polygonPool,
								r = t.slots,
								a = r.length;
							n.length = 0, o.freeAll(s), s.length = 0;
							for (var l = 0; l < a; l++) {
								var h = r[l],
									u = h.getAttachment();
								if (u instanceof e.BoundingBoxAttachment) {
									var c = u;
									n.push(c);
									var d = o.obtain();
									d.length != c.worldVerticesLength && (d = e.Utils.newFloatArray(c.worldVerticesLength)), s.push(d), c.computeWorldVertices(h, 0, c.worldVerticesLength, d, 0, 2)
								}
							}
							i ? this.aabbCompute() : (this.minX = Number.POSITIVE_INFINITY, this.minY = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.maxY = Number.NEGATIVE_INFINITY)
						}, t.prototype.aabbCompute = function() {
							for (var t = Number.POSITIVE_INFINITY, e = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY, n = Number.NEGATIVE_INFINITY, s = this.polygons, o = 0, r = s.length; o < r; o++)
								for (var a = s[o], l = a, h = 0, u = a.length; h < u; h += 2) {
									var c = l[h],
										d = l[h + 1];
									t = Math.min(t, c), e = Math.min(e, d), i = Math.max(i, c), n = Math.max(n, d)
								}
							this.minX = t, this.minY = e, this.maxX = i, this.maxY = n
						}, t.prototype.aabbContainsPoint = function(t, e) {
							return t >= this.minX && t <= this.maxX && e >= this.minY && e <= this.maxY
						}, t.prototype.aabbIntersectsSegment = function(t, e, i, n) {
							var s = this.minX,
								o = this.minY,
								r = this.maxX,
								a = this.maxY;
							if (t <= s && i <= s || e <= o && n <= o || t >= r && i >= r || e >= a && n >= a) return !1;
							var l = (n - e) / (i - t),
								h = l * (s - t) + e;
							if (h > o && h < a) return !0;
							if ((h = l * (r - t) + e) > o && h < a) return !0;
							var u = (o - e) / l + t;
							return u > s && u < r || (u = (a - e) / l + t) > s && u < r
						}, t.prototype.aabbIntersectsSkeleton = function(t) {
							return this.minX < t.maxX && this.maxX > t.minX && this.minY < t.maxY && this.maxY > t.minY
						}, t.prototype.containsPoint = function(t, e) {
							for (var i = this.polygons, n = 0, s = i.length; n < s; n++)
								if (this.containsPointPolygon(i[n], t, e)) return this.boundingBoxes[n];
							return null
						}, t.prototype.containsPointPolygon = function(t, e, i) {
							for (var n = t, s = t.length, o = s - 2, r = !1, a = 0; a < s; a += 2) {
								var l = n[a + 1],
									h = n[o + 1];
								if (l < i && h >= i || h < i && l >= i) {
									var u = n[a];
									u + (i - l) / (h - l) * (n[o] - u) < e && (r = !r)
								}
								o = a
							}
							return r
						}, t.prototype.intersectsSegment = function(t, e, i, n) {
							for (var s = this.polygons, o = 0, r = s.length; o < r; o++)
								if (this.intersectsSegmentPolygon(s[o], t, e, i, n)) return this.boundingBoxes[o];
							return null
						}, t.prototype.intersectsSegmentPolygon = function(t, e, i, n, s) {
							for (var o = t, r = t.length, a = e - n, l = i - s, h = e * s - i * n, u = o[r - 2], c = o[r - 1], d = 0; d < r; d += 2) {
								var p = o[d],
									_ = o[d + 1],
									m = u * _ - c * p,
									g = u - p,
									f = c - _,
									S = a * f - l * g,
									y = (h * g - a * m) / S;
								if ((y >= u && y <= p || y >= p && y <= u) && (y >= e && y <= n || y >= n && y <= e)) {
									var v = (h * f - l * m) / S;
									if ((v >= c && v <= _ || v >= _ && v <= c) && (v >= i && v <= s || v >= s && v <= i)) return !0
								}
								u = p, c = _
							}
							return !1
						}, t.prototype.getPolygon = function(t) {
							if (null == t) throw new Error("boundingBox cannot be null.");
							var e = this.boundingBoxes.indexOf(t);
							return -1 == e ? null : this.polygons[e]
						}, t.prototype.getWidth = function() {
							return this.maxX - this.minX
						}, t.prototype.getHeight = function() {
							return this.maxY - this.minY
						}, t
					}(), e.SkeletonBounds = i
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), i = function() {
						function t() {
							this.triangulator = new e.Triangulator, this.clippingPolygon = new Array, this.clipOutput = new Array, this.clippedVertices = new Array, this.clippedTriangles = new Array, this.scratch = new Array
						}
						return t.prototype.clipStart = function(i, n) {
							if (null != this.clipAttachment) return 0;
							this.clipAttachment = n;
							var s = n.worldVerticesLength,
								o = e.Utils.setArraySize(this.clippingPolygon, s);
							n.computeWorldVertices(i, 0, s, o, 0, 2);
							var r = this.clippingPolygon;
							t.makeClockwise(r);
							for (var a = this.clippingPolygons = this.triangulator.decompose(r, this.triangulator.triangulate(r)), l = 0, h = a.length; l < h; l++) {
								var u = a[l];
								t.makeClockwise(u), u.push(u[0]), u.push(u[1])
							}
							return a.length
						}, t.prototype.clipEndWithSlot = function(t) {
							null != this.clipAttachment && this.clipAttachment.endSlot == t.data && this.clipEnd()
						}, t.prototype.clipEnd = function() {
							null != this.clipAttachment && (this.clipAttachment = null, this.clippingPolygons = null, this.clippedVertices.length = 0, this.clippedTriangles.length = 0, this.clippingPolygon.length = 0)
						}, t.prototype.isClipping = function() {
							return null != this.clipAttachment
						}, t.prototype.clipTriangles = function(t, i, n, s, o, r, a, l) {
							var h = this.clipOutput,
								u = this.clippedVertices,
								c = this.clippedTriangles,
								d = this.clippingPolygons,
								p = this.clippingPolygons.length,
								_ = l ? 12 : 8,
								m = 0;
							u.length = 0, c.length = 0;
							t: for (var g = 0; g < s; g += 3)
								for (var f = n[g] << 1, S = t[f], y = t[f + 1], v = o[f], T = o[f + 1], E = t[f = n[g + 1] << 1], b = t[f + 1], A = o[f], P = o[f + 1], I = t[f = n[g + 2] << 1], w = t[f + 1], L = o[f], C = o[f + 1], x = 0; x < p; x++) {
									var B = u.length;
									if (!this.clip(S, y, E, b, I, w, d[x], h)) {
										(U = e.Utils.setArraySize(u, B + 3 * _))[B] = S, U[B + 1] = y, U[B + 2] = r.r, U[B + 3] = r.g, U[B + 4] = r.b, U[B + 5] = r.a, l ? (U[B + 6] = v, U[B + 7] = T, U[B + 8] = a.r, U[B + 9] = a.g, U[B + 10] = a.b, U[B + 11] = a.a, U[B + 12] = E, U[B + 13] = b, U[B + 14] = r.r, U[B + 15] = r.g, U[B + 16] = r.b, U[B + 17] = r.a, U[B + 18] = A, U[B + 19] = P, U[B + 20] = a.r, U[B + 21] = a.g, U[B + 22] = a.b, U[B + 23] = a.a, U[B + 24] = I, U[B + 25] = w, U[B + 26] = r.r, U[B + 27] = r.g, U[B + 28] = r.b, U[B + 29] = r.a, U[B + 30] = L, U[B + 31] = C, U[B + 32] = a.r, U[B + 33] = a.g, U[B + 34] = a.b, U[B + 35] = a.a) : (U[B + 6] = v, U[B + 7] = T, U[B + 8] = E, U[B + 9] = b, U[B + 10] = r.r, U[B + 11] = r.g, U[B + 12] = r.b, U[B + 13] = r.a, U[B + 14] = A, U[B + 15] = P, U[B + 16] = I, U[B + 17] = w, U[B + 18] = r.r, U[B + 19] = r.g, U[B + 20] = r.b, U[B + 21] = r.a, U[B + 22] = L, U[B + 23] = C), B = c.length, (q = e.Utils.setArraySize(c, B + 3))[B] = m, q[B + 1] = m + 1, q[B + 2] = m + 2, m += 3;
										continue t
									}
									var O = h.length;
									if (0 != O) {
										for (var N = b - w, M = I - E, R = S - I, D = w - y, k = 1 / (N * R + M * (y - w)), F = O >> 1, G = this.clipOutput, U = e.Utils.setArraySize(u, B + F * _), W = 0; W < O; W += 2) {
											var H = G[W],
												V = G[W + 1];
											U[B] = H, U[B + 1] = V, U[B + 2] = r.r, U[B + 3] = r.g, U[B + 4] = r.b, U[B + 5] = r.a;
											var X = H - I,
												Y = V - w,
												z = (N * X + M * Y) * k,
												j = (D * X + R * Y) * k,
												K = 1 - z - j;
											U[B + 6] = v * z + A * j + L * K, U[B + 7] = T * z + P * j + C * K, l && (U[B + 8] = a.r, U[B + 9] = a.g, U[B + 10] = a.b, U[B + 11] = a.a), B += _
										}
										B = c.length;
										var q = e.Utils.setArraySize(c, B + 3 * (F - 2));
										for (F--, W = 1; W < F; W++) q[B] = m, q[B + 1] = m + W, q[B + 2] = m + W + 1, B += 3;
										m += F + 1
									}
								}
						}, t.prototype.clip = function(t, e, i, n, s, o, r, a) {
							var l = a,
								h = !1,
								u = null;
							r.length % 4 >= 2 ? (u = a, a = this.scratch) : u = this.scratch, u.length = 0, u.push(t), u.push(e), u.push(i), u.push(n), u.push(s), u.push(o), u.push(t), u.push(e), a.length = 0;
							for (var c = r, d = r.length - 4, p = 0;; p += 2) {
								for (var _ = c[p], m = c[p + 1], g = c[p + 2], f = c[p + 3], S = _ - g, y = m - f, v = u, T = u.length - 2, E = a.length, b = 0; b < T; b += 2) {
									var A = v[b],
										P = v[b + 1],
										I = v[b + 2],
										w = v[b + 3],
										L = S * (w - f) - y * (I - g) > 0;
									if (S * (P - f) - y * (A - g) > 0) {
										if (L) {
											a.push(I), a.push(w);
											continue
										}
										var C = ((B = I - A) * (m - P) - (x = w - P) * (_ - A)) / (x * (g - _) - B * (f - m));
										a.push(_ + (g - _) * C), a.push(m + (f - m) * C)
									} else if (L) {
										var x, B;
										C = ((B = I - A) * (m - P) - (x = w - P) * (_ - A)) / (x * (g - _) - B * (f - m)), a.push(_ + (g - _) * C), a.push(m + (f - m) * C), a.push(I), a.push(w)
									}
									h = !0
								}
								if (E == a.length) return l.length = 0, !0;
								if (a.push(a[0]), a.push(a[1]), p == d) break;
								var O = a;
								(a = u).length = 0, u = O
							}
							if (l != a) {
								l.length = 0, p = 0;
								for (var N = a.length - 2; p < N; p++) l[p] = a[p]
							} else l.length = l.length - 2;
							return h
						}, t.makeClockwise = function(t) {
							for (var e = t, i = t.length, n = e[i - 2] * e[1] - e[0] * e[i - 1], s = 0, o = 0, r = 0, a = 0, l = i - 3; a < l; a += 2) s = e[a], o = e[a + 1], r = e[a + 2], n += s * e[a + 3] - r * o;
							if (!(n < 0)) {
								a = 0;
								var h = i - 2;
								for (l = i >> 1; a < l; a += 2) {
									var u = e[a],
										c = e[a + 1],
										d = h - a;
									e[a] = e[d], e[a + 1] = e[d + 1], e[d] = u, e[d + 1] = c
								}
							}
						}, t
					}(), e.SkeletonClipping = i
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), i = function() {
						function t() {
							this.bones = new Array, this.slots = new Array, this.skins = new Array, this.events = new Array, this.animations = new Array, this.ikConstraints = new Array, this.transformConstraints = new Array, this.pathConstraints = new Array, this.fps = 0
						}
						return t.prototype.findBone = function(t) {
							if (null == t) throw new Error("boneName cannot be null.");
							for (var e = this.bones, i = 0, n = e.length; i < n; i++) {
								var s = e[i];
								if (s.name == t) return s
							}
							return null
						}, t.prototype.findBoneIndex = function(t) {
							if (null == t) throw new Error("boneName cannot be null.");
							for (var e = this.bones, i = 0, n = e.length; i < n; i++)
								if (e[i].name == t) return i;
							return -1
						}, t.prototype.findSlot = function(t) {
							if (null == t) throw new Error("slotName cannot be null.");
							for (var e = this.slots, i = 0, n = e.length; i < n; i++) {
								var s = e[i];
								if (s.name == t) return s
							}
							return null
						}, t.prototype.findSlotIndex = function(t) {
							if (null == t) throw new Error("slotName cannot be null.");
							for (var e = this.slots, i = 0, n = e.length; i < n; i++)
								if (e[i].name == t) return i;
							return -1
						}, t.prototype.findSkin = function(t) {
							if (null == t) throw new Error("skinName cannot be null.");
							for (var e = this.skins, i = 0, n = e.length; i < n; i++) {
								var s = e[i];
								if (s.name == t) return s
							}
							return null
						}, t.prototype.findEvent = function(t) {
							if (null == t) throw new Error("eventDataName cannot be null.");
							for (var e = this.events, i = 0, n = e.length; i < n; i++) {
								var s = e[i];
								if (s.name == t) return s
							}
							return null
						}, t.prototype.findAnimation = function(t) {
							if (null == t) throw new Error("animationName cannot be null.");
							for (var e = this.animations, i = 0, n = e.length; i < n; i++) {
								var s = e[i];
								if (s.name == t) return s
							}
							return null
						}, t.prototype.findIkConstraint = function(t) {
							if (null == t) throw new Error("constraintName cannot be null.");
							for (var e = this.ikConstraints, i = 0, n = e.length; i < n; i++) {
								var s = e[i];
								if (s.name == t) return s
							}
							return null
						}, t.prototype.findTransformConstraint = function(t) {
							if (null == t) throw new Error("constraintName cannot be null.");
							for (var e = this.transformConstraints, i = 0, n = e.length; i < n; i++) {
								var s = e[i];
								if (s.name == t) return s
							}
							return null
						}, t.prototype.findPathConstraint = function(t) {
							if (null == t) throw new Error("constraintName cannot be null.");
							for (var e = this.pathConstraints, i = 0, n = e.length; i < n; i++) {
								var s = e[i];
								if (s.name == t) return s
							}
							return null
						}, t.prototype.findPathConstraintIndex = function(t) {
							if (null == t) throw new Error("pathConstraintName cannot be null.");
							for (var e = this.pathConstraints, i = 0, n = e.length; i < n; i++)
								if (e[i].name == t) return i;
							return -1
						}, t
					}(), e.SkeletonData = i
				}(i || (i = {})),
				function(t) {
					! function(t) {
						var e = function() {
							function e(t) {
								this.scale = 1, this.linkedMeshes = new Array, this.attachmentLoader = t
							}
							return e.prototype.readSkeletonData = function(i) {
								var n = this.scale,
									s = new t.SkeletonData,
									o = "string" == typeof i ? JSON.parse(i) : i,
									r = o.skeleton;
								if (null != r && (s.hash = r.hash, s.version = r.spine, s.width = r.width, s.height = r.height, s.fps = r.fps, s.imagesPath = r.images), o.bones)
									for (var a = 0; a < o.bones.length; a++) {
										var l = o.bones[a],
											h = null,
											u = this.getValue(l, "parent", null);
										if (null != u && null == (h = s.findBone(u))) throw new Error("Parent bone not found: " + u);
										(_ = new t.BoneData(s.bones.length, l.name, h)).length = this.getValue(l, "length", 0) * n, _.x = this.getValue(l, "x", 0) * n, _.y = this.getValue(l, "y", 0) * n, _.rotation = this.getValue(l, "rotation", 0), _.scaleX = this.getValue(l, "scaleX", 1), _.scaleY = this.getValue(l, "scaleY", 1), _.shearX = this.getValue(l, "shearX", 0), _.shearY = this.getValue(l, "shearY", 0), _.transformMode = e.transformModeFromString(this.getValue(l, "transform", "normal")), s.bones.push(_)
									}
								if (o.slots)
									for (a = 0; a < o.slots.length; a++) {
										var c = (P = o.slots[a]).name,
											d = P.bone,
											p = s.findBone(d);
										if (null == p) throw new Error("Slot bone not found: " + d);
										var _ = new t.SlotData(s.slots.length, c, p),
											m = this.getValue(P, "color", null);
										null != m && _.color.setFromString(m);
										var g = this.getValue(P, "dark", null);
										null != g && (_.darkColor = new t.Color(1, 1, 1, 1), _.darkColor.setFromString(g)), _.attachmentName = this.getValue(P, "attachment", null), _.blendMode = e.blendModeFromString(this.getValue(P, "blend", "normal")), s.slots.push(_)
									}
								if (o.ik)
									for (a = 0; a < o.ik.length; a++) {
										var f = o.ik[a];
										(_ = new t.IkConstraintData(f.name)).order = this.getValue(f, "order", 0);
										for (var S = 0; S < f.bones.length; S++) {
											if (d = f.bones[S], null == (v = s.findBone(d))) throw new Error("IK bone not found: " + d);
											_.bones.push(v)
										}
										var y = f.target;
										if (_.target = s.findBone(y), null == _.target) throw new Error("IK target bone not found: " + y);
										_.bendDirection = this.getValue(f, "bendPositive", !0) ? 1 : -1, _.mix = this.getValue(f, "mix", 1), s.ikConstraints.push(_)
									}
								if (o.transform)
									for (a = 0; a < o.transform.length; a++) {
										for (f = o.transform[a], (_ = new t.TransformConstraintData(f.name)).order = this.getValue(f, "order", 0), S = 0; S < f.bones.length; S++) {
											if (d = f.bones[S], null == (v = s.findBone(d))) throw new Error("Transform constraint bone not found: " + d);
											_.bones.push(v)
										}
										if (y = f.target, _.target = s.findBone(y), null == _.target) throw new Error("Transform constraint target bone not found: " + y);
										_.local = this.getValue(f, "local", !1), _.relative = this.getValue(f, "relative", !1), _.offsetRotation = this.getValue(f, "rotation", 0), _.offsetX = this.getValue(f, "x", 0) * n, _.offsetY = this.getValue(f, "y", 0) * n, _.offsetScaleX = this.getValue(f, "scaleX", 0), _.offsetScaleY = this.getValue(f, "scaleY", 0), _.offsetShearY = this.getValue(f, "shearY", 0), _.rotateMix = this.getValue(f, "rotateMix", 1), _.translateMix = this.getValue(f, "translateMix", 1), _.scaleMix = this.getValue(f, "scaleMix", 1), _.shearMix = this.getValue(f, "shearMix", 1), s.transformConstraints.push(_)
									}
								if (o.path)
									for (a = 0; a < o.path.length; a++) {
										for (f = o.path[a], (_ = new t.PathConstraintData(f.name)).order = this.getValue(f, "order", 0), S = 0; S < f.bones.length; S++) {
											var v;
											if (d = f.bones[S], null == (v = s.findBone(d))) throw new Error("Transform constraint bone not found: " + d);
											_.bones.push(v)
										}
										if (y = f.target, _.target = s.findSlot(y), null == _.target) throw new Error("Path target slot not found: " + y);
										_.positionMode = e.positionModeFromString(this.getValue(f, "positionMode", "percent")), _.spacingMode = e.spacingModeFromString(this.getValue(f, "spacingMode", "length")), _.rotateMode = e.rotateModeFromString(this.getValue(f, "rotateMode", "tangent")), _.offsetRotation = this.getValue(f, "rotation", 0), _.position = this.getValue(f, "position", 0), _.positionMode == t.PositionMode.Fixed && (_.position *= n), _.spacing = this.getValue(f, "spacing", 0), _.spacingMode != t.SpacingMode.Length && _.spacingMode != t.SpacingMode.Fixed || (_.spacing *= n), _.rotateMix = this.getValue(f, "rotateMix", 1), _.translateMix = this.getValue(f, "translateMix", 1), s.pathConstraints.push(_)
									}
								if (o.skins)
									for (var T in o.skins) {
										var E = o.skins[T],
											b = new t.Skin(T);
										for (var c in E) {
											var A = s.findSlotIndex(c);
											if (-1 == A) throw new Error("Slot not found: " + c);
											var P = E[c];
											for (var I in P) {
												var w = this.readAttachment(P[I], b, A, I, s);
												null != w && b.addAttachment(A, I, w)
											}
										}
										s.skins.push(b), "default" == b.name && (s.defaultSkin = b)
									}
								a = 0;
								for (var L = this.linkedMeshes.length; a < L; a++) {
									var C = this.linkedMeshes[a];
									if (null == (b = null == C.skin ? s.defaultSkin : s.findSkin(C.skin))) throw new Error("Skin not found: " + C.skin);
									var x = b.getAttachment(C.slotIndex, C.parent);
									if (null == x) throw new Error("Parent mesh not found: " + C.parent);
									C.mesh.setParentMesh(x)
								}
								if (this.linkedMeshes.length = 0, o.events)
									for (var B in o.events) {
										var O = o.events[B];
										(_ = new t.EventData(B)).intValue = this.getValue(O, "int", 0), _.floatValue = this.getValue(O, "float", 0), _.stringValue = this.getValue(O, "string", ""), _.audioPath = this.getValue(O, "audio", null), null != _.audioPath && (_.volume = this.getValue(O, "volume", 1), _.balance = this.getValue(O, "balance", 0)), s.events.push(_)
									}
								if (o.animations)
									for (var N in o.animations) {
										var M = o.animations[N];
										this.readAnimation(M, N, s)
									}
								return s
							}, e.prototype.readAttachment = function(e, n, s, o, r) {
								var a = this.scale;
								switch (o = this.getValue(e, "name", o), this.getValue(e, "type", "region")) {
									case "region":
										var l = this.getValue(e, "path", o),
											h = this.attachmentLoader.newRegionAttachment(n, o, l);
										return null == h ? null : (h.path = l, h.x = this.getValue(e, "x", 0) * a, h.y = this.getValue(e, "y", 0) * a, h.scaleX = this.getValue(e, "scaleX", 1), h.scaleY = this.getValue(e, "scaleY", 1), h.rotation = this.getValue(e, "rotation", 0), h.width = e.width * a, h.height = e.height * a, null != (y = this.getValue(e, "color", null)) && h.color.setFromString(y), h);
									case "boundingbox":
										var u = this.attachmentLoader.newBoundingBoxAttachment(n, o);
										return null == u ? null : (this.readVertices(e, u, e.vertexCount << 1), null != (y = this.getValue(e, "color", null)) && u.color.setFromString(y), u);
									case "mesh":
									case "linkedmesh":
										l = this.getValue(e, "path", o);
										var c = this.attachmentLoader.newMeshAttachment(n, o, l);
										if (null == c) return null;
										c.path = l, null != (y = this.getValue(e, "color", null)) && c.color.setFromString(y);
										var d = this.getValue(e, "parent", null);
										if (null != d) return c.inheritDeform = this.getValue(e, "deform", !0), this.linkedMeshes.push(new i(c, this.getValue(e, "skin", null), s, d)), c;
										var p = e.uvs;
										return this.readVertices(e, c, p.length), c.triangles = e.triangles, c.regionUVs = new Float32Array(p), c.hullLength = 2 * this.getValue(e, "hull", 0), c;
									case "path":
										if (null == (l = this.attachmentLoader.newPathAttachment(n, o))) return null;
										l.closed = this.getValue(e, "closed", !1), l.constantSpeed = this.getValue(e, "constantSpeed", !0);
										var _ = e.vertexCount;
										this.readVertices(e, l, _ << 1);
										for (var m = t.Utils.newArray(_ / 3, 0), g = 0; g < e.lengths.length; g++) m[g] = e.lengths[g] * a;
										return l.lengths = m, null != (y = this.getValue(e, "color", null)) && l.color.setFromString(y), l;
									case "point":
										var f = this.attachmentLoader.newPointAttachment(n, o);
										return null == f ? null : (f.x = this.getValue(e, "x", 0) * a, f.y = this.getValue(e, "y", 0) * a, f.rotation = this.getValue(e, "rotation", 0), null != (y = this.getValue(e, "color", null)) && f.color.setFromString(y), f);
									case "clipping":
										var S = this.attachmentLoader.newClippingAttachment(n, o);
										if (null == S) return null;
										var y, v = this.getValue(e, "end", null);
										if (null != v) {
											var T = r.findSlot(v);
											if (null == T) throw new Error("Clipping end slot not found: " + v);
											S.endSlot = T
										}
										return _ = e.vertexCount, this.readVertices(e, S, _ << 1), null != (y = this.getValue(e, "color", null)) && S.color.setFromString(y), S
								}
								return null
							}, e.prototype.readVertices = function(e, i, n) {
								var s = this.scale;
								i.worldVerticesLength = n;
								var o = e.vertices;
								if (n != o.length) {
									var r = new Array,
										a = new Array;
									for (c = 0, d = o.length; c < d;) {
										var l = o[c++];
										a.push(l);
										for (var h = c + 4 * l; c < h; c += 4) a.push(o[c]), r.push(o[c + 1] * s), r.push(o[c + 2] * s), r.push(o[c + 3])
									}
									i.bones = a, i.vertices = t.Utils.toFloatArray(r)
								} else {
									var u = t.Utils.toFloatArray(o);
									if (1 != s)
										for (var c = 0, d = o.length; c < d; c++) u[c] *= s;
									i.vertices = u
								}
							}, e.prototype.readAnimation = function(e, i, n) {
								var s = this.scale,
									o = new Array,
									r = 0;
								if (e.slots)
									for (var a in e.slots) {
										var l = e.slots[a];
										if (-1 == (q = n.findSlotIndex(a))) throw new Error("Slot not found: " + a);
										for (var h in l) {
											var u = l[h];
											if ("attachment" == h) {
												(v = new t.AttachmentTimeline(u.length)).slotIndex = q;
												for (var c = 0, d = 0; d < u.length; d++) {
													var p = u[d];
													v.setFrame(c++, p.time, p.name)
												}
												o.push(v), r = Math.max(r, v.frames[v.getFrameCount() - 1])
											} else if ("color" == h) {
												for ((v = new t.ColorTimeline(u.length)).slotIndex = q, c = 0, d = 0; d < u.length; d++) {
													p = u[d];
													var _ = new t.Color;
													_.setFromString(p.color || "ffffffff"), v.setFrame(c, p.time, _.r, _.g, _.b, _.a), this.readCurve(p, v, c), c++
												}
												o.push(v), r = Math.max(r, v.frames[(v.getFrameCount() - 1) * t.ColorTimeline.ENTRIES])
											} else {
												if ("twoColor" != h) throw new Error("Invalid timeline type for a slot: " + h + " (" + a + ")");
												for ((v = new t.TwoColorTimeline(u.length)).slotIndex = q, c = 0, d = 0; d < u.length; d++) {
													p = u[d];
													var m = new t.Color,
														g = new t.Color;
													m.setFromString(p.light), g.setFromString(p.dark), v.setFrame(c, p.time, m.r, m.g, m.b, m.a, g.r, g.g, g.b), this.readCurve(p, v, c), c++
												}
												o.push(v), r = Math.max(r, v.frames[(v.getFrameCount() - 1) * t.TwoColorTimeline.ENTRIES])
											}
										}
									}
								if (e.bones)
									for (var f in e.bones) {
										var S = e.bones[f],
											y = n.findBoneIndex(f);
										if (-1 == y) throw new Error("Bone not found: " + f);
										for (var h in S)
											if (u = S[h], "rotate" === h) {
												for ((v = new t.RotateTimeline(u.length)).boneIndex = y, c = 0, d = 0; d < u.length; d++) p = u[d], v.setFrame(c, p.time, p.angle), this.readCurve(p, v, c), c++;
												o.push(v), r = Math.max(r, v.frames[(v.getFrameCount() - 1) * t.RotateTimeline.ENTRIES])
											} else {
												if ("translate" !== h && "scale" !== h && "shear" !== h) throw new Error("Invalid timeline type for a bone: " + h + " (" + f + ")");
												var v = null,
													T = 1;
												for ("scale" === h ? v = new t.ScaleTimeline(u.length) : "shear" === h ? v = new t.ShearTimeline(u.length) : (v = new t.TranslateTimeline(u.length), T = s), v.boneIndex = y, c = 0, d = 0; d < u.length; d++) {
													p = u[d];
													var E = this.getValue(p, "x", 0),
														b = this.getValue(p, "y", 0);
													v.setFrame(c, p.time, E * T, b * T), this.readCurve(p, v, c), c++
												}
												o.push(v), r = Math.max(r, v.frames[(v.getFrameCount() - 1) * t.TranslateTimeline.ENTRIES])
											}
									}
								if (e.ik)
									for (var A in e.ik) {
										var P = e.ik[A],
											I = n.findIkConstraint(A);
										for ((v = new t.IkConstraintTimeline(P.length)).ikConstraintIndex = n.ikConstraints.indexOf(I), c = 0, d = 0; d < P.length; d++) p = P[d], v.setFrame(c, p.time, this.getValue(p, "mix", 1), this.getValue(p, "bendPositive", !0) ? 1 : -1, this.getValue(p, "compress", !1), this.getValue(p, "stretch", !1)), this.readCurve(p, v, c), c++;
										o.push(v), r = Math.max(r, v.frames[(v.getFrameCount() - 1) * t.IkConstraintTimeline.ENTRIES])
									}
								if (e.transform)
									for (var A in e.transform) {
										for (P = e.transform[A], I = n.findTransformConstraint(A), (v = new t.TransformConstraintTimeline(P.length)).transformConstraintIndex = n.transformConstraints.indexOf(I), c = 0, d = 0; d < P.length; d++) p = P[d], v.setFrame(c, p.time, this.getValue(p, "rotateMix", 1), this.getValue(p, "translateMix", 1), this.getValue(p, "scaleMix", 1), this.getValue(p, "shearMix", 1)), this.readCurve(p, v, c), c++;
										o.push(v), r = Math.max(r, v.frames[(v.getFrameCount() - 1) * t.TransformConstraintTimeline.ENTRIES])
									}
								if (e.paths)
									for (var A in e.paths) {
										P = e.paths[A];
										var w = n.findPathConstraintIndex(A);
										if (-1 == w) throw new Error("Path constraint not found: " + A);
										var L = n.pathConstraints[w];
										for (var h in P)
											if (u = P[h], "position" === h || "spacing" === h) {
												for (v = null, T = 1, "spacing" === h ? (v = new t.PathConstraintSpacingTimeline(u.length), L.spacingMode != t.SpacingMode.Length && L.spacingMode != t.SpacingMode.Fixed || (T = s)) : (v = new t.PathConstraintPositionTimeline(u.length), L.positionMode == t.PositionMode.Fixed && (T = s)), v.pathConstraintIndex = w, c = 0, d = 0; d < u.length; d++) p = u[d], v.setFrame(c, p.time, this.getValue(p, h, 0) * T), this.readCurve(p, v, c), c++;
												o.push(v), r = Math.max(r, v.frames[(v.getFrameCount() - 1) * t.PathConstraintPositionTimeline.ENTRIES])
											} else if ("mix" === h) {
											for ((v = new t.PathConstraintMixTimeline(u.length)).pathConstraintIndex = w, c = 0, d = 0; d < u.length; d++) p = u[d], v.setFrame(c, p.time, this.getValue(p, "rotateMix", 1), this.getValue(p, "translateMix", 1)), this.readCurve(p, v, c), c++;
											o.push(v), r = Math.max(r, v.frames[(v.getFrameCount() - 1) * t.PathConstraintMixTimeline.ENTRIES])
										}
									}
								if (e.deform)
									for (var C in e.deform) {
										var x = e.deform[C],
											B = n.findSkin(C);
										if (null == B) throw new Error("Skin not found: " + C);
										for (var a in x) {
											if (l = x[a], -1 == (q = n.findSlotIndex(a))) throw new Error("Slot not found: " + l.name);
											for (var h in l) {
												u = l[h];
												var O = B.getAttachment(q, h);
												if (null == O) throw new Error("Deform attachment not found: " + u.name);
												var N = null != O.bones,
													M = O.vertices,
													R = N ? M.length / 3 * 2 : M.length;
												(v = new t.DeformTimeline(u.length)).slotIndex = q, v.attachment = O, c = 0;
												for (var D = 0; D < u.length; D++) {
													p = u[D];
													var k = void 0,
														F = this.getValue(p, "vertices", null);
													if (null == F) k = N ? t.Utils.newFloatArray(R) : M;
													else {
														k = t.Utils.newFloatArray(R);
														var G = this.getValue(p, "offset", 0);
														if (t.Utils.arrayCopy(F, 0, k, G, F.length), 1 != s)
															for (var U = (d = G) + F.length; d < U; d++) k[d] *= s;
														if (!N)
															for (d = 0; d < R; d++) k[d] += M[d]
													}
													v.setFrame(c, p.time, k), this.readCurve(p, v, c), c++
												}
												o.push(v), r = Math.max(r, v.frames[v.getFrameCount() - 1])
											}
										}
									}
								var W = e.drawOrder;
								if (null == W && (W = e.draworder), null != W) {
									v = new t.DrawOrderTimeline(W.length);
									var H = n.slots.length;
									for (c = 0, D = 0; D < W.length; D++) {
										var V = W[D],
											X = null,
											Y = this.getValue(V, "offsets", null);
										if (null != Y) {
											X = t.Utils.newArray(H, -1);
											var z = t.Utils.newArray(H - Y.length, 0),
												j = 0,
												K = 0;
											for (d = 0; d < Y.length; d++) {
												var q, Z = Y[d];
												if (-1 == (q = n.findSlotIndex(Z.slot))) throw new Error("Slot not found: " + Z.slot);
												for (; j != q;) z[K++] = j++;
												X[j + Z.offset] = j++
											}
											for (; j < H;) z[K++] = j++;
											for (d = H - 1; d >= 0; d--) - 1 == X[d] && (X[d] = z[--K])
										}
										v.setFrame(c++, V.time, X)
									}
									o.push(v), r = Math.max(r, v.frames[v.getFrameCount() - 1])
								}
								if (e.events) {
									for (v = new t.EventTimeline(e.events.length), c = 0, d = 0; d < e.events.length; d++) {
										var $ = e.events[d],
											Q = n.findEvent($.name);
										if (null == Q) throw new Error("Event not found: " + $.name);
										var J = new t.Event(t.Utils.toSinglePrecision($.time), Q);
										J.intValue = this.getValue($, "int", Q.intValue), J.floatValue = this.getValue($, "float", Q.floatValue), J.stringValue = this.getValue($, "string", Q.stringValue), null != J.data.audioPath && (J.volume = this.getValue($, "volume", 1), J.balance = this.getValue($, "balance", 0)), v.setFrame(c++, J)
									}
									o.push(v), r = Math.max(r, v.frames[v.getFrameCount() - 1])
								}
								if (isNaN(r)) throw new Error("Error while parsing animation, duration is NaN");
								n.animations.push(new t.Animation(i, o, r))
							}, e.prototype.readCurve = function(t, e, i) {
								if (t.curve)
									if ("stepped" === t.curve) e.setStepped(i);
									else if ("[object Array]" === Object.prototype.toString.call(t.curve)) {
									var n = t.curve;
									e.setCurve(i, n[0], n[1], n[2], n[3])
								}
							}, e.prototype.getValue = function(t, e, i) {
								return void 0 !== t[e] ? t[e] : i
							}, e.blendModeFromString = function(e) {
								if ("normal" == (e = e.toLowerCase())) return t.BlendMode.Normal;
								if ("additive" == e) return t.BlendMode.Additive;
								if ("multiply" == e) return t.BlendMode.Multiply;
								if ("screen" == e) return t.BlendMode.Screen;
								throw new Error("Unknown blend mode: " + e)
							}, e.positionModeFromString = function(e) {
								if ("fixed" == (e = e.toLowerCase())) return t.PositionMode.Fixed;
								if ("percent" == e) return t.PositionMode.Percent;
								throw new Error("Unknown position mode: " + e)
							}, e.spacingModeFromString = function(e) {
								if ("length" == (e = e.toLowerCase())) return t.SpacingMode.Length;
								if ("fixed" == e) return t.SpacingMode.Fixed;
								if ("percent" == e) return t.SpacingMode.Percent;
								throw new Error("Unknown position mode: " + e)
							}, e.rotateModeFromString = function(e) {
								if ("tangent" == (e = e.toLowerCase())) return t.RotateMode.Tangent;
								if ("chain" == e) return t.RotateMode.Chain;
								if ("chainscale" == e) return t.RotateMode.ChainScale;
								throw new Error("Unknown rotate mode: " + e)
							}, e.transformModeFromString = function(e) {
								if ("normal" == (e = e.toLowerCase())) return t.TransformMode.Normal;
								if ("onlytranslation" == e) return t.TransformMode.OnlyTranslation;
								if ("norotationorreflection" == e) return t.TransformMode.NoRotationOrReflection;
								if ("noscale" == e) return t.TransformMode.NoScale;
								if ("noscaleorreflection" == e) return t.TransformMode.NoScaleOrReflection;
								throw new Error("Unknown transform mode: " + e)
							}, e
						}();
						t.SkeletonJson = e;
						var i = function(t, e, i, n) {
							this.mesh = t, this.skin = e, this.slotIndex = i, this.parent = n
						}
					}(t.core || (t.core = {}))
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), i = function() {
						function t(t) {
							if (this.attachments = new Array, null == t) throw new Error("name cannot be null.");
							this.name = t
						}
						return t.prototype.addAttachment = function(t, e, i) {
							if (null == i) throw new Error("attachment cannot be null.");
							var n = this.attachments;
							t >= n.length && (n.length = t + 1), n[t] || (n[t] = {}), n[t][e] = i
						}, t.prototype.getAttachment = function(t, e) {
							var i = this.attachments[t];
							return i ? i[e] : null
						}, t.prototype.attachAll = function(t, e) {
							for (var i = 0, n = 0; n < t.slots.length; n++) {
								var s = t.slots[n],
									o = s.getAttachment();
								if (o && i < e.attachments.length) {
									var r = e.attachments[i];
									for (var a in r)
										if (o == r[a]) {
											var l = this.getAttachment(i, a);
											null != l && s.setAttachment(l);
											break
										}
								}
								i++
							}
						}, t
					}(), e.Skin = i
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), i = function() {
						function t(t, i) {
							if (this.attachmentVertices = new Array, null == t) throw new Error("data cannot be null.");
							if (null == i) throw new Error("bone cannot be null.");
							this.data = t, this.bone = i, this.color = new e.Color, this.darkColor = null == t.darkColor ? null : new e.Color, this.setToSetupPose(), this.blendMode = this.data.blendMode
						}
						return t.prototype.getAttachment = function() {
							return this.attachment
						}, t.prototype.setAttachment = function(t) {
							this.attachment != t && (this.attachment = t, this.attachmentTime = this.bone.skeleton.time, this.attachmentVertices.length = 0)
						}, t.prototype.setAttachmentTime = function(t) {
							this.attachmentTime = this.bone.skeleton.time - t
						}, t.prototype.getAttachmentTime = function() {
							return this.bone.skeleton.time - this.attachmentTime
						}, t.prototype.setToSetupPose = function() {
							this.color.setFromColor(this.data.color), null != this.darkColor && this.darkColor.setFromColor(this.data.darkColor), null == this.data.attachmentName ? this.attachment = null : (this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName)))
						}, t
					}(), e.Slot = i
				}(i || (i = {})),
				function(t) {
					var e;
					(e = t.core || (t.core = {})).SlotData = function(t, i, n) {
						if (this.color = new e.Color(1, 1, 1, 1), t < 0) throw new Error("index must be >= 0.");
						if (null == i) throw new Error("name cannot be null.");
						if (null == n) throw new Error("boneData cannot be null.");
						this.index = t, this.name = i, this.boneData = n
					}
				}(i || (i = {})),
				function(t) {
					! function(t) {
						var e, i, n = function() {
							function t(t) {
								this._image = t
							}
							return t.prototype.getImage = function() {
								return this._image
							}, t.filterFromString = function(t) {
								switch (t.toLowerCase()) {
									case "nearest":
										return e.Nearest;
									case "linear":
										return e.Linear;
									case "mipmap":
										return e.MipMap;
									case "mipmapnearestnearest":
										return e.MipMapNearestNearest;
									case "mipmaplinearnearest":
										return e.MipMapLinearNearest;
									case "mipmapnearestlinear":
										return e.MipMapNearestLinear;
									case "mipmaplinearlinear":
										return e.MipMapLinearLinear;
									default:
										throw new Error("Unknown texture filter " + t)
								}
							}, t.wrapFromString = function(t) {
								switch (t.toLowerCase()) {
									case "mirroredtepeat":
										return i.MirroredRepeat;
									case "clamptoedge":
										return i.ClampToEdge;
									case "repeat":
										return i.Repeat;
									default:
										throw new Error("Unknown texture wrap " + t)
								}
							}, t
						}();
						t.Texture = n,
							function(t) {
								t[t.Nearest = 9728] = "Nearest", t[t.Linear = 9729] = "Linear", t[t.MipMap = 9987] = "MipMap", t[t.MipMapNearestNearest = 9984] = "MipMapNearestNearest", t[t.MipMapLinearNearest = 9985] = "MipMapLinearNearest", t[t.MipMapNearestLinear = 9986] = "MipMapNearestLinear", t[t.MipMapLinearLinear = 9987] = "MipMapLinearLinear"
							}(e = t.TextureFilter || (t.TextureFilter = {})),
							function(t) {
								t[t.MirroredRepeat = 33648] = "MirroredRepeat", t[t.ClampToEdge = 33071] = "ClampToEdge", t[t.Repeat = 10497] = "Repeat"
							}(i = t.TextureWrap || (t.TextureWrap = {}));
						var s = function() {
							function t() {
								this.size = null
							}
							return Object.defineProperty(t.prototype, "width", {
								get: function() {
									var t = this.texture;
									return "3" == PIXI.VERSION[0] ? t.crop.width : t.trim ? t.trim.width : t.orig.width
								},
								enumerable: !0,
								configurable: !0
							}), Object.defineProperty(t.prototype, "height", {
								get: function() {
									var t = this.texture;
									return "3" == PIXI.VERSION[0] ? t.crop.height : t.trim ? t.trim.height : t.orig.height
								},
								enumerable: !0,
								configurable: !0
							}), Object.defineProperty(t.prototype, "u", {
								get: function() {
									return this.texture._uvs.x0
								},
								enumerable: !0,
								configurable: !0
							}), Object.defineProperty(t.prototype, "v", {
								get: function() {
									return this.texture._uvs.y0
								},
								enumerable: !0,
								configurable: !0
							}), Object.defineProperty(t.prototype, "u2", {
								get: function() {
									return this.texture._uvs.x2
								},
								enumerable: !0,
								configurable: !0
							}), Object.defineProperty(t.prototype, "v2", {
								get: function() {
									return this.texture._uvs.y2
								},
								enumerable: !0,
								configurable: !0
							}), Object.defineProperty(t.prototype, "offsetX", {
								get: function() {
									var t = this.texture;
									return t.trim ? t.trim.x : 0
								},
								enumerable: !0,
								configurable: !0
							}), Object.defineProperty(t.prototype, "offsetY", {
								get: function() {
									return console.warn("Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on."), this.spineOffsetY
								},
								enumerable: !0,
								configurable: !0
							}), Object.defineProperty(t.prototype, "pixiOffsetY", {
								get: function() {
									var t = this.texture;
									return t.trim ? t.trim.y : 0
								},
								enumerable: !0,
								configurable: !0
							}), Object.defineProperty(t.prototype, "spineOffsetY", {
								get: function() {
									var t = this.texture;
									return this.originalHeight - this.height - (t.trim ? t.trim.y : 0)
								},
								enumerable: !0,
								configurable: !0
							}), Object.defineProperty(t.prototype, "originalWidth", {
								get: function() {
									var t = this.texture;
									return "3" == PIXI.VERSION[0] ? t.trim ? t.trim.width : t.crop.width : t.orig.width
								},
								enumerable: !0,
								configurable: !0
							}), Object.defineProperty(t.prototype, "originalHeight", {
								get: function() {
									var t = this.texture;
									return "3" == PIXI.VERSION[0] ? t.trim ? t.trim.height : t.crop.height : t.orig.height
								},
								enumerable: !0,
								configurable: !0
							}), Object.defineProperty(t.prototype, "x", {
								get: function() {
									return this.texture.frame.x
								},
								enumerable: !0,
								configurable: !0
							}), Object.defineProperty(t.prototype, "y", {
								get: function() {
									return this.texture.frame.y
								},
								enumerable: !0,
								configurable: !0
							}), Object.defineProperty(t.prototype, "rotate", {
								get: function() {
									return 0 !== this.texture.rotate
								},
								enumerable: !0,
								configurable: !0
							}), t
						}();
						t.TextureRegion = s
					}(t.core || (t.core = {}))
				}(i || (i = {})),
				function(t) {
					! function(t) {
						var e = function() {
							function e(t, e, i) {
								this.pages = new Array, this.regions = new Array, t && this.addSpineAtlas(t, e, i)
							}
							return e.prototype.addTexture = function(e, i) {
								for (var n = this.pages, r = null, a = 0; a < n.length; a++)
									if (n[a].baseTexture === i.baseTexture) {
										r = n[a];
										break
									} if (null === r) {
									(r = new s).name = "texturePage";
									var l = i.baseTexture;
									r.width = l.realWidth, r.height = l.realHeight, r.baseTexture = l, r.minFilter = r.magFilter = t.TextureFilter.Nearest, r.uWrap = t.TextureWrap.ClampToEdge, r.vWrap = t.TextureWrap.ClampToEdge, n.push(r)
								}
								var h = new o;
								return h.name = e, h.page = r, h.texture = i, h.index = -1, this.regions.push(h), h
							}, e.prototype.addTextureHash = function(t, e) {
								for (var i in t) t.hasOwnProperty(i) && this.addTexture(e && -1 !== i.indexOf(".") ? i.substr(0, i.lastIndexOf(".")) : i, t[i])
							}, e.prototype.addSpineAtlas = function(t, e, i) {
								return this.load(t, e, i)
							}, e.prototype.load = function(e, n, r) {
								var a = this;
								if (null == n) throw new Error("textureLoader cannot be null.");
								var l = new i(e),
									h = new Array(4),
									u = null,
									c = function() {
										for (;;) {
											var e = l.readLine();
											if (null == e) return r && r(a);
											if (0 == (e = e.trim()).length) u = null;
											else {
												if (!u) {
													(u = new s).name = e, 2 == l.readTuple(h) && (u.width = parseInt(h[0]), u.height = parseInt(h[1]), l.readTuple(h)), l.readTuple(h), u.minFilter = t.Texture.filterFromString(h[0]), u.magFilter = t.Texture.filterFromString(h[1]);
													var i = l.readValue();
													u.uWrap = t.TextureWrap.ClampToEdge, u.vWrap = t.TextureWrap.ClampToEdge, "x" == i ? u.uWrap = t.TextureWrap.Repeat : "y" == i ? u.vWrap = t.TextureWrap.Repeat : "xy" == i && (u.uWrap = u.vWrap = t.TextureWrap.Repeat), n(e, (function(t) {
														if (null === t) return a.pages.splice(a.pages.indexOf(u), 1), r && r(null);
														u.baseTexture = t, t.valid || t.setSize(u.width, u.height), a.pages.push(u), u.setFilters(), u.width && u.height || (u.width = t.realWidth, u.height = t.realHeight, u.width && u.height || console.log("ERROR spine atlas page " + u.name + ": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)")), c()
													})), a.pages.push(u);
													break
												}
												var d = new o;
												d.name = e, d.page = u;
												var p = "true" == l.readValue() ? 6 : 0;
												l.readTuple(h);
												var _ = parseInt(h[0]),
													m = parseInt(h[1]);
												l.readTuple(h);
												var g = parseInt(h[0]),
													f = parseInt(h[1]),
													S = u.baseTexture.resolution;
												_ /= S, m /= S, g /= S, f /= S;
												var y = new PIXI.Rectangle(_, m, p ? f : g, p ? g : f);
												4 == l.readTuple(h) && 4 == l.readTuple(h) && l.readTuple(h);
												var v = parseInt(h[0]) / S,
													T = parseInt(h[1]) / S;
												l.readTuple(h);
												var E = parseInt(h[0]) / S,
													b = parseInt(h[1]) / S,
													A = new PIXI.Rectangle(0, 0, v, T),
													P = new PIXI.Rectangle(E, T - f - b, g, f);
												if ("3" != PIXI.VERSION[0]) d.texture = new PIXI.Texture(d.page.baseTexture, y, A, P, p);
												else {
													var I = new PIXI.Rectangle(_, m, g, f),
														w = I.clone();
													P.width = v, P.height = T, d.texture = new PIXI.Texture(d.page.baseTexture, I, w, P, p)
												}
												d.index = parseInt(l.readValue()), d.texture.updateUvs(), a.regions.push(d)
											}
										}
									};
								c()
							}, e.prototype.findRegion = function(t) {
								for (var e = 0; e < this.regions.length; e++)
									if (this.regions[e].name == t) return this.regions[e];
								return null
							}, e.prototype.dispose = function() {
								for (var t = 0; t < this.pages.length; t++) this.pages[t].baseTexture.dispose()
							}, e
						}();
						t.TextureAtlas = e;
						var i = function() {
								function t(t) {
									this.index = 0, this.lines = t.split(/\r\n|\r|\n/)
								}
								return t.prototype.readLine = function() {
									return this.index >= this.lines.length ? null : this.lines[this.index++]
								}, t.prototype.readValue = function() {
									var t = this.readLine(),
										e = t.indexOf(":");
									if (-1 == e) throw new Error("Invalid line: " + t);
									return t.substring(e + 1).trim()
								}, t.prototype.readTuple = function(t) {
									var e = this.readLine(),
										i = e.indexOf(":");
									if (-1 == i) throw new Error("Invalid line: " + e);
									for (var n = 0, s = i + 1; n < 3; n++) {
										var o = e.indexOf(",", s);
										if (-1 == o) break;
										t[n] = e.substr(s, o - s).trim(), s = o + 1
									}
									return t[n] = e.substring(s).trim(), n + 1
								}, t
							}(),
							s = function() {
								function e() {}
								return e.prototype.setFilters = function() {
									var e = this.baseTexture,
										i = this.minFilter;
									i == t.TextureFilter.Linear ? e.scaleMode = PIXI.SCALE_MODES.LINEAR : this.minFilter == t.TextureFilter.Nearest ? e.scaleMode = PIXI.SCALE_MODES.NEAREST : (e.mipmap = PIXI.MIPMAP_MODES.POW2, i == t.TextureFilter.MipMapNearestNearest ? e.scaleMode = PIXI.SCALE_MODES.NEAREST : e.scaleMode = PIXI.SCALE_MODES.LINEAR)
								}, e
							}();
						t.TextureAtlasPage = s;
						var o = function(t) {
							function e() {
								return null !== t && t.apply(this, arguments) || this
							}
							return n(e, t), e
						}(t.TextureRegion);
						t.TextureAtlasRegion = o
					}(t.core || (t.core = {}))
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), i = function() {
						function t(t, i) {
							if (this.rotateMix = 0, this.translateMix = 0, this.scaleMix = 0, this.shearMix = 0, this.temp = new e.Vector2, null == t) throw new Error("data cannot be null.");
							if (null == i) throw new Error("skeleton cannot be null.");
							this.data = t, this.rotateMix = t.rotateMix, this.translateMix = t.translateMix, this.scaleMix = t.scaleMix, this.shearMix = t.shearMix, this.bones = new Array;
							for (var n = 0; n < t.bones.length; n++) this.bones.push(i.findBone(t.bones[n].name));
							this.target = i.findBone(t.target.name)
						}
						return t.prototype.apply = function() {
							this.update()
						}, t.prototype.update = function() {
							this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld()
						}, t.prototype.applyAbsoluteWorld = function() {
							for (var t = this.rotateMix, i = this.translateMix, n = this.scaleMix, s = this.shearMix, o = this.target, r = o.matrix, a = r.a, l = r.c, h = r.b, u = r.d, c = a * u - l * h > 0 ? e.MathUtils.degRad : -e.MathUtils.degRad, d = this.data.offsetRotation * c, p = this.data.offsetShearY * c, _ = this.bones, m = 0, g = _.length; m < g; m++) {
								var f = _[m],
									S = !1,
									y = f.matrix;
								if (0 != t) {
									var v = y.a,
										T = y.c,
										E = y.b,
										b = y.d;
									(C = Math.atan2(h, a) - Math.atan2(E, v) + d) > e.MathUtils.PI ? C -= e.MathUtils.PI2 : C < -e.MathUtils.PI && (C += e.MathUtils.PI2), C *= t;
									var A = Math.cos(C),
										P = Math.sin(C);
									y.a = A * v - P * E, y.c = A * T - P * b, y.b = P * v + A * E, y.d = P * T + A * b, S = !0
								}
								if (0 != i) {
									var I = this.temp;
									o.localToWorld(I.set(this.data.offsetX, this.data.offsetY)), y.tx += (I.x - y.tx) * i, y.ty += (I.y - y.ty) * i, S = !0
								}
								if (n > 0) {
									var w = Math.sqrt(y.a * y.a + y.b * y.b),
										L = Math.sqrt(a * a + h * h);
									w > 1e-5 && (w = (w + (L - w + this.data.offsetScaleX) * n) / w), y.a *= w, y.b *= w, w = Math.sqrt(y.c * y.c + y.d * y.d), L = Math.sqrt(l * l + u * u), w > 1e-5 && (w = (w + (L - w + this.data.offsetScaleY) * n) / w), y.c *= w, y.d *= w, S = !0
								}
								if (s > 0) {
									T = y.c, b = y.d;
									var C, x = Math.atan2(b, T);
									(C = Math.atan2(u, l) - Math.atan2(h, a) - (x - Math.atan2(y.b, y.a))) > e.MathUtils.PI ? C -= e.MathUtils.PI2 : C < -e.MathUtils.PI && (C += e.MathUtils.PI2), C = x + (C + p) * s, w = Math.sqrt(T * T + b * b), y.c = Math.cos(C) * w, y.d = Math.sin(C) * w, S = !0
								}
								S && (f.appliedValid = !1)
							}
						}, t.prototype.applyRelativeWorld = function() {
							for (var t = this.rotateMix, i = this.translateMix, n = this.scaleMix, s = this.shearMix, o = this.target, r = o.matrix, a = r.a, l = r.c, h = r.b, u = r.d, c = a * u - l * h > 0 ? e.MathUtils.degRad : -e.MathUtils.degRad, d = this.data.offsetRotation * c, p = this.data.offsetShearY * c, _ = this.bones, m = 0, g = _.length; m < g; m++) {
								var f, S = _[m],
									y = !1,
									v = S.matrix;
								if (0 != t) {
									var T = v.a,
										E = v.c,
										b = v.b,
										A = v.d;
									(f = Math.atan2(h, a) + d) > e.MathUtils.PI ? f -= e.MathUtils.PI2 : f < -e.MathUtils.PI && (f += e.MathUtils.PI2), f *= t;
									var P = Math.cos(f),
										I = Math.sin(f);
									v.a = P * T - I * b, v.c = P * E - I * A, v.b = I * T + P * b, v.d = I * E + P * A, y = !0
								}
								if (0 != i) {
									var w = this.temp;
									o.localToWorld(w.set(this.data.offsetX, this.data.offsetY)), v.tx += w.x * i, v.ty += w.y * i, y = !0
								}
								if (n > 0) {
									var L = (Math.sqrt(a * a + h * h) - 1 + this.data.offsetScaleX) * n + 1;
									v.a *= L, v.b *= L, L = (Math.sqrt(l * l + u * u) - 1 + this.data.offsetScaleY) * n + 1, v.c *= L, v.d *= L, y = !0
								}
								s > 0 && ((f = Math.atan2(u, l) - Math.atan2(h, a)) > e.MathUtils.PI ? f -= e.MathUtils.PI2 : f < -e.MathUtils.PI && (f += e.MathUtils.PI2), E = v.c, A = v.d, f = Math.atan2(A, E) + (f - e.MathUtils.PI / 2 + p) * s, L = Math.sqrt(E * E + A * A), v.c = Math.cos(f) * L, v.d = Math.sin(f) * L, y = !0), y && (S.appliedValid = !1)
							}
						}, t.prototype.applyAbsoluteLocal = function() {
							var t = this.rotateMix,
								e = this.translateMix,
								i = this.scaleMix,
								n = this.shearMix,
								s = this.target;
							s.appliedValid || s.updateAppliedTransform();
							for (var o = this.bones, r = 0, a = o.length; r < a; r++) {
								var l = o[r];
								l.appliedValid || l.updateAppliedTransform();
								var h = l.arotation;
								if (0 != t) {
									var u = s.arotation - h + this.data.offsetRotation;
									h += (u -= 360 * (16384 - (16384.499999999996 - u / 360 | 0))) * t
								}
								var c = l.ax,
									d = l.ay;
								0 != e && (c += (s.ax - c + this.data.offsetX) * e, d += (s.ay - d + this.data.offsetY) * e);
								var p = l.ascaleX,
									_ = l.ascaleY;
								i > 0 && (p > 1e-5 && (p = (p + (s.ascaleX - p + this.data.offsetScaleX) * i) / p), _ > 1e-5 && (_ = (_ + (s.ascaleY - _ + this.data.offsetScaleY) * i) / _));
								var m = l.ashearY;
								n > 0 && (u = s.ashearY - m + this.data.offsetShearY, u -= 360 * (16384 - (16384.499999999996 - u / 360 | 0)), l.shearY += u * n), l.updateWorldTransformWith(c, d, h, p, _, l.ashearX, m)
							}
						}, t.prototype.applyRelativeLocal = function() {
							var t = this.rotateMix,
								e = this.translateMix,
								i = this.scaleMix,
								n = this.shearMix,
								s = this.target;
							s.appliedValid || s.updateAppliedTransform();
							for (var o = this.bones, r = 0, a = o.length; r < a; r++) {
								var l = o[r];
								l.appliedValid || l.updateAppliedTransform();
								var h = l.arotation;
								0 != t && (h += (s.arotation + this.data.offsetRotation) * t);
								var u = l.ax,
									c = l.ay;
								0 != e && (u += (s.ax + this.data.offsetX) * e, c += (s.ay + this.data.offsetY) * e);
								var d = l.ascaleX,
									p = l.ascaleY;
								i > 0 && (d > 1e-5 && (d *= (s.ascaleX - 1 + this.data.offsetScaleX) * i + 1), p > 1e-5 && (p *= (s.ascaleY - 1 + this.data.offsetScaleY) * i + 1));
								var _ = l.ashearY;
								n > 0 && (_ += (s.ashearY + this.data.offsetShearY) * n), l.updateWorldTransformWith(u, c, h, d, p, l.ashearX, _)
							}
						}, t.prototype.getOrder = function() {
							return this.data.order
						}, t
					}(), e.TransformConstraint = i
				}(i || (i = {})),
				function(t) {
					(t.core || (t.core = {})).TransformConstraintData = function(t) {
						if (this.order = 0, this.bones = new Array, this.rotateMix = 0, this.translateMix = 0, this.scaleMix = 0, this.shearMix = 0, this.offsetRotation = 0, this.offsetX = 0, this.offsetY = 0, this.offsetScaleX = 0, this.offsetScaleY = 0, this.offsetShearY = 0, this.relative = !1, this.local = !1, null == t) throw new Error("name cannot be null.");
						this.name = t
					}
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), i = function() {
						function t() {
							this.convexPolygons = new Array, this.convexPolygonsIndices = new Array, this.indicesArray = new Array, this.isConcaveArray = new Array, this.triangles = new Array, this.polygonPool = new e.Pool((function() {
								return new Array
							})), this.polygonIndicesPool = new e.Pool((function() {
								return new Array
							}))
						}
						return t.prototype.triangulate = function(e) {
							var i = e,
								n = e.length >> 1,
								s = this.indicesArray;
							s.length = 0;
							for (var o = 0; o < n; o++) s[o] = o;
							var r = this.isConcaveArray;
							r.length = 0, o = 0;
							for (var a = n; o < a; ++o) r[o] = t.isConcave(o, n, i, s);
							var l = this.triangles;
							for (l.length = 0; n > 3;) {
								for (var h = n - 1, u = (o = 0, 1);;) {
									t: if (!r[o]) {
										for (var c = s[h] << 1, d = s[o] << 1, p = s[u] << 1, _ = i[c], m = i[c + 1], g = i[d], f = i[d + 1], S = i[p], y = i[p + 1], v = (u + 1) % n; v != h; v = (v + 1) % n)
											if (r[v]) {
												var T = s[v] << 1,
													E = i[T],
													b = i[T + 1];
												if (t.positiveArea(S, y, _, m, E, b) && t.positiveArea(_, m, g, f, E, b) && t.positiveArea(g, f, S, y, E, b)) break t
											} break
									}if (0 == u) {
										do {
											if (!r[o]) break;
											o--
										} while (o > 0);
										break
									}
									h = o,
									o = u,
									u = (u + 1) % n
								}
								l.push(s[(n + o - 1) % n]), l.push(s[o]), l.push(s[(o + 1) % n]), s.splice(o, 1), r.splice(o, 1);
								var A = (--n + o - 1) % n,
									P = o == n ? 0 : o;
								r[A] = t.isConcave(A, n, i, s), r[P] = t.isConcave(P, n, i, s)
							}
							return 3 == n && (l.push(s[2]), l.push(s[0]), l.push(s[1])), l
						}, t.prototype.decompose = function(e, i) {
							var n = e,
								s = this.convexPolygons;
							this.polygonPool.freeAll(s), s.length = 0;
							var o = this.convexPolygonsIndices;
							this.polygonIndicesPool.freeAll(o), o.length = 0;
							var r = this.polygonIndicesPool.obtain();
							r.length = 0;
							var a = this.polygonPool.obtain();
							a.length = 0;
							for (var l = -1, h = 0, u = 0, c = i.length; u < c; u += 3) {
								var d = i[u] << 1,
									p = i[u + 1] << 1,
									_ = i[u + 2] << 1,
									m = n[d],
									g = n[d + 1],
									f = n[p],
									S = n[p + 1],
									y = n[_],
									v = n[_ + 1],
									T = !1;
								if (l == d) {
									var E = a.length - 4,
										b = t.winding(a[E], a[E + 1], a[E + 2], a[E + 3], y, v),
										A = t.winding(y, v, a[0], a[1], a[2], a[3]);
									b == h && A == h && (a.push(y), a.push(v), r.push(_), T = !0)
								}
								T || (a.length > 0 ? (s.push(a), o.push(r)) : (this.polygonPool.free(a), this.polygonIndicesPool.free(r)), (a = this.polygonPool.obtain()).length = 0, a.push(m), a.push(g), a.push(f), a.push(S), a.push(y), a.push(v), (r = this.polygonIndicesPool.obtain()).length = 0, r.push(d), r.push(p), r.push(_), h = t.winding(m, g, f, S, y, v), l = d)
							}
							for (a.length > 0 && (s.push(a), o.push(r)), u = 0, c = s.length; u < c; u++)
								if (0 != (r = o[u]).length)
									for (var P = r[0], I = r[r.length - 1], w = (a = s[u])[E = a.length - 4], L = a[E + 1], C = a[E + 2], x = a[E + 3], B = a[0], O = a[1], N = a[2], M = a[3], R = t.winding(w, L, C, x, B, O), D = 0; D < c; D++)
										if (D != u) {
											var k = o[D];
											if (3 == k.length) {
												var F = k[0],
													G = k[1],
													U = k[2],
													W = s[D];
												y = W[W.length - 2], v = W[W.length - 1], F == P && G == I && (b = t.winding(w, L, C, x, y, v), A = t.winding(y, v, B, O, N, M), b == R && A == R && (W.length = 0, k.length = 0, a.push(y), a.push(v), r.push(U), w = C, L = x, C = y, x = v, D = 0))
											}
										} for (u = s.length - 1; u >= 0; u--) 0 == (a = s[u]).length && (s.splice(u, 1), this.polygonPool.free(a), r = o[u], o.splice(u, 1), this.polygonIndicesPool.free(r));
							return s
						}, t.isConcave = function(t, e, i, n) {
							var s = n[(e + t - 1) % e] << 1,
								o = n[t] << 1,
								r = n[(t + 1) % e] << 1;
							return !this.positiveArea(i[s], i[s + 1], i[o], i[o + 1], i[r], i[r + 1])
						}, t.positiveArea = function(t, e, i, n, s, o) {
							return t * (o - n) + i * (e - o) + s * (n - e) >= 0
						}, t.winding = function(t, e, i, n, s, o) {
							var r = i - t,
								a = n - e;
							return s * a - o * r + r * e - t * a >= 0 ? 1 : -1
						}, t
					}(), e.Triangulator = i
				}(i || (i = {})),
				function(t) {
					! function(t) {
						var e = function() {
							function t() {
								this.array = new Array
							}
							return t.prototype.add = function(t) {
								var e = this.contains(t);
								return this.array[0 | t] = 0 | t, !e
							}, t.prototype.contains = function(t) {
								return null != this.array[0 | t]
							}, t.prototype.remove = function(t) {
								this.array[0 | t] = void 0
							}, t.prototype.clear = function() {
								this.array.length = 0
							}, t
						}();
						t.IntSet = e;
						var i = function() {
							function t(t, e, i, n) {
								void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.r = t, this.g = e, this.b = i, this.a = n
							}
							return t.prototype.set = function(t, e, i, n) {
								return this.r = t, this.g = e, this.b = i, this.a = n, this.clamp(), this
							}, t.prototype.setFromColor = function(t) {
								return this.r = t.r, this.g = t.g, this.b = t.b, this.a = t.a, this
							}, t.prototype.setFromString = function(t) {
								return t = "#" == t.charAt(0) ? t.substr(1) : t, this.r = parseInt(t.substr(0, 2), 16) / 255, this.g = parseInt(t.substr(2, 2), 16) / 255, this.b = parseInt(t.substr(4, 2), 16) / 255, this.a = (8 != t.length ? 255 : parseInt(t.substr(6, 2), 16)) / 255, this
							}, t.prototype.add = function(t, e, i, n) {
								return this.r += t, this.g += e, this.b += i, this.a += n, this.clamp(), this
							}, t.prototype.clamp = function() {
								return this.r < 0 ? this.r = 0 : this.r > 1 && (this.r = 1), this.g < 0 ? this.g = 0 : this.g > 1 && (this.g = 1), this.b < 0 ? this.b = 0 : this.b > 1 && (this.b = 1), this.a < 0 ? this.a = 0 : this.a > 1 && (this.a = 1), this
							}, t.WHITE = new t(1, 1, 1, 1), t.RED = new t(1, 0, 0, 1), t.GREEN = new t(0, 1, 0, 1), t.BLUE = new t(0, 0, 1, 1), t.MAGENTA = new t(1, 0, 1, 1), t
						}();
						t.Color = i;
						var s = function() {
							function t() {}
							return t.clamp = function(t, e, i) {
								return t < e ? e : t > i ? i : t
							}, t.cosDeg = function(e) {
								return Math.cos(e * t.degRad)
							}, t.sinDeg = function(e) {
								return Math.sin(e * t.degRad)
							}, t.signum = function(t) {
								return t > 0 ? 1 : t < 0 ? -1 : 0
							}, t.toInt = function(t) {
								return t > 0 ? Math.floor(t) : Math.ceil(t)
							}, t.cbrt = function(t) {
								var e = Math.pow(Math.abs(t), 1 / 3);
								return t < 0 ? -e : e
							}, t.randomTriangular = function(e, i) {
								return t.randomTriangularWith(e, i, .5 * (e + i))
							}, t.randomTriangularWith = function(t, e, i) {
								var n = Math.random(),
									s = e - t;
								return n <= (i - t) / s ? t + Math.sqrt(n * s * (i - t)) : e - Math.sqrt((1 - n) * s * (e - i))
							}, t.PI = 3.1415927, t.PI2 = 2 * t.PI, t.radiansToDegrees = 180 / t.PI, t.radDeg = t.radiansToDegrees, t.degreesToRadians = t.PI / 180, t.degRad = t.degreesToRadians, t
						}();
						t.MathUtils = s;
						var o = function() {
							function t() {}
							return t.prototype.apply = function(t, e, i) {
								return t + (e - t) * this.applyInternal(i)
							}, t
						}();
						t.Interpolation = o;
						var r = function(t) {
							function e(e) {
								var i = t.call(this) || this;
								return i.power = 2, i.power = e, i
							}
							return n(e, t), e.prototype.applyInternal = function(t) {
								return t <= .5 ? Math.pow(2 * t, this.power) / 2 : Math.pow(2 * (t - 1), this.power) / (this.power % 2 == 0 ? -2 : 2) + 1
							}, e
						}(o);
						t.Pow = r;
						var a = function(t) {
							function e(e) {
								return t.call(this, e) || this
							}
							return n(e, t), e.prototype.applyInternal = function(t) {
								return Math.pow(t - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1
							}, e
						}(r);
						t.PowOut = a;
						var l = function() {
							function t() {}
							return t.arrayCopy = function(t, e, i, n, s) {
								for (var o = e, r = n; o < e + s; o++, r++) i[r] = t[o]
							}, t.setArraySize = function(t, e, i) {
								void 0 === i && (i = 0);
								var n = t.length;
								if (n == e) return t;
								if (t.length = e, n < e)
									for (var s = n; s < e; s++) t[s] = i;
								return t
							}, t.ensureArrayCapacity = function(e, i, n) {
								return void 0 === n && (n = 0), e.length >= i ? e : t.setArraySize(e, i, n)
							}, t.newArray = function(t, e) {
								for (var i = new Array(t), n = 0; n < t; n++) i[n] = e;
								return i
							}, t.newFloatArray = function(e) {
								if (t.SUPPORTS_TYPED_ARRAYS) return new Float32Array(e);
								for (var i = new Array(e), n = 0; n < i.length; n++) i[n] = 0;
								return i
							}, t.newShortArray = function(e) {
								if (t.SUPPORTS_TYPED_ARRAYS) return new Int16Array(e);
								for (var i = new Array(e), n = 0; n < i.length; n++) i[n] = 0;
								return i
							}, t.toFloatArray = function(e) {
								return t.SUPPORTS_TYPED_ARRAYS ? new Float32Array(e) : e
							}, t.toSinglePrecision = function(e) {
								return t.SUPPORTS_TYPED_ARRAYS ? Math.fround(e) : e
							}, t.webkit602BugfixHelper = function(t, e) {}, t.SUPPORTS_TYPED_ARRAYS = "undefined" != typeof Float32Array, t
						}();
						t.Utils = l;
						var h = function() {
							function t() {}
							return t.logBones = function(t) {
								for (var e = 0; e < t.bones.length; e++) {
									var i = t.bones[e],
										n = i.matrix;
									console.log(i.data.name + ", " + n.a + ", " + n.b + ", " + n.c + ", " + n.d + ", " + n.tx + ", " + n.ty)
								}
							}, t
						}();
						t.DebugUtils = h;
						var u = function() {
							function t(t) {
								this.items = new Array, this.instantiator = t
							}
							return t.prototype.obtain = function() {
								return this.items.length > 0 ? this.items.pop() : this.instantiator()
							}, t.prototype.free = function(t) {
								t.reset && t.reset(), this.items.push(t)
							}, t.prototype.freeAll = function(t) {
								for (var e = 0; e < t.length; e++) t[e].reset && t[e].reset(), this.items[e] = t[e]
							}, t.prototype.clear = function() {
								this.items.length = 0
							}, t
						}();
						t.Pool = u;
						var c = function() {
							function t(t, e) {
								void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = t, this.y = e
							}
							return t.prototype.set = function(t, e) {
								return this.x = t, this.y = e, this
							}, t.prototype.length = function() {
								var t = this.x,
									e = this.y;
								return Math.sqrt(t * t + e * e)
							}, t.prototype.normalize = function() {
								var t = this.length();
								return 0 != t && (this.x /= t, this.y /= t), this
							}, t
						}();
						t.Vector2 = c;
						var d = function() {
							function t() {
								this.maxDelta = .064, this.framesPerSecond = 0, this.delta = 0, this.totalTime = 0, this.lastTime = Date.now() / 1e3, this.frameCount = 0, this.frameTime = 0
							}
							return t.prototype.update = function() {
								var t = Date.now() / 1e3;
								this.delta = t - this.lastTime, this.frameTime += this.delta, this.totalTime += this.delta, this.delta > this.maxDelta && (this.delta = this.maxDelta), this.lastTime = t, this.frameCount++, this.frameTime > 1 && (this.framesPerSecond = this.frameCount / this.frameTime, this.frameTime = 0, this.frameCount = 0)
							}, t
						}();
						t.TimeKeeper = d;
						var p = function() {
							function t(t) {
								void 0 === t && (t = 32), this.addedValues = 0, this.lastValue = 0, this.mean = 0, this.dirty = !0, this.values = new Array(t)
							}
							return t.prototype.hasEnoughData = function() {
								return this.addedValues >= this.values.length
							}, t.prototype.addValue = function(t) {
								this.addedValues < this.values.length && this.addedValues++, this.values[this.lastValue++] = t, this.lastValue > this.values.length - 1 && (this.lastValue = 0), this.dirty = !0
							}, t.prototype.getMean = function() {
								if (this.hasEnoughData()) {
									if (this.dirty) {
										for (var t = 0, e = 0; e < this.values.length; e++) t += this.values[e];
										this.mean = t / this.values.length, this.dirty = !1
									}
									return this.mean
								}
								return 0
							}, t
						}();
						t.WindowedMean = p
					}(t.core || (t.core = {}))
				}(i || (i = {})),
				function(t) {
					! function(t) {
						var e = function(t) {
							if (null == t) throw new Error("name cannot be null.");
							this.name = t
						};
						t.Attachment = e;
						var i = function(t) {
							function e(i) {
								var n = t.call(this, i) || this;
								return n.id = (65535 & e.nextID++) << 11, n.worldVerticesLength = 0, n
							}
							return n(e, t), e.prototype.computeWorldVerticesOld = function(t, e) {
								this.computeWorldVertices(t, 0, this.worldVerticesLength, e, 0, 2)
							}, e.prototype.computeWorldVertices = function(t, e, i, n, s, o) {
								i = s + (i >> 1) * o;
								var r = t.bone.skeleton,
									a = t.attachmentVertices,
									l = this.vertices,
									h = this.bones;
								if (null != h) {
									for (var u = 0, c = 0, d = 0; d < e; d += 2) u += (g = h[u]) + 1, c += g;
									var p = r.bones;
									if (0 == a.length)
										for (L = s, A = 3 * c; L < i; L += o) {
											var _ = 0,
												m = 0,
												g = h[u++];
											for (g += u; u < g; u++, A += 3) {
												v = p[h[u]].matrix, C = l[A], x = l[A + 1];
												var f = l[A + 2];
												_ += (C * v.a + x * v.c + v.tx) * f, m += (C * v.b + x * v.d + v.ty) * f
											}
											n[L] = _, n[L + 1] = m
										} else
											for (var S = a, y = (L = s, A = 3 * c, c << 1); L < i; L += o) {
												for (_ = 0, m = 0, g = h[u++], g += u; u < g; u++, A += 3, y += 2) v = p[h[u]].matrix, C = l[A] + S[y], x = l[A + 1] + S[y + 1], f = l[A + 2], _ += (C * v.a + x * v.c + v.tx) * f, m += (C * v.b + x * v.d + v.ty) * f;
												n[L] = _, n[L + 1] = m
											}
								} else {
									a.length > 0 && (l = a);
									for (var v, T = (v = t.bone.matrix).tx, E = v.ty, b = v.a, A = v.c, P = v.b, I = v.d, w = e, L = s; L < i; w += 2, L += o) {
										var C = l[w],
											x = l[w + 1];
										n[L] = C * b + x * A + T, n[L + 1] = C * P + x * I + E
									}
								}
							}, e.prototype.applyDeform = function(t) {
								return this == t
							}, e.nextID = 0, e
						}(e);
						t.VertexAttachment = i
					}(t.core || (t.core = {}))
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), (i = e.AttachmentType || (e.AttachmentType = {}))[i.Region = 0] = "Region", i[i.BoundingBox = 1] = "BoundingBox", i[i.Mesh = 2] = "Mesh", i[i.LinkedMesh = 3] = "LinkedMesh", i[i.Path = 4] = "Path", i[i.Point = 5] = "Point"
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), i = function(t) {
						function i(i) {
							var n = t.call(this, i) || this;
							return n.color = new e.Color(1, 1, 1, 1), n
						}
						return n(i, t), i
					}(e.VertexAttachment), e.BoundingBoxAttachment = i
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), i = function(t) {
						function i(i) {
							var n = t.call(this, i) || this;
							return n.color = new e.Color(.2275, .2275, .8078, 1), n
						}
						return n(i, t), i
					}(e.VertexAttachment), e.ClippingAttachment = i
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), i = function(t) {
						function i(i) {
							var n = t.call(this, i) || this;
							return n.color = new e.Color(1, 1, 1, 1), n.inheritDeform = !1, n.tempColor = new e.Color(0, 0, 0, 0), n
						}
						return n(i, t), i.prototype.applyDeform = function(t) {
							return this == t || this.inheritDeform && this.parentMesh == t
						}, i.prototype.getParentMesh = function() {
							return this.parentMesh
						}, i.prototype.setParentMesh = function(t) {
							this.parentMesh = t, null != t && (this.bones = t.bones, this.vertices = t.vertices, this.worldVerticesLength = t.worldVerticesLength, this.regionUVs = t.regionUVs, this.triangles = t.triangles, this.hullLength = t.hullLength, this.worldVerticesLength = t.worldVerticesLength)
						}, i
					}(e.VertexAttachment), e.MeshAttachment = i
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), i = function(t) {
						function i(i) {
							var n = t.call(this, i) || this;
							return n.closed = !1, n.constantSpeed = !1, n.color = new e.Color(1, 1, 1, 1), n
						}
						return n(i, t), i
					}(e.VertexAttachment), e.PathAttachment = i
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), i = function(t) {
						function i(i) {
							var n = t.call(this, i) || this;
							return n.color = new e.Color(.38, .94, 0, 1), n
						}
						return n(i, t), i.prototype.computeWorldPosition = function(t, e) {
							var i = t.matrix;
							return e.x = this.x * i.a + this.y * i.c + t.worldX, e.y = this.x * i.b + this.y * i.d + t.worldY, e
						}, i.prototype.computeWorldRotation = function(t) {
							var i = t.matrix,
								n = e.MathUtils.cosDeg(this.rotation),
								s = e.MathUtils.sinDeg(this.rotation),
								o = n * i.a + s * i.c,
								r = n * i.b + s * i.d;
							return Math.atan2(r, o) * e.MathUtils.radDeg
						}, i
					}(e.VertexAttachment), e.PointAttachment = i
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), i = function(t) {
						function i(i) {
							var n = t.call(this, i) || this;
							return n.x = 0, n.y = 0, n.scaleX = 1, n.scaleY = 1, n.rotation = 0, n.width = 0, n.height = 0, n.color = new e.Color(1, 1, 1, 1), n.offset = e.Utils.newFloatArray(8), n.uvs = e.Utils.newFloatArray(8), n.tempColor = new e.Color(1, 1, 1, 1), n
						}
						return n(i, t), i.prototype.updateOffset = function() {
							var t = this.width / this.region.originalWidth * this.scaleX,
								e = this.height / this.region.originalHeight * this.scaleY,
								n = -this.width / 2 * this.scaleX + this.region.offsetX * t,
								s = -this.height / 2 * this.scaleY + this.region.offsetY * e,
								o = n + this.region.width * t,
								r = s + this.region.height * e,
								a = this.rotation * Math.PI / 180,
								l = Math.cos(a),
								h = Math.sin(a),
								u = n * l + this.x,
								c = n * h,
								d = s * l + this.y,
								p = s * h,
								_ = o * l + this.x,
								m = o * h,
								g = r * l + this.y,
								f = r * h,
								S = this.offset;
							S[i.OX1] = u - p, S[i.OY1] = d + c, S[i.OX2] = u - f, S[i.OY2] = g + c, S[i.OX3] = _ - f, S[i.OY3] = g + m, S[i.OX4] = _ - p, S[i.OY4] = d + m
						}, i.prototype.setRegion = function(t) {
							this.region = t;
							var e = this.uvs;
							t.rotate ? (e[2] = t.u, e[3] = t.v2, e[4] = t.u, e[5] = t.v, e[6] = t.u2, e[7] = t.v, e[0] = t.u2, e[1] = t.v2) : (e[0] = t.u, e[1] = t.v2, e[2] = t.u, e[3] = t.v, e[4] = t.u2, e[5] = t.v, e[6] = t.u2, e[7] = t.v2)
						}, i.prototype.computeWorldVertices = function(t, e, n, s) {
							var o = this.offset,
								r = t.matrix,
								a = r.tx,
								l = r.ty,
								h = r.a,
								u = r.c,
								c = r.b,
								d = r.d,
								p = 0,
								_ = 0;
							p = o[i.OX1], _ = o[i.OY1], e[n] = p * h + _ * u + a, e[n + 1] = p * c + _ * d + l, n += s, p = o[i.OX2], _ = o[i.OY2], e[n] = p * h + _ * u + a, e[n + 1] = p * c + _ * d + l, n += s, p = o[i.OX3], _ = o[i.OY3], e[n] = p * h + _ * u + a, e[n + 1] = p * c + _ * d + l, n += s, p = o[i.OX4], _ = o[i.OY4], e[n] = p * h + _ * u + a, e[n + 1] = p * c + _ * d + l
						}, i.OX1 = 0, i.OY1 = 1, i.OX2 = 2, i.OY2 = 3, i.OX3 = 4, i.OY3 = 5, i.OX4 = 6, i.OY4 = 7, i.X1 = 0, i.Y1 = 1, i.C1R = 2, i.C1G = 3, i.C1B = 4, i.C1A = 5, i.U1 = 6, i.V1 = 7, i.X2 = 8, i.Y2 = 9, i.C2R = 10, i.C2G = 11, i.C2B = 12, i.C2A = 13, i.U2 = 14, i.V2 = 15, i.X3 = 16, i.Y3 = 17, i.C3R = 18, i.C3G = 19, i.C3B = 20, i.C3A = 21, i.U3 = 22, i.V3 = 23, i.X4 = 24, i.Y4 = 25, i.C4R = 26, i.C4G = 27, i.C4B = 28, i.C4A = 29, i.U4 = 30, i.V4 = 31, i
					}(e.Attachment), e.RegionAttachment = i
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), i = function() {
						function t(t, e) {
							this.jitterX = 0, this.jitterY = 0, this.jitterX = t, this.jitterY = e
						}
						return t.prototype.begin = function(t) {}, t.prototype.transform = function(t, i, n, s) {
							t.x += e.MathUtils.randomTriangular(-this.jitterX, this.jitterY), t.y += e.MathUtils.randomTriangular(-this.jitterX, this.jitterY)
						}, t.prototype.end = function() {}, t
					}(), e.JitterEffect = i
				}(i || (i = {})),
				function(t) {
					var e, i;
					e = t.core || (t.core = {}), i = function() {
						function t(t) {
							this.centerX = 0, this.centerY = 0, this.radius = 0, this.angle = 0, this.worldX = 0, this.worldY = 0, this.radius = t
						}
						return t.prototype.begin = function(t) {
							this.worldX = t.x + this.centerX, this.worldY = t.y + this.centerY
						}, t.prototype.transform = function(i, n, s, o) {
							var r = this.angle * e.MathUtils.degreesToRadians,
								a = i.x - this.worldX,
								l = i.y - this.worldY,
								h = Math.sqrt(a * a + l * l);
							if (h < this.radius) {
								var u = t.interpolation.apply(0, r, (this.radius - h) / this.radius),
									c = Math.cos(u),
									d = Math.sin(u);
								i.x = c * a - d * l + this.worldX, i.y = d * a + c * l + this.worldY
							}
						}, t.prototype.end = function() {}, t.interpolation = new e.PowOut(2), t
					}(), e.SwirlEffect = i
				}(i || (i = {})), Math.fround || (Math.fround = Math.fround = (e = new Float32Array(1), function(t) {
						return e[0] = t, e[0]
					})),
					function(t) {
						t.core.Bone.yDown = !0;
						var e = [0, 0, 0],
							i = function(t) {
								function e() {
									var e = null !== t && t.apply(this, arguments) || this;
									return e.region = null, e
								}
								return n(e, t), e
							}(PIXI.Sprite);
						t.SpineSprite = i;
						var s = PIXI.GraphicsGeometry.prototype;
						if (!s.invalidate) {
							var o = [];
							s.invalidate = function() {
								var t = this.graphicsData;
								o.push(0), this.graphicsData = o, this.clear(), this.graphicsData = t
							}
						}
						var r = function(t) {
							function e(e, i, n, s, o) {
								return t.call(this, e, i, n, s, o) || this
							}
							return n(e, t), e
						}(PIXI.SimpleMesh);
						t.SpineMesh = r;
						var a = function(s) {
							function o(e) {
								var i = s.call(this) || this;
								if (!e) throw new Error("The spineData param is required.");
								if ("string" == typeof e) throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');
								i.spineData = e, i.skeleton = new t.core.Skeleton(e), i.skeleton.updateWorldTransform(), i.stateData = new t.core.AnimationStateData(e), i.state = new t.core.AnimationState(i.stateData), i.slotContainers = [], i.tempClipContainers = [];
								for (var n = 0, o = i.skeleton.slots.length; n < o; n++) {
									var r = i.skeleton.slots[n],
										a = r.attachment,
										l = i.newContainer();
									if (i.slotContainers.push(l), i.addChild(l), i.tempClipContainers.push(null), a instanceof t.core.RegionAttachment) {
										var h = a.region.name,
											u = i.createSprite(r, a, h);
										r.currentSprite = u, r.currentSpriteName = h, l.addChild(u)
									} else if (a instanceof t.core.MeshAttachment) {
										var c = i.createMesh(r, a);
										r.currentMesh = c, r.currentMeshName = a.name, l.addChild(c)
									} else {
										if (!(a instanceof t.core.ClippingAttachment)) continue;
										i.createGraphics(r, a), l.addChild(r.clippingContainer), l.addChild(r.currentGraphics)
									}
								}
								return i.autoUpdate = !0, i.tintRgb = new Float32Array([1, 1, 1]), i
							}
							return n(o, s), Object.defineProperty(o.prototype, "autoUpdate", {
								get: function() {
									return this.updateTransform === o.prototype.autoUpdateTransform
								},
								set: function(t) {
									this.updateTransform = t ? o.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform
								},
								enumerable: !0,
								configurable: !0
							}), Object.defineProperty(o.prototype, "tint", {
								get: function() {
									return PIXI.utils.rgb2hex(this.tintRgb)
								},
								set: function(t) {
									this.tintRgb = PIXI.utils.hex2rgb(t, this.tintRgb)
								},
								enumerable: !0,
								configurable: !0
							}), Object.defineProperty(o.prototype, "delayLimit", {
								get: function() {
									return (void 0 !== this.localDelayLimit ? this.localDelayLimit : o.globalDelayLimit) || Number.MAX_VALUE
								},
								enumerable: !0,
								configurable: !0
							}), o.prototype.update = function(i) {
								var n = this.delayLimit;
								if (i > n && (i = n), this.state.update(i), this.state.apply(this.skeleton), this.skeleton) {
									this.skeleton.updateWorldTransform();
									var s = this.skeleton.slots,
										o = this.color,
										r = null,
										a = null;
									o ? (r = o.light, a = o.dark) : r = this.tintRgb;
									for (var l = 0, h = s.length; l < h; l++) {
										var u = (w = s[l]).attachment,
											c = this.slotContainers[l];
										if (u) {
											var d = null,
												p = u.color;
											if (u instanceof t.core.RegionAttachment) {
												var _ = u.region;
												if (_) {
													w.currentMesh && (w.currentMesh.visible = !1, w.currentMesh = null, w.currentMeshName = void 0);
													var m = _;
													if (!w.currentSpriteName || w.currentSpriteName !== m.name) {
														var g = m.name;
														if (w.currentSprite && (w.currentSprite.visible = !1), w.sprites = w.sprites || {}, void 0 !== w.sprites[g]) w.sprites[g].visible = !0;
														else {
															var f = this.createSprite(w, u, g);
															c.addChild(f)
														}
														w.currentSprite = w.sprites[g], w.currentSpriteName = g
													}
												}(S = c.transform).setFromMatrix(w.bone.matrix), w.currentSprite.color ? d = w.currentSprite.color : (e[0] = r[0] * w.color.r * p.r, e[1] = r[1] * w.color.g * p.g, e[2] = r[2] * w.color.b * p.b, w.currentSprite.tint = PIXI.utils.rgb2hex(e)), w.currentSprite.blendMode = w.blendMode
											} else if (u instanceof t.core.MeshAttachment) {
												var S;
												if (w.currentSprite && (w.currentSprite.visible = !1, w.currentSprite = null, w.currentSpriteName = void 0, (S = new PIXI.Transform)._parentID = -1, S._worldID = c.transform._worldID, c.transform = S), !w.currentMeshName || w.currentMeshName !== u.name) {
													var y = u.name;
													if (w.currentMesh && (w.currentMesh.visible = !1), w.meshes = w.meshes || {}, void 0 !== w.meshes[y]) w.meshes[y].visible = !0;
													else {
														var v = this.createMesh(w, u);
														c.addChild(v)
													}
													w.currentMesh = w.meshes[y], w.currentMeshName = y
												}
												u.computeWorldVerticesOld(w, w.currentMesh.vertices), w.currentMesh.color ? d = w.currentMesh.color : (e[0] = r[0] * w.color.r * p.r, e[1] = r[1] * w.color.g * p.g, e[2] = r[2] * w.color.b * p.b, w.currentMesh.tint = PIXI.utils.rgb2hex(e)), w.currentMesh.blendMode = w.blendMode
											} else {
												if (!(u instanceof t.core.ClippingAttachment)) {
													c.visible = !1;
													continue
												}
												w.currentGraphics || (this.createGraphics(w, u), c.addChild(w.clippingContainer), c.addChild(w.currentGraphics)), this.updateGraphics(w, u)
											}
											if (c.visible = !0, d) {
												var T = w.color.r * p.r,
													E = w.color.g * p.g,
													b = w.color.b * p.b;
												d.setLight(r[0] * T + a[0] * (1 - T), r[1] * E + a[1] * (1 - E), r[2] * b + a[2] * (1 - b)), w.darkColor ? (T = w.darkColor.r, E = w.darkColor.g, b = w.darkColor.b) : (T = 0, E = 0, b = 0), d.setDark(r[0] * T + a[0] * (1 - T), r[1] * E + a[1] * (1 - E), r[2] * b + a[2] * (1 - b))
											}
											c.alpha = w.color.a
										} else c.visible = !1
									}
									var A = this.skeleton.drawOrder,
										P = null,
										I = null;
									for (l = 0, h = A.length; l < h; l++) {
										var w = s[A[l].data.index];
										if (c = this.slotContainers[A[l].data.index], I || null !== c.parent && c.parent !== this && (c.parent.removeChild(c), c.parent = this), w.currentGraphics && w.attachment) I = w.clippingContainer, P = w.attachment, I.children.length = 0, this.children[l] = c, P.endSlot == w.data && (P.endSlot = null);
										else if (I) {
											var L = this.tempClipContainers[l];
											L || ((L = this.tempClipContainers[l] = this.newContainer()).visible = !1), this.children[l] = L, c.parent = null, I.addChild(c), P.endSlot == w.data && (I.renderable = !0, I = null, P = null)
										} else this.children[l] = c
									}
								}
							}, o.prototype.setSpriteRegion = function(t, e, i) {
								e.region = i, e.texture = i.texture, i.size ? (e.scale.x = i.size.width / i.originalWidth, e.scale.y = -i.size.height / i.originalHeight) : (e.scale.x = t.scaleX * t.width / i.originalWidth, e.scale.y = -t.scaleY * t.height / i.originalHeight)
							}, o.prototype.setMeshRegion = function(t, e, i) {
								e.region = i, e.texture = i.texture, i.texture.updateUvs(), e.uvBuffer.update(t.regionUVs)
							}, o.prototype.autoUpdateTransform = function() {
								if (o.globalAutoUpdate) {
									this.lastTime = this.lastTime || Date.now();
									var t = .001 * (Date.now() - this.lastTime);
									this.lastTime = Date.now(), this.update(t)
								} else this.lastTime = 0;
								PIXI.Container.prototype.updateTransform.call(this)
							}, o.prototype.createSprite = function(e, i, n) {
								var s = i.region;
								e.tempAttachment === i && (s = e.tempRegion, e.tempAttachment = null, e.tempRegion = null);
								var o = s.texture,
									r = this.newSprite(o);
								return r.rotation = i.rotation * t.core.MathUtils.degRad, r.anchor.x = .5, r.anchor.y = .5, r.position.x = i.x, r.position.y = i.y, r.alpha = i.color.a, r.region = i.region, this.setSpriteRegion(i, r, i.region), e.sprites = e.sprites || {}, e.sprites[n] = r, r
							}, o.prototype.createMesh = function(t, e) {
								var i = e.region;
								t.tempAttachment === e && (i = t.tempRegion, t.tempAttachment = null, t.tempRegion = null);
								var n = this.newMesh(i.texture, new Float32Array(e.regionUVs.length), e.regionUVs, new Uint16Array(e.triangles), PIXI.DRAW_MODES.TRIANGLES);
								return n.canvasPadding && (n.canvasPadding = 1.5), n.alpha = e.color.a, n.region = e.region, this.setMeshRegion(e, n, i), t.meshes = t.meshes || {}, t.meshes[e.name] = n, n
							}, o.prototype.createGraphics = function(t, e) {
								var i = this.newGraphics(),
									n = new PIXI.Polygon([]);
								return i.clear(), i.beginFill(16777215, 1), i.drawPolygon(n), i.renderable = !1, t.currentGraphics = i, t.clippingContainer = this.newContainer(), t.clippingContainer.mask = t.currentGraphics, i
							}, o.prototype.updateGraphics = function(t, e) {
								var i = t.currentGraphics.geometry,
									n = i.graphicsData[0].shape.points,
									s = e.worldVerticesLength;
								n.length = s, e.computeWorldVertices(t, 0, s, n, 0, 2), i.invalidate()
							}, o.prototype.hackTextureBySlotIndex = function(e, i, n) {
								void 0 === i && (i = null), void 0 === n && (n = null);
								var s = this.skeleton.slots[e];
								if (!s) return !1;
								var o = s.attachment,
									r = o.region;
								return i && ((r = new t.core.TextureRegion).texture = i, r.size = n), s.currentSprite && s.currentSprite.region != r ? (this.setSpriteRegion(o, s.currentSprite, r), s.currentSprite.region = r) : s.currentMesh && s.currentMesh.region != r ? this.setMeshRegion(o, s.currentMesh, r) : (s.tempRegion = r, s.tempAttachment = o), !0
							}, o.prototype.hackTextureBySlotName = function(t, e, i) {
								void 0 === e && (e = null), void 0 === i && (i = null);
								var n = this.skeleton.findSlotIndex(t);
								return -1 != n && this.hackTextureBySlotIndex(n, e, i)
							}, o.prototype.newContainer = function() {
								return new PIXI.Container
							}, o.prototype.newSprite = function(t) {
								return new i(t)
							}, o.prototype.newGraphics = function() {
								return new PIXI.Graphics
							}, o.prototype.newMesh = function(t, e, i, n, s) {
								return new r(t, e, i, n, s)
							}, o.prototype.transformHack = function() {
								return 1
							}, o.prototype.hackAttachmentGroups = function(t, e, i) {
								if (t) {
									for (var n = [], s = [], o = 0, r = this.skeleton.slots.length; o < r; o++) {
										var a = this.skeleton.slots[o],
											l = a.currentSpriteName || a.currentMeshName || "",
											h = a.currentSprite || a.currentMesh;
										l.endsWith(t) ? (h.parentGroup = e, s.push(h)) : i && h && (h.parentGroup = i, n.push(h))
									}
									return [n, s]
								}
							}, o.prototype.destroy = function(t) {
								for (var e = 0, i = this.skeleton.slots.length; e < i; e++) {
									var n = this.skeleton.slots[e];
									for (var o in n.meshes) n.meshes[o].destroy(t);
									for (var r in n.meshes = null, n.sprites) n.sprites[r].destroy(t);
									n.sprites = null
								}
								for (e = 0, i = this.slotContainers.length; e < i; e++) this.slotContainers[e].destroy(t);
								this.spineData = null, this.skeleton = null, this.slotContainers = null, this.stateData = null, this.state = null, this.tempClipContainers = null, s.prototype.destroy.call(this, t)
							}, o.globalAutoUpdate = !0, o.globalDelayLimit = 0, o.clippingPolygon = [], o
						}(PIXI.Container);
						t.Spine = a
					}(i || (i = {})),
					function(t) {
						PIXI.spine = t;
						var e = PIXI.Texture.prototype;
						e._updateUvs || (e._updateUvs = e.updateUvs)
					}(i || (i = {})),
					function(t) {
						var e = function() {
							function e() {}
							return e.use = function(e, s) {
								if (!e.data || ! function(t) {
										return t.type === PIXI.LoaderResource.TYPE.JSON
									}(e) || !e.data.bones) return s();
								var o = e.metadata || {},
									r = o ? e.metadata.spineSkeletonScale : null,
									a = o ? e.metadata.spineAtlas : null;
								if (!1 === a) return s();
								if (a && a.pages) {
									var l = new t.core.SkeletonJson(new t.core.AtlasAttachmentLoader(a));
									r && (l.scale = r);
									var h = l.readSkeletonData(e.data);
									return e.spineData = h, e.spineAtlas = a, s()
								}
								var u = o.spineAtlasSuffix || ".atlas",
									c = e.url,
									d = c.indexOf("?");
								d > 0 && (c = c.substr(0, d)), c = c.substr(0, c.lastIndexOf(".")) + u, e.metadata && e.metadata.spineAtlasFile && (c = e.metadata.spineAtlasFile), c = c.replace(this.baseUrl, "");
								var p = {
										crossOrigin: e.crossOrigin,
										xhrType: PIXI.LoaderResource.XHR_RESPONSE_TYPE.TEXT,
										metadata: o.spineMetadata || null,
										parentResource: e
									},
									_ = {
										crossOrigin: e.crossOrigin,
										metadata: o.imageMetadata || null,
										parentResource: e
									},
									m = e.url.substr(0, e.url.lastIndexOf("/") + 1);
								m = m.replace(this.baseUrl, "");
								var g = o.imageNamePrefix || e.name + "_atlas_page_",
									f = o.images ? n(o.images) : o.image ? n({
										default: o.image
									}) : o.imageLoader ? o.imageLoader(this, g, m, _) : i(this, g, m, _),
									S = function(i) {
										new t.core.TextureAtlas(i, f, (function(i) {
											if (i) {
												var n = new t.core.SkeletonJson(new t.core.AtlasAttachmentLoader(i));
												r && (n.scale = r), e.spineData = n.readSkeletonData(e.data), e.spineAtlas = i
											}
											s()
										}))
									};
								e.metadata && e.metadata.atlasRawData ? S(e.metadata.atlasRawData) : this.add(e.name + "_atlas", c, p, (function(t) {
									t.error ? s() : S(t.data)
								}))
							}, e
						}();

						function i(t, e, i, n) {
							return i && i.lastIndexOf("/") !== i.length - 1 && (i += "/"),
								function(s, o) {
									var r = e + s,
										a = i + s,
										l = t.resources[r];
									if (l) {
										function h() {
											o(l.texture.baseTexture)
										}
										l.texture ? h() : l.onAfterMiddleware.add(h)
									} else t.add(r, a, n, (function(t) {
										t.error ? o(null) : o(t.texture.baseTexture)
									}))
								}
						}

						function n(t) {
							return function(e, i) {
								var n = t[e] || t.default;
								n && n.baseTexture ? i(n.baseTexture) : i(n)
							}
						}
						t.AtlasParser = e, t.imageLoaderAdapter = i, t.syncImageLoaderAdapter = function(t, e) {
							return t && t.lastIndexOf("/") !== t.length - 1 && (t += "/"),
								function(t, i) {
									i(PIXI.BaseTexture.from(t, e))
								}
						}, t.staticImageLoader = n, PIXI.Loader && PIXI.Loader.registerPlugin(e)
					}(i || (i = {}))
			},
			82859: (t, e, i) => {
				"use strict";
				i.r(e), i.d(e, {
					ALPHA_MODES: () => b,
					AbstractBatchRenderer: () => Nn,
					AbstractRenderer: () => Pn,
					AccessibilityManager: () => me,
					AnimatedSprite: () => $r,
					AppLoaderPlugin: () => _s,
					Application: () => Un,
					Attribute: () => ii,
					BLEND_MODES: () => m,
					BUFFER_BITS: () => _,
					BasePrepare: () => Po,
					BaseRenderTexture: () => qe,
					BaseTexture: () => Re,
					BatchDrawCall: () => xn,
					BatchGeometry: () => Rn,
					BatchPluginFactory: () => Fn,
					BatchRenderer: () => Gn,
					BatchShaderGenerator: () => Mn,
					BatchTextureArray: () => Bn,
					BitmapFont: () => ir,
					BitmapFontData: () => qo,
					BitmapFontLoader: () => rr,
					BitmapText: () => or,
					Bounds: () => oe,
					Buffer: () => si,
					CLEAR_MODES: () => A,
					Circle: () => Vt,
					Container: () => ce,
					CountLimiter: () => fo,
					DEG_TO_RAD: () => Wt,
					DRAW_MODES: () => g,
					DisplayObject: () => le,
					ENV: () => d,
					Ellipse: () => Xt,
					Extract: () => Vn,
					FORMATS: () => f,
					FillStyle: () => bs,
					Filter: () => tn,
					FilterState: () => mi,
					Framebuffer: () => Ke,
					GC_MODES: () => P,
					GLFramebuffer: () => Ti,
					GLProgram: () => mn,
					GLTexture: () => Tn,
					GRAPHICS_CURVES: () => Es,
					Geometry: () => ui,
					Graphics: () => Js,
					GraphicsData: () => zs,
					GraphicsGeometry: () => qs,
					IGLUniformData: () => _n,
					InteractionData: () => ye,
					InteractionEvent: () => Te,
					InteractionManager: () => Ie,
					InteractionTrackingData: () => Ee,
					LINE_CAP: () => Ss,
					LINE_JOIN: () => fs,
					LineStyle: () => Zs,
					Loader: () => ps,
					LoaderResource: () => us,
					MASK_TYPES: () => w,
					MIPMAP_MODES: () => E,
					MSAA_QUALITY: () => L,
					MaskData: () => wi,
					Matrix: () => qt,
					Mesh: () => Yo,
					MeshBatchUvs: () => Ho,
					MeshGeometry: () => jo,
					MeshMaterial: () => zo,
					NineSlicePlane: () => qr,
					ObjectRenderer: () => fi,
					ObservablePoint: () => Kt,
					PI_2: () => Gt,
					PRECISION: () => I,
					ParticleContainer: () => ys,
					ParticleRenderer: () => Ts,
					PlaneGeometry: () => Xr,
					Point: () => jt,
					Polygon: () => Yt,
					Prepare: () => Co,
					Program: () => $i,
					Quad: () => ci,
					QuadUv: () => di,
					RAD_TO_DEG: () => Ut,
					RENDERER_TYPE: () => p,
					Rectangle: () => Ht,
					RenderTexture: () => ti,
					RenderTexturePool: () => ei,
					Renderer: () => In,
					RopeGeometry: () => Yr,
					RoundedRectangle: () => zt,
					Runner: () => we,
					SCALE_MODES: () => v,
					SHAPES: () => Ft,
					Shader: () => Qi,
					SimpleMesh: () => Kr,
					SimplePlane: () => jr,
					SimpleRope: () => zr,
					Sprite: () => no,
					SpriteMaskFilter: () => sn,
					Spritesheet: () => Bo,
					SpritesheetLoader: () => Oo,
					State: () => Ji,
					System: () => ze,
					TARGETS: () => S,
					TEXT_GRADIENT: () => Ds,
					TYPES: () => y,
					TemporaryDisplayObject: () => he,
					Text: () => mo,
					TextMetrics: () => co,
					TextStyle: () => ao,
					Texture: () => Qe,
					TextureLoader: () => ds,
					TextureMatrix: () => nn,
					TextureUvs: () => Ze,
					Ticker: () => fe,
					TickerPlugin: () => Se,
					TilingSprite: () => Do,
					TilingSpriteRenderer: () => Go,
					TimeLimiter: () => xo,
					Transform: () => se,
					UPDATE_PRIORITY: () => pe,
					UniformGroup: () => _i,
					VERSION: () => ia,
					ViewableBuffer: () => On,
					WRAP_MODES: () => T,
					accessibleTarget: () => de,
					autoDetectRenderer: () => wn,
					checkMaxIfStatementsInShader: () => Ki,
					defaultFilterVertex: () => Cn,
					defaultVertex: () => Ln,
					filters: () => na,
					graphicsUtils: () => Ys,
					groupD8: () => ne,
					interactiveTarget: () => Ae,
					isMobile: () => Y,
					resources: () => Ye,
					settings: () => z,
					systems: () => bn,
					uniformParsers: () => Vi,
					useDeprecated: () => ea,
					utils: () => n
				});
				var n = {};
				i.r(n), i.d(n, {
					BaseTextureCache: () => Lt,
					CanvasRenderTarget: () => Bt,
					DATA_URI: () => Mt,
					EventEmitter: () => K(),
					ProgramCache: () => It,
					TextureCache: () => wt,
					clearTextureCache: () => xt,
					correctBlendMode: () => ht,
					createIndicesForQuads: () => pt,
					decomposeDataUri: () => Rt,
					deprecation: () => Pt,
					destroyTextureCache: () => Ct,
					determineCrossOrigin: () => Dt,
					earcut: () => Z(),
					getBufferType: () => _t,
					getResolutionOfUrl: () => kt,
					hex2rgb: () => st,
					hex2string: () => ot,
					interleaveTypedArrays: () => gt,
					isMobile: () => Y,
					isPow2: () => St,
					isWebGLSupported: () => nt,
					log2: () => yt,
					nextPow2: () => ft,
					premultiplyBlendMode: () => lt,
					premultiplyRgba: () => ut,
					premultiplyTint: () => ct,
					premultiplyTintToRgba: () => dt,
					removeItems: () => vt,
					rgb2hex: () => at,
					sayHello: () => it,
					sign: () => Tt,
					skipHello: () => et,
					string2hex: () => rt,
					trimCanvas: () => Ot,
					uid: () => bt,
					url: () => $
				});
				var s = i(36354),
					o = i(45228),
					r = i.n(o);
				if (window.Promise || (window.Promise = s.Polyfill), Object.assign || (Object.assign = r()), Date.now && Date.prototype.getTime || (Date.now = function() {
						return (new Date).getTime()
					}), !window.performance || !window.performance.now) {
					var a = Date.now();
					window.performance || (window.performance = {}), window.performance.now = function() {
						return Date.now() - a
					}
				}
				for (var l = Date.now(), h = ["ms", "moz", "webkit", "o"], u = 0; u < h.length && !window.requestAnimationFrame; ++u) {
					var c = h[u];
					window.requestAnimationFrame = window[c + "RequestAnimationFrame"], window.cancelAnimationFrame = window[c + "CancelAnimationFrame"] || window[c + "CancelRequestAnimationFrame"]
				}
				window.requestAnimationFrame || (window.requestAnimationFrame = function(t) {
					if ("function" != typeof t) throw new TypeError(t + "is not a function");
					var e = Date.now(),
						i = 16 + l - e;
					return i < 0 && (i = 0), l = e, window.setTimeout((function() {
						l = Date.now(), t(performance.now())
					}), i)
				}), window.cancelAnimationFrame || (window.cancelAnimationFrame = function(t) {
					return clearTimeout(t)
				}), Math.sign || (Math.sign = function(t) {
					return 0 === (t = Number(t)) || isNaN(t) ? t : t > 0 ? 1 : -1
				}), Number.isInteger || (Number.isInteger = function(t) {
					return "number" == typeof t && isFinite(t) && Math.floor(t) === t
				}), window.ArrayBuffer || (window.ArrayBuffer = Array), window.Float32Array || (window.Float32Array = Array), window.Uint32Array || (window.Uint32Array = Array), window.Uint16Array || (window.Uint16Array = Array), window.Uint8Array || (window.Uint8Array = Array), window.Int32Array || (window.Int32Array = Array);
				var d, p, _, m, g, f, S, y, v, T, E, b, A, P, I, w, L, C = /iPhone/i,
					x = /iPod/i,
					B = /iPad/i,
					O = /\biOS-universal(?:.+)Mac\b/i,
					N = /\bAndroid(?:.+)Mobile\b/i,
					M = /Android/i,
					R = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
					D = /Silk/i,
					k = /Windows Phone/i,
					F = /\bWindows(?:.+)ARM\b/i,
					G = /BlackBerry/i,
					U = /BB10/i,
					W = /Opera Mini/i,
					H = /\b(CriOS|Chrome)(?:.+)Mobile/i,
					V = /Mobile(?:.+)Firefox\b/i,
					X = function(t) {
						return void 0 !== t && "MacIntel" === t.platform && "number" == typeof t.maxTouchPoints && t.maxTouchPoints > 1 && "undefined" == typeof MSStream
					},
					Y = function(t) {
						var e = {
							userAgent: "",
							platform: "",
							maxTouchPoints: 0
						};
						t || "undefined" == typeof navigator ? "string" == typeof t ? e.userAgent = t : t && t.userAgent && (e = {
							userAgent: t.userAgent,
							platform: t.platform,
							maxTouchPoints: t.maxTouchPoints || 0
						}) : e = {
							userAgent: navigator.userAgent,
							platform: navigator.platform,
							maxTouchPoints: navigator.maxTouchPoints || 0
						};
						var i = e.userAgent,
							n = i.split("[FBAN");
						void 0 !== n[1] && (i = n[0]), void 0 !== (n = i.split("Twitter"))[1] && (i = n[0]);
						var s = function(t) {
								return function(e) {
									return e.test(t)
								}
							}(i),
							o = {
								apple: {
									phone: s(C) && !s(k),
									ipod: s(x),
									tablet: !s(C) && (s(B) || X(e)) && !s(k),
									universal: s(O),
									device: (s(C) || s(x) || s(B) || s(O) || X(e)) && !s(k)
								},
								amazon: {
									phone: s(R),
									tablet: !s(R) && s(D),
									device: s(R) || s(D)
								},
								android: {
									phone: !s(k) && s(R) || !s(k) && s(N),
									tablet: !s(k) && !s(R) && !s(N) && (s(D) || s(M)),
									device: !s(k) && (s(R) || s(D) || s(N) || s(M)) || s(/\bokhttp\b/i)
								},
								windows: {
									phone: s(k),
									tablet: s(F),
									device: s(k) || s(F)
								},
								other: {
									blackberry: s(G),
									blackberry10: s(U),
									opera: s(W),
									firefox: s(V),
									chrome: s(H),
									device: s(G) || s(U) || s(W) || s(V) || s(H)
								},
								any: !1,
								phone: !1,
								tablet: !1
							};
						return o.any = o.apple.device || o.android.device || o.windows.device || o.other.device, o.phone = o.apple.phone || o.android.phone || o.windows.phone, o.tablet = o.apple.tablet || o.android.tablet || o.windows.tablet, o
					}(window.navigator),
					z = {
						MIPMAP_TEXTURES: 1,
						ANISOTROPIC_LEVEL: 0,
						RESOLUTION: 1,
						FILTER_RESOLUTION: 1,
						SPRITE_MAX_TEXTURES: function(t) {
							var e, i = !0;
							(Y.tablet || Y.phone) && (Y.apple.device && (e = navigator.userAgent.match(/OS (\d+)_(\d+)?/)) && parseInt(e[1], 10) < 11 && (i = !1), Y.android.device && (e = navigator.userAgent.match(/Android\s([0-9.]*)/)) && parseInt(e[1], 10) < 7 && (i = !1));
							return i ? 32 : 4
						}(),
						SPRITE_BATCH_SIZE: 4096,
						RENDER_OPTIONS: {
							view: null,
							antialias: !1,
							autoDensity: !1,
							transparent: !1,
							backgroundColor: 0,
							clearBeforeRender: !0,
							preserveDrawingBuffer: !1,
							width: 800,
							height: 600,
							legacy: !1
						},
						GC_MODE: 0,
						GC_MAX_IDLE: 3600,
						GC_MAX_CHECK_COUNT: 600,
						WRAP_MODE: 33071,
						SCALE_MODE: 1,
						PRECISION_VERTEX: "highp",
						PRECISION_FRAGMENT: Y.apple.device ? "highp" : "mediump",
						CAN_UPLOAD_SAME_BUFFER: !Y.apple.device,
						CREATE_IMAGE_BITMAP: !1,
						ROUND_PIXELS: !1
					},
					j = i(30228),
					K = i.n(j),
					q = i(66570),
					Z = i.n(q),
					$ = i(88835);
				! function(t) {
					t[t.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t[t.WEBGL = 1] = "WEBGL", t[t.WEBGL2 = 2] = "WEBGL2"
				}(d || (d = {})),
				function(t) {
					t[t.UNKNOWN = 0] = "UNKNOWN", t[t.WEBGL = 1] = "WEBGL", t[t.CANVAS = 2] = "CANVAS"
				}(p || (p = {})),
				function(t) {
					t[t.COLOR = 16384] = "COLOR", t[t.DEPTH = 256] = "DEPTH", t[t.STENCIL = 1024] = "STENCIL"
				}(_ || (_ = {})),
				function(t) {
					t[t.NORMAL = 0] = "NORMAL", t[t.ADD = 1] = "ADD", t[t.MULTIPLY = 2] = "MULTIPLY", t[t.SCREEN = 3] = "SCREEN", t[t.OVERLAY = 4] = "OVERLAY", t[t.DARKEN = 5] = "DARKEN", t[t.LIGHTEN = 6] = "LIGHTEN", t[t.COLOR_DODGE = 7] = "COLOR_DODGE", t[t.COLOR_BURN = 8] = "COLOR_BURN", t[t.HARD_LIGHT = 9] = "HARD_LIGHT", t[t.SOFT_LIGHT = 10] = "SOFT_LIGHT", t[t.DIFFERENCE = 11] = "DIFFERENCE", t[t.EXCLUSION = 12] = "EXCLUSION", t[t.HUE = 13] = "HUE", t[t.SATURATION = 14] = "SATURATION", t[t.COLOR = 15] = "COLOR", t[t.LUMINOSITY = 16] = "LUMINOSITY", t[t.NORMAL_NPM = 17] = "NORMAL_NPM", t[t.ADD_NPM = 18] = "ADD_NPM", t[t.SCREEN_NPM = 19] = "SCREEN_NPM", t[t.NONE = 20] = "NONE", t[t.SRC_OVER = 0] = "SRC_OVER", t[t.SRC_IN = 21] = "SRC_IN", t[t.SRC_OUT = 22] = "SRC_OUT", t[t.SRC_ATOP = 23] = "SRC_ATOP", t[t.DST_OVER = 24] = "DST_OVER", t[t.DST_IN = 25] = "DST_IN", t[t.DST_OUT = 26] = "DST_OUT", t[t.DST_ATOP = 27] = "DST_ATOP", t[t.ERASE = 26] = "ERASE", t[t.SUBTRACT = 28] = "SUBTRACT", t[t.XOR = 29] = "XOR"
				}(m || (m = {})),
				function(t) {
					t[t.POINTS = 0] = "POINTS", t[t.LINES = 1] = "LINES", t[t.LINE_LOOP = 2] = "LINE_LOOP", t[t.LINE_STRIP = 3] = "LINE_STRIP", t[t.TRIANGLES = 4] = "TRIANGLES", t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN"
				}(g || (g = {})),
				function(t) {
					t[t.RGBA = 6408] = "RGBA", t[t.RGB = 6407] = "RGB", t[t.ALPHA = 6406] = "ALPHA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL"
				}(f || (f = {})),
				function(t) {
					t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z"
				}(S || (S = {})),
				function(t) {
					t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.FLOAT = 5126] = "FLOAT", t[t.HALF_FLOAT = 36193] = "HALF_FLOAT"
				}(y || (y = {})),
				function(t) {
					t[t.NEAREST = 0] = "NEAREST", t[t.LINEAR = 1] = "LINEAR"
				}(v || (v = {})),
				function(t) {
					t[t.CLAMP = 33071] = "CLAMP", t[t.REPEAT = 10497] = "REPEAT", t[t.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT"
				}(T || (T = {})),
				function(t) {
					t[t.OFF = 0] = "OFF", t[t.POW2 = 1] = "POW2", t[t.ON = 2] = "ON"
				}(E || (E = {})),
				function(t) {
					t[t.NPM = 0] = "NPM", t[t.UNPACK = 1] = "UNPACK", t[t.PMA = 2] = "PMA", t[t.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t[t.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t[t.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA"
				}(b || (b = {})),
				function(t) {
					t[t.NO = 0] = "NO", t[t.YES = 1] = "YES", t[t.AUTO = 2] = "AUTO", t[t.BLEND = 0] = "BLEND", t[t.CLEAR = 1] = "CLEAR", t[t.BLIT = 2] = "BLIT"
				}(A || (A = {})),
				function(t) {
					t[t.AUTO = 0] = "AUTO", t[t.MANUAL = 1] = "MANUAL"
				}(P || (P = {})),
				function(t) {
					t.LOW = "lowp", t.MEDIUM = "mediump", t.HIGH = "highp"
				}(I || (I = {})),
				function(t) {
					t[t.NONE = 0] = "NONE", t[t.SCISSOR = 1] = "SCISSOR", t[t.STENCIL = 2] = "STENCIL", t[t.SPRITE = 3] = "SPRITE"
				}(w || (w = {})),
				function(t) {
					t[t.NONE = 0] = "NONE", t[t.LOW = 2] = "LOW", t[t.MEDIUM = 4] = "MEDIUM", t[t.HIGH = 8] = "HIGH"
				}(L || (L = {})), z.RETINA_PREFIX = /@([0-9\.]+)x/, z.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !0;
				var Q, J = !1,
					tt = "5.3.12";

				function et() {
					J = !0
				}

				function it(t) {
					var e;
					if (!J) {
						if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
							var i = ["\n %c %c %c PixiJS " + tt + " -  " + t + "   %c  %c  http://www.pixijs.com/  %c %c %c%c \n\n", "background: #ff66a5; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff66a5; background: #030307; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "background: #ffc3dc; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;"];
							(e = window.console).log.apply(e, i)
						} else window.console && window.console.log("PixiJS " + tt + " - " + t + " - http://www.pixijs.com/");
						J = !0
					}
				}

				function nt() {
					return void 0 === Q && (Q = function() {
						var t = {
							stencil: !0,
							failIfMajorPerformanceCaveat: z.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
						};
						try {
							if (!window.WebGLRenderingContext) return !1;
							var e = document.createElement("canvas"),
								i = e.getContext("webgl", t) || e.getContext("experimental-webgl", t),
								n = !(!i || !i.getContextAttributes().stencil);
							if (i) {
								var s = i.getExtension("WEBGL_lose_context");
								s && s.loseContext()
							}
							return i = null, n
						} catch (t) {
							return !1
						}
					}()), Q
				}

				function st(t, e) {
					return void 0 === e && (e = []), e[0] = (t >> 16 & 255) / 255, e[1] = (t >> 8 & 255) / 255, e[2] = (255 & t) / 255, e
				}

				function ot(t) {
					var e = t.toString(16);
					return "#" + ("000000".substr(0, 6 - e.length) + e)
				}

				function rt(t) {
					return "string" == typeof t && "#" === t[0] && (t = t.substr(1)), parseInt(t, 16)
				}

				function at(t) {
					return (255 * t[0] << 16) + (255 * t[1] << 8) + (255 * t[2] | 0)
				}
				var lt = function() {
					for (var t = [], e = [], i = 0; i < 32; i++) t[i] = i, e[i] = i;
					t[m.NORMAL_NPM] = m.NORMAL, t[m.ADD_NPM] = m.ADD, t[m.SCREEN_NPM] = m.SCREEN, e[m.NORMAL] = m.NORMAL_NPM, e[m.ADD] = m.ADD_NPM, e[m.SCREEN] = m.SCREEN_NPM;
					var n = [];
					return n.push(e), n.push(t), n
				}();

				function ht(t, e) {
					return lt[e ? 1 : 0][t]
				}

				function ut(t, e, i, n) {
					return i = i || new Float32Array(4), n || void 0 === n ? (i[0] = t[0] * e, i[1] = t[1] * e, i[2] = t[2] * e) : (i[0] = t[0], i[1] = t[1], i[2] = t[2]), i[3] = e, i
				}

				function ct(t, e) {
					if (1 === e) return (255 * e << 24) + t;
					if (0 === e) return 0;
					var i = t >> 16 & 255,
						n = t >> 8 & 255,
						s = 255 & t;
					return (255 * e << 24) + ((i = i * e + .5 | 0) << 16) + ((n = n * e + .5 | 0) << 8) + (s * e + .5 | 0)
				}

				function dt(t, e, i, n) {
					return (i = i || new Float32Array(4))[0] = (t >> 16 & 255) / 255, i[1] = (t >> 8 & 255) / 255, i[2] = (255 & t) / 255, (n || void 0 === n) && (i[0] *= e, i[1] *= e, i[2] *= e), i[3] = e, i
				}

				function pt(t, e) {
					void 0 === e && (e = null);
					var i = 6 * t;
					if ((e = e || new Uint16Array(i)).length !== i) throw new Error("Out buffer length is incorrect, got " + e.length + " and expected " + i);
					for (var n = 0, s = 0; n < i; n += 6, s += 4) e[n + 0] = s + 0, e[n + 1] = s + 1, e[n + 2] = s + 2, e[n + 3] = s + 0, e[n + 4] = s + 2, e[n + 5] = s + 3;
					return e
				}

				function _t(t) {
					if (4 === t.BYTES_PER_ELEMENT) return t instanceof Float32Array ? "Float32Array" : t instanceof Uint32Array ? "Uint32Array" : "Int32Array";
					if (2 === t.BYTES_PER_ELEMENT) {
						if (t instanceof Uint16Array) return "Uint16Array"
					} else if (1 === t.BYTES_PER_ELEMENT && t instanceof Uint8Array) return "Uint8Array";
					return null
				}
				var mt = {
					Float32Array,
					Uint32Array,
					Int32Array,
					Uint8Array
				};

				function gt(t, e) {
					for (var i = 0, n = 0, s = {}, o = 0; o < t.length; o++) n += e[o], i += t[o].length;
					var r = new ArrayBuffer(4 * i),
						a = null,
						l = 0;
					for (o = 0; o < t.length; o++) {
						var h = e[o],
							u = t[o],
							c = _t(u);
						s[c] || (s[c] = new mt[c](r)), a = s[c];
						for (var d = 0; d < u.length; d++) a[(d / h | 0) * n + l + d % h] = u[d];
						l += h
					}
					return new Float32Array(r)
				}

				function ft(t) {
					return t += 0 === t ? 1 : 0, --t, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, 1 + (t |= t >>> 16)
				}

				function St(t) {
					return !(t & t - 1 || !t)
				}

				function yt(t) {
					var e = (t > 65535 ? 1 : 0) << 4,
						i = ((t >>>= e) > 255 ? 1 : 0) << 3;
					return e |= i, e |= i = ((t >>>= i) > 15 ? 1 : 0) << 2, (e |= i = ((t >>>= i) > 3 ? 1 : 0) << 1) | (t >>>= i) >> 1
				}

				function vt(t, e, i) {
					var n, s = t.length;
					if (!(e >= s || 0 === i)) {
						var o = s - (i = e + i > s ? s - e : i);
						for (n = e; n < o; ++n) t[n] = t[n + i];
						t.length = o
					}
				}

				function Tt(t) {
					return 0 === t ? 0 : t < 0 ? -1 : 1
				}
				var Et = 0;

				function bt() {
					return ++Et
				}
				var At = {};

				function Pt(t, e, i) {
					if (void 0 === i && (i = 3), !At[e]) {
						var n = (new Error).stack;
						void 0 === n ? console.warn("PixiJS Deprecation Warning: ", e + "\nDeprecated since v" + t) : (n = n.split("\n").splice(i).join("\n"), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", e + "\nDeprecated since v" + t), console.warn(n), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", e + "\nDeprecated since v" + t), console.warn(n))), At[e] = !0
					}
				}
				var It = {},
					wt = Object.create(null),
					Lt = Object.create(null);

				function Ct() {
					var t;
					for (t in wt) wt[t].destroy();
					for (t in Lt) Lt[t].destroy()
				}

				function xt() {
					var t;
					for (t in wt) delete wt[t];
					for (t in Lt) delete Lt[t]
				}
				var Bt = function() {
					function t(t, e, i) {
						this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), this.resolution = i || z.RESOLUTION, this.resize(t, e)
					}
					return t.prototype.clear = function() {
						this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
					}, t.prototype.resize = function(t, e) {
						this.canvas.width = t * this.resolution, this.canvas.height = e * this.resolution
					}, t.prototype.destroy = function() {
						this.context = null, this.canvas = null
					}, Object.defineProperty(t.prototype, "width", {
						get: function() {
							return this.canvas.width
						},
						set: function(t) {
							this.canvas.width = t
						},
						enumerable: !1,
						configurable: !0
					}), Object.defineProperty(t.prototype, "height", {
						get: function() {
							return this.canvas.height
						},
						set: function(t) {
							this.canvas.height = t
						},
						enumerable: !1,
						configurable: !0
					}), t
				}();

				function Ot(t) {
					var e, i, n, s = t.width,
						o = t.height,
						r = t.getContext("2d"),
						a = r.getImageData(0, 0, s, o).data,
						l = a.length,
						h = {
							top: null,
							left: null,
							right: null,
							bottom: null
						},
						u = null;
					for (e = 0; e < l; e += 4) 0 !== a[e + 3] && (i = e / 4 % s, n = ~~(e / 4 / s), null === h.top && (h.top = n), (null === h.left || i < h.left) && (h.left = i), (null === h.right || h.right < i) && (h.right = i + 1), (null === h.bottom || h.bottom < n) && (h.bottom = n));
					return null !== h.top && (s = h.right - h.left, o = h.bottom - h.top + 1, u = r.getImageData(h.left, h.top, s, o)), {
						height: o,
						width: s,
						data: u
					}
				}
				var Nt, Mt = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;

				function Rt(t) {
					var e = Mt.exec(t);
					if (e) return {
						mediaType: e[1] ? e[1].toLowerCase() : void 0,
						subType: e[2] ? e[2].toLowerCase() : void 0,
						charset: e[3] ? e[3].toLowerCase() : void 0,
						encoding: e[4] ? e[4].toLowerCase() : void 0,
						data: e[5]
					}
				}

				function Dt(t, e) {
					if (void 0 === e && (e = window.location), 0 === t.indexOf("data:")) return "";
					e = e || window.location, Nt || (Nt = document.createElement("a")), Nt.href = t;
					var i = (0, $.parse)(Nt.href),
						n = !i.port && "" === e.port || i.port === e.port;
					return i.hostname === e.hostname && n && i.protocol === e.protocol ? "" : "anonymous"
				}

				function kt(t, e) {
					var i = z.RETINA_PREFIX.exec(t);
					return i ? parseFloat(i[1]) : void 0 !== e ? e : 1
				}
				var Ft, Gt = 2 * Math.PI,
					Ut = 180 / Math.PI,
					Wt = Math.PI / 180;
				! function(t) {
					t[t.POLY = 0] = "POLY", t[t.RECT = 1] = "RECT", t[t.CIRC = 2] = "CIRC", t[t.ELIP = 3] = "ELIP", t[t.RREC = 4] = "RREC"
				}(Ft || (Ft = {}));
				var Ht = function() {
						function t(t, e, i, n) {
							void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x = Number(t), this.y = Number(e), this.width = Number(i), this.height = Number(n), this.type = Ft.RECT
						}
						return Object.defineProperty(t.prototype, "left", {
							get: function() {
								return this.x
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "right", {
							get: function() {
								return this.x + this.width
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "top", {
							get: function() {
								return this.y
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "bottom", {
							get: function() {
								return this.y + this.height
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t, "EMPTY", {
							get: function() {
								return new t(0, 0, 0, 0)
							},
							enumerable: !1,
							configurable: !0
						}), t.prototype.clone = function() {
							return new t(this.x, this.y, this.width, this.height)
						}, t.prototype.copyFrom = function(t) {
							return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this
						}, t.prototype.copyTo = function(t) {
							return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
						}, t.prototype.contains = function(t, e) {
							return !(this.width <= 0 || this.height <= 0) && t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height
						}, t.prototype.pad = function(t, e) {
							return void 0 === t && (t = 0), void 0 === e && (e = t), this.x -= t, this.y -= e, this.width += 2 * t, this.height += 2 * e, this
						}, t.prototype.fit = function(t) {
							var e = Math.max(this.x, t.x),
								i = Math.min(this.x + this.width, t.x + t.width),
								n = Math.max(this.y, t.y),
								s = Math.min(this.y + this.height, t.y + t.height);
							return this.x = e, this.width = Math.max(i - e, 0), this.y = n, this.height = Math.max(s - n, 0), this
						}, t.prototype.ceil = function(t, e) {
							void 0 === t && (t = 1), void 0 === e && (e = .001);
							var i = Math.ceil((this.x + this.width - e) * t) / t,
								n = Math.ceil((this.y + this.height - e) * t) / t;
							return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = i - this.x, this.height = n - this.y, this
						}, t.prototype.enlarge = function(t) {
							var e = Math.min(this.x, t.x),
								i = Math.max(this.x + this.width, t.x + t.width),
								n = Math.min(this.y, t.y),
								s = Math.max(this.y + this.height, t.y + t.height);
							return this.x = e, this.width = i - e, this.y = n, this.height = s - n, this
						}, t
					}(),
					Vt = function() {
						function t(t, e, i) {
							void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), this.x = t, this.y = e, this.radius = i, this.type = Ft.CIRC
						}
						return t.prototype.clone = function() {
							return new t(this.x, this.y, this.radius)
						}, t.prototype.contains = function(t, e) {
							if (this.radius <= 0) return !1;
							var i = this.radius * this.radius,
								n = this.x - t,
								s = this.y - e;
							return (n *= n) + (s *= s) <= i
						}, t.prototype.getBounds = function() {
							return new Ht(this.x - this.radius, this.y - this.radius, 2 * this.radius, 2 * this.radius)
						}, t
					}(),
					Xt = function() {
						function t(t, e, i, n) {
							void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x = t, this.y = e, this.width = i, this.height = n, this.type = Ft.ELIP
						}
						return t.prototype.clone = function() {
							return new t(this.x, this.y, this.width, this.height)
						}, t.prototype.contains = function(t, e) {
							if (this.width <= 0 || this.height <= 0) return !1;
							var i = (t - this.x) / this.width,
								n = (e - this.y) / this.height;
							return (i *= i) + (n *= n) <= 1
						}, t.prototype.getBounds = function() {
							return new Ht(this.x - this.width, this.y - this.height, this.width, this.height)
						}, t
					}(),
					Yt = function() {
						function t() {
							for (var t = arguments, e = [], i = 0; i < arguments.length; i++) e[i] = t[i];
							var n = Array.isArray(e[0]) ? e[0] : e;
							if ("number" != typeof n[0]) {
								for (var s = [], o = 0, r = n.length; o < r; o++) s.push(n[o].x, n[o].y);
								n = s
							}
							this.points = n, this.type = Ft.POLY, this.closeStroke = !0
						}
						return t.prototype.clone = function() {
							var e = new t(this.points.slice());
							return e.closeStroke = this.closeStroke, e
						}, t.prototype.contains = function(t, e) {
							for (var i = !1, n = this.points.length / 2, s = 0, o = n - 1; s < n; o = s++) {
								var r = this.points[2 * s],
									a = this.points[2 * s + 1],
									l = this.points[2 * o],
									h = this.points[2 * o + 1];
								a > e != h > e && t < (e - a) / (h - a) * (l - r) + r && (i = !i)
							}
							return i
						}, t
					}(),
					zt = function() {
						function t(t, e, i, n, s) {
							void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 20), this.x = t, this.y = e, this.width = i, this.height = n, this.radius = s, this.type = Ft.RREC
						}
						return t.prototype.clone = function() {
							return new t(this.x, this.y, this.width, this.height, this.radius)
						}, t.prototype.contains = function(t, e) {
							if (this.width <= 0 || this.height <= 0) return !1;
							if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
								if (e >= this.y + this.radius && e <= this.y + this.height - this.radius || t >= this.x + this.radius && t <= this.x + this.width - this.radius) return !0;
								var i = t - (this.x + this.radius),
									n = e - (this.y + this.radius),
									s = this.radius * this.radius;
								if (i * i + n * n <= s) return !0;
								if ((i = t - (this.x + this.width - this.radius)) * i + n * n <= s) return !0;
								if (i * i + (n = e - (this.y + this.height - this.radius)) * n <= s) return !0;
								if ((i = t - (this.x + this.radius)) * i + n * n <= s) return !0
							}
							return !1
						}, t
					}(),
					jt = function() {
						function t(t, e) {
							void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = t, this.y = e
						}
						return t.prototype.clone = function() {
							return new t(this.x, this.y)
						}, t.prototype.copyFrom = function(t) {
							return this.set(t.x, t.y), this
						}, t.prototype.copyTo = function(t) {
							return t.set(this.x, this.y), t
						}, t.prototype.equals = function(t) {
							return t.x === this.x && t.y === this.y
						}, t.prototype.set = function(t, e) {
							return void 0 === t && (t = 0), void 0 === e && (e = t), this.x = t, this.y = e, this
						}, t
					}(),
					Kt = function() {
						function t(t, e, i, n) {
							void 0 === i && (i = 0), void 0 === n && (n = 0), this._x = i, this._y = n, this.cb = t, this.scope = e
						}
						return t.prototype.clone = function(e, i) {
							return void 0 === e && (e = this.cb), void 0 === i && (i = this.scope), new t(e, i, this._x, this._y)
						}, t.prototype.set = function(t, e) {
							return void 0 === t && (t = 0), void 0 === e && (e = t), this._x === t && this._y === e || (this._x = t, this._y = e, this.cb.call(this.scope)), this
						}, t.prototype.copyFrom = function(t) {
							return this._x === t.x && this._y === t.y || (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this
						}, t.prototype.copyTo = function(t) {
							return t.set(this._x, this._y), t
						}, t.prototype.equals = function(t) {
							return t.x === this._x && t.y === this._y
						}, Object.defineProperty(t.prototype, "x", {
							get: function() {
								return this._x
							},
							set: function(t) {
								this._x !== t && (this._x = t, this.cb.call(this.scope))
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "y", {
							get: function() {
								return this._y
							},
							set: function(t) {
								this._y !== t && (this._y = t, this.cb.call(this.scope))
							},
							enumerable: !1,
							configurable: !0
						}), t
					}(),
					qt = function() {
						function t(t, e, i, n, s, o) {
							void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 1), void 0 === s && (s = 0), void 0 === o && (o = 0), this.array = null, this.a = t, this.b = e, this.c = i, this.d = n, this.tx = s, this.ty = o
						}
						return t.prototype.fromArray = function(t) {
							this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5]
						}, t.prototype.set = function(t, e, i, n, s, o) {
							return this.a = t, this.b = e, this.c = i, this.d = n, this.tx = s, this.ty = o, this
						}, t.prototype.toArray = function(t, e) {
							this.array || (this.array = new Float32Array(9));
							var i = e || this.array;
							return t ? (i[0] = this.a, i[1] = this.b, i[2] = 0, i[3] = this.c, i[4] = this.d, i[5] = 0, i[6] = this.tx, i[7] = this.ty, i[8] = 1) : (i[0] = this.a, i[1] = this.c, i[2] = this.tx, i[3] = this.b, i[4] = this.d, i[5] = this.ty, i[6] = 0, i[7] = 0, i[8] = 1), i
						}, t.prototype.apply = function(t, e) {
							e = e || new jt;
							var i = t.x,
								n = t.y;
							return e.x = this.a * i + this.c * n + this.tx, e.y = this.b * i + this.d * n + this.ty, e
						}, t.prototype.applyInverse = function(t, e) {
							e = e || new jt;
							var i = 1 / (this.a * this.d + this.c * -this.b),
								n = t.x,
								s = t.y;
							return e.x = this.d * i * n + -this.c * i * s + (this.ty * this.c - this.tx * this.d) * i, e.y = this.a * i * s + -this.b * i * n + (-this.ty * this.a + this.tx * this.b) * i, e
						}, t.prototype.translate = function(t, e) {
							return this.tx += t, this.ty += e, this
						}, t.prototype.scale = function(t, e) {
							return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this
						}, t.prototype.rotate = function(t) {
							var e = Math.cos(t),
								i = Math.sin(t),
								n = this.a,
								s = this.c,
								o = this.tx;
							return this.a = n * e - this.b * i, this.b = n * i + this.b * e, this.c = s * e - this.d * i, this.d = s * i + this.d * e, this.tx = o * e - this.ty * i, this.ty = o * i + this.ty * e, this
						}, t.prototype.append = function(t) {
							var e = this.a,
								i = this.b,
								n = this.c,
								s = this.d;
							return this.a = t.a * e + t.b * n, this.b = t.a * i + t.b * s, this.c = t.c * e + t.d * n, this.d = t.c * i + t.d * s, this.tx = t.tx * e + t.ty * n + this.tx, this.ty = t.tx * i + t.ty * s + this.ty, this
						}, t.prototype.setTransform = function(t, e, i, n, s, o, r, a, l) {
							return this.a = Math.cos(r + l) * s, this.b = Math.sin(r + l) * s, this.c = -Math.sin(r - a) * o, this.d = Math.cos(r - a) * o, this.tx = t - (i * this.a + n * this.c), this.ty = e - (i * this.b + n * this.d), this
						}, t.prototype.prepend = function(t) {
							var e = this.tx;
							if (1 !== t.a || 0 !== t.b || 0 !== t.c || 1 !== t.d) {
								var i = this.a,
									n = this.c;
								this.a = i * t.a + this.b * t.c, this.b = i * t.b + this.b * t.d, this.c = n * t.a + this.d * t.c, this.d = n * t.b + this.d * t.d
							}
							return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this
						}, t.prototype.decompose = function(t) {
							var e = this.a,
								i = this.b,
								n = this.c,
								s = this.d,
								o = -Math.atan2(-n, s),
								r = Math.atan2(i, e),
								a = Math.abs(o + r);
							return a < 1e-5 || Math.abs(Gt - a) < 1e-5 ? (t.rotation = r, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = o, t.skew.y = r), t.scale.x = Math.sqrt(e * e + i * i), t.scale.y = Math.sqrt(n * n + s * s), t.position.x = this.tx, t.position.y = this.ty, t
						}, t.prototype.invert = function() {
							var t = this.a,
								e = this.b,
								i = this.c,
								n = this.d,
								s = this.tx,
								o = t * n - e * i;
							return this.a = n / o, this.b = -e / o, this.c = -i / o, this.d = t / o, this.tx = (i * this.ty - n * s) / o, this.ty = -(t * this.ty - e * s) / o, this
						}, t.prototype.identity = function() {
							return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this
						}, t.prototype.clone = function() {
							var e = new t;
							return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e
						}, t.prototype.copyTo = function(t) {
							return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t
						}, t.prototype.copyFrom = function(t) {
							return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
						}, Object.defineProperty(t, "IDENTITY", {
							get: function() {
								return new t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t, "TEMP_MATRIX", {
							get: function() {
								return new t
							},
							enumerable: !1,
							configurable: !0
						}), t
					}(),
					Zt = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
					$t = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
					Qt = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
					Jt = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
					te = [],
					ee = [],
					ie = Math.sign;
				! function() {
					for (var t = 0; t < 16; t++) {
						var e = [];
						te.push(e);
						for (var i = 0; i < 16; i++)
							for (var n = ie(Zt[t] * Zt[i] + Qt[t] * $t[i]), s = ie($t[t] * Zt[i] + Jt[t] * $t[i]), o = ie(Zt[t] * Qt[i] + Qt[t] * Jt[i]), r = ie($t[t] * Qt[i] + Jt[t] * Jt[i]), a = 0; a < 16; a++)
								if (Zt[a] === n && $t[a] === s && Qt[a] === o && Jt[a] === r) {
									e.push(a);
									break
								}
					}
					for (t = 0; t < 16; t++) {
						var l = new qt;
						l.set(Zt[t], $t[t], Qt[t], Jt[t], 0, 0), ee.push(l)
					}
				}();
				var ne = {
						E: 0,
						SE: 1,
						S: 2,
						SW: 3,
						W: 4,
						NW: 5,
						N: 6,
						NE: 7,
						MIRROR_VERTICAL: 8,
						MAIN_DIAGONAL: 10,
						MIRROR_HORIZONTAL: 12,
						REVERSE_DIAGONAL: 14,
						uX: function(t) {
							return Zt[t]
						},
						uY: function(t) {
							return $t[t]
						},
						vX: function(t) {
							return Qt[t]
						},
						vY: function(t) {
							return Jt[t]
						},
						inv: function(t) {
							return 8 & t ? 15 & t : 7 & -t
						},
						add: function(t, e) {
							return te[t][e]
						},
						sub: function(t, e) {
							return te[t][ne.inv(e)]
						},
						rotate180: function(t) {
							return 4 ^ t
						},
						isVertical: function(t) {
							return 2 == (3 & t)
						},
						byDirection: function(t, e) {
							return 2 * Math.abs(t) <= Math.abs(e) ? e >= 0 ? ne.S : ne.N : 2 * Math.abs(e) <= Math.abs(t) ? t > 0 ? ne.E : ne.W : e > 0 ? t > 0 ? ne.SE : ne.SW : t > 0 ? ne.NE : ne.NW
						},
						matrixAppendRotationInv: function(t, e, i, n) {
							void 0 === i && (i = 0), void 0 === n && (n = 0);
							var s = ee[ne.inv(e)];
							s.tx = i, s.ty = n, t.append(s)
						}
					},
					se = function() {
						function t() {
							this.worldTransform = new qt, this.localTransform = new qt, this.position = new Kt(this.onChange, this, 0, 0), this.scale = new Kt(this.onChange, this, 1, 1), this.pivot = new Kt(this.onChange, this, 0, 0), this.skew = new Kt(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0
						}
						return t.prototype.onChange = function() {
							this._localID++
						}, t.prototype.updateSkew = function() {
							this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++
						}, t.prototype.updateLocalTransform = function() {
							var t = this.localTransform;
							this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1)
						}, t.prototype.updateTransform = function(t) {
							var e = this.localTransform;
							if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t._worldID) {
								var i = t.worldTransform,
									n = this.worldTransform;
								n.a = e.a * i.a + e.b * i.c, n.b = e.a * i.b + e.b * i.d, n.c = e.c * i.a + e.d * i.c, n.d = e.c * i.b + e.d * i.d, n.tx = e.tx * i.a + e.ty * i.c + i.tx, n.ty = e.tx * i.b + e.ty * i.d + i.ty, this._parentID = t._worldID, this._worldID++
							}
						}, t.prototype.setFromMatrix = function(t) {
							t.decompose(this), this._localID++
						}, Object.defineProperty(t.prototype, "rotation", {
							get: function() {
								return this._rotation
							},
							set: function(t) {
								this._rotation !== t && (this._rotation = t, this.updateSkew())
							},
							enumerable: !1,
							configurable: !0
						}), t.IDENTITY = new t, t
					}();
				z.SORTABLE_CHILDREN = !1;
				var oe = function() {
						function t() {
							this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1
						}
						return t.prototype.isEmpty = function() {
							return this.minX > this.maxX || this.minY > this.maxY
						}, t.prototype.clear = function() {
							this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0
						}, t.prototype.getRectangle = function(t) {
							return this.minX > this.maxX || this.minY > this.maxY ? Ht.EMPTY : ((t = t || new Ht(0, 0, 1, 1)).x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t)
						}, t.prototype.addPoint = function(t) {
							this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y)
						}, t.prototype.addQuad = function(t) {
							var e = this.minX,
								i = this.minY,
								n = this.maxX,
								s = this.maxY,
								o = t[0],
								r = t[1];
							e = o < e ? o : e, i = r < i ? r : i, n = o > n ? o : n, s = r > s ? r : s, e = (o = t[2]) < e ? o : e, i = (r = t[3]) < i ? r : i, n = o > n ? o : n, s = r > s ? r : s, e = (o = t[4]) < e ? o : e, i = (r = t[5]) < i ? r : i, n = o > n ? o : n, s = r > s ? r : s, e = (o = t[6]) < e ? o : e, i = (r = t[7]) < i ? r : i, n = o > n ? o : n, s = r > s ? r : s, this.minX = e, this.minY = i, this.maxX = n, this.maxY = s
						}, t.prototype.addFrame = function(t, e, i, n, s) {
							this.addFrameMatrix(t.worldTransform, e, i, n, s)
						}, t.prototype.addFrameMatrix = function(t, e, i, n, s) {
							var o = t.a,
								r = t.b,
								a = t.c,
								l = t.d,
								h = t.tx,
								u = t.ty,
								c = this.minX,
								d = this.minY,
								p = this.maxX,
								_ = this.maxY,
								m = o * e + a * i + h,
								g = r * e + l * i + u;
							c = m < c ? m : c, d = g < d ? g : d, p = m > p ? m : p, _ = g > _ ? g : _, c = (m = o * n + a * i + h) < c ? m : c, d = (g = r * n + l * i + u) < d ? g : d, p = m > p ? m : p, _ = g > _ ? g : _, c = (m = o * e + a * s + h) < c ? m : c, d = (g = r * e + l * s + u) < d ? g : d, p = m > p ? m : p, _ = g > _ ? g : _, c = (m = o * n + a * s + h) < c ? m : c, d = (g = r * n + l * s + u) < d ? g : d, p = m > p ? m : p, _ = g > _ ? g : _, this.minX = c, this.minY = d, this.maxX = p, this.maxY = _
						}, t.prototype.addVertexData = function(t, e, i) {
							for (var n = this.minX, s = this.minY, o = this.maxX, r = this.maxY, a = e; a < i; a += 2) {
								var l = t[a],
									h = t[a + 1];
								n = l < n ? l : n, s = h < s ? h : s, o = l > o ? l : o, r = h > r ? h : r
							}
							this.minX = n, this.minY = s, this.maxX = o, this.maxY = r
						}, t.prototype.addVertices = function(t, e, i, n) {
							this.addVerticesMatrix(t.worldTransform, e, i, n)
						}, t.prototype.addVerticesMatrix = function(t, e, i, n, s, o) {
							void 0 === s && (s = 0), void 0 === o && (o = s);
							for (var r = t.a, a = t.b, l = t.c, h = t.d, u = t.tx, c = t.ty, d = this.minX, p = this.minY, _ = this.maxX, m = this.maxY, g = i; g < n; g += 2) {
								var f = e[g],
									S = e[g + 1],
									y = r * f + l * S + u,
									v = h * S + a * f + c;
								d = Math.min(d, y - s), _ = Math.max(_, y + s), p = Math.min(p, v - o), m = Math.max(m, v + o)
							}
							this.minX = d, this.minY = p, this.maxX = _, this.maxY = m
						}, t.prototype.addBounds = function(t) {
							var e = this.minX,
								i = this.minY,
								n = this.maxX,
								s = this.maxY;
							this.minX = t.minX < e ? t.minX : e, this.minY = t.minY < i ? t.minY : i, this.maxX = t.maxX > n ? t.maxX : n, this.maxY = t.maxY > s ? t.maxY : s
						}, t.prototype.addBoundsMask = function(t, e) {
							var i = t.minX > e.minX ? t.minX : e.minX,
								n = t.minY > e.minY ? t.minY : e.minY,
								s = t.maxX < e.maxX ? t.maxX : e.maxX,
								o = t.maxY < e.maxY ? t.maxY : e.maxY;
							if (i <= s && n <= o) {
								var r = this.minX,
									a = this.minY,
									l = this.maxX,
									h = this.maxY;
								this.minX = i < r ? i : r, this.minY = n < a ? n : a, this.maxX = s > l ? s : l, this.maxY = o > h ? o : h
							}
						}, t.prototype.addBoundsMatrix = function(t, e) {
							this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY)
						}, t.prototype.addBoundsArea = function(t, e) {
							var i = t.minX > e.x ? t.minX : e.x,
								n = t.minY > e.y ? t.minY : e.y,
								s = t.maxX < e.x + e.width ? t.maxX : e.x + e.width,
								o = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;
							if (i <= s && n <= o) {
								var r = this.minX,
									a = this.minY,
									l = this.maxX,
									h = this.maxY;
								this.minX = i < r ? i : r, this.minY = n < a ? n : a, this.maxX = s > l ? s : l, this.maxY = o > h ? o : h
							}
						}, t.prototype.pad = function(t, e) {
							void 0 === t && (t = 0), void 0 === e && (e = t), this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e)
						}, t.prototype.addFramePad = function(t, e, i, n, s, o) {
							t -= s, e -= o, i += s, n += o, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > i ? this.maxX : i, this.minY = this.minY < e ? this.minY : e, this.maxY = this.maxY > n ? this.maxY : n
						}, t
					}(),
					re = function(t, e) {
						return re = Object.setPrototypeOf || {
							__proto__: []
						}
						instanceof Array && function(t, e) {
							t.__proto__ = e
						} || function(t, e) {
							for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
						}, re(t, e)
					};

				function ae(t, e) {
					function i() {
						this.constructor = t
					}
					re(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
				}
				var le = function(t) {
						function e() {
							var e = t.call(this) || this;
							return e.tempDisplayObjectParent = null, e.transform = new se, e.alpha = 1, e.visible = !0, e.renderable = !0, e.parent = null, e.worldAlpha = 1, e._lastSortedIndex = 0, e._zIndex = 0, e.filterArea = null, e.filters = null, e._enabledFilters = null, e._bounds = new oe, e._localBounds = null, e._boundsID = 0, e._boundsRect = null, e._localBoundsRect = null, e._mask = null, e._destroyed = !1, e.isSprite = !1, e.isMask = !1, e
						}
						return ae(e, t), e.mixin = function(t) {
							for (var i = Object.keys(t), n = 0; n < i.length; ++n) {
								var s = i[n];
								Object.defineProperty(e.prototype, s, Object.getOwnPropertyDescriptor(t, s))
							}
						}, e.prototype._recursivePostUpdateTransform = function() {
							this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform)
						}, e.prototype.updateTransform = function() {
							this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha
						}, e.prototype.getBounds = function(t, e) {
							return t || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), e || (this._boundsRect || (this._boundsRect = new Ht), e = this._boundsRect), this._bounds.getRectangle(e)
						}, e.prototype.getLocalBounds = function(t) {
							t || (this._localBoundsRect || (this._localBoundsRect = new Ht), t = this._localBoundsRect), this._localBounds || (this._localBounds = new oe);
							var e = this.transform,
								i = this.parent;
							this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
							var n = this._bounds,
								s = this._boundsID;
							this._bounds = this._localBounds;
							var o = this.getBounds(!1, t);
							return this.parent = i, this.transform = e, this._bounds = n, this._bounds.updateID += this._boundsID - s, o
						}, e.prototype.toGlobal = function(t, e, i) {
							return void 0 === i && (i = !1), i || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(t, e)
						}, e.prototype.toLocal = function(t, e, i, n) {
							return e && (t = e.toGlobal(t, i, n)), n || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(t, i)
						}, e.prototype.setParent = function(t) {
							if (!t || !t.addChild) throw new Error("setParent: Argument must be a Container");
							return t.addChild(this), t
						}, e.prototype.setTransform = function(t, e, i, n, s, o, r, a, l) {
							return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 1), void 0 === n && (n = 1), void 0 === s && (s = 0), void 0 === o && (o = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === l && (l = 0), this.position.x = t, this.position.y = e, this.scale.x = i || 1, this.scale.y = n || 1, this.rotation = s, this.skew.x = o, this.skew.y = r, this.pivot.x = a, this.pivot.y = l, this
						}, e.prototype.destroy = function(t) {
							this.parent && this.parent.removeChild(this), this.removeAllListeners(), this.transform = null, this.parent = null, this._bounds = null, this._mask = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this._destroyed = !0
						}, Object.defineProperty(e.prototype, "_tempDisplayObjectParent", {
							get: function() {
								return null === this.tempDisplayObjectParent && (this.tempDisplayObjectParent = new he), this.tempDisplayObjectParent
							},
							enumerable: !1,
							configurable: !0
						}), e.prototype.enableTempParent = function() {
							var t = this.parent;
							return this.parent = this._tempDisplayObjectParent, t
						}, e.prototype.disableTempParent = function(t) {
							this.parent = t
						}, Object.defineProperty(e.prototype, "x", {
							get: function() {
								return this.position.x
							},
							set: function(t) {
								this.transform.position.x = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "y", {
							get: function() {
								return this.position.y
							},
							set: function(t) {
								this.transform.position.y = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "worldTransform", {
							get: function() {
								return this.transform.worldTransform
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "localTransform", {
							get: function() {
								return this.transform.localTransform
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "position", {
							get: function() {
								return this.transform.position
							},
							set: function(t) {
								this.transform.position.copyFrom(t)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "scale", {
							get: function() {
								return this.transform.scale
							},
							set: function(t) {
								this.transform.scale.copyFrom(t)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "pivot", {
							get: function() {
								return this.transform.pivot
							},
							set: function(t) {
								this.transform.pivot.copyFrom(t)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "skew", {
							get: function() {
								return this.transform.skew
							},
							set: function(t) {
								this.transform.skew.copyFrom(t)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "rotation", {
							get: function() {
								return this.transform.rotation
							},
							set: function(t) {
								this.transform.rotation = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "angle", {
							get: function() {
								return this.transform.rotation * Ut
							},
							set: function(t) {
								this.transform.rotation = t * Wt
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "zIndex", {
							get: function() {
								return this._zIndex
							},
							set: function(t) {
								this._zIndex = t, this.parent && (this.parent.sortDirty = !0)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "worldVisible", {
							get: function() {
								var t = this;
								do {
									if (!t.visible) return !1;
									t = t.parent
								} while (t);
								return !0
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "mask", {
							get: function() {
								return this._mask
							},
							set: function(t) {
								var e;
								this._mask && ((e = this._mask.maskObject || this._mask).renderable = !0, e.isMask = !1), this._mask = t, this._mask && ((e = this._mask.maskObject || this._mask).renderable = !1, e.isMask = !0)
							},
							enumerable: !1,
							configurable: !0
						}), e
					}(K()),
					he = function(t) {
						function e() {
							var e = null !== t && t.apply(this, arguments) || this;
							return e.sortDirty = null, e
						}
						return ae(e, t), e
					}(le);

				function ue(t, e) {
					return t.zIndex === e.zIndex ? t._lastSortedIndex - e._lastSortedIndex : t.zIndex - e.zIndex
				}
				le.prototype.displayObjectUpdateTransform = le.prototype.updateTransform;
				var ce = function(t) {
					function e() {
						var e = t.call(this) || this;
						return e.children = [], e.sortableChildren = z.SORTABLE_CHILDREN, e.sortDirty = !1, e
					}
					return ae(e, t), e.prototype.onChildrenChange = function(t) {}, e.prototype.addChild = function() {
						for (var t = arguments, e = [], i = 0; i < arguments.length; i++) e[i] = t[i];
						if (e.length > 1)
							for (var n = 0; n < e.length; n++) this.addChild(e[n]);
						else {
							var s = e[0];
							s.parent && s.parent.removeChild(s), s.parent = this, this.sortDirty = !0, s.transform._parentID = -1, this.children.push(s), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", s, this, this.children.length - 1), s.emit("added", this)
						}
						return e[0]
					}, e.prototype.addChildAt = function(t, e) {
						if (e < 0 || e > this.children.length) throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length);
						return t.parent && t.parent.removeChild(t), t.parent = this, this.sortDirty = !0, t.transform._parentID = -1, this.children.splice(e, 0, t), this._boundsID++, this.onChildrenChange(e), t.emit("added", this), this.emit("childAdded", t, this, e), t
					}, e.prototype.swapChildren = function(t, e) {
						if (t !== e) {
							var i = this.getChildIndex(t),
								n = this.getChildIndex(e);
							this.children[i] = e, this.children[n] = t, this.onChildrenChange(i < n ? i : n)
						}
					}, e.prototype.getChildIndex = function(t) {
						var e = this.children.indexOf(t);
						if (-1 === e) throw new Error("The supplied DisplayObject must be a child of the caller");
						return e
					}, e.prototype.setChildIndex = function(t, e) {
						if (e < 0 || e >= this.children.length) throw new Error("The index " + e + " supplied is out of bounds " + this.children.length);
						var i = this.getChildIndex(t);
						vt(this.children, i, 1), this.children.splice(e, 0, t), this.onChildrenChange(e)
					}, e.prototype.getChildAt = function(t) {
						if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Index (" + t + ") does not exist.");
						return this.children[t]
					}, e.prototype.removeChild = function() {
						for (var t = arguments, e = [], i = 0; i < arguments.length; i++) e[i] = t[i];
						if (e.length > 1)
							for (var n = 0; n < e.length; n++) this.removeChild(e[n]);
						else {
							var s = e[0],
								o = this.children.indexOf(s);
							if (-1 === o) return null;
							s.parent = null, s.transform._parentID = -1, vt(this.children, o, 1), this._boundsID++, this.onChildrenChange(o), s.emit("removed", this), this.emit("childRemoved", s, this, o)
						}
						return e[0]
					}, e.prototype.removeChildAt = function(t) {
						var e = this.getChildAt(t);
						return e.parent = null, e.transform._parentID = -1, vt(this.children, t, 1), this._boundsID++, this.onChildrenChange(t), e.emit("removed", this), this.emit("childRemoved", e, this, t), e
					}, e.prototype.removeChildren = function(t, e) {
						void 0 === t && (t = 0), void 0 === e && (e = this.children.length);
						var i, n = t,
							s = e - n;
						if (s > 0 && s <= e) {
							i = this.children.splice(n, s);
							for (var o = 0; o < i.length; ++o) i[o].parent = null, i[o].transform && (i[o].transform._parentID = -1);
							for (this._boundsID++, this.onChildrenChange(t), o = 0; o < i.length; ++o) i[o].emit("removed", this), this.emit("childRemoved", i[o], this, o);
							return i
						}
						if (0 === s && 0 === this.children.length) return [];
						throw new RangeError("removeChildren: numeric values are outside the acceptable range.")
					}, e.prototype.sortChildren = function() {
						for (var t = !1, e = 0, i = this.children.length; e < i; ++e) {
							var n = this.children[e];
							n._lastSortedIndex = e, t || 0 === n.zIndex || (t = !0)
						}
						t && this.children.length > 1 && this.children.sort(ue), this.sortDirty = !1
					}, e.prototype.updateTransform = function() {
						this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
						for (var t = 0, e = this.children.length; t < e; ++t) {
							var i = this.children[t];
							i.visible && i.updateTransform()
						}
					}, e.prototype.calculateBounds = function() {
						this._bounds.clear(), this._calculateBounds();
						for (var t = 0; t < this.children.length; t++) {
							var e = this.children[t];
							if (e.visible && e.renderable)
								if (e.calculateBounds(), e._mask) {
									var i = e._mask.maskObject || e._mask;
									i.calculateBounds(), this._bounds.addBoundsMask(e._bounds, i._bounds)
								} else e.filterArea ? this._bounds.addBoundsArea(e._bounds, e.filterArea) : this._bounds.addBounds(e._bounds)
						}
						this._bounds.updateID = this._boundsID
					}, e.prototype.getLocalBounds = function(e, i) {
						void 0 === i && (i = !1);
						var n = t.prototype.getLocalBounds.call(this, e);
						if (!i)
							for (var s = 0, o = this.children.length; s < o; ++s) {
								var r = this.children[s];
								r.visible && r.updateTransform()
							}
						return n
					}, e.prototype._calculateBounds = function() {}, e.prototype.render = function(t) {
						if (this.visible && !(this.worldAlpha <= 0) && this.renderable)
							if (this._mask || this.filters && this.filters.length) this.renderAdvanced(t);
							else {
								this._render(t);
								for (var e = 0, i = this.children.length; e < i; ++e) this.children[e].render(t)
							}
					}, e.prototype.renderAdvanced = function(t) {
						t.batch.flush();
						var e = this.filters,
							i = this._mask;
						if (e) {
							this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
							for (var n = 0; n < e.length; n++) e[n].enabled && this._enabledFilters.push(e[n]);
							this._enabledFilters.length && t.filter.push(this, this._enabledFilters)
						}
						i && t.mask.push(this, this._mask), this._render(t), n = 0;
						for (var s = this.children.length; n < s; n++) this.children[n].render(t);
						t.batch.flush(), i && t.mask.pop(this), e && this._enabledFilters && this._enabledFilters.length && t.filter.pop()
					}, e.prototype._render = function(t) {}, e.prototype.destroy = function(e) {
						t.prototype.destroy.call(this), this.sortDirty = !1;
						var i = "boolean" == typeof e ? e : e && e.children,
							n = this.removeChildren(0, this.children.length);
						if (i)
							for (var s = 0; s < n.length; ++s) n[s].destroy(e)
					}, Object.defineProperty(e.prototype, "width", {
						get: function() {
							return this.scale.x * this.getLocalBounds().width
						},
						set: function(t) {
							var e = this.getLocalBounds().width;
							this.scale.x = 0 !== e ? t / e : 1, this._width = t
						},
						enumerable: !1,
						configurable: !0
					}), Object.defineProperty(e.prototype, "height", {
						get: function() {
							return this.scale.y * this.getLocalBounds().height
						},
						set: function(t) {
							var e = this.getLocalBounds().height;
							this.scale.y = 0 !== e ? t / e : 1, this._height = t
						},
						enumerable: !1,
						configurable: !0
					}), e
				}(le);
				ce.prototype.containerUpdateTransform = ce.prototype.updateTransform;
				var de = {
					accessible: !1,
					accessibleTitle: null,
					accessibleHint: null,
					tabIndex: 0,
					_accessibleActive: !1,
					_accessibleDiv: null,
					accessibleType: "button",
					accessiblePointerEvents: "auto",
					accessibleChildren: !0,
					renderId: -1
				};
				le.mixin(de);
				var pe, _e = 100,
					me = function() {
						function t(t) {
							this._hookDiv = null, (Y.tablet || Y.phone) && this.createTouchHook();
							var e = document.createElement("div");
							e.style.width = _e + "px", e.style.height = _e + "px", e.style.position = "absolute", e.style.top = "0px", e.style.left = "0px", e.style.zIndex = 2..toString(), this.div = e, this.pool = [], this.renderId = 0, this.debug = !1, this.renderer = t, this.children = [], this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), this._isActive = !1, this._isMobileAccessibility = !1, this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, window.addEventListener("keydown", this._onKeyDown, !1)
						}
						return Object.defineProperty(t.prototype, "isActive", {
							get: function() {
								return this._isActive
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "isMobileAccessibility", {
							get: function() {
								return this._isMobileAccessibility
							},
							enumerable: !1,
							configurable: !0
						}), t.prototype.createTouchHook = function() {
							var t = this,
								e = document.createElement("button");
							e.style.width = "1px", e.style.height = "1px", e.style.position = "absolute", e.style.top = "-1000px", e.style.left = "-1000px", e.style.zIndex = 2..toString(), e.style.backgroundColor = "#FF0000", e.title = "select to enable accessability for this content", e.addEventListener("focus", (function() {
								t._isMobileAccessibility = !0, t.activate(), t.destroyTouchHook()
							})), document.body.appendChild(e), this._hookDiv = e
						}, t.prototype.destroyTouchHook = function() {
							this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null)
						}, t.prototype.activate = function() {
							this._isActive || (this._isActive = !0, window.document.addEventListener("mousemove", this._onMouseMove, !0), window.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), this.renderer.view.parentNode && this.renderer.view.parentNode.appendChild(this.div))
						}, t.prototype.deactivate = function() {
							this._isActive && !this._isMobileAccessibility && (this._isActive = !1, window.document.removeEventListener("mousemove", this._onMouseMove, !0), window.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), this.div.parentNode && this.div.parentNode.removeChild(this.div))
						}, t.prototype.updateAccessibleObjects = function(t) {
							if (t.visible && t.accessibleChildren) {
								t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId);
								for (var e = t.children, i = 0; i < e.length; i++) this.updateAccessibleObjects(e[i])
							}
						}, t.prototype.update = function() {
							var t = performance.now();
							if (!(Y.android.device && t < this.androidUpdateCount) && (this.androidUpdateCount = t + this.androidUpdateFrequency, this.renderer.renderingToScreen)) {
								this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered);
								var e = this.renderer.view.getBoundingClientRect(),
									i = this.renderer.resolution,
									n = e.width / this.renderer.width * i,
									s = e.height / this.renderer.height * i,
									o = this.div;
								o.style.left = e.left + "px", o.style.top = e.top + "px", o.style.width = this.renderer.width + "px", o.style.height = this.renderer.height + "px";
								for (var r = 0; r < this.children.length; r++) {
									var a = this.children[r];
									if (a.renderId !== this.renderId) a._accessibleActive = !1, vt(this.children, r, 1), this.div.removeChild(a._accessibleDiv), this.pool.push(a._accessibleDiv), a._accessibleDiv = null, r--;
									else {
										o = a._accessibleDiv;
										var l = a.hitArea,
											h = a.worldTransform;
										a.hitArea ? (o.style.left = (h.tx + l.x * h.a) * n + "px", o.style.top = (h.ty + l.y * h.d) * s + "px", o.style.width = l.width * h.a * n + "px", o.style.height = l.height * h.d * s + "px") : (l = a.getBounds(), this.capHitArea(l), o.style.left = l.x * n + "px", o.style.top = l.y * s + "px", o.style.width = l.width * n + "px", o.style.height = l.height * s + "px", o.title !== a.accessibleTitle && null !== a.accessibleTitle && (o.title = a.accessibleTitle), o.getAttribute("aria-label") !== a.accessibleHint && null !== a.accessibleHint && o.setAttribute("aria-label", a.accessibleHint)), a.accessibleTitle === o.title && a.tabIndex === o.tabIndex || (o.title = a.accessibleTitle, o.tabIndex = a.tabIndex, this.debug && this.updateDebugHTML(o))
									}
								}
								this.renderId++
							}
						}, t.prototype.updateDebugHTML = function(t) {
							t.innerHTML = "type: " + t.type + "</br> title : " + t.title + "</br> tabIndex: " + t.tabIndex
						}, t.prototype.capHitArea = function(t) {
							t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0), t.x + t.width > this.renderer.width && (t.width = this.renderer.width - t.x), t.y + t.height > this.renderer.height && (t.height = this.renderer.height - t.y)
						}, t.prototype.addChild = function(t) {
							var e = this.pool.pop();
							e || ((e = document.createElement("button")).style.width = _e + "px", e.style.height = _e + "px", e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e.style.position = "absolute", e.style.zIndex = 2..toString(), e.style.borderStyle = "none", navigator.userAgent.toLowerCase().indexOf("chrome") > -1 ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"), e.addEventListener("click", this._onClick.bind(this)), e.addEventListener("focus", this._onFocus.bind(this)), e.addEventListener("focusout", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && null !== t.accessibleTitle ? e.title = t.accessibleTitle : t.accessibleHint && null !== t.accessibleHint || (e.title = "displayObject " + t.tabIndex), t.accessibleHint && null !== t.accessibleHint && e.setAttribute("aria-label", t.accessibleHint), this.debug && this.updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex
						}, t.prototype._onClick = function(t) {
							var e = this.renderer.plugins.interaction;
							e.dispatchEvent(t.target.displayObject, "click", e.eventData), e.dispatchEvent(t.target.displayObject, "pointertap", e.eventData), e.dispatchEvent(t.target.displayObject, "tap", e.eventData)
						}, t.prototype._onFocus = function(t) {
							t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive");
							var e = this.renderer.plugins.interaction;
							e.dispatchEvent(t.target.displayObject, "mouseover", e.eventData)
						}, t.prototype._onFocusOut = function(t) {
							t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite");
							var e = this.renderer.plugins.interaction;
							e.dispatchEvent(t.target.displayObject, "mouseout", e.eventData)
						}, t.prototype._onKeyDown = function(t) {
							9 === t.keyCode && this.activate()
						}, t.prototype._onMouseMove = function(t) {
							0 === t.movementX && 0 === t.movementY || this.deactivate()
						}, t.prototype.destroy = function() {
							this.destroyTouchHook(), this.div = null, window.document.removeEventListener("mousemove", this._onMouseMove, !0), window.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null
						}, t
					}();
				z.TARGET_FPMS = .06,
					function(t) {
						t[t.INTERACTION = 50] = "INTERACTION", t[t.HIGH = 25] = "HIGH", t[t.NORMAL = 0] = "NORMAL", t[t.LOW = -25] = "LOW", t[t.UTILITY = -50] = "UTILITY"
					}(pe || (pe = {}));
				var ge = function() {
						function t(t, e, i, n) {
							void 0 === e && (e = null), void 0 === i && (i = 0), void 0 === n && (n = !1), this.fn = t, this.context = e, this.priority = i, this.once = n, this.next = null, this.previous = null, this._destroyed = !1
						}
						return t.prototype.match = function(t, e) {
							return void 0 === e && (e = null), this.fn === t && this.context === e
						}, t.prototype.emit = function(t) {
							this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));
							var e = this.next;
							return this.once && this.destroy(!0), this._destroyed && (this.next = null), e
						}, t.prototype.connect = function(t) {
							this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this
						}, t.prototype.destroy = function(t) {
							void 0 === t && (t = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
							var e = this.next;
							return this.next = t ? null : e, this.previous = null, e
						}, t
					}(),
					fe = function() {
						function t() {
							var t = this;
							this._head = new ge(null, null, 1 / 0), this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this.autoStart = !1, this.deltaTime = 1, this.deltaMS = 1 / z.TARGET_FPMS, this.elapsedMS = 1 / z.TARGET_FPMS, this.lastTime = -1, this.speed = 1, this.started = !1, this._protected = !1, this._lastFrame = -1, this._tick = function(e) {
								t._requestId = null, t.started && (t.update(e), t.started && null === t._requestId && t._head.next && (t._requestId = requestAnimationFrame(t._tick)))
							}
						}
						return t.prototype._requestIfNeeded = function() {
							null === this._requestId && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick))
						}, t.prototype._cancelIfNeeded = function() {
							null !== this._requestId && (cancelAnimationFrame(this._requestId), this._requestId = null)
						}, t.prototype._startIfPossible = function() {
							this.started ? this._requestIfNeeded() : this.autoStart && this.start()
						}, t.prototype.add = function(t, e, i) {
							return void 0 === i && (i = pe.NORMAL), this._addListener(new ge(t, e, i))
						}, t.prototype.addOnce = function(t, e, i) {
							return void 0 === i && (i = pe.NORMAL), this._addListener(new ge(t, e, i, !0))
						}, t.prototype._addListener = function(t) {
							var e = this._head.next,
								i = this._head;
							if (e) {
								for (; e;) {
									if (t.priority > e.priority) {
										t.connect(i);
										break
									}
									i = e, e = e.next
								}
								t.previous || t.connect(i)
							} else t.connect(i);
							return this._startIfPossible(), this
						}, t.prototype.remove = function(t, e) {
							for (var i = this._head.next; i;) i = i.match(t, e) ? i.destroy() : i.next;
							return this._head.next || this._cancelIfNeeded(), this
						}, Object.defineProperty(t.prototype, "count", {
							get: function() {
								if (!this._head) return 0;
								for (var t = 0, e = this._head; e = e.next;) t++;
								return t
							},
							enumerable: !1,
							configurable: !0
						}), t.prototype.start = function() {
							this.started || (this.started = !0, this._requestIfNeeded())
						}, t.prototype.stop = function() {
							this.started && (this.started = !1, this._cancelIfNeeded())
						}, t.prototype.destroy = function() {
							if (!this._protected) {
								this.stop();
								for (var t = this._head.next; t;) t = t.destroy(!0);
								this._head.destroy(), this._head = null
							}
						}, t.prototype.update = function(t) {
							var e;
							if (void 0 === t && (t = performance.now()), t > this.lastTime) {
								if ((e = this.elapsedMS = t - this.lastTime) > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
									var i = t - this._lastFrame | 0;
									if (i < this._minElapsedMS) return;
									this._lastFrame = t - i % this._minElapsedMS
								}
								this.deltaMS = e, this.deltaTime = this.deltaMS * z.TARGET_FPMS;
								for (var n = this._head, s = n.next; s;) s = s.emit(this.deltaTime);
								n.next || this._cancelIfNeeded()
							} else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
							this.lastTime = t
						}, Object.defineProperty(t.prototype, "FPS", {
							get: function() {
								return 1e3 / this.elapsedMS
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "minFPS", {
							get: function() {
								return 1e3 / this._maxElapsedMS
							},
							set: function(t) {
								var e = Math.min(this.maxFPS, t),
									i = Math.min(Math.max(0, e) / 1e3, z.TARGET_FPMS);
								this._maxElapsedMS = 1 / i
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "maxFPS", {
							get: function() {
								return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
							},
							set: function(t) {
								if (0 === t) this._minElapsedMS = 0;
								else {
									var e = Math.max(this.minFPS, t);
									this._minElapsedMS = 1 / (e / 1e3)
								}
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t, "shared", {
							get: function() {
								if (!t._shared) {
									var e = t._shared = new t;
									e.autoStart = !0, e._protected = !0
								}
								return t._shared
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t, "system", {
							get: function() {
								if (!t._system) {
									var e = t._system = new t;
									e.autoStart = !0, e._protected = !0
								}
								return t._system
							},
							enumerable: !1,
							configurable: !0
						}), t
					}(),
					Se = function() {
						function t() {}
						return t.init = function(t) {
							var e = this;
							t = Object.assign({
								autoStart: !0,
								sharedTicker: !1
							}, t), Object.defineProperty(this, "ticker", {
								set: function(t) {
									this._ticker && this._ticker.remove(this.render, this), this._ticker = t, t && t.add(this.render, this, pe.LOW)
								},
								get: function() {
									return this._ticker
								}
							}), this.stop = function() {
								e._ticker.stop()
							}, this.start = function() {
								e._ticker.start()
							}, this._ticker = null, this.ticker = t.sharedTicker ? fe.shared : new fe, t.autoStart && this.start()
						}, t.destroy = function() {
							if (this._ticker) {
								var t = this._ticker;
								this.ticker = null, t.destroy()
							}
						}, t
					}(),
					ye = function() {
						function t() {
							this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new jt, this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = !1, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0
						}
						return Object.defineProperty(t.prototype, "pointerId", {
							get: function() {
								return this.identifier
							},
							enumerable: !1,
							configurable: !0
						}), t.prototype.getLocalPosition = function(t, e, i) {
							return t.worldTransform.applyInverse(i || this.global, e)
						}, t.prototype.copyEvent = function(t) {
							"isPrimary" in t && t.isPrimary && (this.isPrimary = !0), this.button = "button" in t && t.button;
							var e = "buttons" in t && t.buttons;
							this.buttons = Number.isInteger(e) ? e : "which" in t && t.which, this.width = "width" in t && t.width, this.height = "height" in t && t.height, this.tiltX = "tiltX" in t && t.tiltX, this.tiltY = "tiltY" in t && t.tiltY, this.pointerType = "pointerType" in t && t.pointerType, this.pressure = "pressure" in t && t.pressure, this.rotationAngle = "rotationAngle" in t && t.rotationAngle, this.twist = "twist" in t && t.twist || 0, this.tangentialPressure = "tangentialPressure" in t && t.tangentialPressure || 0
						}, t.prototype.reset = function() {
							this.isPrimary = !1
						}, t
					}(),
					ve = function(t, e) {
						return ve = Object.setPrototypeOf || {
							__proto__: []
						}
						instanceof Array && function(t, e) {
							t.__proto__ = e
						} || function(t, e) {
							for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
						}, ve(t, e)
					},
					Te = function() {
						function t() {
							this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.target = null, this.currentTarget = null, this.type = null, this.data = null
						}
						return t.prototype.stopPropagation = function() {
							this.stopped = !0, this.stopPropagationHint = !0, this.stopsPropagatingAt = this.currentTarget
						}, t.prototype.reset = function() {
							this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.currentTarget = null, this.target = null
						}, t
					}(),
					Ee = function() {
						function t(e) {
							this._pointerId = e, this._flags = t.FLAGS.NONE
						}
						return t.prototype._doSet = function(t, e) {
							this._flags = e ? this._flags | t : this._flags & ~t
						}, Object.defineProperty(t.prototype, "pointerId", {
							get: function() {
								return this._pointerId
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "flags", {
							get: function() {
								return this._flags
							},
							set: function(t) {
								this._flags = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "none", {
							get: function() {
								return this._flags === t.FLAGS.NONE
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "over", {
							get: function() {
								return !!(this._flags & t.FLAGS.OVER)
							},
							set: function(e) {
								this._doSet(t.FLAGS.OVER, e)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "rightDown", {
							get: function() {
								return !!(this._flags & t.FLAGS.RIGHT_DOWN)
							},
							set: function(e) {
								this._doSet(t.FLAGS.RIGHT_DOWN, e)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "leftDown", {
							get: function() {
								return !!(this._flags & t.FLAGS.LEFT_DOWN)
							},
							set: function(e) {
								this._doSet(t.FLAGS.LEFT_DOWN, e)
							},
							enumerable: !1,
							configurable: !0
						}), t.FLAGS = Object.freeze({
							NONE: 0,
							OVER: 1,
							LEFT_DOWN: 2,
							RIGHT_DOWN: 4
						}), t
					}(),
					be = function() {
						function t() {
							this._tempPoint = new jt
						}
						return t.prototype.recursiveFindHit = function(t, e, i, n, s) {
							if (!e || !e.visible) return !1;
							var o = t.data.global,
								r = !1,
								a = s = e.interactive || s,
								l = !0;
							if (e.hitArea ? (n && (e.worldTransform.applyInverse(o, this._tempPoint), e.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? r = !0 : (n = !1, l = !1)), a = !1) : e._mask && n && (e._mask.containsPoint && e._mask.containsPoint(o) || (n = !1)), l && e.interactiveChildren && e.children)
								for (var h = e.children, u = h.length - 1; u >= 0; u--) {
									var c = h[u],
										d = this.recursiveFindHit(t, c, i, n, a);
									if (d) {
										if (!c.parent) continue;
										a = !1, d && (t.target && (n = !1), r = !0)
									}
								}
							return s && (n && !t.target && !e.hitArea && e.containsPoint && e.containsPoint(o) && (r = !0), e.interactive && (r && !t.target && (t.target = e), i && i(t, e, !!r))), r
						}, t.prototype.findHit = function(t, e, i, n) {
							this.recursiveFindHit(t, e, i, n, !1)
						}, t
					}(),
					Ae = {
						interactive: !1,
						interactiveChildren: !0,
						hitArea: null,
						get buttonMode() {
							return "pointer" === this.cursor
						},
						set buttonMode(t) {
							t ? this.cursor = "pointer" : "pointer" === this.cursor && (this.cursor = null)
						},
						cursor: null,
						get trackedPointers() {
							return void 0 === this._trackedPointers && (this._trackedPointers = {}), this._trackedPointers
						},
						_trackedPointers: void 0
					};
				le.mixin(Ae);
				var Pe = {
						target: null,
						data: {
							global: null
						}
					},
					Ie = function(t) {
						function e(e, i) {
							var n = t.call(this) || this;
							return i = i || {}, n.renderer = e, n.autoPreventDefault = void 0 === i.autoPreventDefault || i.autoPreventDefault, n.interactionFrequency = i.interactionFrequency || 10, n.mouse = new ye, n.mouse.identifier = 1, n.mouse.global.set(-999999), n.activeInteractionData = {}, n.activeInteractionData[1] = n.mouse, n.interactionDataPool = [], n.eventData = new Te, n.interactionDOMElement = null, n.moveWhenInside = !1, n.eventsAdded = !1, n.tickerAdded = !1, n.mouseOverRenderer = !1, n.supportsTouchEvents = "ontouchstart" in window, n.supportsPointerEvents = !!window.PointerEvent, n.onPointerUp = n.onPointerUp.bind(n), n.processPointerUp = n.processPointerUp.bind(n), n.onPointerCancel = n.onPointerCancel.bind(n), n.processPointerCancel = n.processPointerCancel.bind(n), n.onPointerDown = n.onPointerDown.bind(n), n.processPointerDown = n.processPointerDown.bind(n), n.onPointerMove = n.onPointerMove.bind(n), n.processPointerMove = n.processPointerMove.bind(n), n.onPointerOut = n.onPointerOut.bind(n), n.processPointerOverOut = n.processPointerOverOut.bind(n), n.onPointerOver = n.onPointerOver.bind(n), n.cursorStyles = {
								default: "inherit",
								pointer: "pointer"
							}, n.currentCursorMode = null, n.cursor = null, n.resolution = 1, n.delayedEvents = [], n.search = new be, n._tempDisplayObject = new he, n._useSystemTicker = void 0 === i.useSystemTicker || i.useSystemTicker, n.setTargetElement(n.renderer.view, n.renderer.resolution), n
						}
						return function(t, e) {
							function i() {
								this.constructor = t
							}
							ve(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
						}(e, t), Object.defineProperty(e.prototype, "useSystemTicker", {
							get: function() {
								return this._useSystemTicker
							},
							set: function(t) {
								this._useSystemTicker = t, t ? this.addTickerListener() : this.removeTickerListener()
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "lastObjectRendered", {
							get: function() {
								return this.renderer._lastObjectRendered || this._tempDisplayObject
							},
							enumerable: !1,
							configurable: !0
						}), e.prototype.hitTest = function(t, e) {
							return Pe.target = null, Pe.data.global = t, e || (e = this.lastObjectRendered), this.processInteractive(Pe, e, null, !0), Pe.target
						}, e.prototype.setTargetElement = function(t, e) {
							void 0 === e && (e = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = t, this.resolution = e, this.addEvents(), this.addTickerListener()
						}, e.prototype.addTickerListener = function() {
							!this.tickerAdded && this.interactionDOMElement && this._useSystemTicker && (fe.system.add(this.tickerUpdate, this, pe.INTERACTION), this.tickerAdded = !0)
						}, e.prototype.removeTickerListener = function() {
							this.tickerAdded && (fe.system.remove(this.tickerUpdate, this), this.tickerAdded = !1)
						}, e.prototype.addEvents = function() {
							if (!this.eventsAdded && this.interactionDOMElement) {
								var t = this.interactionDOMElement.style;
								window.navigator.msPointerEnabled ? (t.msContentZooming = "none", t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none"), this.supportsPointerEvents ? (window.document.addEventListener("pointermove", this.onPointerMove, !0), this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, !0), this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, !0), this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, !0), window.addEventListener("pointercancel", this.onPointerCancel, !0), window.addEventListener("pointerup", this.onPointerUp, !0)) : (window.document.addEventListener("mousemove", this.onPointerMove, !0), this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, !0), this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, !0), this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, !0), window.addEventListener("mouseup", this.onPointerUp, !0)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, !0), this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, !0), this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, !0), this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, !0)), this.eventsAdded = !0
							}
						}, e.prototype.removeEvents = function() {
							if (this.eventsAdded && this.interactionDOMElement) {
								var t = this.interactionDOMElement.style;
								window.navigator.msPointerEnabled ? (t.msContentZooming = "", t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = ""), this.supportsPointerEvents ? (window.document.removeEventListener("pointermove", this.onPointerMove, !0), this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, !0), this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, !0), this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, !0), window.removeEventListener("pointercancel", this.onPointerCancel, !0), window.removeEventListener("pointerup", this.onPointerUp, !0)) : (window.document.removeEventListener("mousemove", this.onPointerMove, !0), this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, !0), this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, !0), this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, !0), window.removeEventListener("mouseup", this.onPointerUp, !0)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, !0), this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, !0), this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, !0), this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, !0)), this.interactionDOMElement = null, this.eventsAdded = !1
							}
						}, e.prototype.tickerUpdate = function(t) {
							this._deltaTime += t, this._deltaTime < this.interactionFrequency || (this._deltaTime = 0, this.update())
						}, e.prototype.update = function() {
							if (this.interactionDOMElement)
								if (this._didMove) this._didMove = !1;
								else {
									for (var t in this.cursor = null, this.activeInteractionData)
										if (this.activeInteractionData.hasOwnProperty(t)) {
											var e = this.activeInteractionData[t];
											if (e.originalEvent && "touch" !== e.pointerType) {
												var i = this.configureInteractionEventForDOMEvent(this.eventData, e.originalEvent, e);
												this.processInteractive(i, this.lastObjectRendered, this.processPointerOverOut, !0)
											}
										} this.setCursorMode(this.cursor)
								}
						}, e.prototype.setCursorMode = function(t) {
							if (t = t || "default", this.currentCursorMode !== t) {
								this.currentCursorMode = t;
								var e = this.cursorStyles[t];
								if (e) switch (typeof e) {
									case "string":
										this.interactionDOMElement.style.cursor = e;
										break;
									case "function":
										e(t);
										break;
									case "object":
										Object.assign(this.interactionDOMElement.style, e)
								} else "string" != typeof t || Object.prototype.hasOwnProperty.call(this.cursorStyles, t) || (this.interactionDOMElement.style.cursor = t)
							}
						}, e.prototype.dispatchEvent = function(t, e, i) {
							i.stopPropagationHint && t !== i.stopsPropagatingAt || (i.currentTarget = t, i.type = e, t.emit(e, i), t[e] && t[e](i))
						}, e.prototype.delayDispatchEvent = function(t, e, i) {
							this.delayedEvents.push({
								displayObject: t,
								eventString: e,
								eventData: i
							})
						}, e.prototype.mapPositionToPoint = function(t, e, i) {
							var n;
							n = this.interactionDOMElement.parentElement ? this.interactionDOMElement.getBoundingClientRect() : {
								x: 0,
								y: 0,
								width: 0,
								height: 0
							};
							var s = 1 / this.resolution;
							t.x = (e - n.left) * (this.interactionDOMElement.width / n.width) * s, t.y = (i - n.top) * (this.interactionDOMElement.height / n.height) * s
						}, e.prototype.processInteractive = function(t, e, i, n) {
							var s = this.search.findHit(t, e, i, n),
								o = this.delayedEvents;
							if (!o.length) return s;
							t.stopPropagationHint = !1;
							var r = o.length;
							this.delayedEvents = [];
							for (var a = 0; a < r; a++) {
								var l = o[a],
									h = l.displayObject,
									u = l.eventString,
									c = l.eventData;
								c.stopsPropagatingAt === h && (c.stopPropagationHint = !0), this.dispatchEvent(h, u, c)
							}
							return s
						}, e.prototype.onPointerDown = function(t) {
							if (!this.supportsTouchEvents || "touch" !== t.pointerType) {
								var e = this.normalizeToPointerData(t);
								this.autoPreventDefault && e[0].isNormalized && (t.cancelable || !("cancelable" in t)) && t.preventDefault();
								for (var i = e.length, n = 0; n < i; n++) {
									var s = e[n],
										o = this.getInteractionDataForPointerId(s),
										r = this.configureInteractionEventForDOMEvent(this.eventData, s, o);
									if (r.data.originalEvent = t, this.processInteractive(r, this.lastObjectRendered, this.processPointerDown, !0), this.emit("pointerdown", r), "touch" === s.pointerType) this.emit("touchstart", r);
									else if ("mouse" === s.pointerType || "pen" === s.pointerType) {
										var a = 2 === s.button;
										this.emit(a ? "rightdown" : "mousedown", this.eventData)
									}
								}
							}
						}, e.prototype.processPointerDown = function(t, e, i) {
							var n = t.data,
								s = t.data.identifier;
							if (i)
								if (e.trackedPointers[s] || (e.trackedPointers[s] = new Ee(s)), this.dispatchEvent(e, "pointerdown", t), "touch" === n.pointerType) this.dispatchEvent(e, "touchstart", t);
								else if ("mouse" === n.pointerType || "pen" === n.pointerType) {
								var o = 2 === n.button;
								o ? e.trackedPointers[s].rightDown = !0 : e.trackedPointers[s].leftDown = !0, this.dispatchEvent(e, o ? "rightdown" : "mousedown", t)
							}
						}, e.prototype.onPointerComplete = function(t, e, i) {
							for (var n = this.normalizeToPointerData(t), s = n.length, o = t.target !== this.interactionDOMElement ? "outside" : "", r = 0; r < s; r++) {
								var a = n[r],
									l = this.getInteractionDataForPointerId(a),
									h = this.configureInteractionEventForDOMEvent(this.eventData, a, l);
								if (h.data.originalEvent = t, this.processInteractive(h, this.lastObjectRendered, i, e || !o), this.emit(e ? "pointercancel" : "pointerup" + o, h), "mouse" === a.pointerType || "pen" === a.pointerType) {
									var u = 2 === a.button;
									this.emit(u ? "rightup" + o : "mouseup" + o, h)
								} else "touch" === a.pointerType && (this.emit(e ? "touchcancel" : "touchend" + o, h), this.releaseInteractionDataForPointerId(a.pointerId))
							}
						}, e.prototype.onPointerCancel = function(t) {
							this.supportsTouchEvents && "touch" === t.pointerType || this.onPointerComplete(t, !0, this.processPointerCancel)
						}, e.prototype.processPointerCancel = function(t, e) {
							var i = t.data,
								n = t.data.identifier;
							void 0 !== e.trackedPointers[n] && (delete e.trackedPointers[n], this.dispatchEvent(e, "pointercancel", t), "touch" === i.pointerType && this.dispatchEvent(e, "touchcancel", t))
						}, e.prototype.onPointerUp = function(t) {
							this.supportsTouchEvents && "touch" === t.pointerType || this.onPointerComplete(t, !1, this.processPointerUp)
						}, e.prototype.processPointerUp = function(t, e, i) {
							var n = t.data,
								s = t.data.identifier,
								o = e.trackedPointers[s],
								r = "touch" === n.pointerType,
								a = "mouse" === n.pointerType || "pen" === n.pointerType,
								l = !1;
							if (a) {
								var h = 2 === n.button,
									u = Ee.FLAGS,
									c = h ? u.RIGHT_DOWN : u.LEFT_DOWN,
									d = void 0 !== o && o.flags & c;
								i ? (this.dispatchEvent(e, h ? "rightup" : "mouseup", t), d && (this.dispatchEvent(e, h ? "rightclick" : "click", t), l = !0)) : d && this.dispatchEvent(e, h ? "rightupoutside" : "mouseupoutside", t), o && (h ? o.rightDown = !1 : o.leftDown = !1)
							}
							i ? (this.dispatchEvent(e, "pointerup", t), r && this.dispatchEvent(e, "touchend", t), o && (a && !l || this.dispatchEvent(e, "pointertap", t), r && (this.dispatchEvent(e, "tap", t), o.over = !1))) : o && (this.dispatchEvent(e, "pointerupoutside", t), r && this.dispatchEvent(e, "touchendoutside", t)), o && o.none && delete e.trackedPointers[s]
						}, e.prototype.onPointerMove = function(t) {
							if (!this.supportsTouchEvents || "touch" !== t.pointerType) {
								var e = this.normalizeToPointerData(t);
								"mouse" !== e[0].pointerType && "pen" !== e[0].pointerType || (this._didMove = !0, this.cursor = null);
								for (var i = e.length, n = 0; n < i; n++) {
									var s = e[n],
										o = this.getInteractionDataForPointerId(s),
										r = this.configureInteractionEventForDOMEvent(this.eventData, s, o);
									r.data.originalEvent = t, this.processInteractive(r, this.lastObjectRendered, this.processPointerMove, !0), this.emit("pointermove", r), "touch" === s.pointerType && this.emit("touchmove", r), "mouse" !== s.pointerType && "pen" !== s.pointerType || this.emit("mousemove", r)
								}
								"mouse" === e[0].pointerType && this.setCursorMode(this.cursor)
							}
						}, e.prototype.processPointerMove = function(t, e, i) {
							var n = t.data,
								s = "touch" === n.pointerType,
								o = "mouse" === n.pointerType || "pen" === n.pointerType;
							o && this.processPointerOverOut(t, e, i), this.moveWhenInside && !i || (this.dispatchEvent(e, "pointermove", t), s && this.dispatchEvent(e, "touchmove", t), o && this.dispatchEvent(e, "mousemove", t))
						}, e.prototype.onPointerOut = function(t) {
							if (!this.supportsTouchEvents || "touch" !== t.pointerType) {
								var e = this.normalizeToPointerData(t)[0];
								"mouse" === e.pointerType && (this.mouseOverRenderer = !1, this.setCursorMode(null));
								var i = this.getInteractionDataForPointerId(e),
									n = this.configureInteractionEventForDOMEvent(this.eventData, e, i);
								n.data.originalEvent = e, this.processInteractive(n, this.lastObjectRendered, this.processPointerOverOut, !1), this.emit("pointerout", n), "mouse" === e.pointerType || "pen" === e.pointerType ? this.emit("mouseout", n) : this.releaseInteractionDataForPointerId(i.identifier)
							}
						}, e.prototype.processPointerOverOut = function(t, e, i) {
							var n = t.data,
								s = t.data.identifier,
								o = "mouse" === n.pointerType || "pen" === n.pointerType,
								r = e.trackedPointers[s];
							i && !r && (r = e.trackedPointers[s] = new Ee(s)), void 0 !== r && (i && this.mouseOverRenderer ? (r.over || (r.over = !0, this.delayDispatchEvent(e, "pointerover", t), o && this.delayDispatchEvent(e, "mouseover", t)), o && null === this.cursor && (this.cursor = e.cursor)) : r.over && (r.over = !1, this.dispatchEvent(e, "pointerout", this.eventData), o && this.dispatchEvent(e, "mouseout", t), r.none && delete e.trackedPointers[s]))
						}, e.prototype.onPointerOver = function(t) {
							var e = this.normalizeToPointerData(t)[0],
								i = this.getInteractionDataForPointerId(e),
								n = this.configureInteractionEventForDOMEvent(this.eventData, e, i);
							n.data.originalEvent = e, "mouse" === e.pointerType && (this.mouseOverRenderer = !0), this.emit("pointerover", n), "mouse" !== e.pointerType && "pen" !== e.pointerType || this.emit("mouseover", n)
						}, e.prototype.getInteractionDataForPointerId = function(t) {
							var e, i = t.pointerId;
							return 1 === i || "mouse" === t.pointerType ? e = this.mouse : this.activeInteractionData[i] ? e = this.activeInteractionData[i] : ((e = this.interactionDataPool.pop() || new ye).identifier = i, this.activeInteractionData[i] = e), e.copyEvent(t), e
						}, e.prototype.releaseInteractionDataForPointerId = function(t) {
							var e = this.activeInteractionData[t];
							e && (delete this.activeInteractionData[t], e.reset(), this.interactionDataPool.push(e))
						}, e.prototype.configureInteractionEventForDOMEvent = function(t, e, i) {
							return t.data = i, this.mapPositionToPoint(i.global, e.clientX, e.clientY), "touch" === e.pointerType && (e.globalX = i.global.x, e.globalY = i.global.y), i.originalEvent = e, t.reset(), t
						}, e.prototype.normalizeToPointerData = function(t) {
							var e = [];
							if (this.supportsTouchEvents && t instanceof TouchEvent)
								for (var i = 0, n = t.changedTouches.length; i < n; i++) {
									var s = t.changedTouches[i];
									void 0 === s.button && (s.button = t.touches.length ? 1 : 0), void 0 === s.buttons && (s.buttons = t.touches.length ? 1 : 0), void 0 === s.isPrimary && (s.isPrimary = 1 === t.touches.length && "touchstart" === t.type), void 0 === s.width && (s.width = s.radiusX || 1), void 0 === s.height && (s.height = s.radiusY || 1), void 0 === s.tiltX && (s.tiltX = 0), void 0 === s.tiltY && (s.tiltY = 0), void 0 === s.pointerType && (s.pointerType = "touch"), void 0 === s.pointerId && (s.pointerId = s.identifier || 0), void 0 === s.pressure && (s.pressure = s.force || .5), void 0 === s.twist && (s.twist = 0), void 0 === s.tangentialPressure && (s.tangentialPressure = 0), void 0 === s.layerX && (s.layerX = s.offsetX = s.clientX), void 0 === s.layerY && (s.layerY = s.offsetY = s.clientY), s.isNormalized = !0, e.push(s)
								} else if (!(t instanceof MouseEvent) || this.supportsPointerEvents && t instanceof window.PointerEvent) e.push(t);
								else {
									var o = t;
									void 0 === o.isPrimary && (o.isPrimary = !0), void 0 === o.width && (o.width = 1), void 0 === o.height && (o.height = 1), void 0 === o.tiltX && (o.tiltX = 0), void 0 === o.tiltY && (o.tiltY = 0), void 0 === o.pointerType && (o.pointerType = "mouse"), void 0 === o.pointerId && (o.pointerId = 1), void 0 === o.pressure && (o.pressure = .5), void 0 === o.twist && (o.twist = 0), void 0 === o.tangentialPressure && (o.tangentialPressure = 0), o.isNormalized = !0, e.push(o)
								} return e
						}, e.prototype.destroy = function() {
							this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null
						}, e
					}(K()),
					we = function() {
						function t(t) {
							this.items = [], this._name = t, this._aliasCount = 0
						}
						return t.prototype.emit = function(t, e, i, n, s, o, r, a) {
							if (arguments.length > 8) throw new Error("max arguments reached");
							var l = this.name,
								h = this.items;
							this._aliasCount++;
							for (var u = 0, c = h.length; u < c; u++) h[u][l](t, e, i, n, s, o, r, a);
							return h === this.items && this._aliasCount--, this
						}, t.prototype.ensureNonAliasedItems = function() {
							this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0))
						}, t.prototype.add = function(t) {
							return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this
						}, t.prototype.remove = function(t) {
							var e = this.items.indexOf(t);
							return -1 !== e && (this.ensureNonAliasedItems(), this.items.splice(e, 1)), this
						}, t.prototype.contains = function(t) {
							return -1 !== this.items.indexOf(t)
						}, t.prototype.removeAll = function() {
							return this.ensureNonAliasedItems(), this.items.length = 0, this
						}, t.prototype.destroy = function() {
							this.removeAll(), this.items = null, this._name = null
						}, Object.defineProperty(t.prototype, "empty", {
							get: function() {
								return 0 === this.items.length
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "name", {
							get: function() {
								return this._name
							},
							enumerable: !1,
							configurable: !0
						}), t
					}();
				Object.defineProperties(we.prototype, {
					dispatch: {
						value: we.prototype.emit
					},
					run: {
						value: we.prototype.emit
					}
				}), z.PREFER_ENV = Y.any ? d.WEBGL : d.WEBGL2, z.STRICT_TEXTURE_CACHE = !1;
				var Le = [];

				function Ce(t, e) {
					if (!t) return null;
					var i = "";
					if ("string" == typeof t) {
						var n = /\.(\w{3,4})(?:$|\?|#)/i.exec(t);
						n && (i = n[1].toLowerCase())
					}
					for (var s = Le.length - 1; s >= 0; --s) {
						var o = Le[s];
						if (o.test && o.test(t, i)) return new o(t, e)
					}
					throw new Error("Unrecognized source type to auto-detect Resource")
				}
				var xe = function(t, e) {
					return xe = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(t, e) {
						t.__proto__ = e
					} || function(t, e) {
						for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
					}, xe(t, e)
				};

				function Be(t, e) {
					function i() {
						this.constructor = t
					}
					xe(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
				}
				var Oe = function() {
						function t(t, e) {
							void 0 === t && (t = 0), void 0 === e && (e = 0), this._width = t, this._height = e, this.destroyed = !1, this.internal = !1, this.onResize = new we("setRealSize"), this.onUpdate = new we("update"), this.onError = new we("onError")
						}
						return t.prototype.bind = function(t) {
							this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height)
						}, t.prototype.unbind = function(t) {
							this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t)
						}, t.prototype.resize = function(t, e) {
							t === this._width && e === this._height || (this._width = t, this._height = e, this.onResize.emit(t, e))
						}, Object.defineProperty(t.prototype, "valid", {
							get: function() {
								return !!this._width && !!this._height
							},
							enumerable: !1,
							configurable: !0
						}), t.prototype.update = function() {
							this.destroyed || this.onUpdate.emit()
						}, t.prototype.load = function() {
							return Promise.resolve(this)
						}, Object.defineProperty(t.prototype, "width", {
							get: function() {
								return this._width
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "height", {
							get: function() {
								return this._height
							},
							enumerable: !1,
							configurable: !0
						}), t.prototype.style = function(t, e, i) {
							return !1
						}, t.prototype.dispose = function() {}, t.prototype.destroy = function() {
							this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null)
						}, t.test = function(t, e) {
							return !1
						}, t
					}(),
					Ne = function(t) {
						function e(e, i) {
							var n = this,
								s = i || {},
								o = s.width,
								r = s.height;
							if (!o || !r) throw new Error("BufferResource width or height invalid");
							return (n = t.call(this, o, r) || this).data = e, n
						}
						return Be(e, t), e.prototype.upload = function(t, e, i) {
							var n = t.gl;
							return n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === b.UNPACK), i.width === e.width && i.height === e.height ? n.texSubImage2D(e.target, 0, 0, 0, e.width, e.height, e.format, e.type, this.data) : (i.width = e.width, i.height = e.height, n.texImage2D(e.target, 0, i.internalFormat, e.width, e.height, 0, e.format, i.type, this.data)), !0
						}, e.prototype.dispose = function() {
							this.data = null
						}, e.test = function(t) {
							return t instanceof Float32Array || t instanceof Uint8Array || t instanceof Uint32Array
						}, e
					}(Oe),
					Me = {
						scaleMode: v.NEAREST,
						format: f.RGBA,
						alphaMode: b.NPM
					},
					Re = function(t) {
						function e(e, i) {
							void 0 === e && (e = null), void 0 === i && (i = null);
							var n = t.call(this) || this,
								s = (i = i || {}).alphaMode,
								o = i.mipmap,
								r = i.anisotropicLevel,
								a = i.scaleMode,
								l = i.width,
								h = i.height,
								u = i.wrapMode,
								c = i.format,
								d = i.type,
								p = i.target,
								_ = i.resolution,
								m = i.resourceOptions;
							return !e || e instanceof Oe || ((e = Ce(e, m)).internal = !0), n.width = l || 0, n.height = h || 0, n.resolution = _ || z.RESOLUTION, n.mipmap = void 0 !== o ? o : z.MIPMAP_TEXTURES, n.anisotropicLevel = void 0 !== r ? r : z.ANISOTROPIC_LEVEL, n.wrapMode = u || z.WRAP_MODE, n.scaleMode = void 0 !== a ? a : z.SCALE_MODE, n.format = c || f.RGBA, n.type = d || y.UNSIGNED_BYTE, n.target = p || S.TEXTURE_2D, n.alphaMode = void 0 !== s ? s : b.UNPACK, void 0 !== i.premultiplyAlpha && (n.premultiplyAlpha = i.premultiplyAlpha), n.uid = bt(), n.touched = 0, n.isPowerOfTwo = !1, n._refreshPOT(), n._glTextures = {}, n.dirtyId = 0, n.dirtyStyleId = 0, n.cacheId = null, n.valid = l > 0 && h > 0, n.textureCacheIds = [], n.destroyed = !1, n.resource = null, n._batchEnabled = 0, n._batchLocation = 0, n.parentTextureArray = null, n.setResource(e), n
						}
						return Be(e, t), Object.defineProperty(e.prototype, "realWidth", {
							get: function() {
								return Math.ceil(this.width * this.resolution - 1e-4)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "realHeight", {
							get: function() {
								return Math.ceil(this.height * this.resolution - 1e-4)
							},
							enumerable: !1,
							configurable: !0
						}), e.prototype.setStyle = function(t, e) {
							var i;
							return void 0 !== t && t !== this.scaleMode && (this.scaleMode = t, i = !0), void 0 !== e && e !== this.mipmap && (this.mipmap = e, i = !0), i && this.dirtyStyleId++, this
						}, e.prototype.setSize = function(t, e, i) {
							return this.resolution = i || this.resolution, this.width = t, this.height = e, this._refreshPOT(), this.update(), this
						}, e.prototype.setRealSize = function(t, e, i) {
							return this.resolution = i || this.resolution, this.width = t / this.resolution, this.height = e / this.resolution, this._refreshPOT(), this.update(), this
						}, e.prototype._refreshPOT = function() {
							this.isPowerOfTwo = St(this.realWidth) && St(this.realHeight)
						}, e.prototype.setResolution = function(t) {
							var e = this.resolution;
							return e === t || (this.resolution = t, this.valid && (this.width = this.width * e / t, this.height = this.height * e / t, this.emit("update", this)), this._refreshPOT()), this
						}, e.prototype.setResource = function(t) {
							if (this.resource === t) return this;
							if (this.resource) throw new Error("Resource can be set only once");
							return t.bind(this), this.resource = t, this
						}, e.prototype.update = function() {
							this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit("loaded", this), this.emit("update", this))
						}, e.prototype.onError = function(t) {
							this.emit("error", this, t)
						}, e.prototype.destroy = function() {
							this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete Lt[this.cacheId], delete wt[this.cacheId], this.cacheId = null), this.dispose(), e.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0
						}, e.prototype.dispose = function() {
							this.emit("dispose", this)
						}, e.prototype.castToBaseTexture = function() {
							return this
						}, e.from = function(t, i, n) {
							void 0 === n && (n = z.STRICT_TEXTURE_CACHE);
							var s = "string" == typeof t,
								o = null;
							s ? o = t : (t._pixiId || (t._pixiId = "pixiid_" + bt()), o = t._pixiId);
							var r = Lt[o];
							if (s && n && !r) throw new Error('The cacheId "' + o + '" does not exist in BaseTextureCache.');
							return r || ((r = new e(t, i)).cacheId = o, e.addToCache(r, o)), r
						}, e.fromBuffer = function(t, i, n, s) {
							t = t || new Float32Array(i * n * 4);
							var o = new Ne(t, {
									width: i,
									height: n
								}),
								r = t instanceof Float32Array ? y.FLOAT : y.UNSIGNED_BYTE;
							return new e(o, Object.assign(Me, s || {
								width: i,
								height: n,
								type: r
							}))
						}, e.addToCache = function(t, e) {
							e && (-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e), Lt[e] && console.warn("BaseTexture added to the cache with an id [" + e + "] that already had an entry"), Lt[e] = t)
						}, e.removeFromCache = function(t) {
							if ("string" == typeof t) {
								var e = Lt[t];
								if (e) {
									var i = e.textureCacheIds.indexOf(t);
									return i > -1 && e.textureCacheIds.splice(i, 1), delete Lt[t], e
								}
							} else if (t && t.textureCacheIds) {
								for (var n = 0; n < t.textureCacheIds.length; ++n) delete Lt[t.textureCacheIds[n]];
								return t.textureCacheIds.length = 0, t
							}
							return null
						}, e._globalBatch = 0, e
					}(K()),
					De = function(t) {
						function e(e, i) {
							var n = this,
								s = i || {},
								o = s.width,
								r = s.height;
							(n = t.call(this, o, r) || this).items = [], n.itemDirtyIds = [];
							for (var a = 0; a < e; a++) {
								var l = new Re;
								n.items.push(l), n.itemDirtyIds.push(-2)
							}
							return n.length = e, n._load = null, n.baseTexture = null, n
						}
						return Be(e, t), e.prototype.initFromArray = function(t, e) {
							for (var i = 0; i < this.length; i++) t[i] && (t[i].castToBaseTexture ? this.addBaseTextureAt(t[i].castToBaseTexture(), i) : t[i] instanceof Oe ? this.addResourceAt(t[i], i) : this.addResourceAt(Ce(t[i], e), i))
						}, e.prototype.dispose = function() {
							for (var t = 0, e = this.length; t < e; t++) this.items[t].destroy();
							this.items = null, this.itemDirtyIds = null, this._load = null
						}, e.prototype.addResourceAt = function(t, e) {
							if (!this.items[e]) throw new Error("Index " + e + " is out of bounds");
							return t.valid && !this.valid && this.resize(t.width, t.height), this.items[e].setResource(t), this
						}, e.prototype.bind = function(e) {
							if (null !== this.baseTexture) throw new Error("Only one base texture per TextureArray is allowed");
							t.prototype.bind.call(this, e);
							for (var i = 0; i < this.length; i++) this.items[i].parentTextureArray = e, this.items[i].on("update", e.update, e)
						}, e.prototype.unbind = function(e) {
							t.prototype.unbind.call(this, e);
							for (var i = 0; i < this.length; i++) this.items[i].parentTextureArray = null, this.items[i].off("update", e.update, e)
						}, e.prototype.load = function() {
							var t = this;
							if (this._load) return this._load;
							var e = this.items.map((function(t) {
								return t.resource
							})).filter((function(t) {
								return t
							})).map((function(t) {
								return t.load()
							}));
							return this._load = Promise.all(e).then((function() {
								var e = t.items[0],
									i = e.realWidth,
									n = e.realHeight;
								return t.resize(i, n), Promise.resolve(t)
							})), this._load
						}, e
					}(Oe),
					ke = function(t) {
						function e(e, i) {
							var n, s, o = this,
								r = i || {},
								a = r.width,
								l = r.height;
							return Array.isArray(e) ? (n = e, s = e.length) : s = e, o = t.call(this, s, {
								width: a,
								height: l
							}) || this, n && o.initFromArray(n, i), o
						}
						return Be(e, t), e.prototype.addBaseTextureAt = function(t, e) {
							if (!t.resource) throw new Error("ArrayResource does not support RenderTexture");
							return this.addResourceAt(t.resource, e), this
						}, e.prototype.bind = function(e) {
							t.prototype.bind.call(this, e), e.target = S.TEXTURE_2D_ARRAY
						}, e.prototype.upload = function(t, e, i) {
							var n = this,
								s = n.length,
								o = n.itemDirtyIds,
								r = n.items,
								a = t.gl;
							i.dirtyId < 0 && a.texImage3D(a.TEXTURE_2D_ARRAY, 0, e.format, this._width, this._height, s, 0, e.format, e.type, null);
							for (var l = 0; l < s; l++) {
								var h = r[l];
								o[l] < h.dirtyId && (o[l] = h.dirtyId, h.valid && a.texSubImage3D(a.TEXTURE_2D_ARRAY, 0, 0, 0, l, h.resource.width, h.resource.height, 1, e.format, e.type, h.resource.source))
							}
							return !0
						}, e
					}(De),
					Fe = function(t) {
						function e(e) {
							var i = this,
								n = e,
								s = n.naturalWidth || n.videoWidth || n.width,
								o = n.naturalHeight || n.videoHeight || n.height;
							return (i = t.call(this, s, o) || this).source = e, i.noSubImage = !1, i
						}
						return Be(e, t), e.crossOrigin = function(t, e, i) {
							void 0 === i && 0 !== e.indexOf("data:") ? t.crossOrigin = Dt(e) : !1 !== i && (t.crossOrigin = "string" == typeof i ? i : "anonymous")
						}, e.prototype.upload = function(t, e, i, n) {
							var s = t.gl,
								o = e.realWidth,
								r = e.realHeight;
							return n = n || this.source, s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === b.UNPACK), this.noSubImage || e.target !== s.TEXTURE_2D || i.width !== o || i.height !== r ? (i.width = o, i.height = r, s.texImage2D(e.target, 0, e.format, e.format, e.type, n)) : s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, e.format, e.type, n), !0
						}, e.prototype.update = function() {
							if (!this.destroyed) {
								var e = this.source,
									i = e.naturalWidth || e.videoWidth || e.width,
									n = e.naturalHeight || e.videoHeight || e.height;
								this.resize(i, n), t.prototype.update.call(this)
							}
						}, e.prototype.dispose = function() {
							this.source = null
						}, e
					}(Oe),
					Ge = function(t) {
						function e() {
							return null !== t && t.apply(this, arguments) || this
						}
						return Be(e, t), e.test = function(t) {
							var e = window.OffscreenCanvas;
							return !!(e && t instanceof e) || t instanceof HTMLCanvasElement
						}, e
					}(Fe),
					Ue = function(t) {
						function e(i, n) {
							var s = this,
								o = n || {},
								r = o.width,
								a = o.height,
								l = o.autoLoad,
								h = o.linkBaseTexture;
							if (i && i.length !== e.SIDES) throw new Error("Invalid length. Got " + i.length + ", expected 6");
							s = t.call(this, 6, {
								width: r,
								height: a
							}) || this;
							for (var u = 0; u < e.SIDES; u++) s.items[u].target = S.TEXTURE_CUBE_MAP_POSITIVE_X + u;
							return s.linkBaseTexture = !1 !== h, i && s.initFromArray(i, n), !1 !== l && s.load(), s
						}
						return Be(e, t), e.prototype.bind = function(e) {
							t.prototype.bind.call(this, e), e.target = S.TEXTURE_CUBE_MAP
						}, e.prototype.addBaseTextureAt = function(t, e, i) {
							if (void 0 === i && (i = this.linkBaseTexture), !this.items[e]) throw new Error("Index " + e + " is out of bounds");
							if (!this.linkBaseTexture || t.parentTextureArray || Object.keys(t._glTextures).length > 0) {
								if (!t.resource) throw new Error("CubeResource does not support copying of renderTexture.");
								this.addResourceAt(t.resource, e)
							} else t.target = S.TEXTURE_CUBE_MAP_POSITIVE_X + e, t.parentTextureArray = this.baseTexture, this.items[e] = t;
							return t.valid && !this.valid && this.resize(t.realWidth, t.realHeight), this.items[e] = t, this
						}, e.prototype.upload = function(t, i, n) {
							for (var s = this.itemDirtyIds, o = 0; o < e.SIDES; o++) {
								var r = this.items[o];
								s[o] < r.dirtyId && (r.valid && r.resource ? (r.resource.upload(t, r, n), s[o] = r.dirtyId) : s[o] < -1 && (t.gl.texImage2D(r.target, 0, n.internalFormat, i.realWidth, i.realHeight, 0, i.format, n.type, null), s[o] = -1))
							}
							return !0
						}, e.test = function(t) {
							return Array.isArray(t) && t.length === e.SIDES
						}, e.SIDES = 6, e
					}(De),
					We = function(t) {
						function e(e, i) {
							var n = this;
							if (i = i || {}, !(e instanceof HTMLImageElement)) {
								var s = new Image;
								Fe.crossOrigin(s, e, i.crossorigin), s.src = e, e = s
							}
							return n = t.call(this, e) || this, !e.complete && n._width && n._height && (n._width = 0, n._height = 0), n.url = e.src, n._process = null, n.preserveBitmap = !1, n.createBitmap = (void 0 !== i.createBitmap ? i.createBitmap : z.CREATE_IMAGE_BITMAP) && !!window.createImageBitmap, n.alphaMode = "number" == typeof i.alphaMode ? i.alphaMode : null, void 0 !== i.premultiplyAlpha && (n.premultiplyAlpha = i.premultiplyAlpha), n.bitmap = null, n._load = null, !1 !== i.autoLoad && n.load(), n
						}
						return Be(e, t), e.prototype.load = function(t) {
							var e = this;
							return this._load || (void 0 !== t && (this.createBitmap = t), this._load = new Promise((function(t, i) {
								var n = e.source;
								e.url = n.src;
								var s = function() {
									e.destroyed || (n.onload = null, n.onerror = null, e.resize(n.width, n.height), e._load = null, e.createBitmap ? t(e.process()) : t(e))
								};
								n.complete && n.src ? s() : (n.onload = s, n.onerror = function(t) {
									i(t), e.onError.emit(t)
								})
							}))), this._load
						}, e.prototype.process = function() {
							var t = this,
								e = this.source;
							return null !== this._process ? this._process : null === this.bitmap && window.createImageBitmap ? (this._process = window.createImageBitmap(e, 0, 0, e.width, e.height, {
								premultiplyAlpha: this.alphaMode === b.UNPACK ? "premultiply" : "none"
							}).then((function(e) {
								return t.destroyed ? Promise.reject() : (t.bitmap = e, t.update(), t._process = null, Promise.resolve(t))
							})), this._process) : Promise.resolve(this)
						}, e.prototype.upload = function(e, i, n) {
							if ("number" == typeof this.alphaMode && (i.alphaMode = this.alphaMode), !this.createBitmap) return t.prototype.upload.call(this, e, i, n);
							if (!this.bitmap && (this.process(), !this.bitmap)) return !1;
							if (t.prototype.upload.call(this, e, i, n, this.bitmap), !this.preserveBitmap) {
								var s = !0,
									o = i._glTextures;
								for (var r in o) {
									var a = o[r];
									if (a !== n && a.dirtyId !== i.dirtyId) {
										s = !1;
										break
									}
								}
								s && (this.bitmap.close && this.bitmap.close(), this.bitmap = null)
							}
							return !0
						}, e.prototype.dispose = function() {
							this.source.onload = null, this.source.onerror = null, t.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null
						}, e.test = function(t) {
							return "string" == typeof t || t instanceof HTMLImageElement
						}, e
					}(Fe),
					He = function(t) {
						function e(e, i) {
							var n = this;
							return i = i || {}, (n = t.call(this, document.createElement("canvas")) || this)._width = 0, n._height = 0, n.svg = e, n.scale = i.scale || 1, n._overrideWidth = i.width, n._overrideHeight = i.height, n._resolve = null, n._crossorigin = i.crossorigin, n._load = null, !1 !== i.autoLoad && n.load(), n
						}
						return Be(e, t), e.prototype.load = function() {
							var t = this;
							return this._load || (this._load = new Promise((function(e) {
								if (t._resolve = function() {
										t.resize(t.source.width, t.source.height), e(t)
									}, /^\<svg/.test(t.svg.trim())) {
									if (!btoa) throw new Error("Your browser doesn't support base64 conversions.");
									t.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(t.svg)))
								}
								t._loadSvg()
							}))), this._load
						}, e.prototype._loadSvg = function() {
							var t = this,
								e = new Image;
							Fe.crossOrigin(e, this.svg, this._crossorigin), e.src = this.svg, e.onerror = function(i) {
								t._resolve && (e.onerror = null, t.onError.emit(i))
							}, e.onload = function() {
								if (t._resolve) {
									var i = e.width,
										n = e.height;
									if (!i || !n) throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
									var s = i * t.scale,
										o = n * t.scale;
									(t._overrideWidth || t._overrideHeight) && (s = t._overrideWidth || t._overrideHeight / n * i, o = t._overrideHeight || t._overrideWidth / i * n), s = Math.round(s), o = Math.round(o);
									var r = t.source;
									r.width = s, r.height = o, r._pixiId = "canvas_" + bt(), r.getContext("2d").drawImage(e, 0, 0, i, n, 0, 0, s, o), t._resolve(), t._resolve = null
								}
							}
						}, e.getSize = function(t) {
							var i = e.SVG_SIZE.exec(t),
								n = {};
							return i && (n[i[1]] = Math.round(parseFloat(i[3])), n[i[5]] = Math.round(parseFloat(i[7]))), n
						}, e.prototype.dispose = function() {
							t.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null
						}, e.test = function(t, e) {
							return "svg" === e || "string" == typeof t && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(t) || "string" == typeof t && 0 === t.indexOf("<svg")
						}, e.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i, e
					}(Fe),
					Ve = function(t) {
						function e(i, n) {
							var s = this;
							if (n = n || {}, !(i instanceof HTMLVideoElement)) {
								var o = document.createElement("video");
								o.setAttribute("preload", "auto"), o.setAttribute("webkit-playsinline", ""), o.setAttribute("playsinline", ""), "string" == typeof i && (i = [i]);
								var r = i[0].src || i[0];
								Fe.crossOrigin(o, r, n.crossorigin);
								for (var a = 0; a < i.length; ++a) {
									var l = document.createElement("source"),
										h = i[a],
										u = h.src,
										c = h.mime,
										d = (u = u || i[a]).split("?").shift().toLowerCase(),
										p = d.substr(d.lastIndexOf(".") + 1);
									c = c || e.MIME_TYPES[p] || "video/" + p, l.src = u, l.type = c, o.appendChild(l)
								}
								i = o
							}
							return (s = t.call(this, i) || this).noSubImage = !0, s._autoUpdate = !0, s._isConnectedToTicker = !1, s._updateFPS = n.updateFPS || 0, s._msToNextUpdate = 0, s.autoPlay = !1 !== n.autoPlay, s._load = null, s._resolve = null, s._onCanPlay = s._onCanPlay.bind(s), s._onError = s._onError.bind(s), !1 !== n.autoLoad && s.load(), s
						}
						return Be(e, t), e.prototype.update = function(e) {
							if (void 0 === e && (e = 0), !this.destroyed) {
								var i = fe.shared.elapsedMS * this.source.playbackRate;
								this._msToNextUpdate = Math.floor(this._msToNextUpdate - i), (!this._updateFPS || this._msToNextUpdate <= 0) && (t.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0)
							}
						}, e.prototype.load = function() {
							var t = this;
							if (this._load) return this._load;
							var e = this.source;
							return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0), e.addEventListener("play", this._onPlayStart.bind(this)), e.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (e.addEventListener("canplay", this._onCanPlay), e.addEventListener("canplaythrough", this._onCanPlay), e.addEventListener("error", this._onError, !0)), this._load = new Promise((function(i) {
								t.valid ? i(t) : (t._resolve = i, e.load())
							})), this._load
						}, e.prototype._onError = function(t) {
							this.source.removeEventListener("error", this._onError, !0), this.onError.emit(t)
						}, e.prototype._isSourcePlaying = function() {
							var t = this.source;
							return t.currentTime > 0 && !1 === t.paused && !1 === t.ended && t.readyState > 2
						}, e.prototype._isSourceReady = function() {
							var t = this.source;
							return 3 === t.readyState || 4 === t.readyState
						}, e.prototype._onPlayStart = function() {
							this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (fe.shared.add(this.update, this), this._isConnectedToTicker = !0)
						}, e.prototype._onPlayStop = function() {
							this._isConnectedToTicker && (fe.shared.remove(this.update, this), this._isConnectedToTicker = !1)
						}, e.prototype._onCanPlay = function() {
							var t = this.source;
							t.removeEventListener("canplay", this._onCanPlay), t.removeEventListener("canplaythrough", this._onCanPlay);
							var e = this.valid;
							this.resize(t.videoWidth, t.videoHeight), !e && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && t.play()
						}, e.prototype.dispose = function() {
							this._isConnectedToTicker && fe.shared.remove(this.update, this);
							var e = this.source;
							e && (e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), t.prototype.dispose.call(this)
						}, Object.defineProperty(e.prototype, "autoUpdate", {
							get: function() {
								return this._autoUpdate
							},
							set: function(t) {
								t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (fe.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (fe.shared.add(this.update, this), this._isConnectedToTicker = !0))
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "updateFPS", {
							get: function() {
								return this._updateFPS
							},
							set: function(t) {
								t !== this._updateFPS && (this._updateFPS = t)
							},
							enumerable: !1,
							configurable: !0
						}), e.test = function(t, i) {
							return t instanceof HTMLVideoElement || e.TYPES.indexOf(i) > -1
						}, e.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], e.MIME_TYPES = {
							ogv: "video/ogg",
							mov: "video/quicktime",
							m4v: "video/mp4"
						}, e
					}(Fe),
					Xe = function(t) {
						function e() {
							return null !== t && t.apply(this, arguments) || this
						}
						return Be(e, t), e.test = function(t) {
							return !!window.createImageBitmap && t instanceof ImageBitmap
						}, e
					}(Fe);
				Le.push(We, Xe, Ge, Ve, He, Ne, Ue, ke);
				var Ye = {
						Resource: Oe,
						BaseImageResource: Fe,
						INSTALLED: Le,
						autoDetectResource: Ce,
						AbstractMultiResource: De,
						ArrayResource: ke,
						BufferResource: Ne,
						CanvasResource: Ge,
						CubeResource: Ue,
						ImageResource: We,
						SVGResource: He,
						VideoResource: Ve,
						ImageBitmapResource: Xe
					},
					ze = function() {
						function t(t) {
							this.renderer = t
						}
						return t.prototype.destroy = function() {
							this.renderer = null
						}, t
					}(),
					je = function(t) {
						function e() {
							return null !== t && t.apply(this, arguments) || this
						}
						return Be(e, t), e.prototype.upload = function(t, e, i) {
							var n = t.gl;
							return n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === b.UNPACK), i.width === e.width && i.height === e.height ? n.texSubImage2D(e.target, 0, 0, 0, e.width, e.height, e.format, e.type, this.data) : (i.width = e.width, i.height = e.height, n.texImage2D(e.target, 0, 1 === t.context.webGLVersion ? n.DEPTH_COMPONENT : n.DEPTH_COMPONENT16, e.width, e.height, 0, e.format, e.type, this.data)), !0
						}, e
					}(Ne),
					Ke = function() {
						function t(t, e) {
							this.width = Math.ceil(t || 100), this.height = Math.ceil(e || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new we("disposeFramebuffer"), this.multisample = L.NONE
						}
						return Object.defineProperty(t.prototype, "colorTexture", {
							get: function() {
								return this.colorTextures[0]
							},
							enumerable: !1,
							configurable: !0
						}), t.prototype.addColorTexture = function(t, e) {
							return void 0 === t && (t = 0), this.colorTextures[t] = e || new Re(null, {
								scaleMode: v.NEAREST,
								resolution: 1,
								mipmap: E.OFF,
								width: this.width,
								height: this.height
							}), this.dirtyId++, this.dirtyFormat++, this
						}, t.prototype.addDepthTexture = function(t) {
							return this.depthTexture = t || new Re(new je(null, {
								width: this.width,
								height: this.height
							}), {
								scaleMode: v.NEAREST,
								resolution: 1,
								width: this.width,
								height: this.height,
								mipmap: E.OFF,
								format: f.DEPTH_COMPONENT,
								type: y.UNSIGNED_SHORT
							}), this.dirtyId++, this.dirtyFormat++, this
						}, t.prototype.enableDepth = function() {
							return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this
						}, t.prototype.enableStencil = function() {
							return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this
						}, t.prototype.resize = function(t, e) {
							if (t = Math.ceil(t), e = Math.ceil(e), t !== this.width || e !== this.height) {
								this.width = t, this.height = e, this.dirtyId++, this.dirtySize++;
								for (var i = 0; i < this.colorTextures.length; i++) {
									var n = this.colorTextures[i],
										s = n.resolution;
									n.setSize(t / s, e / s)
								}
								this.depthTexture && (s = this.depthTexture.resolution, this.depthTexture.setSize(t / s, e / s))
							}
						}, t.prototype.dispose = function() {
							this.disposeRunner.emit(this, !1)
						}, t.prototype.destroyDepthTexture = function() {
							this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat)
						}, t
					}(),
					qe = function(t) {
						function e(e) {
							var i = this;
							"number" == typeof e && (e = {
								width: arguments[0],
								height: arguments[1],
								scaleMode: arguments[2],
								resolution: arguments[3]
							}), i = t.call(this, null, e) || this;
							var n = e || {},
								s = n.width,
								o = n.height;
							return i.mipmap = 0, i.width = Math.ceil(s) || 100, i.height = Math.ceil(o) || 100, i.valid = !0, i.clearColor = [0, 0, 0, 0], i.framebuffer = new Ke(i.width * i.resolution, i.height * i.resolution).addColorTexture(0, i), i.maskStack = [], i.filterStack = [{}], i
						}
						return Be(e, t), e.prototype.resize = function(t, e) {
							t = Math.ceil(t), e = Math.ceil(e), this.framebuffer.resize(t * this.resolution, e * this.resolution)
						}, e.prototype.dispose = function() {
							this.framebuffer.dispose(), t.prototype.dispose.call(this)
						}, e.prototype.destroy = function() {
							t.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null
						}, e
					}(Re),
					Ze = function() {
						function t() {
							this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8)
						}
						return t.prototype.set = function(t, e, i) {
							var n = e.width,
								s = e.height;
							if (i) {
								var o = t.width / 2 / n,
									r = t.height / 2 / s,
									a = t.x / n + o,
									l = t.y / s + r;
								i = ne.add(i, ne.NW), this.x0 = a + o * ne.uX(i), this.y0 = l + r * ne.uY(i), i = ne.add(i, 2), this.x1 = a + o * ne.uX(i), this.y1 = l + r * ne.uY(i), i = ne.add(i, 2), this.x2 = a + o * ne.uX(i), this.y2 = l + r * ne.uY(i), i = ne.add(i, 2), this.x3 = a + o * ne.uX(i), this.y3 = l + r * ne.uY(i)
							} else this.x0 = t.x / n, this.y0 = t.y / s, this.x1 = (t.x + t.width) / n, this.y1 = t.y / s, this.x2 = (t.x + t.width) / n, this.y2 = (t.y + t.height) / s, this.x3 = t.x / n, this.y3 = (t.y + t.height) / s;
							this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3
						}, t
					}(),
					$e = new Ze,
					Qe = function(t) {
						function e(i, n, s, o, r, a) {
							var l = t.call(this) || this;
							if (l.noFrame = !1, n || (l.noFrame = !0, n = new Ht(0, 0, 1, 1)), i instanceof e && (i = i.baseTexture), l.baseTexture = i, l._frame = n, l.trim = o, l.valid = !1, l._uvs = $e, l.uvMatrix = null, l.orig = s || n, l._rotate = Number(r || 0), !0 === r) l._rotate = 2;
							else if (l._rotate % 2 != 0) throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
							return l.defaultAnchor = a ? new jt(a.x, a.y) : new jt(0, 0), l._updateID = 0, l.textureCacheIds = [], i.valid ? l.noFrame ? i.valid && l.onBaseTextureUpdated(i) : l.frame = n : i.once("loaded", l.onBaseTextureUpdated, l), l.noFrame && i.on("update", l.onBaseTextureUpdated, l), l
						}
						return Be(e, t), e.prototype.update = function() {
							this.baseTexture.resource && this.baseTexture.resource.update()
						}, e.prototype.onBaseTextureUpdated = function(t) {
							if (this.noFrame) {
								if (!this.baseTexture.valid) return;
								this._frame.width = t.width, this._frame.height = t.height, this.valid = !0, this.updateUvs()
							} else this.frame = this._frame;
							this.emit("update", this)
						}, e.prototype.destroy = function(t) {
							if (this.baseTexture) {
								if (t) {
									var i = this.baseTexture;
									i && i.url && wt[i.url] && e.removeFromCache(i.url), this.baseTexture.destroy()
								}
								this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null
							}
							this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, e.removeFromCache(this), this.textureCacheIds = null
						}, e.prototype.clone = function() {
							return new e(this.baseTexture, this.frame.clone(), this.orig.clone(), this.trim && this.trim.clone(), this.rotate, this.defaultAnchor)
						}, e.prototype.updateUvs = function() {
							this._uvs === $e && (this._uvs = new Ze), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++
						}, e.from = function(t, i, n) {
							void 0 === i && (i = {}), void 0 === n && (n = z.STRICT_TEXTURE_CACHE);
							var s = "string" == typeof t,
								o = null;
							s ? o = t : (t._pixiId || (t._pixiId = "pixiid_" + bt()), o = t._pixiId);
							var r = wt[o];
							if (s && n && !r) throw new Error('The cacheId "' + o + '" does not exist in TextureCache.');
							return r || (i.resolution || (i.resolution = kt(t)), (r = new e(new Re(t, i))).baseTexture.cacheId = o, Re.addToCache(r.baseTexture, o), e.addToCache(r, o)), r
						}, e.fromURL = function(t, i) {
							var n = Object.assign({
									autoLoad: !1
								}, null == i ? void 0 : i.resourceOptions),
								s = e.from(t, Object.assign({
									resourceOptions: n
								}, i), !1),
								o = s.baseTexture.resource;
							return s.baseTexture.valid ? Promise.resolve(s) : o.load().then((function() {
								return Promise.resolve(s)
							}))
						}, e.fromBuffer = function(t, i, n, s) {
							return new e(Re.fromBuffer(t, i, n, s))
						}, e.fromLoader = function(t, i, n) {
							var s = new We(t);
							s.url = i;
							var o = new e(new Re(s, {
								scaleMode: z.SCALE_MODE,
								resolution: kt(i)
							}));
							return n || (n = i), Re.addToCache(o.baseTexture, n), e.addToCache(o, n), n !== i && (Re.addToCache(o.baseTexture, i), e.addToCache(o, i)), o
						}, e.addToCache = function(t, e) {
							e && (-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e), wt[e] && console.warn("Texture added to the cache with an id [" + e + "] that already had an entry"), wt[e] = t)
						}, e.removeFromCache = function(t) {
							if ("string" == typeof t) {
								var e = wt[t];
								if (e) {
									var i = e.textureCacheIds.indexOf(t);
									return i > -1 && e.textureCacheIds.splice(i, 1), delete wt[t], e
								}
							} else if (t && t.textureCacheIds) {
								for (var n = 0; n < t.textureCacheIds.length; ++n) wt[t.textureCacheIds[n]] === t && delete wt[t.textureCacheIds[n]];
								return t.textureCacheIds.length = 0, t
							}
							return null
						}, Object.defineProperty(e.prototype, "resolution", {
							get: function() {
								return this.baseTexture.resolution
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "frame", {
							get: function() {
								return this._frame
							},
							set: function(t) {
								this._frame = t, this.noFrame = !1;
								var e = t.x,
									i = t.y,
									n = t.width,
									s = t.height,
									o = e + n > this.baseTexture.width,
									r = i + s > this.baseTexture.height;
								if (o || r) {
									var a = o && r ? "and" : "or",
										l = "X: " + e + " + " + n + " = " + (e + n) + " > " + this.baseTexture.width,
										h = "Y: " + i + " + " + s + " = " + (i + s) + " > " + this.baseTexture.height;
									throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + l + " " + a + " " + h)
								}
								this.valid = n && s && this.baseTexture.valid, this.trim || this.rotate || (this.orig = t), this.valid && this.updateUvs()
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "rotate", {
							get: function() {
								return this._rotate
							},
							set: function(t) {
								this._rotate = t, this.valid && this.updateUvs()
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "width", {
							get: function() {
								return this.orig.width
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "height", {
							get: function() {
								return this.orig.height
							},
							enumerable: !1,
							configurable: !0
						}), e.prototype.castToBaseTexture = function() {
							return this.baseTexture
						}, e
					}(K());

				function Je(t) {
					t.destroy = function() {}, t.on = function() {}, t.once = function() {}, t.emit = function() {}
				}
				Qe.EMPTY = new Qe(new Re), Je(Qe.EMPTY), Je(Qe.EMPTY.baseTexture), Qe.WHITE = function() {
					var t = document.createElement("canvas");
					t.width = 16, t.height = 16;
					var e = t.getContext("2d");
					return e.fillStyle = "white", e.fillRect(0, 0, 16, 16), new Qe(new Re(new Ge(t)))
				}(), Je(Qe.WHITE), Je(Qe.WHITE.baseTexture);
				var ti = function(t) {
						function e(e, i) {
							var n = this,
								s = null;
							if (!(e instanceof qe)) {
								var o = arguments[1],
									r = arguments[2],
									a = arguments[3],
									l = arguments[4];
								console.warn("Please use RenderTexture.create(" + o + ", " + r + ") instead of the ctor directly."), s = arguments[0], i = null, e = new qe({
									width: o,
									height: r,
									scaleMode: a,
									resolution: l
								})
							}
							return (n = t.call(this, e, i) || this).legacyRenderer = s, n.valid = !0, n.filterFrame = null, n.filterPoolKey = null, n.updateUvs(), n
						}
						return Be(e, t), Object.defineProperty(e.prototype, "framebuffer", {
							get: function() {
								return this.baseTexture.framebuffer
							},
							enumerable: !1,
							configurable: !0
						}), e.prototype.resize = function(t, e, i) {
							void 0 === i && (i = !0), t = Math.ceil(t), e = Math.ceil(e), this.valid = t > 0 && e > 0, this._frame.width = this.orig.width = t, this._frame.height = this.orig.height = e, i && this.baseTexture.resize(t, e), this.updateUvs()
						}, e.prototype.setResolution = function(t) {
							var e = this.baseTexture;
							e.resolution !== t && (e.setResolution(t), this.resize(e.width, e.height, !1))
						}, e.create = function(t) {
							return "number" == typeof t && (t = {
								width: t,
								height: arguments[1],
								scaleMode: arguments[2],
								resolution: arguments[3]
							}), new e(new qe(t))
						}, e
					}(Qe),
					ei = function() {
						function t(t) {
							this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0
						}
						return t.prototype.createTexture = function(t, e) {
							var i = new qe(Object.assign({
								width: t,
								height: e,
								resolution: 1
							}, this.textureOptions));
							return new ti(i)
						}, t.prototype.getOptimalTexture = function(e, i, n) {
							void 0 === n && (n = 1);
							var s = t.SCREEN_KEY;
							e *= n, i *= n, this.enableFullScreen && e === this._pixelsWidth && i === this._pixelsHeight || (s = (65535 & (e = ft(e))) << 16 | 65535 & (i = ft(i))), this.texturePool[s] || (this.texturePool[s] = []);
							var o = this.texturePool[s].pop();
							return o || (o = this.createTexture(e, i)), o.filterPoolKey = s, o.setResolution(n), o
						}, t.prototype.getFilterTexture = function(t, e) {
							var i = this.getOptimalTexture(t.width, t.height, e || t.resolution);
							return i.filterFrame = t.filterFrame, i
						}, t.prototype.returnTexture = function(t) {
							var e = t.filterPoolKey;
							t.filterFrame = null, this.texturePool[e].push(t)
						}, t.prototype.returnFilterTexture = function(t) {
							this.returnTexture(t)
						}, t.prototype.clear = function(t) {
							if (t = !1 !== t)
								for (var e in this.texturePool) {
									var i = this.texturePool[e];
									if (i)
										for (var n = 0; n < i.length; n++) i[n].destroy(!0)
								}
							this.texturePool = {}
						}, t.prototype.setScreenSize = function(e) {
							if (e.width !== this._pixelsWidth || e.height !== this._pixelsHeight) {
								var i = t.SCREEN_KEY,
									n = this.texturePool[i];
								if (this.enableFullScreen = e.width > 0 && e.height > 0, n)
									for (var s = 0; s < n.length; s++) n[s].destroy(!0);
								this.texturePool[i] = [], this._pixelsWidth = e.width, this._pixelsHeight = e.height
							}
						}, t.SCREEN_KEY = "screen", t
					}(),
					ii = function() {
						function t(t, e, i, n, s, o, r) {
							void 0 === e && (e = 0), void 0 === i && (i = !1), void 0 === n && (n = 5126), this.buffer = t, this.size = e, this.normalized = i, this.type = n, this.stride = s, this.start = o, this.instance = r
						}
						return t.prototype.destroy = function() {
							this.buffer = null
						}, t.from = function(e, i, n, s, o) {
							return new t(e, i, n, s, o)
						}, t
					}(),
					ni = 0,
					si = function() {
						function t(t, e, i) {
							void 0 === e && (e = !0), void 0 === i && (i = !1), this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = i, this.static = e, this.id = ni++, this.disposeRunner = new we("disposeBuffer")
						}
						return t.prototype.update = function(t) {
							this.data = t || this.data, this._updateID++
						}, t.prototype.dispose = function() {
							this.disposeRunner.emit(this, !1)
						}, t.prototype.destroy = function() {
							this.dispose(), this.data = null
						}, t.from = function(e) {
							return e instanceof Array && (e = new Float32Array(e)), new t(e)
						}, t
					}();

				function oi(t) {
					if (4 === t.BYTES_PER_ELEMENT) return t instanceof Float32Array ? "Float32Array" : t instanceof Uint32Array ? "Uint32Array" : "Int32Array";
					if (2 === t.BYTES_PER_ELEMENT) {
						if (t instanceof Uint16Array) return "Uint16Array"
					} else if (1 === t.BYTES_PER_ELEMENT && t instanceof Uint8Array) return "Uint8Array";
					return null
				}
				var ri = {
						Float32Array,
						Uint32Array,
						Int32Array,
						Uint8Array
					},
					ai = {
						5126: 4,
						5123: 2,
						5121: 1
					},
					li = 0,
					hi = {
						Float32Array,
						Uint32Array,
						Int32Array,
						Uint8Array,
						Uint16Array
					},
					ui = function() {
						function t(t, e) {
							void 0 === t && (t = []), void 0 === e && (e = {}), this.buffers = t, this.indexBuffer = null, this.attributes = e, this.glVertexArrayObjects = {}, this.id = li++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new we("disposeGeometry"), this.refCount = 0
						}
						return t.prototype.addAttribute = function(t, e, i, n, s, o, r, a) {
							if (void 0 === i && (i = 0), void 0 === n && (n = !1), void 0 === a && (a = !1), !e) throw new Error("You must pass a buffer when creating an attribute");
							e instanceof si || (e instanceof Array && (e = new Float32Array(e)), e = new si(e));
							var l = t.split("|");
							if (l.length > 1) {
								for (var h = 0; h < l.length; h++) this.addAttribute(l[h], e, i, n, s);
								return this
							}
							var u = this.buffers.indexOf(e);
							return -1 === u && (this.buffers.push(e), u = this.buffers.length - 1), this.attributes[t] = new ii(u, i, n, s, o, r, a), this.instanced = this.instanced || a, this
						}, t.prototype.getAttribute = function(t) {
							return this.attributes[t]
						}, t.prototype.getBuffer = function(t) {
							return this.buffers[this.getAttribute(t).buffer]
						}, t.prototype.addIndex = function(t) {
							return t instanceof si || (t instanceof Array && (t = new Uint16Array(t)), t = new si(t)), t.index = !0, this.indexBuffer = t, -1 === this.buffers.indexOf(t) && this.buffers.push(t), this
						}, t.prototype.getIndex = function() {
							return this.indexBuffer
						}, t.prototype.interleave = function() {
							if (1 === this.buffers.length || 2 === this.buffers.length && this.indexBuffer) return this;
							var t, e = [],
								i = [],
								n = new si;
							for (t in this.attributes) {
								var s = this.attributes[t],
									o = this.buffers[s.buffer];
								e.push(o.data), i.push(s.size * ai[s.type] / 4), s.buffer = 0
							}
							for (n.data = function(t, e) {
									for (var i = 0, n = 0, s = {}, o = 0; o < t.length; o++) n += e[o], i += t[o].length;
									var r = new ArrayBuffer(4 * i),
										a = null,
										l = 0;
									for (o = 0; o < t.length; o++) {
										var h = e[o],
											u = t[o],
											c = oi(u);
										s[c] || (s[c] = new ri[c](r)), a = s[c];
										for (var d = 0; d < u.length; d++) a[(d / h | 0) * n + l + d % h] = u[d];
										l += h
									}
									return new Float32Array(r)
								}(e, i), t = 0; t < this.buffers.length; t++) this.buffers[t] !== this.indexBuffer && this.buffers[t].destroy();
							return this.buffers = [n], this.indexBuffer && this.buffers.push(this.indexBuffer), this
						}, t.prototype.getSize = function() {
							for (var t in this.attributes) {
								var e = this.attributes[t];
								return this.buffers[e.buffer].data.length / (e.stride / 4 || e.size)
							}
							return 0
						}, t.prototype.dispose = function() {
							this.disposeRunner.emit(this, !1)
						}, t.prototype.destroy = function() {
							this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null
						}, t.prototype.clone = function() {
							for (var e = new t, i = 0; i < this.buffers.length; i++) e.buffers[i] = new si(this.buffers[i].data.slice(0));
							for (var i in this.attributes) {
								var n = this.attributes[i];
								e.attributes[i] = new ii(n.buffer, n.size, n.normalized, n.type, n.stride, n.start, n.instance)
							}
							return this.indexBuffer && (e.indexBuffer = e.buffers[this.buffers.indexOf(this.indexBuffer)], e.indexBuffer.index = !0), e
						}, t.merge = function(e) {
							for (var i, n = new t, s = [], o = [], r = [], a = 0; a < e.length; a++) {
								i = e[a];
								for (var l = 0; l < i.buffers.length; l++) o[l] = o[l] || 0, o[l] += i.buffers[l].data.length, r[l] = 0
							}
							for (a = 0; a < i.buffers.length; a++) s[a] = new(hi[oi(i.buffers[a].data)])(o[a]), n.buffers[a] = new si(s[a]);
							for (a = 0; a < e.length; a++)
								for (i = e[a], l = 0; l < i.buffers.length; l++) s[l].set(i.buffers[l].data, r[l]), r[l] += i.buffers[l].data.length;
							if (n.attributes = i.attributes, i.indexBuffer) {
								n.indexBuffer = n.buffers[i.buffers.indexOf(i.indexBuffer)], n.indexBuffer.index = !0;
								var h = 0,
									u = 0,
									c = 0,
									d = 0;
								for (a = 0; a < i.buffers.length; a++)
									if (i.buffers[a] !== i.indexBuffer) {
										d = a;
										break
									} for (var a in i.attributes) {
									var p = i.attributes[a];
									(0 | p.buffer) === d && (u += p.size * ai[p.type] / 4)
								}
								for (a = 0; a < e.length; a++) {
									var _ = e[a].indexBuffer.data;
									for (l = 0; l < _.length; l++) n.indexBuffer.data[l + c] += h;
									h += i.buffers[d].data.length / u, c += _.length
								}
							}
							return n
						}, t
					}(),
					ci = function(t) {
						function e() {
							var e = t.call(this) || this;
							return e.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2]), e
						}
						return Be(e, t), e
					}(ui),
					di = function(t) {
						function e() {
							var e = t.call(this) || this;
							return e.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), e.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), e.vertexBuffer = new si(e.vertices), e.uvBuffer = new si(e.uvs), e.addAttribute("aVertexPosition", e.vertexBuffer).addAttribute("aTextureCoord", e.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e
						}
						return Be(e, t), e.prototype.map = function(t, e) {
							var i = 0,
								n = 0;
							return this.uvs[0] = i, this.uvs[1] = n, this.uvs[2] = i + e.width / t.width, this.uvs[3] = n, this.uvs[4] = i + e.width / t.width, this.uvs[5] = n + e.height / t.height, this.uvs[6] = i, this.uvs[7] = n + e.height / t.height, i = e.x, n = e.y, this.vertices[0] = i, this.vertices[1] = n, this.vertices[2] = i + e.width, this.vertices[3] = n, this.vertices[4] = i + e.width, this.vertices[5] = n + e.height, this.vertices[6] = i, this.vertices[7] = n + e.height, this.invalidate(), this
						}, e.prototype.invalidate = function() {
							return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this
						}, e
					}(ui),
					pi = 0,
					_i = function() {
						function t(t, e) {
							this.uniforms = t, this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = pi++, this.static = !!e
						}
						return t.prototype.update = function() {
							this.dirtyId++
						}, t.prototype.add = function(e, i, n) {
							this.uniforms[e] = new t(i, n)
						}, t.from = function(e, i) {
							return new t(e, i)
						}, t
					}(),
					mi = function() {
						function t() {
							this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.sourceFrame = new Ht, this.destinationFrame = new Ht, this.filters = []
						}
						return t.prototype.clear = function() {
							this.target = null, this.filters = null, this.renderTexture = null
						}, t
					}(),
					gi = function(t) {
						function e(e) {
							var i = t.call(this, e) || this;
							return i.defaultFilterStack = [{}], i.texturePool = new ei, i.texturePool.setScreenSize(e.view), i.statePool = [], i.quad = new ci, i.quadUv = new di, i.tempRect = new Ht, i.activeState = {}, i.globalUniforms = new _i({
								outputFrame: i.tempRect,
								inputSize: new Float32Array(4),
								inputPixel: new Float32Array(4),
								inputClamp: new Float32Array(4),
								resolution: 1,
								filterArea: new Float32Array(4),
								filterClamp: new Float32Array(4)
							}, !0), i.forceClear = !1, i.useMaxPadding = !1, i
						}
						return Be(e, t), e.prototype.push = function(t, e) {
							for (var i = this.renderer, n = this.defaultFilterStack, s = this.statePool.pop() || new mi, o = e[0].resolution, r = e[0].padding, a = e[0].autoFit, l = e[0].legacy, h = 1; h < e.length; h++) {
								var u = e[h];
								o = Math.min(o, u.resolution), r = this.useMaxPadding ? Math.max(r, u.padding) : r + u.padding, a = a && u.autoFit, l = l || u.legacy
							}
							1 === n.length && (this.defaultFilterStack[0].renderTexture = i.renderTexture.current), n.push(s), s.resolution = o, s.legacy = l, s.target = t, s.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), s.sourceFrame.pad(r), a && s.sourceFrame.fit(this.renderer.renderTexture.sourceFrame), s.sourceFrame.ceil(o), s.renderTexture = this.getOptimalFilterTexture(s.sourceFrame.width, s.sourceFrame.height, o), s.filters = e, s.destinationFrame.width = s.renderTexture.width, s.destinationFrame.height = s.renderTexture.height;
							var c = this.tempRect;
							c.width = s.sourceFrame.width, c.height = s.sourceFrame.height, s.renderTexture.filterFrame = s.sourceFrame, i.renderTexture.bind(s.renderTexture, s.sourceFrame, c), i.renderTexture.clear()
						}, e.prototype.pop = function() {
							var t = this.defaultFilterStack,
								e = t.pop(),
								i = e.filters;
							this.activeState = e;
							var n = this.globalUniforms.uniforms;
							n.outputFrame = e.sourceFrame, n.resolution = e.resolution;
							var s = n.inputSize,
								o = n.inputPixel,
								r = n.inputClamp;
							if (s[0] = e.destinationFrame.width, s[1] = e.destinationFrame.height, s[2] = 1 / s[0], s[3] = 1 / s[1], o[0] = s[0] * e.resolution, o[1] = s[1] * e.resolution, o[2] = 1 / o[0], o[3] = 1 / o[1], r[0] = .5 * o[2], r[1] = .5 * o[3], r[2] = e.sourceFrame.width * s[2] - .5 * o[2], r[3] = e.sourceFrame.height * s[3] - .5 * o[3], e.legacy) {
								var a = n.filterArea;
								a[0] = e.destinationFrame.width, a[1] = e.destinationFrame.height, a[2] = e.sourceFrame.x, a[3] = e.sourceFrame.y, n.filterClamp = n.inputClamp
							}
							this.globalUniforms.update();
							var l = t[t.length - 1];
							if (e.renderTexture.framebuffer.multisample > 1 && this.renderer.framebuffer.blit(), 1 === i.length) i[0].apply(this, e.renderTexture, l.renderTexture, A.BLEND, e), this.returnFilterTexture(e.renderTexture);
							else {
								var h = e.renderTexture,
									u = this.getOptimalFilterTexture(h.width, h.height, e.resolution);
								u.filterFrame = h.filterFrame;
								var c = 0;
								for (c = 0; c < i.length - 1; ++c) {
									i[c].apply(this, h, u, A.CLEAR, e);
									var d = h;
									h = u, u = d
								}
								i[c].apply(this, h, l.renderTexture, A.BLEND, e), this.returnFilterTexture(h), this.returnFilterTexture(u)
							}
							e.clear(), this.statePool.push(e)
						}, e.prototype.bindAndClear = function(t, e) {
							if (void 0 === e && (e = A.CLEAR), t && t.filterFrame) {
								var i = this.tempRect;
								i.width = t.filterFrame.width, i.height = t.filterFrame.height, this.renderer.renderTexture.bind(t, t.filterFrame, i)
							} else this.renderer.renderTexture.bind(t);
							"boolean" == typeof e && (e = e ? A.CLEAR : A.BLEND, Pt("5.2.1", "Use CLEAR_MODES when using clear applyFilter option")), (e === A.CLEAR || e === A.BLIT && this.forceClear) && this.renderer.renderTexture.clear()
						}, e.prototype.applyFilter = function(t, e, i, n) {
							var s = this.renderer;
							this.bindAndClear(i, n), t.uniforms.uSampler = e, t.uniforms.filterGlobals = this.globalUniforms, s.state.set(t.state), s.shader.bind(t), t.legacy ? (this.quadUv.map(e._frame, e.filterFrame), s.geometry.bind(this.quadUv), s.geometry.draw(g.TRIANGLES)) : (s.geometry.bind(this.quad), s.geometry.draw(g.TRIANGLE_STRIP))
						}, e.prototype.calculateSpriteMatrix = function(t, e) {
							var i = this.activeState,
								n = i.sourceFrame,
								s = i.destinationFrame,
								o = e._texture.orig,
								r = t.set(s.width, 0, 0, s.height, n.x, n.y),
								a = e.worldTransform.copyTo(qt.TEMP_MATRIX);
							return a.invert(), r.prepend(a), r.scale(1 / o.width, 1 / o.height), r.translate(e.anchor.x, e.anchor.y), r
						}, e.prototype.destroy = function() {
							this.texturePool.clear(!1)
						}, e.prototype.getOptimalFilterTexture = function(t, e, i) {
							return void 0 === i && (i = 1), this.texturePool.getOptimalTexture(t, e, i)
						}, e.prototype.getFilterTexture = function(t, e) {
							if ("number" == typeof t) {
								var i = t;
								t = e, e = i
							}
							t = t || this.activeState.renderTexture;
							var n = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution);
							return n.filterFrame = t.filterFrame, n
						}, e.prototype.returnFilterTexture = function(t) {
							this.texturePool.returnTexture(t)
						}, e.prototype.emptyPool = function() {
							this.texturePool.clear(!0)
						}, e.prototype.resize = function() {
							this.texturePool.setScreenSize(this.renderer.view)
						}, e
					}(ze),
					fi = function() {
						function t(t) {
							this.renderer = t
						}
						return t.prototype.flush = function() {}, t.prototype.destroy = function() {
							this.renderer = null
						}, t.prototype.start = function() {}, t.prototype.stop = function() {
							this.flush()
						}, t.prototype.render = function(t) {}, t
					}(),
					Si = function(t) {
						function e(e) {
							var i = t.call(this, e) || this;
							return i.emptyRenderer = new fi(e), i.currentRenderer = i.emptyRenderer, i
						}
						return Be(e, t), e.prototype.setObjectRenderer = function(t) {
							this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start())
						}, e.prototype.flush = function() {
							this.setObjectRenderer(this.emptyRenderer)
						}, e.prototype.reset = function() {
							this.setObjectRenderer(this.emptyRenderer)
						}, e.prototype.copyBoundTextures = function(t, e) {
							for (var i = this.renderer.texture.boundTextures, n = e - 1; n >= 0; --n) t[n] = i[n] || null, t[n] && (t[n]._batchLocation = n)
						}, e.prototype.boundArray = function(t, e, i, n) {
							for (var s = t.elements, o = t.ids, r = t.count, a = 0, l = 0; l < r; l++) {
								var h = s[l],
									u = h._batchLocation;
								if (u >= 0 && u < n && e[u] === h) o[l] = u;
								else
									for (; a < n;) {
										var c = e[a];
										if (!c || c._batchEnabled !== i || c._batchLocation !== a) {
											o[l] = a, h._batchLocation = a, e[a] = h;
											break
										}
										a++
									}
							}
						}, e
					}(ze),
					yi = 0,
					vi = function(t) {
						function e(e) {
							var i = t.call(this, e) || this;
							return i.webGLVersion = 1, i.extensions = {}, i.supports = {
								uint32Indices: !1
							}, i.handleContextLost = i.handleContextLost.bind(i), i.handleContextRestored = i.handleContextRestored.bind(i), e.view.addEventListener("webglcontextlost", i.handleContextLost, !1), e.view.addEventListener("webglcontextrestored", i.handleContextRestored, !1), i
						}
						return Be(e, t), Object.defineProperty(e.prototype, "isLost", {
							get: function() {
								return !this.gl || this.gl.isContextLost()
							},
							enumerable: !1,
							configurable: !0
						}), e.prototype.contextChange = function(t) {
							this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = yi++, t.isContextLost() && t.getExtension("WEBGL_lose_context") && t.getExtension("WEBGL_lose_context").restoreContext()
						}, e.prototype.initFromContext = function(t) {
							this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = yi++, this.renderer.runners.contextChange.emit(t)
						}, e.prototype.initFromOptions = function(t) {
							var e = this.createContext(this.renderer.view, t);
							this.initFromContext(e)
						}, e.prototype.createContext = function(t, e) {
							var i;
							if (z.PREFER_ENV >= d.WEBGL2 && (i = t.getContext("webgl2", e)), i) this.webGLVersion = 2;
							else if (this.webGLVersion = 1, !(i = t.getContext("webgl", e) || t.getContext("experimental-webgl", e))) throw new Error("This browser does not support WebGL. Try using the canvas renderer");
							return this.gl = i, this.getExtensions(), this.gl
						}, e.prototype.getExtensions = function() {
							var t = this.gl;
							1 === this.webGLVersion ? Object.assign(this.extensions, {
								drawBuffers: t.getExtension("WEBGL_draw_buffers"),
								depthTexture: t.getExtension("WEBGL_depth_texture"),
								loseContext: t.getExtension("WEBGL_lose_context"),
								vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
								anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
								uint32ElementIndex: t.getExtension("OES_element_index_uint"),
								floatTexture: t.getExtension("OES_texture_float"),
								floatTextureLinear: t.getExtension("OES_texture_float_linear"),
								textureHalfFloat: t.getExtension("OES_texture_half_float"),
								textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear")
							}) : 2 === this.webGLVersion && Object.assign(this.extensions, {
								anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
								colorBufferFloat: t.getExtension("EXT_color_buffer_float"),
								floatTextureLinear: t.getExtension("OES_texture_float_linear")
							})
						}, e.prototype.handleContextLost = function(t) {
							t.preventDefault()
						}, e.prototype.handleContextRestored = function() {
							this.renderer.runners.contextChange.emit(this.gl)
						}, e.prototype.destroy = function() {
							var t = this.renderer.view;
							t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext()
						}, e.prototype.postrender = function() {
							this.renderer.renderingToScreen && this.gl.flush()
						}, e.prototype.validateContext = function(t) {
							var e = t.getContextAttributes(),
								i = "WebGL2RenderingContext" in window && t instanceof window.WebGL2RenderingContext;
							i && (this.webGLVersion = 2), e.stencil || console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
							var n = i || !!t.getExtension("OES_element_index_uint");
							this.supports.uint32Indices = n, n || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly")
						}, e
					}(ze),
					Ti = function(t) {
						this.framebuffer = t, this.stencil = null, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.multisample = L.NONE, this.msaaBuffer = null, this.blitFramebuffer = null
					},
					Ei = new Ht,
					bi = function(t) {
						function e(e) {
							var i = t.call(this, e) || this;
							return i.managedFramebuffers = [], i.unknownFramebuffer = new Ke(10, 10), i.msaaSamples = null, i
						}
						return Be(e, t), e.prototype.contextChange = function() {
							var t = this.gl = this.renderer.gl;
							if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new Ht, this.hasMRT = !0, this.writeDepthTexture = !0, this.disposeAll(!0), 1 === this.renderer.context.webGLVersion) {
								var e = this.renderer.context.extensions.drawBuffers,
									i = this.renderer.context.extensions.depthTexture;
								z.PREFER_ENV === d.WEBGL_LEGACY && (e = null, i = null), e ? t.drawBuffers = function(t) {
									return e.drawBuffersWEBGL(t)
								} : (this.hasMRT = !1, t.drawBuffers = function() {}), i || (this.writeDepthTexture = !1)
							} else this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES)
						}, e.prototype.bind = function(t, e) {
							var i = this.gl;
							if (t) {
								var n = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
								this.current !== t && (this.current = t, i.bindFramebuffer(i.FRAMEBUFFER, n.framebuffer)), n.dirtyId !== t.dirtyId && (n.dirtyId = t.dirtyId, n.dirtyFormat !== t.dirtyFormat ? (n.dirtyFormat = t.dirtyFormat, this.updateFramebuffer(t)) : n.dirtySize !== t.dirtySize && (n.dirtySize = t.dirtySize, this.resizeFramebuffer(t)));
								for (var s = 0; s < t.colorTextures.length; s++) {
									var o = t.colorTextures[s];
									this.renderer.texture.unbind(o.parentTextureArray || o)
								}
								t.depthTexture && this.renderer.texture.unbind(t.depthTexture), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, t.width, t.height)
							} else this.current && (this.current = null, i.bindFramebuffer(i.FRAMEBUFFER, null)), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height)
						}, e.prototype.setViewport = function(t, e, i, n) {
							var s = this.viewport;
							s.width === i && s.height === n && s.x === t && s.y === e || (s.x = t, s.y = e, s.width = i, s.height = n, this.gl.viewport(t, e, i, n))
						}, Object.defineProperty(e.prototype, "size", {
							get: function() {
								return this.current ? {
									x: 0,
									y: 0,
									width: this.current.width,
									height: this.current.height
								} : {
									x: 0,
									y: 0,
									width: this.renderer.width,
									height: this.renderer.height
								}
							},
							enumerable: !1,
							configurable: !0
						}), e.prototype.clear = function(t, e, i, n, s) {
							void 0 === s && (s = _.COLOR | _.DEPTH);
							var o = this.gl;
							o.clearColor(t, e, i, n), o.clear(s)
						}, e.prototype.initFramebuffer = function(t) {
							var e = this.gl,
								i = new Ti(e.createFramebuffer());
							return i.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = i, this.managedFramebuffers.push(t), t.disposeRunner.add(this), i
						}, e.prototype.resizeFramebuffer = function(t) {
							var e = this.gl,
								i = t.glFramebuffers[this.CONTEXT_UID];
							i.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, i.stencil), e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height));
							for (var n = t.colorTextures, s = 0; s < n.length; s++) this.renderer.texture.bind(n[s], 0);
							t.depthTexture && this.renderer.texture.bind(t.depthTexture, 0)
						}, e.prototype.updateFramebuffer = function(t) {
							var e = this.gl,
								i = t.glFramebuffers[this.CONTEXT_UID],
								n = t.colorTextures.length;
							e.drawBuffers || (n = Math.min(n, 1)), i.multisample > 1 && (i.msaaBuffer = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, i.msaaBuffer), e.renderbufferStorageMultisample(e.RENDERBUFFER, i.multisample, e.RGBA8, t.width, t.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, i.msaaBuffer));
							for (var s = [], o = 0; o < n; o++)
								if (!(0 === o && i.multisample > 1)) {
									var r = t.colorTextures[o],
										a = r.parentTextureArray || r;
									this.renderer.texture.bind(a, 0), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + o, r.target, a._glTextures[this.CONTEXT_UID].texture, 0), s.push(e.COLOR_ATTACHMENT0 + o)
								} if (s.length > 1 && e.drawBuffers(s), t.depthTexture && this.writeDepthTexture) {
								var l = t.depthTexture;
								this.renderer.texture.bind(l, 0), e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, l._glTextures[this.CONTEXT_UID].texture, 0)
							}
							i.stencil || !t.stencil && !t.depth || (i.stencil = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, i.stencil), e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height), t.depthTexture || e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, i.stencil))
						}, e.prototype.detectSamples = function(t) {
							var e = this.msaaSamples,
								i = L.NONE;
							if (t <= 1 || null === e) return i;
							for (var n = 0; n < e.length; n++)
								if (e[n] <= t) {
									i = e[n];
									break
								} return 1 === i && (i = L.NONE), i
						}, e.prototype.blit = function(t, e, i) {
							var n = this,
								s = n.current,
								o = n.renderer,
								r = n.gl,
								a = n.CONTEXT_UID;
							if (2 === o.context.webGLVersion && s) {
								var l = s.glFramebuffers[a];
								if (l) {
									if (!t) {
										if (l.multisample <= 1) return;
										l.blitFramebuffer || (l.blitFramebuffer = new Ke(s.width, s.height), l.blitFramebuffer.addColorTexture(0, s.colorTextures[0])), (t = l.blitFramebuffer).width = s.width, t.height = s.height
									}
									e || ((e = Ei).width = s.width, e.height = s.height), i || (i = e);
									var h = e.width === i.width && e.height === i.height;
									this.bind(t), r.bindFramebuffer(r.READ_FRAMEBUFFER, l.framebuffer), r.blitFramebuffer(e.x, e.y, e.width, e.height, i.x, i.y, i.width, i.height, r.COLOR_BUFFER_BIT, h ? r.NEAREST : r.LINEAR)
								}
							}
						}, e.prototype.disposeFramebuffer = function(t, e) {
							var i = t.glFramebuffers[this.CONTEXT_UID],
								n = this.gl;
							if (i) {
								delete t.glFramebuffers[this.CONTEXT_UID];
								var s = this.managedFramebuffers.indexOf(t);
								s >= 0 && this.managedFramebuffers.splice(s, 1), t.disposeRunner.remove(this), e || (n.deleteFramebuffer(i.framebuffer), i.stencil && n.deleteRenderbuffer(i.stencil))
							}
						}, e.prototype.disposeAll = function(t) {
							var e = this.managedFramebuffers;
							this.managedFramebuffers = [];
							for (var i = 0; i < e.length; i++) this.disposeFramebuffer(e[i], t)
						}, e.prototype.forceStencil = function() {
							var t = this.current;
							if (t) {
								var e = t.glFramebuffers[this.CONTEXT_UID];
								if (e && !e.stencil) {
									t.enableStencil();
									var i = t.width,
										n = t.height,
										s = this.gl,
										o = s.createRenderbuffer();
									s.bindRenderbuffer(s.RENDERBUFFER, o), s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, i, n), e.stencil = o, s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, o)
								}
							}
						}, e.prototype.reset = function() {
							this.current = this.unknownFramebuffer, this.viewport = new Ht
						}, e
					}(ze),
					Ai = function(t) {
						this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0
					},
					Pi = {
						5126: 4,
						5123: 2,
						5121: 1
					},
					Ii = function(t) {
						function e(e) {
							var i = t.call(this, e) || this;
							return i._activeGeometry = null, i._activeVao = null, i.hasVao = !0, i.hasInstance = !0, i.canUseUInt32ElementIndex = !1, i.managedGeometries = {}, i.managedBuffers = {}, i
						}
						return Be(e, t), e.prototype.contextChange = function() {
							this.disposeAll(!0);
							var t = this.gl = this.renderer.gl,
								e = this.renderer.context;
							if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, 2 !== e.webGLVersion) {
								var i = this.renderer.context.extensions.vertexArrayObject;
								z.PREFER_ENV === d.WEBGL_LEGACY && (i = null), i ? (t.createVertexArray = function() {
									return i.createVertexArrayOES()
								}, t.bindVertexArray = function(t) {
									return i.bindVertexArrayOES(t)
								}, t.deleteVertexArray = function(t) {
									return i.deleteVertexArrayOES(t)
								}) : (this.hasVao = !1, t.createVertexArray = function() {
									return null
								}, t.bindVertexArray = function() {
									return null
								}, t.deleteVertexArray = function() {
									return null
								})
							}
							if (2 !== e.webGLVersion) {
								var n = t.getExtension("ANGLE_instanced_arrays");
								n ? (t.vertexAttribDivisor = function(t, e) {
									return n.vertexAttribDivisorANGLE(t, e)
								}, t.drawElementsInstanced = function(t, e, i, s, o) {
									return n.drawElementsInstancedANGLE(t, e, i, s, o)
								}, t.drawArraysInstanced = function(t, e, i, s) {
									return n.drawArraysInstancedANGLE(t, e, i, s)
								}) : this.hasInstance = !1
							}
							this.canUseUInt32ElementIndex = 2 === e.webGLVersion || !!e.extensions.uint32ElementIndex
						}, e.prototype.bind = function(t, e) {
							e = e || this.renderer.shader.shader;
							var i = this.gl,
								n = t.glVertexArrayObjects[this.CONTEXT_UID],
								s = !1;
							n || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = n = {}, s = !0);
							var o = n[e.program.id] || this.initGeometryVao(t, e.program, s);
							this._activeGeometry = t, this._activeVao !== o && (this._activeVao = o, this.hasVao ? i.bindVertexArray(o) : this.activateVao(t, e.program)), this.updateBuffers()
						}, e.prototype.reset = function() {
							this.unbind()
						}, e.prototype.updateBuffers = function() {
							for (var t = this._activeGeometry, e = this.gl, i = 0; i < t.buffers.length; i++) {
								var n = t.buffers[i],
									s = n._glBuffers[this.CONTEXT_UID];
								if (n._updateID !== s.updateID) {
									s.updateID = n._updateID;
									var o = n.index ? e.ELEMENT_ARRAY_BUFFER : e.ARRAY_BUFFER;
									if (e.bindBuffer(o, s.buffer), this._boundBuffer = s, s.byteLength >= n.data.byteLength) e.bufferSubData(o, 0, n.data);
									else {
										var r = n.static ? e.STATIC_DRAW : e.DYNAMIC_DRAW;
										s.byteLength = n.data.byteLength, e.bufferData(o, n.data, r)
									}
								}
							}
						}, e.prototype.checkCompatibility = function(t, e) {
							var i = t.attributes,
								n = e.attributeData;
							for (var s in n)
								if (!i[s]) throw new Error('shader and geometry incompatible, geometry missing the "' + s + '" attribute')
						}, e.prototype.getSignature = function(t, e) {
							var i = t.attributes,
								n = e.attributeData,
								s = ["g", t.id];
							for (var o in i) n[o] && s.push(o);
							return s.join("-")
						}, e.prototype.initGeometryVao = function(t, e, i) {
							void 0 === i && (i = !0), this.checkCompatibility(t, e);
							var n = this.gl,
								s = this.CONTEXT_UID,
								o = this.getSignature(t, e),
								r = t.glVertexArrayObjects[this.CONTEXT_UID],
								a = r[o];
							if (a) return r[e.id] = a, a;
							var l = t.buffers,
								h = t.attributes,
								u = {},
								c = {};
							for (var d in l) u[d] = 0, c[d] = 0;
							for (var d in h) !h[d].size && e.attributeData[d] ? h[d].size = e.attributeData[d].size : h[d].size || console.warn("PIXI Geometry attribute '" + d + "' size cannot be determined (likely the bound shader does not have the attribute)"), u[h[d].buffer] += h[d].size * Pi[h[d].type];
							for (var d in h) {
								var p = h[d],
									_ = p.size;
								void 0 === p.stride && (u[p.buffer] === _ * Pi[p.type] ? p.stride = 0 : p.stride = u[p.buffer]), void 0 === p.start && (p.start = c[p.buffer], c[p.buffer] += _ * Pi[p.type])
							}
							a = n.createVertexArray(), n.bindVertexArray(a);
							for (var m = 0; m < l.length; m++) {
								var g = l[m];
								g._glBuffers[s] || (g._glBuffers[s] = new Ai(n.createBuffer()), this.managedBuffers[g.id] = g, g.disposeRunner.add(this)), i && g._glBuffers[s].refCount++
							}
							return this.activateVao(t, e), this._activeVao = a, r[e.id] = a, r[o] = a, a
						}, e.prototype.disposeBuffer = function(t, e) {
							if (this.managedBuffers[t.id]) {
								delete this.managedBuffers[t.id];
								var i = t._glBuffers[this.CONTEXT_UID],
									n = this.gl;
								t.disposeRunner.remove(this), i && (e || n.deleteBuffer(i.buffer), delete t._glBuffers[this.CONTEXT_UID])
							}
						}, e.prototype.disposeGeometry = function(t, e) {
							if (this.managedGeometries[t.id]) {
								delete this.managedGeometries[t.id];
								var i = t.glVertexArrayObjects[this.CONTEXT_UID],
									n = this.gl,
									s = t.buffers;
								if (t.disposeRunner.remove(this), i) {
									for (var o = 0; o < s.length; o++) {
										var r = s[o]._glBuffers[this.CONTEXT_UID];
										r.refCount--, 0 !== r.refCount || e || this.disposeBuffer(s[o], e)
									}
									if (!e)
										for (var a in i)
											if ("g" === a[0]) {
												var l = i[a];
												this._activeVao === l && this.unbind(), n.deleteVertexArray(l)
											} delete t.glVertexArrayObjects[this.CONTEXT_UID]
								}
							}
						}, e.prototype.disposeAll = function(t) {
							for (var e = Object.keys(this.managedGeometries), i = 0; i < e.length; i++) this.disposeGeometry(this.managedGeometries[e[i]], t);
							for (e = Object.keys(this.managedBuffers), i = 0; i < e.length; i++) this.disposeBuffer(this.managedBuffers[e[i]], t)
						}, e.prototype.activateVao = function(t, e) {
							var i = this.gl,
								n = this.CONTEXT_UID,
								s = t.buffers,
								o = t.attributes;
							t.indexBuffer && i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, t.indexBuffer._glBuffers[n].buffer);
							var r = null;
							for (var a in o) {
								var l = o[a],
									h = s[l.buffer]._glBuffers[n];
								if (e.attributeData[a]) {
									r !== h && (i.bindBuffer(i.ARRAY_BUFFER, h.buffer), r = h);
									var u = e.attributeData[a].location;
									if (i.enableVertexAttribArray(u), i.vertexAttribPointer(u, l.size, l.type || i.FLOAT, l.normalized, l.stride, l.start), l.instance) {
										if (!this.hasInstance) throw new Error("geometry error, GPU Instancing is not supported on this device");
										i.vertexAttribDivisor(u, 1)
									}
								}
							}
						}, e.prototype.draw = function(t, e, i, n) {
							var s = this.gl,
								o = this._activeGeometry;
							if (o.indexBuffer) {
								var r = o.indexBuffer.data.BYTES_PER_ELEMENT,
									a = 2 === r ? s.UNSIGNED_SHORT : s.UNSIGNED_INT;
								2 === r || 4 === r && this.canUseUInt32ElementIndex ? o.instanced ? s.drawElementsInstanced(t, e || o.indexBuffer.data.length, a, (i || 0) * r, n || 1) : s.drawElements(t, e || o.indexBuffer.data.length, a, (i || 0) * r) : console.warn("unsupported index buffer type: uint32")
							} else o.instanced ? s.drawArraysInstanced(t, i, e || o.getSize(), n || 1) : s.drawArrays(t, i, e || o.getSize());
							return this
						}, e.prototype.unbind = function() {
							this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null
						}, e
					}(ze),
					wi = function() {
						function t(t) {
							void 0 === t && (t = null), this.type = w.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._target = null
						}
						return t.prototype.reset = function() {
							this.pooled && (this.maskObject = null, this.type = w.NONE, this.autoDetect = !0), this._target = null
						}, t.prototype.copyCountersOrReset = function(t) {
							t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null)
						}, t
					}();

				function Li(t, e, i) {
					var n = t.createShader(e);
					return t.shaderSource(n, i), t.compileShader(n), n
				}

				function Ci(t, e, i, n) {
					var s = Li(t, t.VERTEX_SHADER, e),
						o = Li(t, t.FRAGMENT_SHADER, i),
						r = t.createProgram();
					if (t.attachShader(r, s), t.attachShader(r, o), n)
						for (var a in n) t.bindAttribLocation(r, n[a], a);
					return t.linkProgram(r), t.getProgramParameter(r, t.LINK_STATUS) || (t.getShaderParameter(s, t.COMPILE_STATUS) || (console.warn(e), console.error(t.getShaderInfoLog(s))), t.getShaderParameter(o, t.COMPILE_STATUS) || (console.warn(i), console.error(t.getShaderInfoLog(o))), console.error("Pixi.js Error: Could not initialize shader."), console.error("gl.VALIDATE_STATUS", t.getProgramParameter(r, t.VALIDATE_STATUS)), console.error("gl.getError()", t.getError()), "" !== t.getProgramInfoLog(r) && console.warn("Pixi.js Warning: gl.getProgramInfoLog()", t.getProgramInfoLog(r)), t.deleteProgram(r), r = null), t.deleteShader(s), t.deleteShader(o), r
				}

				function xi(t) {
					for (var e = new Array(t), i = 0; i < e.length; i++) e[i] = !1;
					return e
				}

				function Bi(t, e) {
					switch (t) {
						case "float":
						case "int":
						case "sampler2D":
						case "sampler2DArray":
							return 0;
						case "vec2":
							return new Float32Array(2 * e);
						case "vec3":
							return new Float32Array(3 * e);
						case "vec4":
							return new Float32Array(4 * e);
						case "ivec2":
							return new Int32Array(2 * e);
						case "ivec3":
							return new Int32Array(3 * e);
						case "ivec4":
							return new Int32Array(4 * e);
						case "bool":
							return !1;
						case "bvec2":
							return xi(2 * e);
						case "bvec3":
							return xi(3 * e);
						case "bvec4":
							return xi(4 * e);
						case "mat2":
							return new Float32Array([1, 0, 0, 1]);
						case "mat3":
							return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
						case "mat4":
							return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
					}
					return null
				}
				var Oi, Ni = {},
					Mi = Ni;

				function Ri() {
					if (Mi === Ni || Mi && Mi.isContextLost()) {
						var t = document.createElement("canvas"),
							e = void 0;
						z.PREFER_ENV >= d.WEBGL2 && (e = t.getContext("webgl2", {})), e || ((e = t.getContext("webgl", {}) || t.getContext("experimental-webgl", {})) ? e.getExtension("WEBGL_draw_buffers") : e = null), Mi = e
					}
					return Mi
				}

				function Di(t, e, i) {
					if ("precision" !== t.substring(0, 9)) {
						var n = e;
						return e === I.HIGH && i !== I.HIGH && (n = I.MEDIUM), "precision " + n + " float;\n" + t
					}
					return i !== I.HIGH && "precision highp" === t.substring(0, 15) ? t.replace("precision highp", "precision mediump") : t
				}
				var ki = {
					float: 1,
					vec2: 2,
					vec3: 3,
					vec4: 4,
					int: 1,
					ivec2: 2,
					ivec3: 3,
					ivec4: 4,
					bool: 1,
					bvec2: 2,
					bvec3: 3,
					bvec4: 4,
					mat2: 4,
					mat3: 9,
					mat4: 16,
					sampler2D: 1
				};

				function Fi(t) {
					return ki[t]
				}
				var Gi = null,
					Ui = {
						FLOAT: "float",
						FLOAT_VEC2: "vec2",
						FLOAT_VEC3: "vec3",
						FLOAT_VEC4: "vec4",
						INT: "int",
						INT_VEC2: "ivec2",
						INT_VEC3: "ivec3",
						INT_VEC4: "ivec4",
						BOOL: "bool",
						BOOL_VEC2: "bvec2",
						BOOL_VEC3: "bvec3",
						BOOL_VEC4: "bvec4",
						FLOAT_MAT2: "mat2",
						FLOAT_MAT3: "mat3",
						FLOAT_MAT4: "mat4",
						SAMPLER_2D: "sampler2D",
						INT_SAMPLER_2D: "sampler2D",
						UNSIGNED_INT_SAMPLER_2D: "sampler2D",
						SAMPLER_CUBE: "samplerCube",
						INT_SAMPLER_CUBE: "samplerCube",
						UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
						SAMPLER_2D_ARRAY: "sampler2DArray",
						INT_SAMPLER_2D_ARRAY: "sampler2DArray",
						UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
					};

				function Wi(t, e) {
					if (!Gi) {
						var i = Object.keys(Ui);
						Gi = {};
						for (var n = 0; n < i.length; ++n) {
							var s = i[n];
							Gi[t[s]] = Ui[s]
						}
					}
					return Gi[e]
				}
				var Hi, Vi = [{
						test: function(t) {
							return "float" === t.type && 1 === t.size
						},
						code: function(t) {
							return '\n            if(uv["' + t + '"] !== ud["' + t + '"].value)\n            {\n                ud["' + t + '"].value = uv["' + t + '"]\n                gl.uniform1f(ud["' + t + '"].location, uv["' + t + '"])\n            }\n            '
						}
					}, {
						test: function(t) {
							return ("sampler2D" === t.type || "samplerCube" === t.type || "sampler2DArray" === t.type) && 1 === t.size && !t.isArray
						},
						code: function(t) {
							return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + t + '"], t);\n\n            if(ud["' + t + '"].value !== t)\n            {\n                ud["' + t + '"].value = t;\n                gl.uniform1i(ud["' + t + '"].location, t);\n; // eslint-disable-line max-len\n            }'
						}
					}, {
						test: function(t, e) {
							return "mat3" === t.type && 1 === t.size && void 0 !== e.a
						},
						code: function(t) {
							return '\n            gl.uniformMatrix3fv(ud["' + t + '"].location, false, uv["' + t + '"].toArray(true));\n            '
						}
					}, {
						test: function(t, e) {
							return "vec2" === t.type && 1 === t.size && void 0 !== e.x
						},
						code: function(t) {
							return '\n                cv = ud["' + t + '"].value;\n                v = uv["' + t + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + t + '"].location, v.x, v.y);\n                }'
						}
					}, {
						test: function(t) {
							return "vec2" === t.type && 1 === t.size
						},
						code: function(t) {
							return '\n                cv = ud["' + t + '"].value;\n                v = uv["' + t + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + t + '"].location, v[0], v[1]);\n                }\n            '
						}
					}, {
						test: function(t, e) {
							return "vec4" === t.type && 1 === t.size && void 0 !== e.width
						},
						code: function(t) {
							return '\n                cv = ud["' + t + '"].value;\n                v = uv["' + t + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + t + '"].location, v.x, v.y, v.width, v.height)\n                }'
						}
					}, {
						test: function(t) {
							return "vec4" === t.type && 1 === t.size
						},
						code: function(t) {
							return '\n                cv = ud["' + t + '"].value;\n                v = uv["' + t + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + t + '"].location, v[0], v[1], v[2], v[3])\n                }'
						}
					}],
					Xi = {
						float: "\n    if(cv !== v)\n    {\n        cv.v = v;\n        gl.uniform1f(location, v)\n    }",
						vec2: "\n    if(cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        gl.uniform2f(location, v[0], v[1])\n    }",
						vec3: "\n    if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
						vec4: "gl.uniform4f(location, v[0], v[1], v[2], v[3])",
						int: "gl.uniform1i(location, v)",
						ivec2: "gl.uniform2i(location, v[0], v[1])",
						ivec3: "gl.uniform3i(location, v[0], v[1], v[2])",
						ivec4: "gl.uniform4i(location, v[0], v[1], v[2], v[3])",
						bool: "gl.uniform1i(location, v)",
						bvec2: "gl.uniform2i(location, v[0], v[1])",
						bvec3: "gl.uniform3i(location, v[0], v[1], v[2])",
						bvec4: "gl.uniform4i(location, v[0], v[1], v[2], v[3])",
						mat2: "gl.uniformMatrix2fv(location, false, v)",
						mat3: "gl.uniformMatrix3fv(location, false, v)",
						mat4: "gl.uniformMatrix4fv(location, false, v)",
						sampler2D: "gl.uniform1i(location, v)",
						samplerCube: "gl.uniform1i(location, v)",
						sampler2DArray: "gl.uniform1i(location, v)"
					},
					Yi = {
						float: "gl.uniform1fv(location, v)",
						vec2: "gl.uniform2fv(location, v)",
						vec3: "gl.uniform3fv(location, v)",
						vec4: "gl.uniform4fv(location, v)",
						mat4: "gl.uniformMatrix4fv(location, false, v)",
						mat3: "gl.uniformMatrix3fv(location, false, v)",
						mat2: "gl.uniformMatrix2fv(location, false, v)",
						int: "gl.uniform1iv(location, v)",
						ivec2: "gl.uniform2iv(location, v)",
						ivec3: "gl.uniform3iv(location, v)",
						ivec4: "gl.uniform4iv(location, v)",
						bool: "gl.uniform1iv(location, v)",
						bvec2: "gl.uniform2iv(location, v)",
						bvec3: "gl.uniform3iv(location, v)",
						bvec4: "gl.uniform4iv(location, v)",
						sampler2D: "gl.uniform1iv(location, v)",
						samplerCube: "gl.uniform1iv(location, v)",
						sampler2DArray: "gl.uniform1iv(location, v)"
					},
					zi = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join("\n");

				function ji(t) {
					for (var e = "", i = 0; i < t; ++i) i > 0 && (e += "\nelse "), i < t - 1 && (e += "if(test == " + i + ".0){}");
					return e
				}

				function Ki(t, e) {
					if (0 === t) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
					for (var i = e.createShader(e.FRAGMENT_SHADER);;) {
						var n = zi.replace(/%forloop%/gi, ji(t));
						if (e.shaderSource(i, n), e.compileShader(i), e.getShaderParameter(i, e.COMPILE_STATUS)) break;
						t = t / 2 | 0
					}
					return t
				}
				var qi = 0,
					Zi = {},
					$i = function() {
						function t(e, i, n) {
							void 0 === n && (n = "pixi-shader"), this.id = qi++, this.vertexSrc = e || t.defaultVertexSrc, this.fragmentSrc = i || t.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), "#version" !== this.vertexSrc.substring(0, 8) && (n = n.replace(/\s+/g, "-"), Zi[n] ? (Zi[n]++, n += "-" + Zi[n]) : Zi[n] = 1, this.vertexSrc = "#define SHADER_NAME " + n + "\n" + this.vertexSrc, this.fragmentSrc = "#define SHADER_NAME " + n + "\n" + this.fragmentSrc, this.vertexSrc = Di(this.vertexSrc, z.PRECISION_VERTEX, I.HIGH), this.fragmentSrc = Di(this.fragmentSrc, z.PRECISION_FRAGMENT, function() {
								if (!Oi) {
									Oi = I.MEDIUM;
									var t = Ri();
									if (t && t.getShaderPrecisionFormat) {
										var e = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT);
										Oi = e.precision ? I.HIGH : I.MEDIUM
									}
								}
								return Oi
							}())), this.extractData(this.vertexSrc, this.fragmentSrc), this.glPrograms = {}, this.syncUniforms = null
						}
						return t.prototype.extractData = function(t, e) {
							var i = Ri();
							if (i) {
								var n = Ci(i, t, e);
								this.attributeData = this.getAttributeData(n, i), this.uniformData = this.getUniformData(n, i), i.deleteProgram(n)
							} else this.uniformData = {}, this.attributeData = {}
						}, t.prototype.getAttributeData = function(t, e) {
							for (var i = {}, n = [], s = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), o = 0; o < s; o++) {
								var r = e.getActiveAttrib(t, o),
									a = Wi(e, r.type),
									l = {
										type: a,
										name: r.name,
										size: Fi(a),
										location: 0
									};
								i[r.name] = l, n.push(l)
							}
							for (n.sort((function(t, e) {
									return t.name > e.name ? 1 : -1
								})), o = 0; o < n.length; o++) n[o].location = o;
							return i
						}, t.prototype.getUniformData = function(t, e) {
							for (var i = {}, n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), s = 0; s < n; s++) {
								var o = e.getActiveUniform(t, s),
									r = o.name.replace(/\[.*?\]$/, ""),
									a = o.name.match(/\[.*?\]$/),
									l = Wi(e, o.type);
								i[r] = {
									type: l,
									size: o.size,
									isArray: a,
									value: Bi(l, o.size)
								}
							}
							return i
						}, Object.defineProperty(t, "defaultVertexSrc", {
							get: function() {
								return "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n"
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t, "defaultFragmentSrc", {
							get: function() {
								return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}"
							},
							enumerable: !1,
							configurable: !0
						}), t.from = function(e, i, n) {
							var s = e + i,
								o = It[s];
							return o || (It[s] = o = new t(e, i, n)), o
						}, t
					}(),
					Qi = function() {
						function t(t, e) {
							for (var i in this.program = t, this.uniformGroup = e ? e instanceof _i ? e : new _i(e) : new _i({}), t.uniformData) this.uniformGroup.uniforms[i] instanceof Array && (this.uniformGroup.uniforms[i] = new Float32Array(this.uniformGroup.uniforms[i]))
						}
						return t.prototype.checkUniformExists = function(t, e) {
							if (e.uniforms[t]) return !0;
							for (var i in e.uniforms) {
								var n = e.uniforms[i];
								if (n.group && this.checkUniformExists(t, n)) return !0
							}
							return !1
						}, t.prototype.destroy = function() {
							this.uniformGroup = null
						}, Object.defineProperty(t.prototype, "uniforms", {
							get: function() {
								return this.uniformGroup.uniforms
							},
							enumerable: !1,
							configurable: !0
						}), t.from = function(e, i, n) {
							return new t($i.from(e, i), n)
						}, t
					}(),
					Ji = function() {
						function t() {
							this.data = 0, this.blendMode = m.NORMAL, this.polygonOffset = 0, this.blend = !0
						}
						return Object.defineProperty(t.prototype, "blend", {
							get: function() {
								return !!(1 & this.data)
							},
							set: function(t) {
								!!(1 & this.data) !== t && (this.data ^= 1)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "offsets", {
							get: function() {
								return !!(2 & this.data)
							},
							set: function(t) {
								!!(2 & this.data) !== t && (this.data ^= 2)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "culling", {
							get: function() {
								return !!(4 & this.data)
							},
							set: function(t) {
								!!(4 & this.data) !== t && (this.data ^= 4)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "depthTest", {
							get: function() {
								return !!(8 & this.data)
							},
							set: function(t) {
								!!(8 & this.data) !== t && (this.data ^= 8)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "clockwiseFrontFace", {
							get: function() {
								return !!(16 & this.data)
							},
							set: function(t) {
								!!(16 & this.data) !== t && (this.data ^= 16)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "blendMode", {
							get: function() {
								return this._blendMode
							},
							set: function(t) {
								this.blend = t !== m.NONE, this._blendMode = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "polygonOffset", {
							get: function() {
								return this._polygonOffset
							},
							set: function(t) {
								this.offsets = !!t, this._polygonOffset = t
							},
							enumerable: !1,
							configurable: !0
						}), t.for2d = function() {
							var e = new t;
							return e.depthTest = !1, e.blend = !0, e
						}, t
					}(),
					tn = function(t) {
						function e(i, n, s) {
							var o = this,
								r = $i.from(i || e.defaultVertexSrc, n || e.defaultFragmentSrc);
							return (o = t.call(this, r, s) || this).padding = 0, o.resolution = z.FILTER_RESOLUTION, o.enabled = !0, o.autoFit = !0, o.legacy = !!o.program.attributeData.aTextureCoord, o.state = new Ji, o
						}
						return Be(e, t), e.prototype.apply = function(t, e, i, n, s) {
							t.applyFilter(this, e, i, n)
						}, Object.defineProperty(e.prototype, "blendMode", {
							get: function() {
								return this.state.blendMode
							},
							set: function(t) {
								this.state.blendMode = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e, "defaultVertexSrc", {
							get: function() {
								return "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n"
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e, "defaultFragmentSrc", {
							get: function() {
								return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n"
							},
							enumerable: !1,
							configurable: !0
						}), e
					}(Qi),
					en = new qt,
					nn = function() {
						function t(t, e) {
							this._texture = t, this.mapCoord = new qt, this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = void 0 === e ? .5 : e, this.isSimple = !1
						}
						return Object.defineProperty(t.prototype, "texture", {
							get: function() {
								return this._texture
							},
							set: function(t) {
								this._texture = t, this._textureID = -1
							},
							enumerable: !1,
							configurable: !0
						}), t.prototype.multiplyUvs = function(t, e) {
							void 0 === e && (e = t);
							for (var i = this.mapCoord, n = 0; n < t.length; n += 2) {
								var s = t[n],
									o = t[n + 1];
								e[n] = s * i.a + o * i.c + i.tx, e[n + 1] = s * i.b + o * i.d + i.ty
							}
							return e
						}, t.prototype.update = function(t) {
							var e = this._texture;
							if (!e || !e.valid) return !1;
							if (!t && this._textureID === e._updateID) return !1;
							this._textureID = e._updateID, this._updateID++;
							var i = e._uvs;
							this.mapCoord.set(i.x1 - i.x0, i.y1 - i.y0, i.x3 - i.x0, i.y3 - i.y0, i.x0, i.y0);
							var n = e.orig,
								s = e.trim;
							s && (en.set(n.width / s.width, 0, 0, n.height / s.height, -s.x / s.width, -s.y / s.height), this.mapCoord.append(en));
							var o = e.baseTexture,
								r = this.uClampFrame,
								a = this.clampMargin / o.resolution,
								l = this.clampOffset;
							return r[0] = (e._frame.x + a + l) / o.width, r[1] = (e._frame.y + a + l) / o.height, r[2] = (e._frame.x + e._frame.width - a + l) / o.width, r[3] = (e._frame.y + e._frame.height - a + l) / o.height, this.uClampOffset[0] = l / o.realWidth, this.uClampOffset[1] = l / o.realHeight, this.isSimple = e._frame.width === o.width && e._frame.height === o.height && 0 === e.rotate, !0
						}, t
					}(),
					sn = function(t) {
						function e(e) {
							var i = this,
								n = new qt;
							return i = t.call(this, "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n", "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n") || this, e.renderable = !1, i.maskSprite = e, i.maskMatrix = n, i
						}
						return Be(e, t), e.prototype.apply = function(t, e, i, n) {
							var s = this.maskSprite,
								o = s._texture;
							o.valid && (o.uvMatrix || (o.uvMatrix = new nn(o, 0)), o.uvMatrix.update(), this.uniforms.npmAlpha = o.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = o, this.uniforms.otherMatrix = t.calculateSpriteMatrix(this.maskMatrix, s).prepend(o.uvMatrix.mapCoord), this.uniforms.alpha = s.worldAlpha, this.uniforms.maskClamp = o.uvMatrix.uClampFrame, t.applyFilter(this, e, i, n))
						}, e
					}(tn),
					on = function(t) {
						function e(e) {
							var i = t.call(this, e) || this;
							return i.enableScissor = !1, i.alphaMaskPool = [], i.maskDataPool = [], i.maskStack = [], i.alphaMaskIndex = 0, i
						}
						return Be(e, t), e.prototype.setMaskStack = function(t) {
							this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t)
						}, e.prototype.push = function(t, e) {
							var i = e;
							if (!i.isMaskData) {
								var n = this.maskDataPool.pop() || new wi;
								n.pooled = !0, n.maskObject = e, i = n
							}
							switch (i.autoDetect && this.detect(i), i.copyCountersOrReset(this.maskStack[this.maskStack.length - 1]), i._target = t, i.type) {
								case w.SCISSOR:
									this.maskStack.push(i), this.renderer.scissor.push(i);
									break;
								case w.STENCIL:
									this.maskStack.push(i), this.renderer.stencil.push(i);
									break;
								case w.SPRITE:
									i.copyCountersOrReset(null), this.pushSpriteMask(i), this.maskStack.push(i)
							}
						}, e.prototype.pop = function(t) {
							var e = this.maskStack.pop();
							if (e && e._target === t) {
								switch (e.type) {
									case w.SCISSOR:
										this.renderer.scissor.pop();
										break;
									case w.STENCIL:
										this.renderer.stencil.pop(e.maskObject);
										break;
									case w.SPRITE:
										this.popSpriteMask()
								}
								e.reset(), e.pooled && this.maskDataPool.push(e)
							}
						}, e.prototype.detect = function(t) {
							var e = t.maskObject;
							if (e.isSprite) t.type = w.SPRITE;
							else if (t.type = w.STENCIL, this.enableScissor && e.isFastRect && e.isFastRect()) {
								var i = e.worldTransform,
									n = Math.atan2(i.b, i.a),
									s = Math.atan2(i.d, i.c);
								n = Math.round(n * (180 / Math.PI) * 100), s = ((s = Math.round(s * (180 / Math.PI) * 100) - n) % 18e3 + 18e3) % 18e3, 0 == (n = (n % 9e3 + 9e3) % 9e3) && 9e3 === s && (t.type = w.SCISSOR)
							}
						}, e.prototype.pushSpriteMask = function(t) {
							var e = t.maskObject,
								i = t._target,
								n = this.alphaMaskPool[this.alphaMaskIndex];
							n || (n = this.alphaMaskPool[this.alphaMaskIndex] = [new sn(e)]), n[0].resolution = this.renderer.resolution, n[0].maskSprite = e;
							var s = i.filterArea;
							i.filterArea = e.getBounds(!0), this.renderer.filter.push(i, n), i.filterArea = s, this.alphaMaskIndex++
						}, e.prototype.popSpriteMask = function() {
							this.renderer.filter.pop(), this.alphaMaskIndex--
						}, e
					}(ze),
					rn = function(t) {
						function e(e) {
							var i = t.call(this, e) || this;
							return i.maskStack = [], i.glConst = 0, i
						}
						return Be(e, t), e.prototype.getStackLength = function() {
							return this.maskStack.length
						}, e.prototype.setMaskStack = function(t) {
							var e = this.renderer.gl,
								i = this.getStackLength();
							this.maskStack = t;
							var n = this.getStackLength();
							n !== i && (0 === n ? e.disable(this.glConst) : (e.enable(this.glConst), this._useCurrent()))
						}, e.prototype._useCurrent = function() {}, e.prototype.destroy = function() {
							t.prototype.destroy.call(this), this.maskStack = null
						}, e
					}(ze),
					an = function(t) {
						function e(e) {
							var i = t.call(this, e) || this;
							return i.glConst = WebGLRenderingContext.SCISSOR_TEST, i
						}
						return Be(e, t), e.prototype.getStackLength = function() {
							var t = this.maskStack[this.maskStack.length - 1];
							return t ? t._scissorCounter : 0
						}, e.prototype.push = function(t) {
							var e = t.maskObject;
							e.renderable = !0;
							var i = t._scissorRect,
								n = e.getBounds(!0),
								s = this.renderer.gl;
							e.renderable = !1, i ? n.fit(i) : s.enable(s.SCISSOR_TEST), t._scissorCounter++, t._scissorRect = n, this._useCurrent()
						}, e.prototype.pop = function() {
							var t = this.renderer.gl;
							this.getStackLength() > 0 ? this._useCurrent() : t.disable(t.SCISSOR_TEST)
						}, e.prototype._useCurrent = function() {
							var t = this.maskStack[this.maskStack.length - 1]._scissorRect,
								e = this.renderer.renderTexture.current,
								i = this.renderer.projection,
								n = i.transform,
								s = i.sourceFrame,
								o = i.destinationFrame,
								r = e ? e.resolution : this.renderer.resolution,
								a = (t.x - s.x) * r + o.x,
								l = (t.y - s.y) * r + o.y,
								h = t.width * r,
								u = t.height * r;
							n && (a += n.tx * r, l += n.ty * r), e || (l = this.renderer.height - u - l), this.renderer.gl.scissor(a, l, h, u)
						}, e
					}(rn),
					ln = function(t) {
						function e(e) {
							var i = t.call(this, e) || this;
							return i.glConst = WebGLRenderingContext.STENCIL_TEST, i
						}
						return Be(e, t), e.prototype.getStackLength = function() {
							var t = this.maskStack[this.maskStack.length - 1];
							return t ? t._stencilCounter : 0
						}, e.prototype.push = function(t) {
							var e = t.maskObject,
								i = this.renderer.gl,
								n = t._stencilCounter;
							0 === n && (this.renderer.framebuffer.forceStencil(), i.enable(i.STENCIL_TEST)), t._stencilCounter++, i.colorMask(!1, !1, !1, !1), i.stencilFunc(i.EQUAL, n, this._getBitwiseMask()), i.stencilOp(i.KEEP, i.KEEP, i.INCR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, this._useCurrent()
						}, e.prototype.pop = function(t) {
							var e = this.renderer.gl;
							0 === this.getStackLength() ? (e.disable(e.STENCIL_TEST), e.clear(e.STENCIL_BUFFER_BIT), e.clearStencil(0)) : (e.colorMask(!1, !1, !1, !1), e.stencilOp(e.KEEP, e.KEEP, e.DECR), t.renderable = !0, t.render(this.renderer), this.renderer.batch.flush(), t.renderable = !1, this._useCurrent())
						}, e.prototype._useCurrent = function() {
							var t = this.renderer.gl;
							t.colorMask(!0, !0, !0, !0), t.stencilFunc(t.EQUAL, this.getStackLength(), this._getBitwiseMask()), t.stencilOp(t.KEEP, t.KEEP, t.KEEP)
						}, e.prototype._getBitwiseMask = function() {
							return (1 << this.getStackLength()) - 1
						}, e
					}(rn),
					hn = function(t) {
						function e(e) {
							var i = t.call(this, e) || this;
							return i.destinationFrame = null, i.sourceFrame = null, i.defaultFrame = null, i.projectionMatrix = new qt, i.transform = null, i
						}
						return Be(e, t), e.prototype.update = function(t, e, i, n) {
							this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = e || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, i, n), this.transform && this.projectionMatrix.append(this.transform);
							var s = this.renderer;
							s.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, s.globalUniforms.update(), s.shader.shader && s.shader.syncUniformGroup(s.shader.shader.uniforms.globals)
						}, e.prototype.calculateProjection = function(t, e, i, n) {
							var s = this.projectionMatrix,
								o = n ? -1 : 1;
							s.identity(), s.a = 1 / e.width * 2, s.d = o * (1 / e.height * 2), s.tx = -1 - e.x * s.a, s.ty = -o - e.y * s.d
						}, e.prototype.setTransform = function(t) {}, e
					}(ze),
					un = new Ht,
					cn = new Ht,
					dn = new Ht,
					pn = function(t) {
						function e(e) {
							var i = t.call(this, e) || this;
							return i.clearColor = e._backgroundColorRgba, i.defaultMaskStack = [], i.current = null, i.sourceFrame = new Ht, i.destinationFrame = new Ht, i
						}
						return Be(e, t), e.prototype.bind = function(t, e, i) {
							void 0 === t && (t = null);
							var n, s, o, r = this.renderer;
							this.current = t, t ? (o = (n = t.baseTexture).resolution, e || (un.width = t.frame.width, un.height = t.frame.height, e = un), i || (cn.x = t.frame.x, cn.y = t.frame.y, cn.width = e.width, cn.height = e.height, i = cn), s = n.framebuffer) : (o = r.resolution, e || (un.width = r.screen.width, un.height = r.screen.height, e = un), i || ((i = un).width = e.width, i.height = e.height)), dn.x = i.x * o, dn.y = i.y * o, dn.width = i.width * o, dn.height = i.height * o, this.renderer.framebuffer.bind(s, dn), this.renderer.projection.update(i, e, o, !s), t ? this.renderer.mask.setMaskStack(n.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e), this.destinationFrame.copyFrom(i)
						}, e.prototype.clear = function(t, e) {
							t = this.current ? t || this.current.baseTexture.clearColor : t || this.clearColor, this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e)
						}, e.prototype.resize = function() {
							this.bind(null)
						}, e.prototype.reset = function() {
							this.bind(null)
						}, e
					}(ze),
					_n = function() {},
					mn = function() {
						function t(t, e) {
							this.program = t, this.uniformData = e, this.uniformGroups = {}
						}
						return t.prototype.destroy = function() {
							this.uniformData = null, this.uniformGroups = null, this.program = null
						}, t
					}(),
					gn = 0,
					fn = {
						textureCount: 0
					},
					Sn = function(t) {
						function e(e) {
							var i = t.call(this, e) || this;
							return i.destroyed = !1, i.systemCheck(), i.gl = null, i.shader = null, i.program = null, i.cache = {}, i.id = gn++, i
						}
						return Be(e, t), e.prototype.systemCheck = function() {
							if (! function() {
									if ("boolean" == typeof Hi) return Hi;
									try {
										var t = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
										Hi = !0 === t({
											a: "b"
										}, "a", "b")
									} catch (t) {
										Hi = !1
									}
									return Hi
								}()) throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.")
						}, e.prototype.contextChange = function(t) {
							this.gl = t, this.reset()
						}, e.prototype.bind = function(t, e) {
							t.uniforms.globals = this.renderer.globalUniforms;
							var i = t.program,
								n = i.glPrograms[this.renderer.CONTEXT_UID] || this.generateShader(t);
							return this.shader = t, this.program !== i && (this.program = i, this.gl.useProgram(n.program)), e || (fn.textureCount = 0, this.syncUniformGroup(t.uniformGroup, fn)), n
						}, e.prototype.setUniforms = function(t) {
							var e = this.shader.program,
								i = e.glPrograms[this.renderer.CONTEXT_UID];
							e.syncUniforms(i.uniformData, t, this.renderer)
						}, e.prototype.syncUniformGroup = function(t, e) {
							var i = this.getglProgram();
							t.static && t.dirtyId === i.uniformGroups[t.id] || (i.uniformGroups[t.id] = t.dirtyId, this.syncUniforms(t, i, e))
						}, e.prototype.syncUniforms = function(t, e, i) {
							(t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(e.uniformData, t.uniforms, this.renderer, i)
						}, e.prototype.createSyncGroups = function(t) {
							var e = this.getSignature(t, this.shader.program.uniformData);
							return this.cache[e] || (this.cache[e] = function(t, e) {
								var i = ["\n        var v = null;\n        var cv = null\n        var t = 0;\n        var gl = renderer.gl\n    "];
								for (var n in t.uniforms) {
									var s = e[n];
									if (s) {
										for (var o = t.uniforms[n], r = !1, a = 0; a < Vi.length; a++)
											if (Vi[a].test(s, o)) {
												i.push(Vi[a].code(n, o)), r = !0;
												break
											} if (!r) {
											var l = (1 === s.size ? Xi : Yi)[s.type].replace("location", 'ud["' + n + '"].location');
											i.push('\n            cv = ud["' + n + '"].value;\n            v = uv["' + n + '"];\n            ' + l + ";")
										}
									} else t.uniforms[n].group && i.push('\n                    renderer.shader.syncUniformGroup(uv["' + n + '"], syncData);\n                ')
								}
								return new Function("ud", "uv", "renderer", "syncData", i.join("\n"))
							}(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[e], t.syncUniforms[this.shader.program.id]
						}, e.prototype.getSignature = function(t, e) {
							var i = t.uniforms,
								n = [];
							for (var s in i) n.push(s), e[s] && n.push(e[s].type);
							return n.join("-")
						}, e.prototype.getglProgram = function() {
							return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null
						}, e.prototype.generateShader = function(t) {
							var e = this.gl,
								i = t.program,
								n = {};
							for (var s in i.attributeData) n[s] = i.attributeData[s].location;
							var o = Ci(e, i.vertexSrc, i.fragmentSrc, n),
								r = {};
							for (var s in i.uniformData) {
								var a = i.uniformData[s];
								r[s] = {
									location: e.getUniformLocation(o, s),
									value: Bi(a.type, a.size)
								}
							}
							var l = new mn(o, r);
							return i.glPrograms[this.renderer.CONTEXT_UID] = l, l
						}, e.prototype.reset = function() {
							this.program = null, this.shader = null
						}, e.prototype.destroy = function() {
							this.destroyed = !0
						}, e
					}(ze),
					yn = function(t) {
						function e(e) {
							var i = t.call(this, e) || this;
							return i.gl = null, i.stateId = 0, i.polygonOffset = 0, i.blendMode = m.NONE, i._blendEq = !1, i.map = [], i.map[0] = i.setBlend, i.map[1] = i.setOffset, i.map[2] = i.setCullFace, i.map[3] = i.setDepthTest, i.map[4] = i.setFrontFace, i.checks = [], i.defaultState = new Ji, i.defaultState.blend = !0, i
						}
						return Be(e, t), e.prototype.contextChange = function(t) {
							this.gl = t, this.blendModes = function(t, e) {
								return void 0 === e && (e = []), e[m.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[m.ADD] = [t.ONE, t.ONE], e[m.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[m.SCREEN] = [t.ONE, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[m.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[m.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[m.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[m.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[m.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[m.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[m.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[m.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[m.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[m.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[m.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[m.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[m.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[m.NONE] = [0, 0], e[m.NORMAL_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[m.ADD_NPM] = [t.SRC_ALPHA, t.ONE, t.ONE, t.ONE], e[m.SCREEN_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[m.SRC_IN] = [t.DST_ALPHA, t.ZERO], e[m.SRC_OUT] = [t.ONE_MINUS_DST_ALPHA, t.ZERO], e[m.SRC_ATOP] = [t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA], e[m.DST_OVER] = [t.ONE_MINUS_DST_ALPHA, t.ONE], e[m.DST_IN] = [t.ZERO, t.SRC_ALPHA], e[m.DST_OUT] = [t.ZERO, t.ONE_MINUS_SRC_ALPHA], e[m.DST_ATOP] = [t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA], e[m.XOR] = [t.ONE_MINUS_DST_ALPHA, t.ONE_MINUS_SRC_ALPHA], e[m.SUBTRACT] = [t.ONE, t.ONE, t.ONE, t.ONE, t.FUNC_REVERSE_SUBTRACT, t.FUNC_ADD], e
							}(t), this.set(this.defaultState), this.reset()
						}, e.prototype.set = function(t) {
							if (t = t || this.defaultState, this.stateId !== t.data) {
								for (var e = this.stateId ^ t.data, i = 0; e;) 1 & e && this.map[i].call(this, !!(t.data & 1 << i)), e >>= 1, i++;
								this.stateId = t.data
							}
							for (i = 0; i < this.checks.length; i++) this.checks[i](this, t)
						}, e.prototype.forceState = function(t) {
							t = t || this.defaultState;
							for (var e = 0; e < this.map.length; e++) this.map[e].call(this, !!(t.data & 1 << e));
							for (e = 0; e < this.checks.length; e++) this.checks[e](this, t);
							this.stateId = t.data
						}, e.prototype.setBlend = function(t) {
							this.updateCheck(e.checkBlendMode, t), this.gl[t ? "enable" : "disable"](this.gl.BLEND)
						}, e.prototype.setOffset = function(t) {
							this.updateCheck(e.checkPolygonOffset, t), this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL)
						}, e.prototype.setDepthTest = function(t) {
							this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST)
						}, e.prototype.setCullFace = function(t) {
							this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE)
						}, e.prototype.setFrontFace = function(t) {
							this.gl.frontFace(this.gl[t ? "CW" : "CCW"])
						}, e.prototype.setBlendMode = function(t) {
							if (t !== this.blendMode) {
								this.blendMode = t;
								var e = this.blendModes[t],
									i = this.gl;
								2 === e.length ? i.blendFunc(e[0], e[1]) : i.blendFuncSeparate(e[0], e[1], e[2], e[3]), 6 === e.length ? (this._blendEq = !0, i.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD))
							}
						}, e.prototype.setPolygonOffset = function(t, e) {
							this.gl.polygonOffset(t, e)
						}, e.prototype.reset = function() {
							this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0)
						}, e.prototype.updateCheck = function(t, e) {
							var i = this.checks.indexOf(t);
							e && -1 === i ? this.checks.push(t) : e || -1 === i || this.checks.splice(i, 1)
						}, e.checkBlendMode = function(t, e) {
							t.setBlendMode(e.blendMode)
						}, e.checkPolygonOffset = function(t, e) {
							t.setPolygonOffset(1, e.polygonOffset)
						}, e
					}(ze),
					vn = function(t) {
						function e(e) {
							var i = t.call(this, e) || this;
							return i.count = 0, i.checkCount = 0, i.maxIdle = z.GC_MAX_IDLE, i.checkCountMax = z.GC_MAX_CHECK_COUNT, i.mode = z.GC_MODE, i
						}
						return Be(e, t), e.prototype.postrender = function() {
							this.renderer.renderingToScreen && (this.count++, this.mode !== P.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())))
						}, e.prototype.run = function() {
							for (var t = this.renderer.texture, e = t.managedTextures, i = !1, n = 0; n < e.length; n++) {
								var s = e[n];
								!s.framebuffer && this.count - s.touched > this.maxIdle && (t.destroyTexture(s, !0), e[n] = null, i = !0)
							}
							if (i) {
								var o = 0;
								for (n = 0; n < e.length; n++) null !== e[n] && (e[o++] = e[n]);
								e.length = o
							}
						}, e.prototype.unload = function(t) {
							var e = this.renderer.texture,
								i = t._texture;
							i && !i.framebuffer && e.destroyTexture(i);
							for (var n = t.children.length - 1; n >= 0; n--) this.unload(t.children[n])
						}, e
					}(ze),
					Tn = function(t) {
						this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = 6408, this.internalFormat = 5121
					},
					En = function(t) {
						function e(e) {
							var i = t.call(this, e) || this;
							return i.boundTextures = [], i.currentLocation = -1, i.managedTextures = [], i._unknownBoundTextures = !1, i.unknownTexture = new Re, i
						}
						return Be(e, t), e.prototype.contextChange = function() {
							var t = this.gl = this.renderer.gl;
							this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion;
							var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
							this.boundTextures.length = e;
							for (var i = 0; i < e; i++) this.boundTextures[i] = null;
							this.emptyTextures = {};
							var n = new Tn(t.createTexture());
							for (t.bindTexture(t.TEXTURE_2D, n.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = n, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new Tn(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture), i = 0; i < 6; i++) t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);
							for (t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR), i = 0; i < this.boundTextures.length; i++) this.bind(null, i)
						}, e.prototype.bind = function(t, e) {
							void 0 === e && (e = 0);
							var i = this.gl;
							if (t) {
								if ((t = t.castToBaseTexture()).parentTextureArray) return;
								if (t.valid) {
									t.touched = this.renderer.textureGC.count;
									var n = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
									this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e, i.activeTexture(i.TEXTURE0 + e)), i.bindTexture(t.target, n.texture)), n.dirtyId !== t.dirtyId && (this.currentLocation !== e && (this.currentLocation = e, i.activeTexture(i.TEXTURE0 + e)), this.updateTexture(t)), this.boundTextures[e] = t
								}
							} else this.currentLocation !== e && (this.currentLocation = e, i.activeTexture(i.TEXTURE0 + e)), i.bindTexture(i.TEXTURE_2D, this.emptyTextures[i.TEXTURE_2D].texture), this.boundTextures[e] = null
						}, e.prototype.reset = function() {
							this._unknownBoundTextures = !0, this.currentLocation = -1;
							for (var t = 0; t < this.boundTextures.length; t++) this.boundTextures[t] = this.unknownTexture
						}, e.prototype.unbind = function(t) {
							var e = this.gl,
								i = this.boundTextures;
							if (this._unknownBoundTextures) {
								this._unknownBoundTextures = !1;
								for (var n = 0; n < i.length; n++) i[n] === this.unknownTexture && this.bind(null, n)
							}
							for (n = 0; n < i.length; n++) i[n] === t && (this.currentLocation !== n && (e.activeTexture(e.TEXTURE0 + n), this.currentLocation = n), e.bindTexture(t.target, this.emptyTextures[t.target].texture), i[n] = null)
						}, e.prototype.initTexture = function(t) {
							var e = new Tn(this.gl.createTexture());
							return e.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = e, this.managedTextures.push(t), t.on("dispose", this.destroyTexture, this), e
						}, e.prototype.initTextureType = function(t, e) {
							if (e.internalFormat = t.format, e.type = t.type, 2 === this.webGLVersion) {
								var i = this.renderer.gl;
								t.type === i.FLOAT && t.format === i.RGBA && (e.internalFormat = i.RGBA32F), t.type === y.HALF_FLOAT && (e.type = i.HALF_FLOAT), e.type === i.HALF_FLOAT && t.format === i.RGBA && (e.internalFormat = i.RGBA16F)
							}
						}, e.prototype.updateTexture = function(t) {
							var e = t._glTextures[this.CONTEXT_UID];
							if (e) {
								var i = this.renderer;
								if (this.initTextureType(t, e), t.resource && t.resource.upload(i, t, e));
								else {
									var n = t.realWidth,
										s = t.realHeight,
										o = i.gl;
									(e.width !== n || e.height !== s || e.dirtyId < 0) && (e.width = n, e.height = s, o.texImage2D(t.target, 0, e.internalFormat, n, s, 0, t.format, e.type, null))
								}
								t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t), e.dirtyId = t.dirtyId
							}
						}, e.prototype.destroyTexture = function(t, e) {
							var i = this.gl;
							if ((t = t.castToBaseTexture())._glTextures[this.CONTEXT_UID] && (this.unbind(t), i.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off("dispose", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !e)) {
								var n = this.managedTextures.indexOf(t); - 1 !== n && vt(this.managedTextures, n, 1)
							}
						}, e.prototype.updateTextureStyle = function(t) {
							var e = t._glTextures[this.CONTEXT_UID];
							e && (t.mipmap !== E.POW2 && 2 === this.webGLVersion || t.isPowerOfTwo ? e.mipmap = t.mipmap >= 1 : e.mipmap = !1, 2 === this.webGLVersion || t.isPowerOfTwo ? e.wrapMode = t.wrapMode : e.wrapMode = T.CLAMP, t.resource && t.resource.style(this.renderer, t, e) || this.setStyle(t, e), e.dirtyStyleId = t.dirtyStyleId)
						}, e.prototype.setStyle = function(t, e) {
							var i = this.gl;
							if (e.mipmap && i.generateMipmap(t.target), i.texParameteri(t.target, i.TEXTURE_WRAP_S, e.wrapMode), i.texParameteri(t.target, i.TEXTURE_WRAP_T, e.wrapMode), e.mipmap) {
								i.texParameteri(t.target, i.TEXTURE_MIN_FILTER, t.scaleMode === v.LINEAR ? i.LINEAR_MIPMAP_LINEAR : i.NEAREST_MIPMAP_NEAREST);
								var n = this.renderer.context.extensions.anisotropicFiltering;
								if (n && t.anisotropicLevel > 0 && t.scaleMode === v.LINEAR) {
									var s = Math.min(t.anisotropicLevel, i.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
									i.texParameterf(t.target, n.TEXTURE_MAX_ANISOTROPY_EXT, s)
								}
							} else i.texParameteri(t.target, i.TEXTURE_MIN_FILTER, t.scaleMode === v.LINEAR ? i.LINEAR : i.NEAREST);
							i.texParameteri(t.target, i.TEXTURE_MAG_FILTER, t.scaleMode === v.LINEAR ? i.LINEAR : i.NEAREST)
						}, e
					}(ze),
					bn = {
						FilterSystem: gi,
						BatchSystem: Si,
						ContextSystem: vi,
						FramebufferSystem: bi,
						GeometrySystem: Ii,
						MaskSystem: on,
						ScissorSystem: an,
						StencilSystem: ln,
						ProjectionSystem: hn,
						RenderTextureSystem: pn,
						ShaderSystem: Sn,
						StateSystem: yn,
						TextureGCSystem: vn,
						TextureSystem: En
					},
					An = new qt,
					Pn = function(t) {
						function e(e, i) {
							void 0 === e && (e = p.UNKNOWN);
							var n = t.call(this) || this;
							return (i = Object.assign({}, z.RENDER_OPTIONS, i)).roundPixels && (z.ROUND_PIXELS = i.roundPixels, Pt("5.0.0", "Renderer roundPixels option is deprecated, please use PIXI.settings.ROUND_PIXELS", 2)), n.options = i, n.type = e, n.screen = new Ht(0, 0, i.width, i.height), n.view = i.view || document.createElement("canvas"), n.resolution = i.resolution || z.RESOLUTION, n.transparent = i.transparent, n.autoDensity = i.autoDensity || i.autoResize || !1, n.preserveDrawingBuffer = i.preserveDrawingBuffer, n.clearBeforeRender = i.clearBeforeRender, n._backgroundColor = 0, n._backgroundColorRgba = [0, 0, 0, 0], n._backgroundColorString = "#000000", n.backgroundColor = i.backgroundColor || n._backgroundColor, n._lastObjectRendered = null, n.plugins = {}, n
						}
						return Be(e, t), e.prototype.initPlugins = function(t) {
							for (var e in t) this.plugins[e] = new t[e](this)
						}, Object.defineProperty(e.prototype, "width", {
							get: function() {
								return this.view.width
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "height", {
							get: function() {
								return this.view.height
							},
							enumerable: !1,
							configurable: !0
						}), e.prototype.resize = function(t, e) {
							this.screen.width = t, this.screen.height = e, this.view.width = t * this.resolution, this.view.height = e * this.resolution, this.autoDensity && (this.view.style.width = t + "px", this.view.style.height = e + "px"), this.emit("resize", t, e)
						}, e.prototype.generateTexture = function(t, e, i, n) {
							0 === (n = n || t.getLocalBounds(null, !0)).width && (n.width = 1), 0 === n.height && (n.height = 1);
							var s = ti.create({
								width: 0 | n.width,
								height: 0 | n.height,
								scaleMode: e,
								resolution: i
							});
							return An.tx = -n.x, An.ty = -n.y, this.render(t, s, !1, An, !!t.parent), s
						}, e.prototype.destroy = function(t) {
							for (var e in this.plugins) this.plugins[e].destroy(), this.plugins[e] = null;
							t && this.view.parentNode && this.view.parentNode.removeChild(this.view);
							var i = this;
							i.plugins = null, i.type = p.UNKNOWN, i.view = null, i.screen = null, i._tempDisplayObjectParent = null, i.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null
						}, Object.defineProperty(e.prototype, "backgroundColor", {
							get: function() {
								return this._backgroundColor
							},
							set: function(t) {
								this._backgroundColor = t, this._backgroundColorString = ot(t), st(t, this._backgroundColorRgba)
							},
							enumerable: !1,
							configurable: !0
						}), e
					}(K()),
					In = function(t) {
						function e(i) {
							var n = t.call(this, p.WEBGL, i) || this;
							return i = n.options, n.gl = null, n.CONTEXT_UID = 0, n.runners = {
								destroy: new we("destroy"),
								contextChange: new we("contextChange"),
								reset: new we("reset"),
								update: new we("update"),
								postrender: new we("postrender"),
								prerender: new we("prerender"),
								resize: new we("resize")
							}, n.globalUniforms = new _i({
								projectionMatrix: new qt
							}, !0), n.addSystem(on, "mask").addSystem(vi, "context").addSystem(yn, "state").addSystem(Sn, "shader").addSystem(En, "texture").addSystem(Ii, "geometry").addSystem(bi, "framebuffer").addSystem(an, "scissor").addSystem(ln, "stencil").addSystem(hn, "projection").addSystem(vn, "textureGC").addSystem(gi, "filter").addSystem(pn, "renderTexture").addSystem(Si, "batch"), n.initPlugins(e.__plugins), i.context ? n.context.initFromContext(i.context) : n.context.initFromOptions({
								alpha: !!n.transparent,
								antialias: i.antialias,
								premultipliedAlpha: n.transparent && "notMultiplied" !== n.transparent,
								stencil: !0,
								preserveDrawingBuffer: i.preserveDrawingBuffer,
								powerPreference: n.options.powerPreference
							}), n.renderingToScreen = !0, it(2 === n.context.webGLVersion ? "WebGL 2" : "WebGL 1"), n.resize(n.options.width, n.options.height), n
						}
						return Be(e, t), e.create = function(t) {
							if (nt()) return new e(t);
							throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.')
						}, e.prototype.addSystem = function(t, e) {
							e || (e = t.name);
							var i = new t(this);
							if (this[e]) throw new Error('Whoops! The name "' + e + '" is already in use');
							for (var n in this[e] = i, this.runners) this.runners[n].add(i);
							return this
						}, e.prototype.render = function(t, e, i, n, s) {
							if (this.renderingToScreen = !e, this.runners.prerender.emit(), this.emit("prerender"), this.projection.transform = n, !this.context.isLost) {
								if (e || (this._lastObjectRendered = t), !s) {
									var o = t.enableTempParent();
									t.updateTransform(), t.disableTempParent(o)
								}
								this.renderTexture.bind(e), this.batch.currentRenderer.start(), (void 0 !== i ? i : this.clearBeforeRender) && this.renderTexture.clear(), t.render(this), this.batch.currentRenderer.flush(), e && e.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit("postrender")
							}
						}, e.prototype.resize = function(e, i) {
							t.prototype.resize.call(this, e, i), this.runners.resize.emit(e, i)
						}, e.prototype.reset = function() {
							return this.runners.reset.emit(), this
						}, e.prototype.clear = function() {
							this.renderTexture.bind(), this.renderTexture.clear()
						}, e.prototype.destroy = function(e) {
							for (var i in this.runners.destroy.emit(), this.runners) this.runners[i].destroy();
							t.prototype.destroy.call(this, e), this.gl = null
						}, e.registerPlugin = function(t, i) {
							e.__plugins = e.__plugins || {}, e.__plugins[t] = i
						}, e
					}(Pn);

				function wn(t) {
					return In.create(t)
				}
				var Ln = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",
					Cn = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n",
					xn = function() {
						this.texArray = null, this.blend = 0, this.type = g.TRIANGLES, this.start = 0, this.size = 0, this.data = null
					},
					Bn = function() {
						function t() {
							this.elements = [], this.ids = [], this.count = 0
						}
						return t.prototype.clear = function() {
							for (var t = 0; t < this.count; t++) this.elements[t] = null;
							this.count = 0
						}, t
					}(),
					On = function() {
						function t(t) {
							this.rawBinaryData = new ArrayBuffer(t), this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData)
						}
						return Object.defineProperty(t.prototype, "int8View", {
							get: function() {
								return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "uint8View", {
							get: function() {
								return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "int16View", {
							get: function() {
								return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "uint16View", {
							get: function() {
								return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "int32View", {
							get: function() {
								return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View
							},
							enumerable: !1,
							configurable: !0
						}), t.prototype.view = function(t) {
							return this[t + "View"]
						}, t.prototype.destroy = function() {
							this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null
						}, t.sizeOf = function(t) {
							switch (t) {
								case "int8":
								case "uint8":
									return 1;
								case "int16":
								case "uint16":
									return 2;
								case "int32":
								case "uint32":
								case "float32":
									return 4;
								default:
									throw new Error(t + " isn't a valid view type")
							}
						}, t
					}(),
					Nn = function(t) {
						function e(e) {
							var i = t.call(this, e) || this;
							return i.shaderGenerator = null, i.geometryClass = null, i.vertexSize = null, i.state = Ji.for2d(), i.size = 4 * z.SPRITE_BATCH_SIZE, i._vertexCount = 0, i._indexCount = 0, i._bufferedElements = [], i._bufferedTextures = [], i._bufferSize = 0, i._shader = null, i._packedGeometries = [], i._packedGeometryPoolSize = 2, i._flushId = 0, i._aBuffers = {}, i._iBuffers = {}, i.MAX_TEXTURES = 1, i.renderer.on("prerender", i.onPrerender, i), e.runners.contextChange.add(i), i._dcIndex = 0, i._aIndex = 0, i._iIndex = 0, i._attributeBuffer = null, i._indexBuffer = null, i._tempBoundTextures = [], i
						}
						return Be(e, t), e.prototype.contextChange = function() {
							var t = this.renderer.gl;
							z.PREFER_ENV === d.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), z.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = Ki(this.MAX_TEXTURES, t)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
							for (var e = 0; e < this._packedGeometryPoolSize; e++) this._packedGeometries[e] = new this.geometryClass;
							this.initFlushBuffers()
						}, e.prototype.initFlushBuffers = function() {
							for (var t = e._drawCallPool, i = e._textureArrayPool, n = this.size / 4, s = Math.floor(n / this.MAX_TEXTURES) + 1; t.length < n;) t.push(new xn);
							for (; i.length < s;) i.push(new Bn);
							for (var o = 0; o < this.MAX_TEXTURES; o++) this._tempBoundTextures[o] = null
						}, e.prototype.onPrerender = function() {
							this._flushId = 0
						}, e.prototype.render = function(t) {
							t._texture.valid && (this._vertexCount + t.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += t.vertexData.length / 2, this._indexCount += t.indices.length, this._bufferedTextures[this._bufferSize] = t._texture.baseTexture, this._bufferedElements[this._bufferSize++] = t)
						}, e.prototype.buildTexturesAndDrawCalls = function() {
							var t = this._bufferedTextures,
								i = this.MAX_TEXTURES,
								n = e._textureArrayPool,
								s = this.renderer.batch,
								o = this._tempBoundTextures,
								r = this.renderer.textureGC.count,
								a = ++Re._globalBatch,
								l = 0,
								h = n[0],
								u = 0;
							s.copyBoundTextures(o, i);
							for (var c = 0; c < this._bufferSize; ++c) {
								var d = t[c];
								t[c] = null, d._batchEnabled !== a && (h.count >= i && (s.boundArray(h, o, a, i), this.buildDrawCalls(h, u, c), u = c, h = n[++l], ++a), d._batchEnabled = a, d.touched = r, h.elements[h.count++] = d)
							}
							for (h.count > 0 && (s.boundArray(h, o, a, i), this.buildDrawCalls(h, u, this._bufferSize), ++l, ++a), c = 0; c < o.length; c++) o[c] = null;
							Re._globalBatch = a
						}, e.prototype.buildDrawCalls = function(t, i, n) {
							var s = this,
								o = s._bufferedElements,
								r = s._attributeBuffer,
								a = s._indexBuffer,
								l = s.vertexSize,
								h = e._drawCallPool,
								u = this._dcIndex,
								c = this._aIndex,
								d = this._iIndex,
								p = h[u];
							p.start = this._iIndex, p.texArray = t;
							for (var _ = i; _ < n; ++_) {
								var m = o[_],
									g = m._texture.baseTexture,
									f = lt[g.alphaMode ? 1 : 0][m.blendMode];
								o[_] = null, i < _ && p.blend !== f && (p.size = d - p.start, i = _, (p = h[++u]).texArray = t, p.start = d), this.packInterleavedGeometry(m, r, a, c, d), c += m.vertexData.length / 2 * l, d += m.indices.length, p.blend = f
							}
							i < n && (p.size = d - p.start, ++u), this._dcIndex = u, this._aIndex = c, this._iIndex = d
						}, e.prototype.bindAndClearTexArray = function(t) {
							for (var e = this.renderer.texture, i = 0; i < t.count; i++) e.bind(t.elements[i], t.ids[i]), t.elements[i] = null;
							t.count = 0
						}, e.prototype.updateGeometry = function() {
							var t = this,
								e = t._packedGeometries,
								i = t._attributeBuffer,
								n = t._indexBuffer;
							z.CAN_UPLOAD_SAME_BUFFER ? (e[this._flushId]._buffer.update(i.rawBinaryData), e[this._flushId]._indexBuffer.update(n), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, e[this._flushId] = new this.geometryClass), e[this._flushId]._buffer.update(i.rawBinaryData), e[this._flushId]._indexBuffer.update(n), this.renderer.geometry.bind(e[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++)
						}, e.prototype.drawBatches = function() {
							for (var t = this._dcIndex, i = this.renderer, n = i.gl, s = i.state, o = e._drawCallPool, r = null, a = 0; a < t; a++) {
								var l = o[a],
									h = l.texArray,
									u = l.type,
									c = l.size,
									d = l.start,
									p = l.blend;
								r !== h && (r = h, this.bindAndClearTexArray(h)), this.state.blendMode = p, s.set(this.state), n.drawElements(u, c, n.UNSIGNED_SHORT, 2 * d)
							}
						}, e.prototype.flush = function() {
							0 !== this._vertexCount && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0)
						}, e.prototype.start = function() {
							this.renderer.state.set(this.state), this.renderer.shader.bind(this._shader), z.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId])
						}, e.prototype.stop = function() {
							this.flush()
						}, e.prototype.destroy = function() {
							for (var e = 0; e < this._packedGeometryPoolSize; e++) this._packedGeometries[e] && this._packedGeometries[e].destroy();
							this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), t.prototype.destroy.call(this)
						}, e.prototype.getAttributeBuffer = function(t) {
							var e = ft(Math.ceil(t / 8)),
								i = yt(e),
								n = 8 * e;
							this._aBuffers.length <= i && (this._iBuffers.length = i + 1);
							var s = this._aBuffers[n];
							return s || (this._aBuffers[n] = s = new On(n * this.vertexSize * 4)), s
						}, e.prototype.getIndexBuffer = function(t) {
							var e = ft(Math.ceil(t / 12)),
								i = yt(e),
								n = 12 * e;
							this._iBuffers.length <= i && (this._iBuffers.length = i + 1);
							var s = this._iBuffers[i];
							return s || (this._iBuffers[i] = s = new Uint16Array(n)), s
						}, e.prototype.packInterleavedGeometry = function(t, e, i, n, s) {
							for (var o = e.uint32View, r = e.float32View, a = n / this.vertexSize, l = t.uvs, h = t.indices, u = t.vertexData, c = t._texture.baseTexture._batchLocation, d = Math.min(t.worldAlpha, 1), p = d < 1 && t._texture.baseTexture.alphaMode ? ct(t._tintRGB, d) : t._tintRGB + (255 * d << 24), _ = 0; _ < u.length; _ += 2) r[n++] = u[_], r[n++] = u[_ + 1], r[n++] = l[_], r[n++] = l[_ + 1], o[n++] = p, r[n++] = c;
							for (_ = 0; _ < h.length; _++) i[s++] = a + h[_]
						}, e._drawCallPool = [], e._textureArrayPool = [], e
					}(fi),
					Mn = function() {
						function t(t, e) {
							if (this.vertexSrc = t, this.fragTemplate = e, this.programCache = {}, this.defaultGroupCache = {}, e.indexOf("%count%") < 0) throw new Error('Fragment template must contain "%count%".');
							if (e.indexOf("%forloop%") < 0) throw new Error('Fragment template must contain "%forloop%".')
						}
						return t.prototype.generateShader = function(t) {
							if (!this.programCache[t]) {
								for (var e = new Int32Array(t), i = 0; i < t; i++) e[i] = i;
								this.defaultGroupCache[t] = _i.from({
									uSamplers: e
								}, !0);
								var n = this.fragTemplate;
								n = (n = n.replace(/%count%/gi, "" + t)).replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new $i(this.vertexSrc, n)
							}
							var s = {
								tint: new Float32Array([1, 1, 1, 1]),
								translationMatrix: new qt,
								default: this.defaultGroupCache[t]
							};
							return new Qi(this.programCache[t], s)
						}, t.prototype.generateSampleSrc = function(t) {
							var e = "";
							e += "\n", e += "\n";
							for (var i = 0; i < t; i++) i > 0 && (e += "\nelse "), i < t - 1 && (e += "if(vTextureId < " + i + ".5)"), e += "\n{", e += "\n\tcolor = texture2D(uSamplers[" + i + "], vTextureCoord);", e += "\n}";
							return (e += "\n") + "\n"
						}, t
					}(),
					Rn = function(t) {
						function e(e) {
							void 0 === e && (e = !1);
							var i = t.call(this) || this;
							return i._buffer = new si(null, e, !1), i._indexBuffer = new si(null, e, !0), i.addAttribute("aVertexPosition", i._buffer, 2, !1, y.FLOAT).addAttribute("aTextureCoord", i._buffer, 2, !1, y.FLOAT).addAttribute("aColor", i._buffer, 4, !0, y.UNSIGNED_BYTE).addAttribute("aTextureId", i._buffer, 1, !0, y.FLOAT).addIndex(i._indexBuffer), i
						}
						return Be(e, t), e
					}(ui),
					Dn = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n",
					kn = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n",
					Fn = function() {
						function t() {}
						return t.create = function(t) {
							var e = Object.assign({
									vertex: Dn,
									fragment: kn,
									geometryClass: Rn,
									vertexSize: 6
								}, t),
								i = e.vertex,
								n = e.fragment,
								s = e.vertexSize,
								o = e.geometryClass;
							return function(t) {
								function e(e) {
									var r = t.call(this, e) || this;
									return r.shaderGenerator = new Mn(i, n), r.geometryClass = o, r.vertexSize = s, r
								}
								return Be(e, t), e
							}(Nn)
						}, Object.defineProperty(t, "defaultVertexSrc", {
							get: function() {
								return Dn
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t, "defaultFragmentTemplate", {
							get: function() {
								return kn
							},
							enumerable: !1,
							configurable: !0
						}), t
					}(),
					Gn = Fn.create(),
					Un = function() {
						function t(e) {
							var i = this;
							e = Object.assign({
								forceCanvas: !1
							}, e), this.renderer = wn(e), this.stage = new ce, t._plugins.forEach((function(t) {
								t.init.call(i, e)
							}))
						}
						return t.registerPlugin = function(e) {
							t._plugins.push(e)
						}, t.prototype.render = function() {
							this.renderer.render(this.stage)
						}, Object.defineProperty(t.prototype, "view", {
							get: function() {
								return this.renderer.view
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "screen", {
							get: function() {
								return this.renderer.screen
							},
							enumerable: !1,
							configurable: !0
						}), t.prototype.destroy = function(e, i) {
							var n = this,
								s = t._plugins.slice(0);
							s.reverse(), s.forEach((function(t) {
								t.destroy.call(n)
							})), this.stage.destroy(i), this.stage = null, this.renderer.destroy(e), this.renderer = null
						}, t
					}();
				Un._plugins = [];
				var Wn = function() {
					function t() {}
					return t.init = function(t) {
						var e = this;
						Object.defineProperty(this, "resizeTo", {
							set: function(t) {
								window.removeEventListener("resize", this.queueResize), this._resizeTo = t, t && (window.addEventListener("resize", this.queueResize), this.resize())
							},
							get: function() {
								return this._resizeTo
							}
						}), this.queueResize = function() {
							e._resizeTo && (e.cancelResize(), e._resizeId = requestAnimationFrame((function() {
								return e.resize()
							})))
						}, this.cancelResize = function() {
							e._resizeId && (cancelAnimationFrame(e._resizeId), e._resizeId = null)
						}, this.resize = function() {
							if (e._resizeTo) {
								var t, i;
								if (e.cancelResize(), e._resizeTo === window) t = window.innerWidth, i = window.innerHeight;
								else {
									var n = e._resizeTo;
									t = n.clientWidth, i = n.clientHeight
								}
								e.renderer.resize(t, i)
							}
						}, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null
					}, t.destroy = function() {
						window.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null
					}, t
				}();
				Un.registerPlugin(Wn);
				var Hn = new Ht,
					Vn = function() {
						function t(t) {
							this.renderer = t, t.extract = this
						}
						return t.prototype.image = function(t, e, i) {
							var n = new Image;
							return n.src = this.base64(t, e, i), n
						}, t.prototype.base64 = function(t, e, i) {
							return this.canvas(t).toDataURL(e, i)
						}, t.prototype.canvas = function(e) {
							var i, n, s, o = this.renderer,
								r = !1,
								a = !1;
							e && (e instanceof ti ? s = e : (s = this.renderer.generateTexture(e), a = !0)), s ? (i = s.baseTexture.resolution, n = s.frame, r = !1, o.renderTexture.bind(s)) : (i = this.renderer.resolution, r = !0, (n = Hn).width = this.renderer.width, n.height = this.renderer.height, o.renderTexture.bind(null));
							var l = Math.floor(n.width * i + 1e-4),
								h = Math.floor(n.height * i + 1e-4),
								u = new Bt(l, h, 1),
								c = new Uint8Array(4 * l * h),
								d = o.gl;
							d.readPixels(n.x * i, n.y * i, l, h, d.RGBA, d.UNSIGNED_BYTE, c);
							var p = u.context.getImageData(0, 0, l, h);
							if (t.arrayPostDivide(c, p.data), u.context.putImageData(p, 0, 0), r) {
								var _ = new Bt(u.width, u.height, 1);
								_.context.scale(1, -1), _.context.drawImage(u.canvas, 0, -h), u.destroy(), u = _
							}
							return a && s.destroy(!0), u.canvas
						}, t.prototype.pixels = function(e) {
							var i, n, s, o = this.renderer,
								r = !1;
							e && (e instanceof ti ? s = e : (s = this.renderer.generateTexture(e), r = !0)), s ? (i = s.baseTexture.resolution, n = s.frame, o.renderTexture.bind(s)) : (i = o.resolution, (n = Hn).width = o.width, n.height = o.height, o.renderTexture.bind(null));
							var a = n.width * i,
								l = n.height * i,
								h = new Uint8Array(4 * a * l),
								u = o.gl;
							return u.readPixels(n.x * i, n.y * i, a, l, u.RGBA, u.UNSIGNED_BYTE, h), r && s.destroy(!0), t.arrayPostDivide(h, h), h
						}, t.prototype.destroy = function() {
							this.renderer.extract = null, this.renderer = null
						}, t.arrayPostDivide = function(t, e) {
							for (var i = 0; i < t.length; i += 4) {
								var n = e[i + 3] = t[i + 3];
								0 !== n ? (e[i] = Math.round(Math.min(255 * t[i] / n, 255)), e[i + 1] = Math.round(Math.min(255 * t[i + 1] / n, 255)), e[i + 2] = Math.round(Math.min(255 * t[i + 2] / n, 255))) : (e[i] = t[i], e[i + 1] = t[i + 1], e[i + 2] = t[i + 2])
							}
						}, t
					}(),
					Xn = i(84678),
					Yn = i.n(Xn),
					zn = i(6755),
					jn = i.n(zn);

				function Kn() {}

				function qn(t, e, i, n) {
					var s = 0,
						o = t.length;
					! function r(a) {
						a || s === o ? i && i(a) : n ? setTimeout((function() {
							e(t[s++], r)
						}), 1) : e(t[s++], r)
					}()
				}

				function Zn(t) {
					return function() {
						if (null === t) throw new Error("Callback was already called.");
						var e = t;
						t = null, e.apply(this, arguments)
					}
				}
				var $n = {};

				function Qn(t, e) {
					for (var i = 0; i < e.length; i++) {
						var n = e[i];
						n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
					}
				}

				function Jn(t, e, i) {
					return e && Qn(t.prototype, e), i && Qn(t, i), t
				}
				var ts = !(!window.XDomainRequest || "withCredentials" in new XMLHttpRequest),
					es = null;

				function is() {}
				var ns = function() {
					function t(e, i, n) {
						if ("string" != typeof e || "string" != typeof i) throw new Error("Both name and url are required for constructing a resource.");
						n = n || {}, this._flags = 0, this._setFlag(t.STATUS_FLAGS.DATA_URL, 0 === i.indexOf("data:")), this.name = e, this.url = i, this.extension = this._getExtension(), this.data = null, this.crossOrigin = !0 === n.crossOrigin ? "anonymous" : n.crossOrigin, this.timeout = n.timeout || 0, this.loadType = n.loadType || this._determineLoadType(), this.xhrType = n.xhrType, this.metadata = n.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = t.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = is, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new(jn()), this.onProgress = new(jn()), this.onComplete = new(jn()), this.onAfterMiddleware = new(jn())
					}
					t.setExtensionLoadType = function(e, i) {
						ss(t._loadTypeMap, e, i)
					}, t.setExtensionXhrType = function(e, i) {
						ss(t._xhrTypeMap, e, i)
					};
					var e = t.prototype;
					return e.complete = function() {
						this._clearEvents(), this._finish()
					}, e.abort = function(e) {
						if (!this.error) {
							if (this.error = new Error(e), this._clearEvents(), this.xhr) this.xhr.abort();
							else if (this.xdr) this.xdr.abort();
							else if (this.data)
								if (this.data.src) this.data.src = t.EMPTY_GIF;
								else
									for (; this.data.firstChild;) this.data.removeChild(this.data.firstChild);
							this._finish()
						}
					}, e.load = function(e) {
						var i = this;
						if (!this.isLoading)
							if (this.isComplete) e && setTimeout((function() {
								return e(i)
							}), 1);
							else switch (e && this.onComplete.once(e), this._setFlag(t.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), !1 !== this.crossOrigin && "string" == typeof this.crossOrigin || (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {
								case t.LOAD_TYPE.IMAGE:
									this.type = t.TYPE.IMAGE, this._loadElement("image");
									break;
								case t.LOAD_TYPE.AUDIO:
									this.type = t.TYPE.AUDIO, this._loadSourceElement("audio");
									break;
								case t.LOAD_TYPE.VIDEO:
									this.type = t.TYPE.VIDEO, this._loadSourceElement("video");
									break;
								case t.LOAD_TYPE.XHR:
								default:
									ts && this.crossOrigin ? this._loadXdr() : this._loadXhr()
							}
					}, e._hasFlag = function(t) {
						return !!(this._flags & t)
					}, e._setFlag = function(t, e) {
						this._flags = e ? this._flags | t : this._flags & ~t
					}, e._clearEvents = function() {
						clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener("error", this._boundOnError, !1), this.data.removeEventListener("load", this._boundComplete, !1), this.data.removeEventListener("progress", this._boundOnProgress, !1), this.data.removeEventListener("canplaythrough", this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener("error", this._boundXhrOnError, !1), this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, !1), this.xhr.removeEventListener("abort", this._boundXhrOnAbort, !1), this.xhr.removeEventListener("progress", this._boundOnProgress, !1), this.xhr.removeEventListener("load", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null))
					}, e._finish = function() {
						if (this.isComplete) throw new Error("Complete called again for an already completed resource.");
						this._setFlag(t.STATUS_FLAGS.COMPLETE, !0), this._setFlag(t.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this)
					}, e._loadElement = function(t) {
						this.metadata.loadElement ? this.data = this.metadata.loadElement : "image" === t && void 0 !== window.Image ? this.data = new Image : this.data = document.createElement(t), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout))
					}, e._loadSourceElement = function(t) {
						if (this.metadata.loadElement ? this.data = this.metadata.loadElement : "audio" === t && void 0 !== window.Audio ? this.data = new Audio : this.data = document.createElement(t), null !== this.data) {
							if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource)
								if (navigator.isCocoonJS) this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
								else if (Array.isArray(this.url))
								for (var e = this.metadata.mimeType, i = 0; i < this.url.length; ++i) this.data.appendChild(this._createSource(t, this.url[i], Array.isArray(e) ? e[i] : e));
							else {
								var n = this.metadata.mimeType;
								this.data.appendChild(this._createSource(t, this.url, Array.isArray(n) ? n[0] : n))
							}
							this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.data.addEventListener("canplaythrough", this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout))
						} else this.abort("Unsupported element: " + t)
					}, e._loadXhr = function() {
						"string" != typeof this.xhrType && (this.xhrType = this._determineXhrType());
						var e = this.xhr = new XMLHttpRequest;
						e.open("GET", this.url, !0), e.timeout = this.timeout, this.xhrType === t.XHR_RESPONSE_TYPE.JSON || this.xhrType === t.XHR_RESPONSE_TYPE.DOCUMENT ? e.responseType = t.XHR_RESPONSE_TYPE.TEXT : e.responseType = this.xhrType, e.addEventListener("error", this._boundXhrOnError, !1), e.addEventListener("timeout", this._boundXhrOnTimeout, !1), e.addEventListener("abort", this._boundXhrOnAbort, !1), e.addEventListener("progress", this._boundOnProgress, !1), e.addEventListener("load", this._boundXhrOnLoad, !1), e.send()
					}, e._loadXdr = function() {
						"string" != typeof this.xhrType && (this.xhrType = this._determineXhrType());
						var t = this.xhr = new XDomainRequest;
						t.timeout = this.timeout || 5e3, t.onerror = this._boundXhrOnError, t.ontimeout = this._boundXhrOnTimeout, t.onprogress = this._boundOnProgress, t.onload = this._boundXhrOnLoad, t.open("GET", this.url, !0), setTimeout((function() {
							return t.send()
						}), 1)
					}, e._createSource = function(t, e, i) {
						i || (i = t + "/" + this._getExtension(e));
						var n = document.createElement("source");
						return n.src = e, n.type = i, n
					}, e._onError = function(t) {
						this.abort("Failed to load element using: " + t.target.nodeName)
					}, e._onProgress = function(t) {
						t && t.lengthComputable && this.onProgress.dispatch(this, t.loaded / t.total)
					}, e._onTimeout = function() {
						this.abort("Load timed out.")
					}, e._xhrOnError = function() {
						var t = this.xhr;
						this.abort(os(t) + " Request failed. Status: " + t.status + ', text: "' + t.statusText + '"')
					}, e._xhrOnTimeout = function() {
						var t = this.xhr;
						this.abort(os(t) + " Request timed out.")
					}, e._xhrOnAbort = function() {
						var t = this.xhr;
						this.abort(os(t) + " Request was aborted by the user.")
					}, e._xhrOnLoad = function() {
						var e = this.xhr,
							i = "",
							n = void 0 === e.status ? 200 : e.status;
						if ("" !== e.responseType && "text" !== e.responseType && void 0 !== e.responseType || (i = e.responseText), 0 === n && (i.length > 0 || e.responseType === t.XHR_RESPONSE_TYPE.BUFFER) ? n = 200 : 1223 === n && (n = 204), 2 == (n / 100 | 0)) {
							if (this.xhrType === t.XHR_RESPONSE_TYPE.TEXT) this.data = i, this.type = t.TYPE.TEXT;
							else if (this.xhrType === t.XHR_RESPONSE_TYPE.JSON) try {
								this.data = JSON.parse(i), this.type = t.TYPE.JSON
							} catch (t) {
								return void this.abort("Error trying to parse loaded json: " + t)
							} else if (this.xhrType === t.XHR_RESPONSE_TYPE.DOCUMENT) try {
								if (window.DOMParser) {
									var s = new DOMParser;
									this.data = s.parseFromString(i, "text/xml")
								} else {
									var o = document.createElement("div");
									o.innerHTML = i, this.data = o
								}
								this.type = t.TYPE.XML
							} catch (t) {
								return void this.abort("Error trying to parse loaded xml: " + t)
							} else this.data = e.response || i;
							this.complete()
						} else this.abort("[" + e.status + "] " + e.statusText + ": " + e.responseURL)
					}, e._determineCrossOrigin = function(t, e) {
						if (0 === t.indexOf("data:")) return "";
						if (window.origin !== window.location.origin) return "anonymous";
						e = e || window.location, es || (es = document.createElement("a")), es.href = t;
						var i = !(t = Yn()(es.href, {
								strictMode: !0
							})).port && "" === e.port || t.port === e.port,
							n = t.protocol ? t.protocol + ":" : "";
						return t.host === e.hostname && i && n === e.protocol ? "" : "anonymous"
					}, e._determineXhrType = function() {
						return t._xhrTypeMap[this.extension] || t.XHR_RESPONSE_TYPE.TEXT
					}, e._determineLoadType = function() {
						return t._loadTypeMap[this.extension] || t.LOAD_TYPE.XHR
					}, e._getExtension = function() {
						var t = this.url,
							e = "";
						if (this.isDataUrl) {
							var i = t.indexOf("/");
							e = t.substring(i + 1, t.indexOf(";", i))
						} else {
							var n = t.indexOf("?"),
								s = t.indexOf("#"),
								o = Math.min(n > -1 ? n : t.length, s > -1 ? s : t.length);
							e = (t = t.substring(0, o)).substring(t.lastIndexOf(".") + 1)
						}
						return e.toLowerCase()
					}, e._getMimeFromXhrType = function(e) {
						switch (e) {
							case t.XHR_RESPONSE_TYPE.BUFFER:
								return "application/octet-binary";
							case t.XHR_RESPONSE_TYPE.BLOB:
								return "application/blob";
							case t.XHR_RESPONSE_TYPE.DOCUMENT:
								return "application/xml";
							case t.XHR_RESPONSE_TYPE.JSON:
								return "application/json";
							case t.XHR_RESPONSE_TYPE.DEFAULT:
							case t.XHR_RESPONSE_TYPE.TEXT:
							default:
								return "text/plain"
						}
					}, Jn(t, [{
						key: "isDataUrl",
						get: function() {
							return this._hasFlag(t.STATUS_FLAGS.DATA_URL)
						}
					}, {
						key: "isComplete",
						get: function() {
							return this._hasFlag(t.STATUS_FLAGS.COMPLETE)
						}
					}, {
						key: "isLoading",
						get: function() {
							return this._hasFlag(t.STATUS_FLAGS.LOADING)
						}
					}]), t
				}();

				function ss(t, e, i) {
					e && 0 === e.indexOf(".") && (e = e.substring(1)), e && (t[e] = i)
				}

				function os(t) {
					return t.toString().replace("object ", "")
				}
				ns.STATUS_FLAGS = {
					NONE: 0,
					DATA_URL: 1,
					COMPLETE: 2,
					LOADING: 4
				}, ns.TYPE = {
					UNKNOWN: 0,
					JSON: 1,
					XML: 2,
					IMAGE: 3,
					AUDIO: 4,
					VIDEO: 5,
					TEXT: 6
				}, ns.LOAD_TYPE = {
					XHR: 1,
					IMAGE: 2,
					AUDIO: 3,
					VIDEO: 4
				}, ns.XHR_RESPONSE_TYPE = {
					DEFAULT: "text",
					BUFFER: "arraybuffer",
					BLOB: "blob",
					DOCUMENT: "document",
					JSON: "json",
					TEXT: "text"
				}, ns._loadTypeMap = {
					gif: ns.LOAD_TYPE.IMAGE,
					png: ns.LOAD_TYPE.IMAGE,
					bmp: ns.LOAD_TYPE.IMAGE,
					jpg: ns.LOAD_TYPE.IMAGE,
					jpeg: ns.LOAD_TYPE.IMAGE,
					tif: ns.LOAD_TYPE.IMAGE,
					tiff: ns.LOAD_TYPE.IMAGE,
					webp: ns.LOAD_TYPE.IMAGE,
					tga: ns.LOAD_TYPE.IMAGE,
					svg: ns.LOAD_TYPE.IMAGE,
					"svg+xml": ns.LOAD_TYPE.IMAGE,
					mp3: ns.LOAD_TYPE.AUDIO,
					ogg: ns.LOAD_TYPE.AUDIO,
					wav: ns.LOAD_TYPE.AUDIO,
					mp4: ns.LOAD_TYPE.VIDEO,
					webm: ns.LOAD_TYPE.VIDEO
				}, ns._xhrTypeMap = {
					xhtml: ns.XHR_RESPONSE_TYPE.DOCUMENT,
					html: ns.XHR_RESPONSE_TYPE.DOCUMENT,
					htm: ns.XHR_RESPONSE_TYPE.DOCUMENT,
					xml: ns.XHR_RESPONSE_TYPE.DOCUMENT,
					tmx: ns.XHR_RESPONSE_TYPE.DOCUMENT,
					svg: ns.XHR_RESPONSE_TYPE.DOCUMENT,
					tsx: ns.XHR_RESPONSE_TYPE.DOCUMENT,
					gif: ns.XHR_RESPONSE_TYPE.BLOB,
					png: ns.XHR_RESPONSE_TYPE.BLOB,
					bmp: ns.XHR_RESPONSE_TYPE.BLOB,
					jpg: ns.XHR_RESPONSE_TYPE.BLOB,
					jpeg: ns.XHR_RESPONSE_TYPE.BLOB,
					tif: ns.XHR_RESPONSE_TYPE.BLOB,
					tiff: ns.XHR_RESPONSE_TYPE.BLOB,
					webp: ns.XHR_RESPONSE_TYPE.BLOB,
					tga: ns.XHR_RESPONSE_TYPE.BLOB,
					json: ns.XHR_RESPONSE_TYPE.JSON,
					text: ns.XHR_RESPONSE_TYPE.TEXT,
					txt: ns.XHR_RESPONSE_TYPE.TEXT,
					ttf: ns.XHR_RESPONSE_TYPE.BUFFER,
					otf: ns.XHR_RESPONSE_TYPE.BUFFER
				}, ns.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
				var rs = window.URL || window.webkitURL,
					as = {
						caching: function(t, e) {
							var i = this;
							$n[t.url] ? (t.data = $n[t.url], t.complete()) : t.onComplete.once((function() {
								return $n[i.url] = i.data
							})), e()
						},
						parsing: function(t, e) {
							if (t.data) {
								if (t.xhr && t.xhrType === ns.XHR_RESPONSE_TYPE.BLOB)
									if (window.Blob && "string" != typeof t.data) {
										if (0 === t.data.type.indexOf("image")) {
											var i = rs.createObjectURL(t.data);
											return t.blob = t.data, t.data = new Image, t.data.src = i, t.type = ns.TYPE.IMAGE, void(t.data.onload = function() {
												rs.revokeObjectURL(i), t.data.onload = null, e()
											})
										}
									} else {
										var n = t.xhr.getResponseHeader("content-type");
										if (n && 0 === n.indexOf("image")) return t.data = new Image, t.data.src = "data:" + n + ";base64," + function(t) {
											for (var e = "", i = 0; i < t.length;) {
												for (var n = [0, 0, 0], s = [0, 0, 0, 0], o = 0; o < n.length; ++o) i < t.length ? n[o] = 255 & t.charCodeAt(i++) : n[o] = 0;
												switch (s[0] = n[0] >> 2, s[1] = (3 & n[0]) << 4 | n[1] >> 4, s[2] = (15 & n[1]) << 2 | n[2] >> 6, s[3] = 63 & n[2], i - (t.length - 1)) {
													case 2:
														s[3] = 64, s[2] = 64;
														break;
													case 1:
														s[3] = 64
												}
												for (var r = 0; r < s.length; ++r) e += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(s[r])
											}
											return e
										}(t.xhr.responseText), t.type = ns.TYPE.IMAGE, void(t.data.onload = function() {
											t.data.onload = null, e()
										})
									} e()
							} else e()
						}
					},
					ls = /(#[\w-]+)?$/,
					hs = function() {
						function t(e, i) {
							var n = this;
							void 0 === e && (e = ""), void 0 === i && (i = 10), this.baseUrl = e, this.progress = 0, this.loading = !1, this.defaultQueryString = "", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(t, e) {
								return n._loadResource(t, e)
							}, this._queue = function(t, e) {
								if (null == e) e = 1;
								else if (0 === e) throw new Error("Concurrency must not be zero");
								var i = 0,
									n = {
										_tasks: [],
										concurrency: e,
										saturated: Kn,
										unsaturated: Kn,
										buffer: e / 4,
										empty: Kn,
										drain: Kn,
										error: Kn,
										started: !1,
										paused: !1,
										push: function(t, e) {
											s(t, !1, e)
										},
										kill: function() {
											i = 0, n.drain = Kn, n.started = !1, n._tasks = []
										},
										unshift: function(t, e) {
											s(t, !0, e)
										},
										process: function() {
											for (; !n.paused && i < n.concurrency && n._tasks.length;) {
												var e = n._tasks.shift();
												0 === n._tasks.length && n.empty(), (i += 1) === n.concurrency && n.saturated(), t(e.data, Zn(o(e)))
											}
										},
										length: function() {
											return n._tasks.length
										},
										running: function() {
											return i
										},
										idle: function() {
											return n._tasks.length + i === 0
										},
										pause: function() {
											!0 !== n.paused && (n.paused = !0)
										},
										resume: function() {
											if (!1 !== n.paused) {
												n.paused = !1;
												for (var t = 1; t <= n.concurrency; t++) n.process()
											}
										}
									};

								function s(t, e, i) {
									if (null != i && "function" != typeof i) throw new Error("task callback must be a function");
									if (n.started = !0, null == t && n.idle()) setTimeout((function() {
										return n.drain()
									}), 1);
									else {
										var s = {
											data: t,
											callback: "function" == typeof i ? i : Kn
										};
										e ? n._tasks.unshift(s) : n._tasks.push(s), setTimeout((function() {
											return n.process()
										}), 1)
									}
								}

								function o(t) {
									return function() {
										i -= 1, t.callback.apply(t, arguments), null != arguments[0] && n.error(arguments[0], t.data), i <= n.concurrency - n.buffer && n.unsaturated(), n.idle() && n.drain(), n.process()
									}
								}
								return n
							}(this._boundLoadResource, i), this._queue.pause(), this.resources = {}, this.onProgress = new(jn()), this.onError = new(jn()), this.onLoad = new(jn()), this.onStart = new(jn()), this.onComplete = new(jn());
							for (var s = 0; s < t._defaultBeforeMiddleware.length; ++s) this.pre(t._defaultBeforeMiddleware[s]);
							for (var o = 0; o < t._defaultAfterMiddleware.length; ++o) this.use(t._defaultAfterMiddleware[o])
						}
						var e = t.prototype;
						return e.add = function(t, e, i, n) {
							if (Array.isArray(t)) {
								for (var s = 0; s < t.length; ++s) this.add(t[s]);
								return this
							}
							if ("object" == typeof t && (n = e || t.callback || t.onComplete, i = t, e = t.url, t = t.name || t.key || t.url), "string" != typeof e && (n = i, i = e, e = t), "string" != typeof e) throw new Error("No url passed to add resource to loader.");
							if ("function" == typeof i && (n = i, i = null), this.loading && (!i || !i.parentResource)) throw new Error("Cannot add resources while the loader is running.");
							if (this.resources[t]) throw new Error('Resource named "' + t + '" already exists.');
							if (e = this._prepareUrl(e), this.resources[t] = new ns(t, e, i), "function" == typeof n && this.resources[t].onAfterMiddleware.once(n), this.loading) {
								for (var o = i.parentResource, r = [], a = 0; a < o.children.length; ++a) o.children[a].isComplete || r.push(o.children[a]);
								var l = o.progressChunk * (r.length + 1) / (r.length + 2);
								o.children.push(this.resources[t]), o.progressChunk = l;
								for (var h = 0; h < r.length; ++h) r[h].progressChunk = l;
								this.resources[t].progressChunk = l
							}
							return this._queue.push(this.resources[t]), this
						}, e.pre = function(t) {
							return this._beforeMiddleware.push(t), this
						}, e.use = function(t) {
							return this._afterMiddleware.push(t), this
						}, e.reset = function() {
							for (var t in this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause(), this.resources) {
								var e = this.resources[t];
								e._onLoadBinding && e._onLoadBinding.detach(), e.isLoading && e.abort()
							}
							return this.resources = {}, this
						}, e.load = function(t) {
							if ("function" == typeof t && this.onComplete.once(t), this.loading) return this;
							if (this._queue.idle()) this._onStart(), this._onComplete();
							else {
								for (var e = 100 / this._queue._tasks.length, i = 0; i < this._queue._tasks.length; ++i) this._queue._tasks[i].data.progressChunk = e;
								this._onStart(), this._queue.resume()
							}
							return this
						}, e._prepareUrl = function(t) {
							var e, i = Yn()(t, {
								strictMode: !0
							});
							if (e = i.protocol || !i.path || 0 === t.indexOf("//") ? t : this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && "/" !== t.charAt(0) ? this.baseUrl + "/" + t : this.baseUrl + t, this.defaultQueryString) {
								var n = ls.exec(e)[0]; - 1 !== (e = e.substr(0, e.length - n.length)).indexOf("?") ? e += "&" + this.defaultQueryString : e += "?" + this.defaultQueryString, e += n
							}
							return e
						}, e._loadResource = function(t, e) {
							var i = this;
							t._dequeue = e, qn(this._beforeMiddleware, (function(e, n) {
								e.call(i, t, (function() {
									n(t.isComplete ? {} : null)
								}))
							}), (function() {
								t.isComplete ? i._onLoad(t) : (t._onLoadBinding = t.onComplete.once(i._onLoad, i), t.load())
							}), !0)
						}, e._onStart = function() {
							this.progress = 0, this.loading = !0, this.onStart.dispatch(this)
						}, e._onComplete = function() {
							this.progress = 100, this.loading = !1, this.onComplete.dispatch(this, this.resources)
						}, e._onLoad = function(t) {
							var e = this;
							t._onLoadBinding = null, this._resourcesParsing.push(t), t._dequeue(), qn(this._afterMiddleware, (function(i, n) {
								i.call(e, t, n)
							}), (function() {
								t.onAfterMiddleware.dispatch(t), e.progress = Math.min(100, e.progress + t.progressChunk), e.onProgress.dispatch(e, t), t.error ? e.onError.dispatch(t.error, e, t) : e.onLoad.dispatch(e, t), e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1), e._queue.idle() && 0 === e._resourcesParsing.length && e._onComplete()
							}), !0)
						}, Jn(t, [{
							key: "concurrency",
							get: function() {
								return this._queue.concurrency
							},
							set: function(t) {
								this._queue.concurrency = t
							}
						}]), t
					}();
				hs._defaultBeforeMiddleware = [], hs._defaultAfterMiddleware = [], hs.pre = function(t) {
					return hs._defaultBeforeMiddleware.push(t), hs
				}, hs.use = function(t) {
					return hs._defaultAfterMiddleware.push(t), hs
				};
				var us = ns,
					cs = function(t, e) {
						return cs = Object.setPrototypeOf || {
							__proto__: []
						}
						instanceof Array && function(t, e) {
							t.__proto__ = e
						} || function(t, e) {
							for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
						}, cs(t, e)
					},
					ds = function() {
						function t() {}
						return t.use = function(t, e) {
							t.data && t.type === ns.TYPE.IMAGE && (t.texture = Qe.fromLoader(t.data, t.url, t.name)), e()
						}, t
					}(),
					ps = function(t) {
						function e(i, n) {
							for (var s = t.call(this, i, n) || this, o = 0; o < e._plugins.length; ++o) {
								var r = e._plugins[o],
									a = r.pre,
									l = r.use;
								a && s.pre(a), l && s.use(l)
							}
							return s._protected = !1, s
						}
						return function(t, e) {
							function i() {
								this.constructor = t
							}
							cs(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
						}(e, t), e.prototype.destroy = function() {
							this._protected || this.reset()
						}, Object.defineProperty(e, "shared", {
							get: function() {
								var t = e._shared;
								return t || ((t = new e)._protected = !0, e._shared = t), t
							},
							enumerable: !1,
							configurable: !0
						}), e.registerPlugin = function(t) {
							return e._plugins.push(t), t.add && t.add(), e
						}, e._plugins = [], e
					}(hs);
				ps.registerPlugin({
					use: as.parsing
				}), ps.registerPlugin(ds);
				var _s = function() {
						function t() {}
						return t.init = function(t) {
							t = Object.assign({
								sharedLoader: !1
							}, t), this.loader = t.sharedLoader ? ps.shared : new ps
						}, t.destroy = function() {
							this.loader && (this.loader.destroy(), this.loader = null)
						}, t
					}(),
					ms = function(t, e) {
						return ms = Object.setPrototypeOf || {
							__proto__: []
						}
						instanceof Array && function(t, e) {
							t.__proto__ = e
						} || function(t, e) {
							for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
						}, ms(t, e)
					};

				function gs(t, e) {
					function i() {
						this.constructor = t
					}
					ms(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
				}
				var fs, Ss, ys = function(t) {
						function e(e, i, n, s) {
							void 0 === e && (e = 1500), void 0 === n && (n = 16384), void 0 === s && (s = !1);
							var o = t.call(this) || this;
							return n > 16384 && (n = 16384), o._properties = [!1, !0, !1, !1, !1], o._maxSize = e, o._batchSize = n, o._buffers = null, o._bufferUpdateIDs = [], o._updateID = 0, o.interactiveChildren = !1, o.blendMode = m.NORMAL, o.autoResize = s, o.roundPixels = !0, o.baseTexture = null, o.setProperties(i), o._tint = 0, o.tintRgb = new Float32Array(4), o.tint = 16777215, o
						}
						return gs(e, t), e.prototype.setProperties = function(t) {
							t && (this._properties[0] = "vertices" in t || "scale" in t ? !!t.vertices || !!t.scale : this._properties[0], this._properties[1] = "position" in t ? !!t.position : this._properties[1], this._properties[2] = "rotation" in t ? !!t.rotation : this._properties[2], this._properties[3] = "uvs" in t ? !!t.uvs : this._properties[3], this._properties[4] = "tint" in t || "alpha" in t ? !!t.tint || !!t.alpha : this._properties[4])
						}, e.prototype.updateTransform = function() {
							this.displayObjectUpdateTransform()
						}, Object.defineProperty(e.prototype, "tint", {
							get: function() {
								return this._tint
							},
							set: function(t) {
								this._tint = t, st(t, this.tintRgb)
							},
							enumerable: !1,
							configurable: !0
						}), e.prototype.render = function(t) {
							var e = this;
							this.visible && !(this.worldAlpha <= 0) && this.children.length && this.renderable && (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", (function() {
								return e.onChildrenChange(0)
							}))), t.batch.setObjectRenderer(t.plugins.particle), t.plugins.particle.render(this))
						}, e.prototype.onChildrenChange = function(t) {
							for (var e = Math.floor(t / this._batchSize); this._bufferUpdateIDs.length < e;) this._bufferUpdateIDs.push(0);
							this._bufferUpdateIDs[e] = ++this._updateID
						}, e.prototype.dispose = function() {
							if (this._buffers) {
								for (var t = 0; t < this._buffers.length; ++t) this._buffers[t].destroy();
								this._buffers = null
							}
						}, e.prototype.destroy = function(e) {
							t.prototype.destroy.call(this, e), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null
						}, e
					}(ce),
					vs = function() {
						function t(t, e, i) {
							this.geometry = new ui, this.indexBuffer = null, this.size = i, this.dynamicProperties = [], this.staticProperties = [];
							for (var n = 0; n < t.length; ++n) {
								var s = t[n];
								s = {
									attributeName: s.attributeName,
									size: s.size,
									uploadFunction: s.uploadFunction,
									type: s.type || y.FLOAT,
									offset: s.offset
								}, e[n] ? this.dynamicProperties.push(s) : this.staticProperties.push(s)
							}
							this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers()
						}
						return t.prototype.initBuffers = function() {
							var t = this.geometry,
								e = 0;
							this.indexBuffer = new si(pt(this.size), !0, !0), t.addIndex(this.indexBuffer), this.dynamicStride = 0;
							for (var i = 0; i < this.dynamicProperties.length; ++i)(r = this.dynamicProperties[i]).offset = e, e += r.size, this.dynamicStride += r.size;
							var n = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
							this.dynamicData = new Float32Array(n), this.dynamicDataUint32 = new Uint32Array(n), this.dynamicBuffer = new si(this.dynamicData, !1, !1);
							var s = 0;
							for (this.staticStride = 0, i = 0; i < this.staticProperties.length; ++i)(r = this.staticProperties[i]).offset = s, s += r.size, this.staticStride += r.size;
							var o = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
							for (this.staticData = new Float32Array(o), this.staticDataUint32 = new Uint32Array(o), this.staticBuffer = new si(this.staticData, !0, !1), i = 0; i < this.dynamicProperties.length; ++i) {
								var r = this.dynamicProperties[i];
								t.addAttribute(r.attributeName, this.dynamicBuffer, 0, r.type === y.UNSIGNED_BYTE, r.type, 4 * this.dynamicStride, 4 * r.offset)
							}
							for (i = 0; i < this.staticProperties.length; ++i) r = this.staticProperties[i], t.addAttribute(r.attributeName, this.staticBuffer, 0, r.type === y.UNSIGNED_BYTE, r.type, 4 * this.staticStride, 4 * r.offset)
						}, t.prototype.uploadDynamic = function(t, e, i) {
							for (var n = 0; n < this.dynamicProperties.length; n++) {
								var s = this.dynamicProperties[n];
								s.uploadFunction(t, e, i, s.type === y.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, s.offset)
							}
							this.dynamicBuffer._updateID++
						}, t.prototype.uploadStatic = function(t, e, i) {
							for (var n = 0; n < this.staticProperties.length; n++) {
								var s = this.staticProperties[n];
								s.uploadFunction(t, e, i, s.type === y.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, s.offset)
							}
							this.staticBuffer._updateID++
						}, t.prototype.destroy = function() {
							this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy()
						}, t
					}(),
					Ts = function(t) {
						function e(e) {
							var i = t.call(this, e) || this;
							return i.shader = null, i.properties = null, i.tempMatrix = new qt, i.properties = [{
								attributeName: "aVertexPosition",
								size: 2,
								uploadFunction: i.uploadVertices,
								offset: 0
							}, {
								attributeName: "aPositionCoord",
								size: 2,
								uploadFunction: i.uploadPosition,
								offset: 0
							}, {
								attributeName: "aRotation",
								size: 1,
								uploadFunction: i.uploadRotation,
								offset: 0
							}, {
								attributeName: "aTextureCoord",
								size: 2,
								uploadFunction: i.uploadUvs,
								offset: 0
							}, {
								attributeName: "aColor",
								size: 1,
								type: y.UNSIGNED_BYTE,
								uploadFunction: i.uploadTint,
								offset: 0
							}], i.shader = Qi.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n", "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}", {}), i.state = Ji.for2d(), i
						}
						return gs(e, t), e.prototype.render = function(t) {
							var e = t.children,
								i = t._maxSize,
								n = t._batchSize,
								s = this.renderer,
								o = e.length;
							if (0 !== o) {
								o > i && !t.autoResize && (o = i);
								var r = t._buffers;
								r || (r = t._buffers = this.generateBuffers(t));
								var a = e[0]._texture.baseTexture;
								this.state.blendMode = ht(t.blendMode, a.alphaMode), s.state.set(this.state);
								var l = s.gl,
									h = t.worldTransform.copyTo(this.tempMatrix);
								h.prepend(s.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = h.toArray(!0), this.shader.uniforms.uColor = ut(t.tintRgb, t.worldAlpha, this.shader.uniforms.uColor, a.alphaMode), this.shader.uniforms.uSampler = a, this.renderer.shader.bind(this.shader);
								for (var u = !1, c = 0, d = 0; c < o; c += n, d += 1) {
									var p = o - c;
									p > n && (p = n), d >= r.length && r.push(this._generateOneMoreBuffer(t));
									var _ = r[d];
									_.uploadDynamic(e, c, p);
									var m = t._bufferUpdateIDs[d] || 0;
									(u = u || _._updateID < m) && (_._updateID = t._updateID, _.uploadStatic(e, c, p)), s.geometry.bind(_.geometry), l.drawElements(l.TRIANGLES, 6 * p, l.UNSIGNED_SHORT, 0)
								}
							}
						}, e.prototype.generateBuffers = function(t) {
							for (var e = [], i = t._maxSize, n = t._batchSize, s = t._properties, o = 0; o < i; o += n) e.push(new vs(this.properties, s, n));
							return e
						}, e.prototype._generateOneMoreBuffer = function(t) {
							var e = t._batchSize,
								i = t._properties;
							return new vs(this.properties, i, e)
						}, e.prototype.uploadVertices = function(t, e, i, n, s, o) {
							for (var r = 0, a = 0, l = 0, h = 0, u = 0; u < i; ++u) {
								var c = t[e + u],
									d = c._texture,
									p = c.scale.x,
									_ = c.scale.y,
									m = d.trim,
									g = d.orig;
								m ? (r = (a = m.x - c.anchor.x * g.width) + m.width, l = (h = m.y - c.anchor.y * g.height) + m.height) : (r = g.width * (1 - c.anchor.x), a = g.width * -c.anchor.x, l = g.height * (1 - c.anchor.y), h = g.height * -c.anchor.y), n[o] = a * p, n[o + 1] = h * _, n[o + s] = r * p, n[o + s + 1] = h * _, n[o + 2 * s] = r * p, n[o + 2 * s + 1] = l * _, n[o + 3 * s] = a * p, n[o + 3 * s + 1] = l * _, o += 4 * s
							}
						}, e.prototype.uploadPosition = function(t, e, i, n, s, o) {
							for (var r = 0; r < i; r++) {
								var a = t[e + r].position;
								n[o] = a.x, n[o + 1] = a.y, n[o + s] = a.x, n[o + s + 1] = a.y, n[o + 2 * s] = a.x, n[o + 2 * s + 1] = a.y, n[o + 3 * s] = a.x, n[o + 3 * s + 1] = a.y, o += 4 * s
							}
						}, e.prototype.uploadRotation = function(t, e, i, n, s, o) {
							for (var r = 0; r < i; r++) {
								var a = t[e + r].rotation;
								n[o] = a, n[o + s] = a, n[o + 2 * s] = a, n[o + 3 * s] = a, o += 4 * s
							}
						}, e.prototype.uploadUvs = function(t, e, i, n, s, o) {
							for (var r = 0; r < i; ++r) {
								var a = t[e + r]._texture._uvs;
								a ? (n[o] = a.x0, n[o + 1] = a.y0, n[o + s] = a.x1, n[o + s + 1] = a.y1, n[o + 2 * s] = a.x2, n[o + 2 * s + 1] = a.y2, n[o + 3 * s] = a.x3, n[o + 3 * s + 1] = a.y3, o += 4 * s) : (n[o] = 0, n[o + 1] = 0, n[o + s] = 0, n[o + s + 1] = 0, n[o + 2 * s] = 0, n[o + 2 * s + 1] = 0, n[o + 3 * s] = 0, n[o + 3 * s + 1] = 0, o += 4 * s)
							}
						}, e.prototype.uploadTint = function(t, e, i, n, s, o) {
							for (var r = 0; r < i; ++r) {
								var a = t[e + r],
									l = a._texture.baseTexture.alphaMode > 0,
									h = a.alpha,
									u = h < 1 && l ? ct(a._tintRGB, h) : a._tintRGB + (255 * h << 24);
								n[o] = u, n[o + s] = u, n[o + 2 * s] = u, n[o + 3 * s] = u, o += 4 * s
							}
						}, e.prototype.destroy = function() {
							t.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null
						}, e
					}(fi);
				! function(t) {
					t.MITER = "miter", t.BEVEL = "bevel", t.ROUND = "round"
				}(fs || (fs = {})),
				function(t) {
					t.BUTT = "butt", t.ROUND = "round", t.SQUARE = "square"
				}(Ss || (Ss = {}));
				var Es = {
						adaptive: !0,
						maxLength: 10,
						minSegments: 8,
						maxSegments: 2048,
						epsilon: 1e-4,
						_segmentsCount: function(t, e) {
							if (void 0 === e && (e = 20), !this.adaptive || !t || isNaN(t)) return e;
							var i = Math.ceil(t / this.maxLength);
							return i < this.minSegments ? i = this.minSegments : i > this.maxSegments && (i = this.maxSegments), i
						}
					},
					bs = function() {
						function t() {
							this.color = 16777215, this.alpha = 1, this.texture = Qe.WHITE, this.matrix = null, this.visible = !1, this.reset()
						}
						return t.prototype.clone = function() {
							var e = new t;
							return e.color = this.color, e.alpha = this.alpha, e.texture = this.texture, e.matrix = this.matrix, e.visible = this.visible, e
						}, t.prototype.reset = function() {
							this.color = 16777215, this.alpha = 1, this.texture = Qe.WHITE, this.matrix = null, this.visible = !1
						}, t.prototype.destroy = function() {
							this.texture = null, this.matrix = null
						}, t
					}(),
					As = function(t, e) {
						return As = Object.setPrototypeOf || {
							__proto__: []
						}
						instanceof Array && function(t, e) {
							t.__proto__ = e
						} || function(t, e) {
							for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
						}, As(t, e)
					};

				function Ps(t, e) {
					function i() {
						this.constructor = t
					}
					As(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
				}
				var Is = {
						build: function(t) {
							t.points = t.shape.points.slice()
						},
						triangulate: function(t, e) {
							var i = t.points,
								n = t.holes,
								s = e.points,
								o = e.indices;
							if (i.length >= 6) {
								for (var r = [], a = 0; a < n.length; a++) {
									var l = n[a];
									r.push(i.length / 2), i = i.concat(l.points)
								}
								var h = Z()(i, r, 2);
								if (!h) return;
								var u = s.length / 2;
								for (a = 0; a < h.length; a += 3) o.push(h[a] + u), o.push(h[a + 1] + u), o.push(h[a + 2] + u);
								for (a = 0; a < i.length; a++) s.push(i[a])
							}
						}
					},
					ws = {
						build: function(t) {
							var e, i, n = t.shape,
								s = t.points,
								o = n.x,
								r = n.y;
							if (s.length = 0, t.type === Ft.CIRC) e = n.radius, i = n.radius;
							else {
								var a = t.shape;
								e = a.width, i = a.height
							}
							if (0 !== e && 0 !== i) {
								var l = Math.floor(30 * Math.sqrt(n.radius)) || Math.floor(15 * Math.sqrt(e + i));
								l /= 2.3;
								for (var h = 2 * Math.PI / l, u = 0; u < l - .5; u++) s.push(o + Math.sin(-h * u) * e, r + Math.cos(-h * u) * i);
								s.push(s[0], s[1])
							}
						},
						triangulate: function(t, e) {
							var i = t.points,
								n = e.points,
								s = e.indices,
								o = n.length / 2,
								r = o,
								a = t.shape,
								l = t.matrix,
								h = a.x,
								u = a.y;
							n.push(t.matrix ? l.a * h + l.c * u + l.tx : h, t.matrix ? l.b * h + l.d * u + l.ty : u);
							for (var c = 0; c < i.length; c += 2) n.push(i[c], i[c + 1]), s.push(o++, r, o)
						}
					},
					Ls = {
						build: function(t) {
							var e = t.shape,
								i = e.x,
								n = e.y,
								s = e.width,
								o = e.height,
								r = t.points;
							r.length = 0, r.push(i, n, i + s, n, i + s, n + o, i, n + o)
						},
						triangulate: function(t, e) {
							var i = t.points,
								n = e.points,
								s = n.length / 2;
							n.push(i[0], i[1], i[2], i[3], i[6], i[7], i[4], i[5]), e.indices.push(s, s + 1, s + 2, s + 1, s + 2, s + 3)
						}
					};

				function Cs(t, e, i) {
					return t + (e - t) * i
				}

				function xs(t, e, i, n, s, o, r) {
					void 0 === r && (r = []);
					for (var a = r, l = 0, h = 0, u = 0, c = 0, d = 0, p = 0, _ = 0, m = 0; _ <= 20; ++_) l = Cs(t, i, m = _ / 20), h = Cs(e, n, m), u = Cs(i, s, m), c = Cs(n, o, m), d = Cs(l, u, m), p = Cs(h, c, m), a.push(d, p);
					return a
				}
				var Bs = {
					build: function(t) {
						var e = t.shape,
							i = t.points,
							n = e.x,
							s = e.y,
							o = e.width,
							r = e.height,
							a = Math.max(0, Math.min(e.radius, Math.min(o, r) / 2));
						i.length = 0, a ? (xs(n, s + a, n, s, n + a, s, i), xs(n + o - a, s, n + o, s, n + o, s + a, i), xs(n + o, s + r - a, n + o, s + r, n + o - a, s + r, i), xs(n + a, s + r, n, s + r, n, s + r - a, i)) : i.push(n, s, n + o, s, n + o, s + r, n, s + r)
					},
					triangulate: function(t, e) {
						for (var i = t.points, n = e.points, s = e.indices, o = n.length / 2, r = Z()(i, null, 2), a = 0, l = r.length; a < l; a += 3) s.push(r[a] + o), s.push(r[a + 1] + o), s.push(r[a + 2] + o);
						for (a = 0, l = i.length; a < l; a++) n.push(i[a], i[++a])
					}
				};

				function Os(t, e, i, n, s, o, r, a) {
					var l, h;
					r ? (l = n, h = -i) : (l = -n, h = i);
					var u = t - i * s + l,
						c = e - n * s + h,
						d = t + i * o + l,
						p = e + n * o + h;
					return a.push(u, c), a.push(d, p), 2
				}

				function Ns(t, e, i, n, s, o, r, a) {
					var l = i - t,
						h = n - e,
						u = Math.atan2(l, h),
						c = Math.atan2(s - t, o - e);
					a && u < c ? u += 2 * Math.PI : !a && u > c && (c += 2 * Math.PI);
					var d = u,
						p = c - u,
						_ = Math.abs(p),
						m = Math.sqrt(l * l + h * h),
						g = 1 + (15 * _ * Math.sqrt(m) / Math.PI | 0),
						f = p / g;
					if (d += f, a) {
						r.push(t, e), r.push(i, n);
						for (var S = 1, y = d; S < g; S++, y += f) r.push(t, e), r.push(t + Math.sin(y) * m, e + Math.cos(y) * m);
						r.push(t, e), r.push(s, o)
					} else {
						for (r.push(i, n), r.push(t, e), S = 1, y = d; S < g; S++, y += f) r.push(t + Math.sin(y) * m, e + Math.cos(y) * m), r.push(t, e);
						r.push(s, o), r.push(t, e)
					}
					return 2 * g
				}

				function Ms(t, e) {
					t.lineStyle.native ? function(t, e) {
						var i = 0,
							n = t.shape,
							s = t.points || n.points,
							o = n.type !== Ft.POLY || n.closeStroke;
						if (0 !== s.length) {
							var r = e.points,
								a = e.indices,
								l = s.length / 2,
								h = r.length / 2,
								u = h;
							for (r.push(s[0], s[1]), i = 1; i < l; i++) r.push(s[2 * i], s[2 * i + 1]), a.push(u, u + 1), u++;
							o && a.push(u, h)
						}
					}(t, e) : function(t, e) {
						var i = t.shape,
							n = t.points || i.points.slice(),
							s = e.closePointEps;
						if (0 !== n.length) {
							var o = t.lineStyle,
								r = new jt(n[0], n[1]),
								a = new jt(n[n.length - 2], n[n.length - 1]),
								l = i.type !== Ft.POLY || i.closeStroke,
								h = Math.abs(r.x - a.x) < s && Math.abs(r.y - a.y) < s;
							if (l) {
								n = n.slice(), h && (n.pop(), n.pop(), a.set(n[n.length - 2], n[n.length - 1]));
								var u = .5 * (r.x + a.x),
									c = .5 * (a.y + r.y);
								n.unshift(u, c), n.push(u, c)
							}
							var d = e.points,
								p = n.length / 2,
								_ = n.length,
								m = d.length / 2,
								g = o.width / 2,
								f = g * g,
								S = o.miterLimit * o.miterLimit,
								y = n[0],
								v = n[1],
								T = n[2],
								E = n[3],
								b = 0,
								A = 0,
								P = -(v - E),
								I = y - T,
								w = 0,
								L = 0,
								C = Math.sqrt(P * P + I * I);
							P /= C, I /= C, P *= g, I *= g;
							var x = o.alignment,
								B = 2 * (1 - x),
								O = 2 * x;
							l || (o.cap === Ss.ROUND ? _ += Ns(y - P * (B - O) * .5, v - I * (B - O) * .5, y - P * B, v - I * B, y + P * O, v + I * O, d, !0) + 2 : o.cap === Ss.SQUARE && (_ += Os(y, v, P, I, B, O, !0, d))), d.push(y - P * B, v - I * B), d.push(y + P * O, v + I * O);
							for (var N = 1; N < p - 1; ++N) {
								y = n[2 * (N - 1)], v = n[2 * (N - 1) + 1], T = n[2 * N], E = n[2 * N + 1], b = n[2 * (N + 1)], A = n[2 * (N + 1) + 1], P = -(v - E), I = y - T, P /= C = Math.sqrt(P * P + I * I), I /= C, P *= g, I *= g, w = -(E - A), L = T - b, w /= C = Math.sqrt(w * w + L * L), L /= C, w *= g, L *= g;
								var M = T - y,
									R = v - E,
									D = T - b,
									k = A - E,
									F = R * D - k * M,
									G = F < 0;
								if (Math.abs(F) < .1) d.push(T - P * B, E - I * B), d.push(T + P * O, E + I * O);
								else {
									var U = (-P + y) * (-I + E) - (-P + T) * (-I + v),
										W = (-w + b) * (-L + E) - (-w + T) * (-L + A),
										H = (M * W - D * U) / F,
										V = (k * U - R * W) / F,
										X = (H - T) * (H - T) + (V - E) * (V - E),
										Y = T + (H - T) * B,
										z = E + (V - E) * B,
										j = T - (H - T) * O,
										K = E - (V - E) * O,
										q = G ? B : O;
									X <= Math.min(M * M + R * R, D * D + k * k) + q * q * f ? o.join === fs.BEVEL || X / f > S ? (G ? (d.push(Y, z), d.push(T + P * O, E + I * O), d.push(Y, z), d.push(T + w * O, E + L * O)) : (d.push(T - P * B, E - I * B), d.push(j, K), d.push(T - w * B, E - L * B), d.push(j, K)), _ += 2) : o.join === fs.ROUND ? G ? (d.push(Y, z), d.push(T + P * O, E + I * O), _ += Ns(T, E, T + P * O, E + I * O, T + w * O, E + L * O, d, !0) + 4, d.push(Y, z), d.push(T + w * O, E + L * O)) : (d.push(T - P * B, E - I * B), d.push(j, K), _ += Ns(T, E, T - P * B, E - I * B, T - w * B, E - L * B, d, !1) + 4, d.push(T - w * B, E - L * B), d.push(j, K)) : (d.push(Y, z), d.push(j, K)) : (d.push(T - P * B, E - I * B), d.push(T + P * O, E + I * O), o.join === fs.BEVEL || X / f > S || (o.join === fs.ROUND ? _ += G ? Ns(T, E, T + P * O, E + I * O, T + w * O, E + L * O, d, !0) + 2 : Ns(T, E, T - P * B, E - I * B, T - w * B, E - L * B, d, !1) + 2 : (G ? (d.push(j, K), d.push(j, K)) : (d.push(Y, z), d.push(Y, z)), _ += 2)), d.push(T - w * B, E - L * B), d.push(T + w * O, E + L * O), _ += 2)
								}
							}
							y = n[2 * (p - 2)], v = n[2 * (p - 2) + 1], T = n[2 * (p - 1)], P = -(v - (E = n[2 * (p - 1) + 1])), I = y - T, P /= C = Math.sqrt(P * P + I * I), I /= C, P *= g, I *= g, d.push(T - P * B, E - I * B), d.push(T + P * O, E + I * O), l || (o.cap === Ss.ROUND ? _ += Ns(T - P * (B - O) * .5, E - I * (B - O) * .5, T - P * B, E - I * B, T + P * O, E + I * O, d, !1) + 2 : o.cap === Ss.SQUARE && (_ += Os(T, E, P, I, B, O, !1, d)));
							var Z = e.indices,
								$ = Es.epsilon * Es.epsilon;
							for (N = m; N < _ + m - 2; ++N) y = d[2 * N], v = d[2 * N + 1], T = d[2 * (N + 1)], E = d[2 * (N + 1) + 1], b = d[2 * (N + 2)], A = d[2 * (N + 2) + 1], Math.abs(y * (E - A) + T * (A - v) + b * (v - E)) < $ || Z.push(N, N + 1, N + 2)
						}
					}(t, e)
				}
				var Rs, Ds, ks = function(t) {
						function e(e, i, n, s, o, r) {
							void 0 === r && (r = 0), o = o || s / 2;
							for (var a = -1 * Math.PI / 2 + r, l = 2 * n, h = Gt / l, u = [], c = 0; c < l; c++) {
								var d = c % 2 ? o : s,
									p = c * h + a;
								u.push(e + d * Math.cos(p), i + d * Math.sin(p))
							}
							return t.call(this, u) || this
						}
						return Ps(e, t), e
					}(Yt),
					Fs = function() {
						function t() {}
						return t.curveTo = function(t, e, i, n, s, o) {
							var r = o[o.length - 2],
								a = o[o.length - 1] - e,
								l = r - t,
								h = n - e,
								u = i - t,
								c = Math.abs(a * u - l * h);
							if (c < 1e-8 || 0 === s) return o[o.length - 2] === t && o[o.length - 1] === e || o.push(t, e), null;
							var d = a * a + l * l,
								p = h * h + u * u,
								_ = a * h + l * u,
								m = s * Math.sqrt(d) / c,
								g = s * Math.sqrt(p) / c,
								f = m * _ / d,
								S = g * _ / p,
								y = m * u + g * l,
								v = m * h + g * a,
								T = l * (g + f),
								E = a * (g + f),
								b = u * (m + S),
								A = h * (m + S);
							return {
								cx: y + t,
								cy: v + e,
								radius: s,
								startAngle: Math.atan2(E - v, T - y),
								endAngle: Math.atan2(A - v, b - y),
								anticlockwise: l * h > u * a
							}
						}, t.arc = function(t, e, i, n, s, o, r, a, l) {
							for (var h = r - o, u = Es._segmentsCount(Math.abs(h) * s, 40 * Math.ceil(Math.abs(h) / Gt)), c = h / (2 * u), d = 2 * c, p = Math.cos(c), _ = Math.sin(c), m = u - 1, g = m % 1 / m, f = 0; f <= m; ++f) {
								var S = c + o + d * (f + g * f),
									y = Math.cos(S),
									v = -Math.sin(S);
								l.push((p * y + _ * v) * s + i, (p * -v + _ * y) * s + n)
							}
						}, t
					}(),
					Gs = function() {
						function t() {}
						return t.curveLength = function(t, e, i, n, s, o, r, a) {
							for (var l = 0, h = 0, u = 0, c = 0, d = 0, p = 0, _ = 0, m = 0, g = 0, f = 0, S = 0, y = t, v = e, T = 1; T <= 10; ++T) f = y - (m = (_ = (p = (d = 1 - (h = T / 10)) * d) * d) * t + 3 * p * h * i + 3 * d * (u = h * h) * s + (c = u * h) * r), S = v - (g = _ * e + 3 * p * h * n + 3 * d * u * o + c * a), y = m, v = g, l += Math.sqrt(f * f + S * S);
							return l
						}, t.curveTo = function(e, i, n, s, o, r, a) {
							var l = a[a.length - 2],
								h = a[a.length - 1];
							a.length -= 2;
							var u = Es._segmentsCount(t.curveLength(l, h, e, i, n, s, o, r)),
								c = 0,
								d = 0,
								p = 0,
								_ = 0,
								m = 0;
							a.push(l, h);
							for (var g = 1, f = 0; g <= u; ++g) p = (d = (c = 1 - (f = g / u)) * c) * c, m = (_ = f * f) * f, a.push(p * l + 3 * d * f * e + 3 * c * _ * n + m * o, p * h + 3 * d * f * i + 3 * c * _ * s + m * r)
						}, t
					}(),
					Us = function() {
						function t() {}
						return t.curveLength = function(t, e, i, n, s, o) {
							var r = t - 2 * i + s,
								a = e - 2 * n + o,
								l = 2 * i - 2 * t,
								h = 2 * n - 2 * e,
								u = 4 * (r * r + a * a),
								c = 4 * (r * l + a * h),
								d = l * l + h * h,
								p = 2 * Math.sqrt(u + c + d),
								_ = Math.sqrt(u),
								m = 2 * u * _,
								g = 2 * Math.sqrt(d),
								f = c / _;
							return (m * p + _ * c * (p - g) + (4 * d * u - c * c) * Math.log((2 * _ + f + p) / (f + g))) / (4 * m)
						}, t.curveTo = function(e, i, n, s, o) {
							for (var r = o[o.length - 2], a = o[o.length - 1], l = Es._segmentsCount(t.curveLength(r, a, e, i, n, s)), h = 0, u = 0, c = 1; c <= l; ++c) {
								var d = c / l;
								h = r + (e - r) * d, u = a + (i - a) * d, o.push(h + (e + (n - e) * d - h) * d, u + (i + (s - i) * d - u) * d)
							}
						}, t
					}(),
					Ws = function() {
						function t() {
							this.reset()
						}
						return t.prototype.begin = function(t, e, i) {
							this.reset(), this.style = t, this.start = e, this.attribStart = i
						}, t.prototype.end = function(t, e) {
							this.attribSize = e - this.attribStart, this.size = t - this.start
						}, t.prototype.reset = function() {
							this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0
						}, t
					}(),
					Hs = ((Rs = {})[Ft.POLY] = Is, Rs[Ft.CIRC] = ws, Rs[Ft.ELIP] = ws, Rs[Ft.RECT] = Ls, Rs[Ft.RREC] = Bs, Rs),
					Vs = [],
					Xs = [],
					Ys = {
						buildPoly: Is,
						buildCircle: ws,
						buildRectangle: Ls,
						buildRoundedRectangle: Bs,
						FILL_COMMANDS: Hs,
						BATCH_POOL: Vs,
						DRAW_CALL_POOL: Xs,
						buildLine: Ms,
						Star: ks,
						ArcUtils: Fs,
						BezierUtils: Gs,
						QuadraticUtils: Us,
						BatchPart: Ws
					},
					zs = function() {
						function t(t, e, i, n) {
							void 0 === e && (e = null), void 0 === i && (i = null), void 0 === n && (n = null), this.shape = t, this.lineStyle = i, this.fillStyle = e, this.matrix = n, this.type = t.type, this.points = [], this.holes = []
						}
						return t.prototype.clone = function() {
							return new t(this.shape, this.fillStyle, this.lineStyle, this.matrix)
						}, t.prototype.destroy = function() {
							this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null
						}, t
					}(),
					js = new jt,
					Ks = new oe,
					qs = function(t) {
						function e() {
							var e = t.call(this) || this;
							return e.uvsFloat32 = null, e.indicesUint16 = null, e.points = [], e.colors = [], e.uvs = [], e.indices = [], e.textureIds = [], e.graphicsData = [], e.dirty = 0, e.batchDirty = -1, e.cacheDirty = -1, e.clearDirty = 0, e.drawCalls = [], e.batches = [], e.shapeIndex = 0, e._bounds = new oe, e.boundsDirty = -1, e.boundsPadding = 0, e.batchable = !1, e.indicesUint16 = null, e.uvsFloat32 = null, e.closePointEps = 1e-4, e
						}
						return Ps(e, t), Object.defineProperty(e.prototype, "bounds", {
							get: function() {
								return this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds
							},
							enumerable: !1,
							configurable: !0
						}), e.prototype.invalidate = function() {
							this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
							for (var t = 0; t < this.drawCalls.length; t++) this.drawCalls[t].texArray.clear(), Xs.push(this.drawCalls[t]);
							for (this.drawCalls.length = 0, t = 0; t < this.batches.length; t++) {
								var e = this.batches[t];
								e.reset(), Vs.push(e)
							}
							this.batches.length = 0
						}, e.prototype.clear = function() {
							return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this
						}, e.prototype.drawShape = function(t, e, i, n) {
							void 0 === e && (e = null), void 0 === i && (i = null), void 0 === n && (n = null);
							var s = new zs(t, e, i, n);
							return this.graphicsData.push(s), this.dirty++, this
						}, e.prototype.drawHole = function(t, e) {
							if (void 0 === e && (e = null), !this.graphicsData.length) return null;
							var i = new zs(t, null, null, e),
								n = this.graphicsData[this.graphicsData.length - 1];
							return i.lineStyle = n.lineStyle, n.holes.push(i), this.dirty++, this
						}, e.prototype.destroy = function() {
							t.prototype.destroy.call(this);
							for (var e = 0; e < this.graphicsData.length; ++e) this.graphicsData[e].destroy();
							this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null
						}, e.prototype.containsPoint = function(t) {
							for (var e = this.graphicsData, i = 0; i < e.length; ++i) {
								var n = e[i];
								if (n.fillStyle.visible && n.shape && (n.matrix ? n.matrix.applyInverse(t, js) : js.copyFrom(t), n.shape.contains(js.x, js.y))) {
									var s = !1;
									if (n.holes)
										for (var o = 0; o < n.holes.length; o++)
											if (n.holes[o].shape.contains(js.x, js.y)) {
												s = !0;
												break
											} if (!s) return !0
								}
							}
							return !1
						}, e.prototype.updateBatches = function(t) {
							if (this.graphicsData.length) {
								if (this.validateBatching()) {
									this.cacheDirty = this.dirty;
									var e = this.uvs,
										i = this.graphicsData,
										n = null,
										s = null;
									this.batches.length > 0 && (s = (n = this.batches[this.batches.length - 1]).style);
									for (var o = this.shapeIndex; o < i.length; o++) {
										this.shapeIndex++;
										var r = i[o],
											a = r.fillStyle,
											l = r.lineStyle;
										Hs[r.type].build(r), r.matrix && this.transformPoints(r.points, r.matrix);
										for (var h = 0; h < 2; h++) {
											var u = 0 === h ? a : l;
											if (u.visible) {
												var c = u.texture.baseTexture,
													d = this.indices.length,
													p = this.points.length / 2;
												c.wrapMode = T.REPEAT, 0 === h ? this.processFill(r) : this.processLine(r);
												var _ = this.points.length / 2 - p;
												0 !== _ && (n && !this._compareStyles(s, u) && (n.end(d, p), n = null), n || ((n = Vs.pop() || new Ws).begin(u, d, p), this.batches.push(n), s = u), this.addUvs(this.points, e, u.texture, p, _, u.matrix))
											}
										}
									}
									var m = this.indices.length,
										g = this.points.length / 2;
									if (n && n.end(m, g), 0 !== this.batches.length) {
										if (this.indicesUint16 && this.indices.length === this.indicesUint16.length) this.indicesUint16.set(this.indices);
										else {
											var f = g > 65535 && t;
											this.indicesUint16 = f ? new Uint32Array(this.indices) : new Uint16Array(this.indices)
										}
										this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls()
									} else this.batchable = !0
								}
							} else this.batchable = !0
						}, e.prototype._compareStyles = function(t, e) {
							return !(!t || !e) && t.texture.baseTexture === e.texture.baseTexture && t.color + t.alpha === e.color + e.alpha && !!t.native == !!e.native
						}, e.prototype.validateBatching = function() {
							if (this.dirty === this.cacheDirty || !this.graphicsData.length) return !1;
							for (var t = 0, e = this.graphicsData.length; t < e; t++) {
								var i = this.graphicsData[t],
									n = i.fillStyle,
									s = i.lineStyle;
								if (n && !n.texture.baseTexture.valid) return !1;
								if (s && !s.texture.baseTexture.valid) return !1
							}
							return !0
						}, e.prototype.packBatches = function() {
							this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
							for (var t = this.batches, e = 0, i = t.length; e < i; e++)
								for (var n = t[e], s = 0; s < n.size; s++) {
									var o = n.start + s;
									this.indicesUint16[o] = this.indicesUint16[o] - n.attribStart
								}
						}, e.prototype.isBatchable = function() {
							if (this.points.length > 131070) return !1;
							for (var t = this.batches, i = 0; i < t.length; i++)
								if (t[i].style.native) return !1;
							return this.points.length < 2 * e.BATCHABLE_SIZE
						}, e.prototype.buildDrawCalls = function() {
							for (var t = ++Re._globalBatch, e = 0; e < this.drawCalls.length; e++) this.drawCalls[e].texArray.clear(), Xs.push(this.drawCalls[e]);
							this.drawCalls.length = 0;
							var i = this.colors,
								n = this.textureIds,
								s = Xs.pop();
							s || ((s = new xn).texArray = new Bn), s.texArray.count = 0, s.start = 0, s.size = 0, s.type = g.TRIANGLES;
							var o = 0,
								r = null,
								a = 0,
								l = !1,
								h = g.TRIANGLES,
								u = 0;
							for (this.drawCalls.push(s), e = 0; e < this.batches.length; e++) {
								var c = this.batches[e],
									d = c.style,
									p = d.texture.baseTexture;
								l !== !!d.native && (h = (l = !!d.native) ? g.LINES : g.TRIANGLES, r = null, o = 8, t++), r !== p && (r = p, p._batchEnabled !== t && (8 === o && (t++, o = 0, s.size > 0 && ((s = Xs.pop()) || ((s = new xn).texArray = new Bn), this.drawCalls.push(s)), s.start = u, s.size = 0, s.texArray.count = 0, s.type = h), p.touched = 1, p._batchEnabled = t, p._batchLocation = o, p.wrapMode = 10497, s.texArray.elements[s.texArray.count++] = p, o++)), s.size += c.size, u += c.size, a = p._batchLocation, this.addColors(i, d.color, d.alpha, c.attribSize, c.attribStart), this.addTextureIds(n, a, c.attribSize, c.attribStart)
							}
							Re._globalBatch = t, this.packAttributes()
						}, e.prototype.packAttributes = function() {
							for (var t = this.points, e = this.uvs, i = this.colors, n = this.textureIds, s = new ArrayBuffer(3 * t.length * 4), o = new Float32Array(s), r = new Uint32Array(s), a = 0, l = 0; l < t.length / 2; l++) o[a++] = t[2 * l], o[a++] = t[2 * l + 1], o[a++] = e[2 * l], o[a++] = e[2 * l + 1], r[a++] = i[l], o[a++] = n[l];
							this._buffer.update(s), this._indexBuffer.update(this.indicesUint16)
						}, e.prototype.processFill = function(t) {
							t.holes.length ? (this.processHoles(t.holes), Is.triangulate(t, this)) : Hs[t.type].triangulate(t, this)
						}, e.prototype.processLine = function(t) {
							Ms(t, this);
							for (var e = 0; e < t.holes.length; e++) Ms(t.holes[e], this)
						}, e.prototype.processHoles = function(t) {
							for (var e = 0; e < t.length; e++) {
								var i = t[e];
								Hs[i.type].build(i), i.matrix && this.transformPoints(i.points, i.matrix)
							}
						}, e.prototype.calculateBounds = function() {
							var t = this._bounds,
								e = Ks,
								i = qt.IDENTITY;
							this._bounds.clear(), e.clear();
							for (var n = 0; n < this.graphicsData.length; n++) {
								var s = this.graphicsData[n],
									o = s.shape,
									r = s.type,
									a = s.lineStyle,
									l = s.matrix || qt.IDENTITY,
									h = 0;
								if (a && a.visible) {
									var u = a.alignment;
									h = a.width, r === Ft.POLY ? h *= .5 + Math.abs(.5 - u) : h *= Math.max(0, u)
								}
								if (i !== l && (e.isEmpty() || (t.addBoundsMatrix(e, i), e.clear()), i = l), r === Ft.RECT || r === Ft.RREC) {
									var c = o;
									e.addFramePad(c.x, c.y, c.x + c.width, c.y + c.height, h, h)
								} else if (r === Ft.CIRC) {
									var d = o;
									e.addFramePad(d.x, d.y, d.x, d.y, d.radius + h, d.radius + h)
								} else if (r === Ft.ELIP) {
									var p = o;
									e.addFramePad(p.x, p.y, p.x, p.y, p.width + h, p.height + h)
								} else {
									var _ = o;
									t.addVerticesMatrix(i, _.points, 0, _.points.length, h, h)
								}
							}
							e.isEmpty() || t.addBoundsMatrix(e, i), t.pad(this.boundsPadding, this.boundsPadding)
						}, e.prototype.transformPoints = function(t, e) {
							for (var i = 0; i < t.length / 2; i++) {
								var n = t[2 * i],
									s = t[2 * i + 1];
								t[2 * i] = e.a * n + e.c * s + e.tx, t[2 * i + 1] = e.b * n + e.d * s + e.ty
							}
						}, e.prototype.addColors = function(t, e, i, n, s) {
							void 0 === s && (s = 0);
							var o = ct((e >> 16) + (65280 & e) + ((255 & e) << 16), i);
							t.length = Math.max(t.length, s + n);
							for (var r = 0; r < n; r++) t[s + r] = o
						}, e.prototype.addTextureIds = function(t, e, i, n) {
							void 0 === n && (n = 0), t.length = Math.max(t.length, n + i);
							for (var s = 0; s < i; s++) t[n + s] = e
						}, e.prototype.addUvs = function(t, e, i, n, s, o) {
							void 0 === o && (o = null);
							for (var r = 0, a = e.length, l = i.frame; r < s;) {
								var h = t[2 * (n + r)],
									u = t[2 * (n + r) + 1];
								if (o) {
									var c = o.a * h + o.c * u + o.tx;
									u = o.b * h + o.d * u + o.ty, h = c
								}
								r++, e.push(h / l.width, u / l.height)
							}
							var d = i.baseTexture;
							(l.width < d.width || l.height < d.height) && this.adjustUvs(e, i, a, s)
						}, e.prototype.adjustUvs = function(t, e, i, n) {
							for (var s = e.baseTexture, o = 1e-6, r = i + 2 * n, a = e.frame, l = a.width / s.width, h = a.height / s.height, u = a.x / a.width, c = a.y / a.height, d = Math.floor(t[i] + o), p = Math.floor(t[i + 1] + o), _ = i + 2; _ < r; _ += 2) d = Math.min(d, Math.floor(t[_] + o)), p = Math.min(p, Math.floor(t[_ + 1] + o));
							for (u -= d, c -= p, _ = i; _ < r; _ += 2) t[_] = (t[_] + u) * l, t[_ + 1] = (t[_ + 1] + c) * h
						}, e.BATCHABLE_SIZE = 100, e
					}(Rn),
					Zs = function(t) {
						function e() {
							var e = null !== t && t.apply(this, arguments) || this;
							return e.width = 0, e.alignment = .5, e.native = !1, e.cap = Ss.BUTT, e.join = fs.MITER, e.miterLimit = 10, e
						}
						return Ps(e, t), e.prototype.clone = function() {
							var t = new e;
							return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t.width = this.width, t.alignment = this.alignment, t.native = this.native, t.cap = this.cap, t.join = this.join, t.miterLimit = this.miterLimit, t
						}, e.prototype.reset = function() {
							t.prototype.reset.call(this), this.color = 0, this.alignment = .5, this.width = 0, this.native = !1
						}, e
					}(bs),
					$s = new Float32Array(3),
					Qs = {},
					Js = function(t) {
						function e(e) {
							void 0 === e && (e = null);
							var i = t.call(this) || this;
							return i._geometry = e || new qs, i._geometry.refCount++, i.shader = null, i.state = Ji.for2d(), i._fillStyle = new bs, i._lineStyle = new Zs, i._matrix = null, i._holeMode = !1, i.currentPath = null, i.batches = [], i.batchTint = -1, i.batchDirty = -1, i.vertexData = null, i.pluginName = "batch", i._transformID = -1, i.tint = 16777215, i.blendMode = m.NORMAL, i
						}
						return Ps(e, t), Object.defineProperty(e.prototype, "geometry", {
							get: function() {
								return this._geometry
							},
							enumerable: !1,
							configurable: !0
						}), e.prototype.clone = function() {
							return this.finishPoly(), new e(this._geometry)
						}, Object.defineProperty(e.prototype, "blendMode", {
							get: function() {
								return this.state.blendMode
							},
							set: function(t) {
								this.state.blendMode = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "tint", {
							get: function() {
								return this._tint
							},
							set: function(t) {
								this._tint = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "fill", {
							get: function() {
								return this._fillStyle
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "line", {
							get: function() {
								return this._lineStyle
							},
							enumerable: !1,
							configurable: !0
						}), e.prototype.lineStyle = function(t) {
							if (void 0 === t && (t = null), "number" == typeof t) {
								var e = arguments;
								t = {
									width: e[0] || 0,
									color: e[1] || 0,
									alpha: void 0 !== e[2] ? e[2] : 1,
									alignment: void 0 !== e[3] ? e[3] : .5,
									native: !!e[4]
								}
							}
							return this.lineTextureStyle(t)
						}, e.prototype.lineTextureStyle = function(t) {
							if ("number" == typeof t) {
								Pt("v5.2.0", "Please use object-based options for Graphics#lineTextureStyle");
								var e = arguments;
								t = {
									width: e[0],
									texture: e[1],
									color: e[2],
									alpha: e[3],
									matrix: e[4],
									alignment: e[5],
									native: e[6]
								}, Object.keys(t).forEach((function(e) {
									return void 0 === t[e] && delete t[e]
								}))
							}
							t = Object.assign({
								width: 0,
								texture: Qe.WHITE,
								color: t && t.texture ? 16777215 : 0,
								alpha: 1,
								matrix: null,
								alignment: .5,
								native: !1,
								cap: Ss.BUTT,
								join: fs.MITER,
								miterLimit: 10
							}, t), this.currentPath && this.startPoly();
							var i = t.width > 0 && t.alpha > 0;
							return i ? (t.matrix && (t.matrix = t.matrix.clone(), t.matrix.invert()), Object.assign(this._lineStyle, {
								visible: i
							}, t)) : this._lineStyle.reset(), this
						}, e.prototype.startPoly = function() {
							if (this.currentPath) {
								var t = this.currentPath.points,
									e = this.currentPath.points.length;
								e > 2 && (this.drawShape(this.currentPath), this.currentPath = new Yt, this.currentPath.closeStroke = !1, this.currentPath.points.push(t[e - 2], t[e - 1]))
							} else this.currentPath = new Yt, this.currentPath.closeStroke = !1
						}, e.prototype.finishPoly = function() {
							this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0)
						}, e.prototype.moveTo = function(t, e) {
							return this.startPoly(), this.currentPath.points[0] = t, this.currentPath.points[1] = e, this
						}, e.prototype.lineTo = function(t, e) {
							this.currentPath || this.moveTo(0, 0);
							var i = this.currentPath.points,
								n = i[i.length - 2],
								s = i[i.length - 1];
							return n === t && s === e || i.push(t, e), this
						}, e.prototype._initCurve = function(t, e) {
							void 0 === t && (t = 0), void 0 === e && (e = 0), this.currentPath ? 0 === this.currentPath.points.length && (this.currentPath.points = [t, e]) : this.moveTo(t, e)
						}, e.prototype.quadraticCurveTo = function(t, e, i, n) {
							this._initCurve();
							var s = this.currentPath.points;
							return 0 === s.length && this.moveTo(0, 0), Us.curveTo(t, e, i, n, s), this
						}, e.prototype.bezierCurveTo = function(t, e, i, n, s, o) {
							return this._initCurve(), Gs.curveTo(t, e, i, n, s, o, this.currentPath.points), this
						}, e.prototype.arcTo = function(t, e, i, n, s) {
							this._initCurve(t, e);
							var o = this.currentPath.points,
								r = Fs.curveTo(t, e, i, n, s, o);
							if (r) {
								var a = r.cx,
									l = r.cy,
									h = r.radius,
									u = r.startAngle,
									c = r.endAngle,
									d = r.anticlockwise;
								this.arc(a, l, h, u, c, d)
							}
							return this
						}, e.prototype.arc = function(t, e, i, n, s, o) {
							if (void 0 === o && (o = !1), n === s) return this;
							if (!o && s <= n ? s += Gt : o && n <= s && (n += Gt), 0 == s - n) return this;
							var r = t + Math.cos(n) * i,
								a = e + Math.sin(n) * i,
								l = this._geometry.closePointEps,
								h = this.currentPath ? this.currentPath.points : null;
							if (h) {
								var u = Math.abs(h[h.length - 2] - r),
									c = Math.abs(h[h.length - 1] - a);
								u < l && c < l || h.push(r, a)
							} else this.moveTo(r, a), h = this.currentPath.points;
							return Fs.arc(r, a, t, e, i, n, s, o, h), this
						}, e.prototype.beginFill = function(t, e) {
							return void 0 === t && (t = 0), void 0 === e && (e = 1), this.beginTextureFill({
								texture: Qe.WHITE,
								color: t,
								alpha: e
							})
						}, e.prototype.beginTextureFill = function(t) {
							if (t instanceof Qe) {
								Pt("v5.2.0", "Please use object-based options for Graphics#beginTextureFill");
								var e = arguments;
								t = {
									texture: e[0],
									color: e[1],
									alpha: e[2],
									matrix: e[3]
								}, Object.keys(t).forEach((function(e) {
									return void 0 === t[e] && delete t[e]
								}))
							}
							t = Object.assign({
								texture: Qe.WHITE,
								color: 16777215,
								alpha: 1,
								matrix: null
							}, t), this.currentPath && this.startPoly();
							var i = t.alpha > 0;
							return i ? (t.matrix && (t.matrix = t.matrix.clone(), t.matrix.invert()), Object.assign(this._fillStyle, {
								visible: i
							}, t)) : this._fillStyle.reset(), this
						}, e.prototype.endFill = function() {
							return this.finishPoly(), this._fillStyle.reset(), this
						}, e.prototype.drawRect = function(t, e, i, n) {
							return this.drawShape(new Ht(t, e, i, n))
						}, e.prototype.drawRoundedRect = function(t, e, i, n, s) {
							return this.drawShape(new zt(t, e, i, n, s))
						}, e.prototype.drawCircle = function(t, e, i) {
							return this.drawShape(new Vt(t, e, i))
						}, e.prototype.drawEllipse = function(t, e, i, n) {
							return this.drawShape(new Xt(t, e, i, n))
						}, e.prototype.drawPolygon = function() {
							for (var t, e = arguments, i = [], n = 0; n < arguments.length; n++) i[n] = e[n];
							var s = !0,
								o = i[0];
							o.points ? (s = o.closeStroke, t = o.points) : t = Array.isArray(i[0]) ? i[0] : i;
							var r = new Yt(t);
							return r.closeStroke = s, this.drawShape(r), this
						}, e.prototype.drawShape = function(t) {
							return this._holeMode ? this._geometry.drawHole(t, this._matrix) : this._geometry.drawShape(t, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this
						}, e.prototype.drawStar = function(t, e, i, n, s, o) {
							return void 0 === o && (o = 0), this.drawPolygon(new ks(t, e, i, n, s, o))
						}, e.prototype.clear = function() {
							return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this
						}, e.prototype.isFastRect = function() {
							var t = this._geometry.graphicsData;
							return 1 === t.length && t[0].shape.type === Ft.RECT && !(t[0].lineStyle.visible && t[0].lineStyle.width)
						}, e.prototype._render = function(t) {
							this.finishPoly();
							var e = this._geometry,
								i = t.context.supports.uint32Indices;
							e.updateBatches(i), e.batchable ? (this.batchDirty !== e.batchDirty && this._populateBatches(), this._renderBatched(t)) : (t.batch.flush(), this._renderDirect(t))
						}, e.prototype._populateBatches = function() {
							var t = this._geometry,
								e = this.blendMode,
								i = t.batches.length;
							this.batchTint = -1, this._transformID = -1, this.batchDirty = t.batchDirty, this.batches.length = i, this.vertexData = new Float32Array(t.points);
							for (var n = 0; n < i; n++) {
								var s = t.batches[n],
									o = s.style.color,
									r = new Float32Array(this.vertexData.buffer, 4 * s.attribStart * 2, 2 * s.attribSize),
									a = new Float32Array(t.uvsFloat32.buffer, 4 * s.attribStart * 2, 2 * s.attribSize),
									l = {
										vertexData: r,
										blendMode: e,
										indices: new Uint16Array(t.indicesUint16.buffer, 2 * s.start, s.size),
										uvs: a,
										_batchRGB: st(o),
										_tintRGB: o,
										_texture: s.style.texture,
										alpha: s.style.alpha,
										worldAlpha: 1
									};
								this.batches[n] = l
							}
						}, e.prototype._renderBatched = function(t) {
							if (this.batches.length) {
								t.batch.setObjectRenderer(t.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
								for (var e = 0, i = this.batches.length; e < i; e++) {
									var n = this.batches[e];
									n.worldAlpha = this.worldAlpha * n.alpha, t.plugins[this.pluginName].render(n)
								}
							}
						}, e.prototype._renderDirect = function(t) {
							var e = this._resolveDirectShader(t),
								i = this._geometry,
								n = this.tint,
								s = this.worldAlpha,
								o = e.uniforms,
								r = i.drawCalls;
							o.translationMatrix = this.transform.worldTransform, o.tint[0] = (n >> 16 & 255) / 255 * s, o.tint[1] = (n >> 8 & 255) / 255 * s, o.tint[2] = (255 & n) / 255 * s, o.tint[3] = s, t.shader.bind(e), t.geometry.bind(i, e), t.state.set(this.state);
							for (var a = 0, l = r.length; a < l; a++) this._renderDrawCallDirect(t, i.drawCalls[a])
						}, e.prototype._renderDrawCallDirect = function(t, e) {
							for (var i = e.texArray, n = e.type, s = e.size, o = e.start, r = i.count, a = 0; a < r; a++) t.texture.bind(i.elements[a], a);
							t.geometry.draw(n, s, o)
						}, e.prototype._resolveDirectShader = function(t) {
							var e = this.shader,
								i = this.pluginName;
							if (!e) {
								if (!Qs[i]) {
									for (var n = t.plugins.batch.MAX_TEXTURES, s = new Int32Array(n), o = 0; o < n; o++) s[o] = o;
									var r = {
											tint: new Float32Array([1, 1, 1, 1]),
											translationMatrix: new qt,
											default: _i.from({
												uSamplers: s
											}, !0)
										},
										a = t.plugins[i]._shader.program;
									Qs[i] = new Qi(a, r)
								}
								e = Qs[i]
							}
							return e
						}, e.prototype._calculateBounds = function() {
							this.finishPoly();
							var t = this._geometry;
							if (t.graphicsData.length) {
								var e = t.bounds,
									i = e.minX,
									n = e.minY,
									s = e.maxX,
									o = e.maxY;
								this._bounds.addFrame(this.transform, i, n, s, o)
							}
						}, e.prototype.containsPoint = function(t) {
							return this.worldTransform.applyInverse(t, e._TEMP_POINT), this._geometry.containsPoint(e._TEMP_POINT)
						}, e.prototype.calculateTints = function() {
							if (this.batchTint !== this.tint) {
								this.batchTint = this.tint;
								for (var t = st(this.tint, $s), e = 0; e < this.batches.length; e++) {
									var i = this.batches[e],
										n = i._batchRGB,
										s = (t[0] * n[0] * 255 << 16) + (t[1] * n[1] * 255 << 8) + (0 | t[2] * n[2] * 255);
									i._tintRGB = (s >> 16) + (65280 & s) + ((255 & s) << 16)
								}
							}
						}, e.prototype.calculateVertices = function() {
							var t = this.transform._worldID;
							if (this._transformID !== t) {
								this._transformID = t;
								for (var e = this.transform.worldTransform, i = e.a, n = e.b, s = e.c, o = e.d, r = e.tx, a = e.ty, l = this._geometry.points, h = this.vertexData, u = 0, c = 0; c < l.length; c += 2) {
									var d = l[c],
										p = l[c + 1];
									h[u++] = i * d + s * p + r, h[u++] = o * p + n * d + a
								}
							}
						}, e.prototype.closePath = function() {
							var t = this.currentPath;
							return t && (t.closeStroke = !0), this
						}, e.prototype.setMatrix = function(t) {
							return this._matrix = t, this
						}, e.prototype.beginHole = function() {
							return this.finishPoly(), this._holeMode = !0, this
						}, e.prototype.endHole = function() {
							return this.finishPoly(), this._holeMode = !1, this
						}, e.prototype.destroy = function(e) {
							this._geometry.refCount--, 0 === this._geometry.refCount && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, t.prototype.destroy.call(this, e)
						}, e._TEMP_POINT = new jt, e
					}(ce),
					to = function(t, e) {
						return to = Object.setPrototypeOf || {
							__proto__: []
						}
						instanceof Array && function(t, e) {
							t.__proto__ = e
						} || function(t, e) {
							for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
						}, to(t, e)
					},
					eo = new jt,
					io = new Uint16Array([0, 1, 2, 0, 2, 3]),
					no = function(t) {
						function e(e) {
							var i = t.call(this) || this;
							return i._anchor = new Kt(i._onAnchorUpdate, i, e ? e.defaultAnchor.x : 0, e ? e.defaultAnchor.y : 0), i._texture = null, i._width = 0, i._height = 0, i._tint = null, i._tintRGB = null, i.tint = 16777215, i.blendMode = m.NORMAL, i._cachedTint = 16777215, i.uvs = null, i.texture = e || Qe.EMPTY, i.vertexData = new Float32Array(8), i.vertexTrimmedData = null, i._transformID = -1, i._textureID = -1, i._transformTrimmedID = -1, i._textureTrimmedID = -1, i.indices = io, i.pluginName = "batch", i.isSprite = !0, i._roundPixels = z.ROUND_PIXELS, i
						}
						return function(t, e) {
							function i() {
								this.constructor = t
							}
							to(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
						}(e, t), e.prototype._onTextureUpdate = function() {
							this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = Tt(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = Tt(this.scale.y) * this._height / this._texture.orig.height)
						}, e.prototype._onAnchorUpdate = function() {
							this._transformID = -1, this._transformTrimmedID = -1
						}, e.prototype.calculateVertices = function() {
							var t = this._texture;
							if (this._transformID !== this.transform._worldID || this._textureID !== t._updateID) {
								this._textureID !== t._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = t._updateID;
								var e = this.transform.worldTransform,
									i = e.a,
									n = e.b,
									s = e.c,
									o = e.d,
									r = e.tx,
									a = e.ty,
									l = this.vertexData,
									h = t.trim,
									u = t.orig,
									c = this._anchor,
									d = 0,
									p = 0,
									_ = 0,
									m = 0;
								if (h ? (d = (p = h.x - c._x * u.width) + h.width, _ = (m = h.y - c._y * u.height) + h.height) : (d = (p = -c._x * u.width) + u.width, _ = (m = -c._y * u.height) + u.height), l[0] = i * p + s * m + r, l[1] = o * m + n * p + a, l[2] = i * d + s * m + r, l[3] = o * m + n * d + a, l[4] = i * d + s * _ + r, l[5] = o * _ + n * d + a, l[6] = i * p + s * _ + r, l[7] = o * _ + n * p + a, this._roundPixels)
									for (var g = z.RESOLUTION, f = 0; f < l.length; ++f) l[f] = Math.round((l[f] * g | 0) / g)
							}
						}, e.prototype.calculateTrimmedVertices = function() {
							if (this.vertexTrimmedData) {
								if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) return
							} else this.vertexTrimmedData = new Float32Array(8);
							this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
							var t = this._texture,
								e = this.vertexTrimmedData,
								i = t.orig,
								n = this._anchor,
								s = this.transform.worldTransform,
								o = s.a,
								r = s.b,
								a = s.c,
								l = s.d,
								h = s.tx,
								u = s.ty,
								c = -n._x * i.width,
								d = c + i.width,
								p = -n._y * i.height,
								_ = p + i.height;
							e[0] = o * c + a * p + h, e[1] = l * p + r * c + u, e[2] = o * d + a * p + h, e[3] = l * p + r * d + u, e[4] = o * d + a * _ + h, e[5] = l * _ + r * d + u, e[6] = o * c + a * _ + h, e[7] = l * _ + r * c + u
						}, e.prototype._render = function(t) {
							this.calculateVertices(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this)
						}, e.prototype._calculateBounds = function() {
							var t = this._texture.trim,
								e = this._texture.orig;
							!t || t.width === e.width && t.height === e.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData))
						}, e.prototype.getLocalBounds = function(e) {
							return 0 === this.children.length ? (this._bounds.minX = this._texture.orig.width * -this._anchor._x, this._bounds.minY = this._texture.orig.height * -this._anchor._y, this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Ht), e = this._localBoundsRect), this._bounds.getRectangle(e)) : t.prototype.getLocalBounds.call(this, e)
						}, e.prototype.containsPoint = function(t) {
							this.worldTransform.applyInverse(t, eo);
							var e = this._texture.orig.width,
								i = this._texture.orig.height,
								n = -e * this.anchor.x,
								s = 0;
							return eo.x >= n && eo.x < n + e && (s = -i * this.anchor.y, eo.y >= s && eo.y < s + i)
						}, e.prototype.destroy = function(e) {
							if (t.prototype.destroy.call(this, e), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null, "boolean" == typeof e ? e : e && e.texture) {
								var i = "boolean" == typeof e ? e : e && e.baseTexture;
								this._texture.destroy(!!i)
							}
							this._texture = null
						}, e.from = function(t, i) {
							return new e(t instanceof Qe ? t : Qe.from(t, i))
						}, Object.defineProperty(e.prototype, "roundPixels", {
							get: function() {
								return this._roundPixels
							},
							set: function(t) {
								this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "width", {
							get: function() {
								return Math.abs(this.scale.x) * this._texture.orig.width
							},
							set: function(t) {
								var e = Tt(this.scale.x) || 1;
								this.scale.x = e * t / this._texture.orig.width, this._width = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "height", {
							get: function() {
								return Math.abs(this.scale.y) * this._texture.orig.height
							},
							set: function(t) {
								var e = Tt(this.scale.y) || 1;
								this.scale.y = e * t / this._texture.orig.height, this._height = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "anchor", {
							get: function() {
								return this._anchor
							},
							set: function(t) {
								this._anchor.copyFrom(t)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "tint", {
							get: function() {
								return this._tint
							},
							set: function(t) {
								this._tint = t, this._tintRGB = (t >> 16) + (65280 & t) + ((255 & t) << 16)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "texture", {
							get: function() {
								return this._texture
							},
							set: function(t) {
								this._texture !== t && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = t || Qe.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, t && (t.baseTexture.valid ? this._onTextureUpdate() : t.once("update", this._onTextureUpdate, this)))
							},
							enumerable: !1,
							configurable: !0
						}), e
					}(ce),
					so = function(t, e) {
						return so = Object.setPrototypeOf || {
							__proto__: []
						}
						instanceof Array && function(t, e) {
							t.__proto__ = e
						} || function(t, e) {
							for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
						}, so(t, e)
					};
				! function(t) {
					t[t.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", t[t.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL"
				}(Ds || (Ds = {}));
				var oo = {
						align: "left",
						breakWords: !1,
						dropShadow: !1,
						dropShadowAlpha: 1,
						dropShadowAngle: Math.PI / 6,
						dropShadowBlur: 0,
						dropShadowColor: "black",
						dropShadowDistance: 5,
						fill: "black",
						fillGradientType: Ds.LINEAR_VERTICAL,
						fillGradientStops: [],
						fontFamily: "Arial",
						fontSize: 26,
						fontStyle: "normal",
						fontVariant: "normal",
						fontWeight: "normal",
						letterSpacing: 0,
						lineHeight: 0,
						lineJoin: "miter",
						miterLimit: 10,
						padding: 0,
						stroke: "black",
						strokeThickness: 0,
						textBaseline: "alphabetic",
						trim: !1,
						whiteSpace: "pre",
						wordWrap: !1,
						wordWrapWidth: 100,
						leading: 0
					},
					ro = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"],
					ao = function() {
						function t(t) {
							this.styleID = 0, this.reset(), uo(this, t, t)
						}
						return t.prototype.clone = function() {
							var e = {};
							return uo(e, this, oo), new t(e)
						}, t.prototype.reset = function() {
							uo(this, oo, oo)
						}, Object.defineProperty(t.prototype, "align", {
							get: function() {
								return this._align
							},
							set: function(t) {
								this._align !== t && (this._align = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "breakWords", {
							get: function() {
								return this._breakWords
							},
							set: function(t) {
								this._breakWords !== t && (this._breakWords = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "dropShadow", {
							get: function() {
								return this._dropShadow
							},
							set: function(t) {
								this._dropShadow !== t && (this._dropShadow = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "dropShadowAlpha", {
							get: function() {
								return this._dropShadowAlpha
							},
							set: function(t) {
								this._dropShadowAlpha !== t && (this._dropShadowAlpha = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "dropShadowAngle", {
							get: function() {
								return this._dropShadowAngle
							},
							set: function(t) {
								this._dropShadowAngle !== t && (this._dropShadowAngle = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "dropShadowBlur", {
							get: function() {
								return this._dropShadowBlur
							},
							set: function(t) {
								this._dropShadowBlur !== t && (this._dropShadowBlur = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "dropShadowColor", {
							get: function() {
								return this._dropShadowColor
							},
							set: function(t) {
								var e = ho(t);
								this._dropShadowColor !== e && (this._dropShadowColor = e, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "dropShadowDistance", {
							get: function() {
								return this._dropShadowDistance
							},
							set: function(t) {
								this._dropShadowDistance !== t && (this._dropShadowDistance = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "fill", {
							get: function() {
								return this._fill
							},
							set: function(t) {
								var e = ho(t);
								this._fill !== e && (this._fill = e, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "fillGradientType", {
							get: function() {
								return this._fillGradientType
							},
							set: function(t) {
								this._fillGradientType !== t && (this._fillGradientType = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "fillGradientStops", {
							get: function() {
								return this._fillGradientStops
							},
							set: function(t) {
								(function(t, e) {
									if (!Array.isArray(t) || !Array.isArray(e)) return !1;
									if (t.length !== e.length) return !1;
									for (var i = 0; i < t.length; ++i)
										if (t[i] !== e[i]) return !1;
									return !0
								})(this._fillGradientStops, t) || (this._fillGradientStops = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "fontFamily", {
							get: function() {
								return this._fontFamily
							},
							set: function(t) {
								this.fontFamily !== t && (this._fontFamily = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "fontSize", {
							get: function() {
								return this._fontSize
							},
							set: function(t) {
								this._fontSize !== t && (this._fontSize = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "fontStyle", {
							get: function() {
								return this._fontStyle
							},
							set: function(t) {
								this._fontStyle !== t && (this._fontStyle = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "fontVariant", {
							get: function() {
								return this._fontVariant
							},
							set: function(t) {
								this._fontVariant !== t && (this._fontVariant = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "fontWeight", {
							get: function() {
								return this._fontWeight
							},
							set: function(t) {
								this._fontWeight !== t && (this._fontWeight = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "letterSpacing", {
							get: function() {
								return this._letterSpacing
							},
							set: function(t) {
								this._letterSpacing !== t && (this._letterSpacing = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "lineHeight", {
							get: function() {
								return this._lineHeight
							},
							set: function(t) {
								this._lineHeight !== t && (this._lineHeight = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "leading", {
							get: function() {
								return this._leading
							},
							set: function(t) {
								this._leading !== t && (this._leading = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "lineJoin", {
							get: function() {
								return this._lineJoin
							},
							set: function(t) {
								this._lineJoin !== t && (this._lineJoin = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "miterLimit", {
							get: function() {
								return this._miterLimit
							},
							set: function(t) {
								this._miterLimit !== t && (this._miterLimit = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "padding", {
							get: function() {
								return this._padding
							},
							set: function(t) {
								this._padding !== t && (this._padding = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "stroke", {
							get: function() {
								return this._stroke
							},
							set: function(t) {
								var e = ho(t);
								this._stroke !== e && (this._stroke = e, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "strokeThickness", {
							get: function() {
								return this._strokeThickness
							},
							set: function(t) {
								this._strokeThickness !== t && (this._strokeThickness = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "textBaseline", {
							get: function() {
								return this._textBaseline
							},
							set: function(t) {
								this._textBaseline !== t && (this._textBaseline = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "trim", {
							get: function() {
								return this._trim
							},
							set: function(t) {
								this._trim !== t && (this._trim = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "whiteSpace", {
							get: function() {
								return this._whiteSpace
							},
							set: function(t) {
								this._whiteSpace !== t && (this._whiteSpace = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "wordWrap", {
							get: function() {
								return this._wordWrap
							},
							set: function(t) {
								this._wordWrap !== t && (this._wordWrap = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(t.prototype, "wordWrapWidth", {
							get: function() {
								return this._wordWrapWidth
							},
							set: function(t) {
								this._wordWrapWidth !== t && (this._wordWrapWidth = t, this.styleID++)
							},
							enumerable: !1,
							configurable: !0
						}), t.prototype.toFontString = function() {
							var t = "number" == typeof this.fontSize ? this.fontSize + "px" : this.fontSize,
								e = this.fontFamily;
							Array.isArray(this.fontFamily) || (e = this.fontFamily.split(","));
							for (var i = e.length - 1; i >= 0; i--) {
								var n = e[i].trim();
								!/([\"\'])[^\'\"]+\1/.test(n) && ro.indexOf(n) < 0 && (n = '"' + n + '"'), e[i] = n
							}
							return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + t + " " + e.join(",")
						}, t
					}();

				function lo(t) {
					return "number" == typeof t ? ot(t) : ("string" == typeof t && 0 === t.indexOf("0x") && (t = t.replace("0x", "#")), t)
				}

				function ho(t) {
					if (Array.isArray(t)) {
						for (var e = 0; e < t.length; ++e) t[e] = lo(t[e]);
						return t
					}
					return lo(t)
				}

				function uo(t, e, i) {
					for (var n in i) Array.isArray(e[n]) ? t[n] = e[n].slice() : t[n] = e[n]
				}
				var co = function() {
						function t(t, e, i, n, s, o, r, a, l) {
							this.text = t, this.style = e, this.width = i, this.height = n, this.lines = s, this.lineWidths = o, this.lineHeight = r, this.maxLineWidth = a, this.fontProperties = l
						}
						return t.measureText = function(e, i, n, s) {
							void 0 === s && (s = t._canvas), n = null == n ? i.wordWrap : n;
							var o = i.toFontString(),
								r = t.measureFont(o);
							0 === r.fontSize && (r.fontSize = i.fontSize, r.ascent = i.fontSize);
							var a = s.getContext("2d");
							a.font = o;
							for (var l = (n ? t.wordWrap(e, i, s) : e).split(/(?:\r\n|\r|\n)/), h = new Array(l.length), u = 0, c = 0; c < l.length; c++) {
								var d = a.measureText(l[c]).width + (l[c].length - 1) * i.letterSpacing;
								h[c] = d, u = Math.max(u, d)
							}
							var p = u + i.strokeThickness;
							i.dropShadow && (p += i.dropShadowDistance);
							var _ = i.lineHeight || r.fontSize + i.strokeThickness,
								m = Math.max(_, r.fontSize + i.strokeThickness) + (l.length - 1) * (_ + i.leading);
							return i.dropShadow && (m += i.dropShadowDistance), new t(e, i, p, m, l, h, _ + i.leading, u, r)
						}, t.wordWrap = function(e, i, n) {
							void 0 === n && (n = t._canvas);
							for (var s = n.getContext("2d"), o = 0, r = "", a = "", l = Object.create(null), h = i.letterSpacing, u = i.whiteSpace, c = t.collapseSpaces(u), d = t.collapseNewlines(u), p = !c, _ = i.wordWrapWidth + h, m = t.tokenize(e), g = 0; g < m.length; g++) {
								var f = m[g];
								if (t.isNewline(f)) {
									if (!d) {
										a += t.addLine(r), p = !c, r = "", o = 0;
										continue
									}
									f = " "
								}
								if (c) {
									var S = t.isBreakingSpace(f),
										y = t.isBreakingSpace(r[r.length - 1]);
									if (S && y) continue
								}
								var v = t.getFromCache(f, h, l, s);
								if (v > _)
									if ("" !== r && (a += t.addLine(r), r = "", o = 0), t.canBreakWords(f, i.breakWords))
										for (var T = t.wordWrapSplit(f), E = 0; E < T.length; E++) {
											for (var b = T[E], A = 1; T[E + A];) {
												var P = T[E + A],
													I = b[b.length - 1];
												if (t.canBreakChars(I, P, f, E, i.breakWords)) break;
												b += P, A++
											}
											E += b.length - 1;
											var w = t.getFromCache(b, h, l, s);
											w + o > _ && (a += t.addLine(r), p = !1, r = "", o = 0), r += b, o += w
										} else {
											r.length > 0 && (a += t.addLine(r), r = "", o = 0);
											var L = g === m.length - 1;
											a += t.addLine(f, !L), p = !1, r = "", o = 0
										} else v + o > _ && (p = !1, a += t.addLine(r), r = "", o = 0), (r.length > 0 || !t.isBreakingSpace(f) || p) && (r += f, o += v)
							}
							return a + t.addLine(r, !1)
						}, t.addLine = function(e, i) {
							return void 0 === i && (i = !0), e = t.trimRight(e), i ? e + "\n" : e
						}, t.getFromCache = function(t, e, i, n) {
							var s = i[t];
							if ("number" != typeof s) {
								var o = t.length * e;
								s = n.measureText(t).width + o, i[t] = s
							}
							return s
						}, t.collapseSpaces = function(t) {
							return "normal" === t || "pre-line" === t
						}, t.collapseNewlines = function(t) {
							return "normal" === t
						}, t.trimRight = function(e) {
							if ("string" != typeof e) return "";
							for (var i = e.length - 1; i >= 0; i--) {
								var n = e[i];
								if (!t.isBreakingSpace(n)) break;
								e = e.slice(0, -1)
							}
							return e
						}, t.isNewline = function(e) {
							return "string" == typeof e && t._newlines.indexOf(e.charCodeAt(0)) >= 0
						}, t.isBreakingSpace = function(e) {
							return "string" == typeof e && t._breakingSpaces.indexOf(e.charCodeAt(0)) >= 0
						}, t.tokenize = function(e) {
							var i = [],
								n = "";
							if ("string" != typeof e) return i;
							for (var s = 0; s < e.length; s++) {
								var o = e[s];
								t.isBreakingSpace(o) || t.isNewline(o) ? ("" !== n && (i.push(n), n = ""), i.push(o)) : n += o
							}
							return "" !== n && i.push(n), i
						}, t.canBreakWords = function(t, e) {
							return e
						}, t.canBreakChars = function(t, e, i, n, s) {
							return !0
						}, t.wordWrapSplit = function(t) {
							return t.split("")
						}, t.measureFont = function(e) {
							if (t._fonts[e]) return t._fonts[e];
							var i = {
									ascent: 0,
									descent: 0,
									fontSize: 0
								},
								n = t._canvas,
								s = t._context;
							s.font = e;
							var o = t.METRICS_STRING + t.BASELINE_SYMBOL,
								r = Math.ceil(s.measureText(o).width),
								a = Math.ceil(s.measureText(t.BASELINE_SYMBOL).width),
								l = 2 * a;
							a = a * t.BASELINE_MULTIPLIER | 0, n.width = r, n.height = l, s.fillStyle = "#f00", s.fillRect(0, 0, r, l), s.font = e, s.textBaseline = "alphabetic", s.fillStyle = "#000", s.fillText(o, 0, a);
							var h = s.getImageData(0, 0, r, l).data,
								u = h.length,
								c = 4 * r,
								d = 0,
								p = 0,
								_ = !1;
							for (d = 0; d < a; ++d) {
								for (var m = 0; m < c; m += 4)
									if (255 !== h[p + m]) {
										_ = !0;
										break
									} if (_) break;
								p += c
							}
							for (i.ascent = a - d, p = u - c, _ = !1, d = l; d > a; --d) {
								for (m = 0; m < c; m += 4)
									if (255 !== h[p + m]) {
										_ = !0;
										break
									} if (_) break;
								p -= c
							}
							return i.descent = d - a, i.fontSize = i.ascent + i.descent, t._fonts[e] = i, i
						}, t.clearMetrics = function(e) {
							void 0 === e && (e = ""), e ? delete t._fonts[e] : t._fonts = {}
						}, t
					}(),
					po = function() {
						try {
							var t = new OffscreenCanvas(0, 0),
								e = t.getContext("2d");
							return e && e.measureText ? t : document.createElement("canvas")
						} catch (t) {
							return document.createElement("canvas")
						}
					}();
				po.width = po.height = 10, co._canvas = po, co._context = po.getContext("2d"), co._fonts = {}, co.METRICS_STRING = "|q", co.BASELINE_SYMBOL = "M", co.BASELINE_MULTIPLIER = 1.4, co._newlines = [10, 13], co._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
				var _o = {
						texture: !0,
						children: !1,
						baseTexture: !0
					},
					mo = function(t) {
						function e(e, i, n) {
							var s = this,
								o = !1;
							n || (n = document.createElement("canvas"), o = !0), n.width = 3, n.height = 3;
							var r = Qe.from(n);
							return r.orig = new Ht, r.trim = new Ht, (s = t.call(this, r) || this)._ownCanvas = o, s.canvas = n, s.context = s.canvas.getContext("2d"), s._resolution = z.RESOLUTION, s._autoResolution = !0, s._text = null, s._style = null, s._styleListener = null, s._font = "", s.text = e, s.style = i, s.localStyleID = -1, s
						}
						return function(t, e) {
							function i() {
								this.constructor = t
							}
							so(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
						}(e, t), e.prototype.updateText = function(t) {
							var e = this._style;
							if (this.localStyleID !== e.styleID && (this.dirty = !0, this.localStyleID = e.styleID), this.dirty || !t) {
								this._font = this._style.toFontString();
								var i, n, s = this.context,
									o = co.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas),
									r = o.width,
									a = o.height,
									l = o.lines,
									h = o.lineHeight,
									u = o.lineWidths,
									c = o.maxLineWidth,
									d = o.fontProperties;
								this.canvas.width = Math.ceil((Math.max(1, r) + 2 * e.padding) * this._resolution), this.canvas.height = Math.ceil((Math.max(1, a) + 2 * e.padding) * this._resolution), s.scale(this._resolution, this._resolution), s.clearRect(0, 0, this.canvas.width, this.canvas.height), s.font = this._font, s.lineWidth = e.strokeThickness, s.textBaseline = e.textBaseline, s.lineJoin = e.lineJoin, s.miterLimit = e.miterLimit;
								for (var p = e.dropShadow ? 2 : 1, _ = 0; _ < p; ++_) {
									var m = e.dropShadow && 0 === _,
										g = m ? Math.ceil(Math.max(1, a) + 2 * e.padding) : 0,
										f = g * this._resolution;
									if (m) {
										s.fillStyle = "black", s.strokeStyle = "black";
										var S = e.dropShadowColor,
											y = st("number" == typeof S ? S : rt(S)),
											v = e.dropShadowBlur * this._resolution,
											T = e.dropShadowDistance * this._resolution;
										s.shadowColor = "rgba(" + 255 * y[0] + "," + 255 * y[1] + "," + 255 * y[2] + "," + e.dropShadowAlpha + ")", s.shadowBlur = v, s.shadowOffsetX = Math.cos(e.dropShadowAngle) * T, s.shadowOffsetY = Math.sin(e.dropShadowAngle) * T + f
									} else s.fillStyle = this._generateFillStyle(e, l, o), s.strokeStyle = e.stroke, s.shadowColor = "black", s.shadowBlur = 0, s.shadowOffsetX = 0, s.shadowOffsetY = 0;
									for (var E = 0; E < l.length; E++) i = e.strokeThickness / 2, n = e.strokeThickness / 2 + E * h + d.ascent, "right" === e.align ? i += c - u[E] : "center" === e.align && (i += (c - u[E]) / 2), e.stroke && e.strokeThickness && this.drawLetterSpacing(l[E], i + e.padding, n + e.padding - g, !0), e.fill && this.drawLetterSpacing(l[E], i + e.padding, n + e.padding - g)
								}
								this.updateTexture()
							}
						}, e.prototype.drawLetterSpacing = function(t, e, i, n) {
							void 0 === n && (n = !1);
							var s = this._style.letterSpacing;
							if (0 !== s)
								for (var o = e, r = Array.from ? Array.from(t) : t.split(""), a = this.context.measureText(t).width, l = 0, h = 0; h < r.length; ++h) {
									var u = r[h];
									n ? this.context.strokeText(u, o, i) : this.context.fillText(u, o, i), o += a - (l = this.context.measureText(t.substring(h + 1)).width) + s, a = l
								} else n ? this.context.strokeText(t, e, i) : this.context.fillText(t, e, i)
						}, e.prototype.updateTexture = function() {
							var t = this.canvas;
							if (this._style.trim) {
								var e = Ot(t);
								e.data && (t.width = e.width, t.height = e.height, this.context.putImageData(e.data, 0, 0))
							}
							var i = this._texture,
								n = this._style,
								s = n.trim ? 0 : n.padding,
								o = i.baseTexture;
							i.trim.width = i._frame.width = Math.ceil(t.width / this._resolution), i.trim.height = i._frame.height = Math.ceil(t.height / this._resolution), i.trim.x = -s, i.trim.y = -s, i.orig.width = i._frame.width - 2 * s, i.orig.height = i._frame.height - 2 * s, this._onTextureUpdate(), o.setRealSize(t.width, t.height, this._resolution), this._recursivePostUpdateTransform(), this.dirty = !1
						}, e.prototype._render = function(e) {
							this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), t.prototype._render.call(this, e)
						}, e.prototype.getLocalBounds = function(e) {
							return this.updateText(!0), t.prototype.getLocalBounds.call(this, e)
						}, e.prototype._calculateBounds = function() {
							this.updateText(!0), this.calculateVertices(), this._bounds.addQuad(this.vertexData)
						}, e.prototype._generateFillStyle = function(t, e, i) {
							var n, s = t.fill;
							if (!Array.isArray(s)) return s;
							if (1 === s.length) return s[0];
							var o = t.dropShadow ? t.dropShadowDistance : 0,
								r = t.padding || 0,
								a = Math.ceil(this.canvas.width / this._resolution) - o - 2 * r,
								l = Math.ceil(this.canvas.height / this._resolution) - o - 2 * r,
								h = s.slice(),
								u = t.fillGradientStops.slice();
							if (!u.length)
								for (var c = h.length + 1, d = 1; d < c; ++d) u.push(d / c);
							if (h.unshift(s[0]), u.unshift(0), h.push(s[s.length - 1]), u.push(1), t.fillGradientType === Ds.LINEAR_VERTICAL) {
								n = this.context.createLinearGradient(a / 2, r, a / 2, l + r);
								var p = 0,
									_ = (i.fontProperties.fontSize + t.strokeThickness) / l;
								for (d = 0; d < e.length; d++)
									for (var m = i.lineHeight * d, g = 0; g < h.length; g++) {
										var f = m / l + ("number" == typeof u[g] ? u[g] : g / h.length) * _,
											S = Math.max(p, f);
										S = Math.min(S, 1), n.addColorStop(S, h[g]), p = S
									}
							} else {
								n = this.context.createLinearGradient(r, l / 2, a + r, l / 2);
								var y = h.length + 1,
									v = 1;
								for (d = 0; d < h.length; d++) {
									var T;
									T = "number" == typeof u[d] ? u[d] : v / y, n.addColorStop(T, h[d]), v++
								}
							}
							return n
						}, e.prototype.destroy = function(e) {
							"boolean" == typeof e && (e = {
								children: e
							}), e = Object.assign({}, _o, e), t.prototype.destroy.call(this, e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null
						}, Object.defineProperty(e.prototype, "width", {
							get: function() {
								return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width
							},
							set: function(t) {
								this.updateText(!0);
								var e = Tt(this.scale.x) || 1;
								this.scale.x = e * t / this._texture.orig.width, this._width = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "height", {
							get: function() {
								return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height
							},
							set: function(t) {
								this.updateText(!0);
								var e = Tt(this.scale.y) || 1;
								this.scale.y = e * t / this._texture.orig.height, this._height = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "style", {
							get: function() {
								return this._style
							},
							set: function(t) {
								t = t || {}, this._style = t instanceof ao ? t : new ao(t), this.localStyleID = -1, this.dirty = !0
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "text", {
							get: function() {
								return this._text
							},
							set: function(t) {
								t = String(null == t ? "" : t), this._text !== t && (this._text = t, this.dirty = !0)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "resolution", {
							get: function() {
								return this._resolution
							},
							set: function(t) {
								this._autoResolution = !1, this._resolution !== t && (this._resolution = t, this.dirty = !0)
							},
							enumerable: !1,
							configurable: !0
						}), e
					}(no);
				z.UPLOADS_PER_FRAME = 4;
				var go = function(t, e) {
						return go = Object.setPrototypeOf || {
							__proto__: []
						}
						instanceof Array && function(t, e) {
							t.__proto__ = e
						} || function(t, e) {
							for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
						}, go(t, e)
					},
					fo = function() {
						function t(t) {
							this.maxItemsPerFrame = t, this.itemsLeft = 0
						}
						return t.prototype.beginFrame = function() {
							this.itemsLeft = this.maxItemsPerFrame
						}, t.prototype.allowedToUpload = function() {
							return this.itemsLeft-- > 0
						}, t
					}();

				function So(t, e) {
					var i = !1;
					if (t && t._textures && t._textures.length)
						for (var n = 0; n < t._textures.length; n++)
							if (t._textures[n] instanceof Qe) {
								var s = t._textures[n].baseTexture; - 1 === e.indexOf(s) && (e.push(s), i = !0)
							} return i
				}

				function yo(t, e) {
					if (t.baseTexture instanceof Re) {
						var i = t.baseTexture;
						return -1 === e.indexOf(i) && e.push(i), !0
					}
					return !1
				}

				function vo(t, e) {
					if (t._texture && t._texture instanceof Qe) {
						var i = t._texture.baseTexture;
						return -1 === e.indexOf(i) && e.push(i), !0
					}
					return !1
				}

				function To(t, e) {
					return e instanceof mo && (e.updateText(!0), !0)
				}

				function Eo(t, e) {
					if (e instanceof ao) {
						var i = e.toFontString();
						return co.measureFont(i), !0
					}
					return !1
				}

				function bo(t, e) {
					if (t instanceof mo) {
						-1 === e.indexOf(t.style) && e.push(t.style), -1 === e.indexOf(t) && e.push(t);
						var i = t._texture.baseTexture;
						return -1 === e.indexOf(i) && e.push(i), !0
					}
					return !1
				}

				function Ao(t, e) {
					return t instanceof ao && (-1 === e.indexOf(t) && e.push(t), !0)
				}
				var Po = function() {
					function t(t) {
						var e = this;
						this.limiter = new fo(z.UPLOADS_PER_FRAME), this.renderer = t, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = function() {
							e.queue && e.prepareItems()
						}, this.registerFindHook(bo), this.registerFindHook(Ao), this.registerFindHook(So), this.registerFindHook(yo), this.registerFindHook(vo), this.registerUploadHook(To), this.registerUploadHook(Eo)
					}
					return t.prototype.upload = function(t, e) {
						"function" == typeof t && (e = t, t = null), t && this.add(t), this.queue.length ? (e && this.completes.push(e), this.ticking || (this.ticking = !0, fe.system.addOnce(this.tick, this, pe.UTILITY))) : e && e()
					}, t.prototype.tick = function() {
						setTimeout(this.delayedTick, 0)
					}, t.prototype.prepareItems = function() {
						for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload();) {
							var t = this.queue[0],
								e = !1;
							if (t && !t._destroyed)
								for (var i = 0, n = this.uploadHooks.length; i < n; i++)
									if (this.uploadHooks[i](this.uploadHookHelper, t)) {
										this.queue.shift(), e = !0;
										break
									} e || this.queue.shift()
						}
						if (this.queue.length) fe.system.addOnce(this.tick, this, pe.UTILITY);
						else {
							this.ticking = !1;
							var s = this.completes.slice(0);
							for (this.completes.length = 0, i = 0, n = s.length; i < n; i++) s[i]()
						}
					}, t.prototype.registerFindHook = function(t) {
						return t && this.addHooks.push(t), this
					}, t.prototype.registerUploadHook = function(t) {
						return t && this.uploadHooks.push(t), this
					}, t.prototype.add = function(t) {
						for (var e = 0, i = this.addHooks.length; e < i && !this.addHooks[e](t, this.queue); e++);
						if (t instanceof ce)
							for (e = t.children.length - 1; e >= 0; e--) this.add(t.children[e]);
						return this
					}, t.prototype.destroy = function() {
						this.ticking && fe.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null
					}, t
				}();

				function Io(t, e) {
					return e instanceof Re && (e._glTextures[t.CONTEXT_UID] || t.texture.bind(e), !0)
				}

				function wo(t, e) {
					if (!(e instanceof Js)) return !1;
					var i = e.geometry;
					e.finishPoly(), i.updateBatches();
					for (var n = i.batches, s = 0; s < n.length; s++) {
						var o = n[s].style.texture;
						o && Io(t, o.baseTexture)
					}
					return i.batchable || t.geometry.bind(i, e._resolveDirectShader(t)), !0
				}

				function Lo(t, e) {
					return t instanceof Js && (e.push(t), !0)
				}
				var Co = function(t) {
						function e(e) {
							var i = t.call(this, e) || this;
							return i.uploadHookHelper = i.renderer, i.registerFindHook(Lo), i.registerUploadHook(Io), i.registerUploadHook(wo), i
						}
						return function(t, e) {
							function i() {
								this.constructor = t
							}
							go(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
						}(e, t), e
					}(Po),
					xo = function() {
						function t(t) {
							this.maxMilliseconds = t, this.frameStart = 0
						}
						return t.prototype.beginFrame = function() {
							this.frameStart = Date.now()
						}, t.prototype.allowedToUpload = function() {
							return Date.now() - this.frameStart < this.maxMilliseconds
						}, t
					}(),
					Bo = function() {
						function t(t, e, i) {
							void 0 === i && (i = null), this._texture = t instanceof Qe ? t : null, this.baseTexture = t instanceof Re ? t : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e;
							var n = this.baseTexture.resource;
							this.resolution = this._updateResolution(i || (n ? n.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null
						}
						return t.prototype._updateResolution = function(t) {
							void 0 === t && (t = null);
							var e = this.data.meta.scale,
								i = kt(t, null);
							return null === i && (i = void 0 !== e ? parseFloat(e) : 1), 1 !== i && this.baseTexture.setResolution(i), i
						}, t.prototype.parse = function(e) {
							this._batchIndex = 0, this._callback = e, this._frameKeys.length <= t.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch()
						}, t.prototype._processFrames = function(e) {
							for (var i = e, n = t.BATCH_SIZE; i - e < n && i < this._frameKeys.length;) {
								var s = this._frameKeys[i],
									o = this._frames[s],
									r = o.frame;
								if (r) {
									var a, l = null,
										h = !1 !== o.trimmed && o.sourceSize ? o.sourceSize : o.frame,
										u = new Ht(0, 0, Math.floor(h.w) / this.resolution, Math.floor(h.h) / this.resolution);
									a = o.rotated ? new Ht(Math.floor(r.x) / this.resolution, Math.floor(r.y) / this.resolution, Math.floor(r.h) / this.resolution, Math.floor(r.w) / this.resolution) : new Ht(Math.floor(r.x) / this.resolution, Math.floor(r.y) / this.resolution, Math.floor(r.w) / this.resolution, Math.floor(r.h) / this.resolution), !1 !== o.trimmed && o.spriteSourceSize && (l = new Ht(Math.floor(o.spriteSourceSize.x) / this.resolution, Math.floor(o.spriteSourceSize.y) / this.resolution, Math.floor(r.w) / this.resolution, Math.floor(r.h) / this.resolution)), this.textures[s] = new Qe(this.baseTexture, a, u, l, o.rotated ? 2 : 0, o.anchor), Qe.addToCache(this.textures[s], s)
								}
								i++
							}
						}, t.prototype._processAnimations = function() {
							var t = this.data.animations || {};
							for (var e in t) {
								this.animations[e] = [];
								for (var i = 0; i < t[e].length; i++) {
									var n = t[e][i];
									this.animations[e].push(this.textures[n])
								}
							}
						}, t.prototype._parseComplete = function() {
							var t = this._callback;
							this._callback = null, this._batchIndex = 0, t.call(this, this.textures)
						}, t.prototype._nextBatch = function() {
							var e = this;
							this._processFrames(this._batchIndex * t.BATCH_SIZE), this._batchIndex++, setTimeout((function() {
								e._batchIndex * t.BATCH_SIZE < e._frameKeys.length ? e._nextBatch() : (e._processAnimations(), e._parseComplete())
							}), 0)
						}, t.prototype.destroy = function(t) {
							var e;
							for (var i in void 0 === t && (t = !1), this.textures) this.textures[i].destroy();
							this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && (null === (e = this._texture) || void 0 === e || e.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null
						}, t.BATCH_SIZE = 1e3, t
					}(),
					Oo = function() {
						function t() {}
						return t.use = function(e, i) {
							var n = this,
								s = e.name + "_image";
							if (e.data && e.type === us.TYPE.JSON && e.data.frames && !n.resources[s]) {
								var o = {
										crossOrigin: e.crossOrigin,
										metadata: e.metadata.imageMetadata,
										parentResource: e
									},
									r = t.getResourcePath(e, n.baseUrl);
								n.add(s, r, o, (function(t) {
									if (t.error) i(t.error);
									else {
										var n = new Bo(t.texture, e.data, e.url);
										n.parse((function() {
											e.spritesheet = n, e.textures = n.textures, i()
										}))
									}
								}))
							} else i()
						}, t.getResourcePath = function(t, e) {
							return t.isDataUrl ? t.data.meta.image : $.resolve(t.url.replace(e, ""), t.data.meta.image)
						}, t
					}(),
					No = function(t, e) {
						return No = Object.setPrototypeOf || {
							__proto__: []
						}
						instanceof Array && function(t, e) {
							t.__proto__ = e
						} || function(t, e) {
							for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
						}, No(t, e)
					};

				function Mo(t, e) {
					function i() {
						this.constructor = t
					}
					No(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
				}
				var Ro = new jt,
					Do = function(t) {
						function e(e, i, n) {
							void 0 === i && (i = 100), void 0 === n && (n = 100);
							var s = t.call(this, e) || this;
							return s.tileTransform = new se, s._width = i, s._height = n, s.uvMatrix = s.texture.uvMatrix || new nn(e), s.pluginName = "tilingSprite", s.uvRespectAnchor = !1, s
						}
						return Mo(e, t), Object.defineProperty(e.prototype, "clampMargin", {
							get: function() {
								return this.uvMatrix.clampMargin
							},
							set: function(t) {
								this.uvMatrix.clampMargin = t, this.uvMatrix.update(!0)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "tileScale", {
							get: function() {
								return this.tileTransform.scale
							},
							set: function(t) {
								this.tileTransform.scale.copyFrom(t)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "tilePosition", {
							get: function() {
								return this.tileTransform.position
							},
							set: function(t) {
								this.tileTransform.position.copyFrom(t)
							},
							enumerable: !1,
							configurable: !0
						}), e.prototype._onTextureUpdate = function() {
							this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215
						}, e.prototype._render = function(t) {
							var e = this._texture;
							e && e.valid && (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this))
						}, e.prototype._calculateBounds = function() {
							var t = this._width * -this._anchor._x,
								e = this._height * -this._anchor._y,
								i = this._width * (1 - this._anchor._x),
								n = this._height * (1 - this._anchor._y);
							this._bounds.addFrame(this.transform, t, e, i, n)
						}, e.prototype.getLocalBounds = function(e) {
							return 0 === this.children.length ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Ht), e = this._localBoundsRect), this._bounds.getRectangle(e)) : t.prototype.getLocalBounds.call(this, e)
						}, e.prototype.containsPoint = function(t) {
							this.worldTransform.applyInverse(t, Ro);
							var e = this._width,
								i = this._height,
								n = -e * this.anchor._x;
							if (Ro.x >= n && Ro.x < n + e) {
								var s = -i * this.anchor._y;
								if (Ro.y >= s && Ro.y < s + i) return !0
							}
							return !1
						}, e.prototype.destroy = function(e) {
							t.prototype.destroy.call(this, e), this.tileTransform = null, this.uvMatrix = null
						}, e.from = function(t, i) {
							return "number" == typeof i && (Pt("5.3.0", "TilingSprite.from use options instead of width and height args"), i = {
								width: i,
								height: arguments[2]
							}), new e(Qe.from(t, i), i.width, i.height)
						}, Object.defineProperty(e.prototype, "width", {
							get: function() {
								return this._width
							},
							set: function(t) {
								this._width = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "height", {
							get: function() {
								return this._height
							},
							set: function(t) {
								this._height = t
							},
							enumerable: !1,
							configurable: !0
						}), e
					}(no),
					ko = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n",
					Fo = new qt,
					Go = function(t) {
						function e(e) {
							var i = t.call(this, e) || this,
								n = {
									globals: i.renderer.globalUniforms
								};
							return i.shader = Qi.from(ko, "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture2D(uSampler, coord);\n    gl_FragColor = texSample * uColor;\n}\n", n), i.simpleShader = Qi.from(ko, "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n", n), i.quad = new di, i.state = Ji.for2d(), i
						}
						return Mo(e, t), e.prototype.render = function(t) {
							var e = this.renderer,
								i = this.quad,
								n = i.vertices;
							n[0] = n[6] = t._width * -t.anchor.x, n[1] = n[3] = t._height * -t.anchor.y, n[2] = n[4] = t._width * (1 - t.anchor.x), n[5] = n[7] = t._height * (1 - t.anchor.y), t.uvRespectAnchor && ((n = i.uvs)[0] = n[6] = -t.anchor.x, n[1] = n[3] = -t.anchor.y, n[2] = n[4] = 1 - t.anchor.x, n[5] = n[7] = 1 - t.anchor.y), i.invalidate();
							var s = t._texture,
								o = s.baseTexture,
								r = t.tileTransform.localTransform,
								a = t.uvMatrix,
								l = o.isPowerOfTwo && s.frame.width === o.width && s.frame.height === o.height;
							l && (o._glTextures[e.CONTEXT_UID] ? l = o.wrapMode !== T.CLAMP : o.wrapMode === T.CLAMP && (o.wrapMode = T.REPEAT));
							var h = l ? this.simpleShader : this.shader,
								u = s.width,
								c = s.height,
								d = t._width,
								p = t._height;
							Fo.set(r.a * u / d, r.b * u / p, r.c * c / d, r.d * c / p, r.tx / d, r.ty / p), Fo.invert(), l ? Fo.prepend(a.mapCoord) : (h.uniforms.uMapCoord = a.mapCoord.toArray(!0), h.uniforms.uClampFrame = a.uClampFrame, h.uniforms.uClampOffset = a.uClampOffset), h.uniforms.uTransform = Fo.toArray(!0), h.uniforms.uColor = dt(t.tint, t.worldAlpha, h.uniforms.uColor, o.alphaMode), h.uniforms.translationMatrix = t.transform.worldTransform.toArray(!0), h.uniforms.uSampler = s, e.shader.bind(h), e.geometry.bind(i), this.state.blendMode = ht(t.blendMode, o.alphaMode), e.state.set(this.state), e.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0)
						}, e
					}(fi),
					Uo = function(t, e) {
						return Uo = Object.setPrototypeOf || {
							__proto__: []
						}
						instanceof Array && function(t, e) {
							t.__proto__ = e
						} || function(t, e) {
							for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
						}, Uo(t, e)
					};

				function Wo(t, e) {
					function i() {
						this.constructor = t
					}
					Uo(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
				}
				var Ho = function() {
						function t(t, e) {
							this.uvBuffer = t, this.uvMatrix = e, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0
						}
						return t.prototype.update = function(t) {
							if (t || this._bufferUpdateId !== this.uvBuffer._updateID || this._textureUpdateId !== this.uvMatrix._updateID) {
								this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
								var e = this.uvBuffer.data;
								this.data && this.data.length === e.length || (this.data = new Float32Array(e.length)), this.uvMatrix.multiplyUvs(e, this.data), this._updateID++
							}
						}, t
					}(),
					Vo = new jt,
					Xo = new Yt,
					Yo = function(t) {
						function e(e, i, n, s) {
							void 0 === s && (s = g.TRIANGLES);
							var o = t.call(this) || this;
							return o.geometry = e, e.refCount++, o.shader = i, o.state = n || Ji.for2d(), o.drawMode = s, o.start = 0, o.size = 0, o.uvs = null, o.indices = null, o.vertexData = new Float32Array(1), o.vertexDirty = 0, o._transformID = -1, o._roundPixels = z.ROUND_PIXELS, o.batchUvs = null, o
						}
						return Wo(e, t), Object.defineProperty(e.prototype, "uvBuffer", {
							get: function() {
								return this.geometry.buffers[1]
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "verticesBuffer", {
							get: function() {
								return this.geometry.buffers[0]
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "material", {
							get: function() {
								return this.shader
							},
							set: function(t) {
								this.shader = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "blendMode", {
							get: function() {
								return this.state.blendMode
							},
							set: function(t) {
								this.state.blendMode = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "roundPixels", {
							get: function() {
								return this._roundPixels
							},
							set: function(t) {
								this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "tint", {
							get: function() {
								return this.shader.tint
							},
							set: function(t) {
								this.shader.tint = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "texture", {
							get: function() {
								return this.shader.texture
							},
							set: function(t) {
								this.shader.texture = t
							},
							enumerable: !1,
							configurable: !0
						}), e.prototype._render = function(t) {
							var i = this.geometry.buffers[0].data;
							this.shader.batchable && this.drawMode === g.TRIANGLES && i.length < 2 * e.BATCHABLE_SIZE ? this._renderToBatch(t) : this._renderDefault(t)
						}, e.prototype._renderDefault = function(t) {
							var e = this.shader;
							e.alpha = this.worldAlpha, e.update && e.update(), t.batch.flush(), e.program.uniformData.translationMatrix && (e.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0)), t.shader.bind(e), t.state.set(this.state), t.geometry.bind(this.geometry, e), t.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount)
						}, e.prototype._renderToBatch = function(t) {
							var e = this.geometry;
							this.shader.uvMatrix && (this.shader.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = e.indexBuffer.data, this._tintRGB = this.shader._tintRGB, this._texture = this.shader.texture;
							var i = this.material.pluginName;
							t.batch.setObjectRenderer(t.plugins[i]), t.plugins[i].render(this)
						}, e.prototype.calculateVertices = function() {
							var t = this.geometry,
								e = t.buffers[0].data;
							if (t.vertexDirtyId !== this.vertexDirty || this._transformID !== this.transform._worldID) {
								this._transformID = this.transform._worldID, this.vertexData.length !== e.length && (this.vertexData = new Float32Array(e.length));
								for (var i = this.transform.worldTransform, n = i.a, s = i.b, o = i.c, r = i.d, a = i.tx, l = i.ty, h = this.vertexData, u = 0; u < h.length / 2; u++) {
									var c = e[2 * u],
										d = e[2 * u + 1];
									h[2 * u] = n * c + o * d + a, h[2 * u + 1] = s * c + r * d + l
								}
								if (this._roundPixels) {
									var p = z.RESOLUTION;
									for (u = 0; u < h.length; ++u) h[u] = Math.round((h[u] * p | 0) / p)
								}
								this.vertexDirty = t.vertexDirtyId
							}
						}, e.prototype.calculateUvs = function() {
							var t = this.geometry.buffers[1];
							this.shader.uvMatrix.isSimple ? this.uvs = t.data : (this.batchUvs || (this.batchUvs = new Ho(t, this.shader.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data)
						}, e.prototype._calculateBounds = function() {
							this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length)
						}, e.prototype.containsPoint = function(t) {
							if (!this.getBounds().contains(t.x, t.y)) return !1;
							this.worldTransform.applyInverse(t, Vo);
							for (var e = this.geometry.getBuffer("aVertexPosition").data, i = Xo.points, n = this.geometry.getIndex().data, s = n.length, o = 4 === this.drawMode ? 3 : 1, r = 0; r + 2 < s; r += o) {
								var a = 2 * n[r],
									l = 2 * n[r + 1],
									h = 2 * n[r + 2];
								if (i[0] = e[a], i[1] = e[a + 1], i[2] = e[l], i[3] = e[l + 1], i[4] = e[h], i[5] = e[h + 1], Xo.contains(Vo.x, Vo.y)) return !0
							}
							return !1
						}, e.prototype.destroy = function(e) {
							t.prototype.destroy.call(this, e), this.geometry.refCount--, 0 === this.geometry.refCount && this.geometry.dispose(), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null
						}, e.BATCHABLE_SIZE = 100, e
					}(ce),
					zo = function(t) {
						function e(e, i) {
							var n = this,
								s = {
									uSampler: e,
									alpha: 1,
									uTextureMatrix: qt.IDENTITY,
									uColor: new Float32Array([1, 1, 1, 1])
								};
							return (i = Object.assign({
								tint: 16777215,
								alpha: 1,
								pluginName: "batch"
							}, i)).uniforms && Object.assign(s, i.uniforms), (n = t.call(this, i.program || $i.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n", "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n"), s) || this)._colorDirty = !1, n.uvMatrix = new nn(e), n.batchable = void 0 === i.program, n.pluginName = i.pluginName, n.tint = i.tint, n.alpha = i.alpha, n
						}
						return Wo(e, t), Object.defineProperty(e.prototype, "texture", {
							get: function() {
								return this.uniforms.uSampler
							},
							set: function(t) {
								this.uniforms.uSampler !== t && (this.uniforms.uSampler = t, this.uvMatrix.texture = t)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "alpha", {
							get: function() {
								return this._alpha
							},
							set: function(t) {
								t !== this._alpha && (this._alpha = t, this._colorDirty = !0)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "tint", {
							get: function() {
								return this._tint
							},
							set: function(t) {
								t !== this._tint && (this._tint = t, this._tintRGB = (t >> 16) + (65280 & t) + ((255 & t) << 16), this._colorDirty = !0)
							},
							enumerable: !1,
							configurable: !0
						}), e.prototype.update = function() {
							if (this._colorDirty) {
								this._colorDirty = !1;
								var t = this.texture.baseTexture;
								dt(this._tint, this._alpha, this.uniforms.uColor, t.alphaMode)
							}
							this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord)
						}, e
					}(Qi),
					jo = function(t) {
						function e(e, i, n) {
							var s = t.call(this) || this,
								o = new si(e),
								r = new si(i, !0),
								a = new si(n, !0, !0);
							return s.addAttribute("aVertexPosition", o, 2, !1, y.FLOAT).addAttribute("aTextureCoord", r, 2, !1, y.FLOAT).addIndex(a), s._updateId = -1, s
						}
						return Wo(e, t), Object.defineProperty(e.prototype, "vertexDirtyId", {
							get: function() {
								return this.buffers[0]._updateID
							},
							enumerable: !1,
							configurable: !0
						}), e
					}(ui),
					Ko = function(t, e) {
						return Ko = Object.setPrototypeOf || {
							__proto__: []
						}
						instanceof Array && function(t, e) {
							t.__proto__ = e
						} || function(t, e) {
							for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
						}, Ko(t, e)
					},
					qo = function() {
						this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = []
					},
					Zo = function() {
						function t() {}
						return t.test = function(t) {
							return "string" == typeof t && 0 === t.indexOf("info face=")
						}, t.parse = function(t) {
							var e = t.match(/^[a-z]+\s+.+$/gm),
								i = {
									info: [],
									common: [],
									page: [],
									char: [],
									chars: [],
									kerning: [],
									kernings: []
								};
							for (var n in e) {
								var s = e[n].match(/^[a-z]+/gm)[0],
									o = e[n].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),
									r = {};
								for (var a in o) {
									var l = o[a].split("="),
										h = l[0],
										u = l[1].replace(/"/gm, ""),
										c = parseFloat(u),
										d = isNaN(c) ? u : c;
									r[h] = d
								}
								i[s].push(r)
							}
							var p = new qo;
							return i.info.forEach((function(t) {
								return p.info.push({
									face: t.face,
									size: parseInt(t.size, 10)
								})
							})), i.common.forEach((function(t) {
								return p.common.push({
									lineHeight: parseInt(t.lineHeight, 10)
								})
							})), i.page.forEach((function(t) {
								return p.page.push({
									id: parseInt(t.id, 10),
									file: t.file
								})
							})), i.char.forEach((function(t) {
								return p.char.push({
									id: parseInt(t.id, 10),
									page: parseInt(t.page, 10),
									x: parseInt(t.x, 10),
									y: parseInt(t.y, 10),
									width: parseInt(t.width, 10),
									height: parseInt(t.height, 10),
									xoffset: parseInt(t.xoffset, 10),
									yoffset: parseInt(t.yoffset, 10),
									xadvance: parseInt(t.xadvance, 10)
								})
							})), i.kerning.forEach((function(t) {
								return p.kerning.push({
									first: parseInt(t.first, 10),
									second: parseInt(t.second, 10),
									amount: parseInt(t.amount, 10)
								})
							})), p
						}, t
					}(),
					$o = function() {
						function t() {}
						return t.test = function(t) {
							return t instanceof XMLDocument && t.getElementsByTagName("page").length && null !== t.getElementsByTagName("info")[0].getAttribute("face")
						}, t.parse = function(t) {
							for (var e = new qo, i = t.getElementsByTagName("info"), n = t.getElementsByTagName("common"), s = t.getElementsByTagName("page"), o = t.getElementsByTagName("char"), r = t.getElementsByTagName("kerning"), a = 0; a < i.length; a++) e.info.push({
								face: i[a].getAttribute("face"),
								size: parseInt(i[a].getAttribute("size"), 10)
							});
							for (a = 0; a < n.length; a++) e.common.push({
								lineHeight: parseInt(n[a].getAttribute("lineHeight"), 10)
							});
							for (a = 0; a < s.length; a++) e.page.push({
								id: parseInt(s[a].getAttribute("id"), 10) || 0,
								file: s[a].getAttribute("file")
							});
							for (a = 0; a < o.length; a++) {
								var l = o[a];
								e.char.push({
									id: parseInt(l.getAttribute("id"), 10),
									page: parseInt(l.getAttribute("page"), 10) || 0,
									x: parseInt(l.getAttribute("x"), 10),
									y: parseInt(l.getAttribute("y"), 10),
									width: parseInt(l.getAttribute("width"), 10),
									height: parseInt(l.getAttribute("height"), 10),
									xoffset: parseInt(l.getAttribute("xoffset"), 10),
									yoffset: parseInt(l.getAttribute("yoffset"), 10),
									xadvance: parseInt(l.getAttribute("xadvance"), 10)
								})
							}
							for (a = 0; a < r.length; a++) e.kerning.push({
								first: parseInt(r[a].getAttribute("first"), 10),
								second: parseInt(r[a].getAttribute("second"), 10),
								amount: parseInt(r[a].getAttribute("amount"), 10)
							});
							return e
						}, t
					}(),
					Qo = function() {
						function t() {}
						return t.test = function(t) {
							if ("string" == typeof t && t.indexOf("<font>") > -1) {
								var e = (new self.DOMParser).parseFromString(t, "text/xml");
								return $o.test(e)
							}
							return !1
						}, t.parse = function(t) {
							var e = (new window.DOMParser).parseFromString(t, "text/xml");
							return $o.parse(e)
						}, t
					}(),
					Jo = [Zo, $o, Qo];

				function tr(t) {
					for (var e = 0; e < Jo.length; e++)
						if (Jo[e].test(t)) return Jo[e];
					return null
				}

				function er(t, e, i, n, s, o, r) {
					var a = i.text,
						l = i.fontProperties;
					e.translate(n, s), e.scale(o, o);
					var h = r.strokeThickness / 2,
						u = -r.strokeThickness / 2;
					if (e.font = r.toFontString(), e.lineWidth = r.strokeThickness, e.textBaseline = r.textBaseline, e.lineJoin = r.lineJoin, e.miterLimit = r.miterLimit, e.fillStyle = function(t, e, i, n, s, o) {
							var r, a = i.fill;
							if (!Array.isArray(a)) return a;
							if (1 === a.length) return a[0];
							var l = i.dropShadow ? i.dropShadowDistance : 0,
								h = i.padding || 0,
								u = Math.ceil(t.width / n) - l - 2 * h,
								c = Math.ceil(t.height / n) - l - 2 * h,
								d = a.slice(),
								p = i.fillGradientStops.slice();
							if (!p.length)
								for (var _ = d.length + 1, m = 1; m < _; ++m) p.push(m / _);
							if (d.unshift(a[0]), p.unshift(0), d.push(a[a.length - 1]), p.push(1), i.fillGradientType === Ds.LINEAR_VERTICAL) {
								r = e.createLinearGradient(u / 2, h, u / 2, c + h);
								var g = 0,
									f = (o.fontProperties.fontSize + i.strokeThickness) / c;
								for (m = 0; m < s.length; m++)
									for (var S = o.lineHeight * m, y = 0; y < d.length; y++) {
										var v = S / c + ("number" == typeof p[y] ? p[y] : y / d.length) * f,
											T = Math.max(g, v);
										T = Math.min(T, 1), r.addColorStop(T, d[y]), g = T
									}
							} else {
								r = e.createLinearGradient(h, c / 2, u + h, c / 2);
								var E = d.length + 1,
									b = 1;
								for (m = 0; m < d.length; m++) {
									var A;
									A = "number" == typeof p[m] ? p[m] : b / E, r.addColorStop(A, d[m]), b++
								}
							}
							return r
						}(t, e, r, o, [a], i), e.strokeStyle = r.stroke, r.dropShadow) {
						var c = r.dropShadowColor,
							d = st("number" == typeof c ? c : rt(c)),
							p = r.dropShadowBlur * o,
							_ = r.dropShadowDistance * o;
						e.shadowColor = "rgba(" + 255 * d[0] + "," + 255 * d[1] + "," + 255 * d[2] + "," + r.dropShadowAlpha + ")", e.shadowBlur = p, e.shadowOffsetX = Math.cos(r.dropShadowAngle) * _, e.shadowOffsetY = Math.sin(r.dropShadowAngle) * _
					} else e.shadowColor = "black", e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0;
					r.stroke && r.strokeThickness && e.strokeText(a, h, u + i.lineHeight - l.descent), r.fill && e.fillText(a, h, u + i.lineHeight - l.descent), e.setTransform(1, 0, 0, 1, 0, 0), e.fillStyle = "rgba(0, 0, 0, 0)"
				}
				var ir = function() {
						function t(t, e, i) {
							var n = t.info[0],
								s = t.common[0],
								o = kt(t.page[0].file),
								r = {};
							this._ownsTextures = i, this.font = n.face, this.size = n.size, this.lineHeight = s.lineHeight / o, this.chars = {}, this.pageTextures = r;
							for (var a = 0; a < t.page.length; a++) {
								var l = t.page[a],
									h = l.id,
									u = l.file;
								r[h] = e instanceof Array ? e[a] : e[u]
							}
							for (a = 0; a < t.char.length; a++) {
								var c = t.char[a],
									d = (h = c.id, c.page),
									p = t.char[a],
									_ = p.x,
									m = p.y,
									g = p.width,
									f = p.height,
									S = p.xoffset,
									y = p.yoffset,
									v = p.xadvance;
								m /= o, g /= o, f /= o, S /= o, y /= o, v /= o;
								var T = new Ht((_ /= o) + r[d].frame.x / o, m + r[d].frame.y / o, g, f);
								this.chars[h] = {
									xOffset: S,
									yOffset: y,
									xAdvance: v,
									kerning: {},
									texture: new Qe(r[d].baseTexture, T),
									page: d
								}
							}
							for (a = 0; a < t.kerning.length; a++) {
								var E = t.kerning[a],
									b = E.first,
									A = E.second,
									P = E.amount;
								b /= o, A /= o, P /= o, this.chars[A] && (this.chars[A].kerning[b] = P)
							}
						}
						return t.prototype.destroy = function() {
							for (var t in this.chars) this.chars[t].texture.destroy(), this.chars[t].texture = null;
							for (var t in this.pageTextures) this._ownsTextures && this.pageTextures[t].destroy(!0), this.pageTextures[t] = null;
							this.chars = null, this.pageTextures = null
						}, t.install = function(e, i, n) {
							var s;
							if (e instanceof qo) s = e;
							else {
								var o = tr(e);
								if (!o) throw new Error("Unrecognized data format for font.");
								s = o.parse(e)
							}
							i instanceof Qe && (i = [i]);
							var r = new t(s, i, n);
							return t.available[r.font] = r, r
						}, t.uninstall = function(e) {
							var i = t.available[e];
							if (!i) throw new Error("No font found named '" + e + "'");
							i.destroy(), delete t.available[e]
						}, t.from = function(e, i, n) {
							if (!e) throw new Error("[BitmapFont] Property `name` is required.");
							var s = Object.assign({}, t.defaultOptions, n),
								o = s.chars,
								r = s.padding,
								a = s.resolution,
								l = s.textureWidth,
								h = s.textureHeight,
								u = function(t) {
									"string" == typeof t && (t = [t]);
									for (var e = [], i = 0, n = t.length; i < n; i++) {
										var s = t[i];
										if (Array.isArray(s)) {
											if (2 !== s.length) throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + s.length + ".");
											var o = s[0].charCodeAt(0),
												r = s[1].charCodeAt(0);
											if (r < o) throw new Error("[BitmapFont]: Invalid character range.");
											for (var a = o, l = r; a <= l; a++) e.push(String.fromCharCode(a))
										} else e.push.apply(e, s.split(""))
									}
									if (0 === e.length) throw new Error("[BitmapFont]: Empty set when resolving characters.");
									return e
								}(o),
								c = i instanceof ao ? i : new ao(i),
								d = l,
								p = new qo;
							p.info[0] = {
								face: c.fontFamily,
								size: c.fontSize
							}, p.common[0] = {
								lineHeight: c.fontSize
							};
							for (var _, m, g, f = 0, S = 0, y = 0, v = [], T = 0; T < u.length; T++) {
								_ || ((_ = document.createElement("canvas")).width = l, _.height = h, m = _.getContext("2d"), g = new Re(_, {
									resolution: a
								}), v.push(new Qe(g)), p.page.push({
									id: v.length - 1,
									file: ""
								}));
								var E = co.measureText(u[T], c, !1, _),
									b = E.width,
									A = Math.ceil(E.height),
									P = Math.ceil(("italic" === c.fontStyle ? 2 : 1) * b);
								if (S >= h - A * a) {
									if (0 === S) throw new Error("[BitmapFont] textureHeight " + h + "px is too small for " + c.fontSize + "px fonts");
									--T, _ = null, m = null, g = null, S = 0, f = 0, y = 0
								} else if (y = Math.max(A + E.fontProperties.descent, y), P * a + f >= d) --T, S += y * a, S = Math.ceil(S), f = 0, y = 0;
								else {
									er(_, m, E, f, S, a, c);
									var I = E.text.charCodeAt(0);
									p.char.push({
										id: I,
										page: v.length - 1,
										x: f / a,
										y: S / a,
										width: P,
										height: A,
										xoffset: 0,
										yoffset: 0,
										xadvance: Math.ceil(b - (c.dropShadow ? c.dropShadowDistance : 0) - (c.stroke ? c.strokeThickness : 0))
									}), f += (P + 2 * r) * a, f = Math.ceil(f)
								}
							}
							var w = new t(p, v, !0);
							return void 0 !== t.available[e] && t.uninstall(e), t.available[e] = w, w
						}, t.ALPHA = [
							["a", "z"],
							["A", "Z"], " "
						], t.NUMERIC = [
							["0", "9"]
						], t.ALPHANUMERIC = [
							["a", "z"],
							["A", "Z"],
							["0", "9"], " "
						], t.ASCII = [
							[" ", "~"]
						], t.defaultOptions = {
							resolution: 1,
							textureWidth: 512,
							textureHeight: 512,
							padding: 4,
							chars: t.ALPHANUMERIC
						}, t.available = {}, t
					}(),
					nr = [],
					sr = [],
					or = function(t) {
						function e(i, n) {
							void 0 === n && (n = {});
							var s = t.call(this) || this;
							s._tint = 16777215, n.font && (Pt("5.3.0", "PIXI.BitmapText constructor style.font property is deprecated."), s._upgradeStyle(n));
							var o = Object.assign({}, e.styleDefaults, n),
								r = o.align,
								a = o.tint,
								l = o.maxWidth,
								h = o.letterSpacing,
								u = o.fontName,
								c = o.fontSize;
							if (!ir.available[u]) throw new Error('Missing BitmapFont "' + u + '"');
							return s._activePagesMeshData = [], s._textWidth = 0, s._textHeight = 0, s._align = r, s._tint = a, s._fontName = u, s._fontSize = c || ir.available[u].size, s._text = i, s._maxWidth = l, s._maxLineHeight = 0, s._letterSpacing = h, s._anchor = new Kt((function() {
								s.dirty = !0
							}), s, 0, 0), s._roundPixels = z.ROUND_PIXELS, s.dirty = !0, s._textureCache = {}, s
						}
						return function(t, e) {
							function i() {
								this.constructor = t
							}
							Ko(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
						}(e, t), e.prototype.updateText = function() {
							for (var t, e = ir.available[this._fontName], i = this._fontSize / e.size, n = new jt, s = [], o = [], r = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ", a = r.length, l = this._maxWidth * e.size / this._fontSize, h = null, u = 0, c = 0, d = 0, p = -1, _ = 0, m = 0, g = 0, f = 0; f < a; f++) {
								var S = r.charCodeAt(f),
									y = r.charAt(f);
								if (/(?:\s)/.test(y) && (p = f, _ = u), "\r" !== y && "\n" !== y) {
									var v = e.chars[S];
									if (v) {
										h && v.kerning[h] && (n.x += v.kerning[h]);
										var T = sr.pop() || {
											texture: Qe.EMPTY,
											line: 0,
											charCode: 0,
											position: new jt
										};
										T.texture = v.texture, T.line = d, T.charCode = S, T.position.x = n.x + v.xOffset + this._letterSpacing / 2, T.position.y = n.y + v.yOffset, s.push(T), n.x += v.xAdvance + this._letterSpacing, u = n.x, g = Math.max(g, v.yOffset + v.texture.height), h = S, -1 !== p && l > 0 && n.x > l && (vt(s, 1 + p - ++m, 1 + f - p), f = p, p = -1, o.push(_), c = Math.max(c, _), d++, n.x = 0, n.y += e.lineHeight, h = null)
									}
								} else o.push(u), c = Math.max(c, u), ++d, ++m, n.x = 0, n.y += e.lineHeight, h = null
							}
							var E = r.charAt(r.length - 1);
							"\r" !== E && "\n" !== E && (/(?:\s)/.test(E) && (u = _), o.push(u), c = Math.max(c, u));
							var b = [];
							for (f = 0; f <= d; f++) {
								var A = 0;
								"right" === this._align ? A = c - o[f] : "center" === this._align && (A = (c - o[f]) / 2), b.push(A)
							}
							var P = s.length,
								I = {},
								w = [],
								L = this._activePagesMeshData;
							for (f = 0; f < L.length; f++) nr.push(L[f]);
							for (f = 0; f < P; f++) {
								var C = (F = s[f].texture).baseTexture.uid;
								if (!I[C]) {
									if (!(Y = nr.pop())) {
										var x = new jo,
											B = new zo(Qe.EMPTY);
										Y = {
											index: 0,
											indexCount: 0,
											vertexCount: 0,
											uvsCount: 0,
											total: 0,
											mesh: new Yo(x, B),
											vertices: null,
											uvs: null,
											indices: null
										}
									}
									Y.index = 0, Y.indexCount = 0, Y.vertexCount = 0, Y.uvsCount = 0, Y.total = 0;
									var O = this._textureCache;
									O[C] = O[C] || new Qe(F.baseTexture), Y.mesh.texture = O[C], Y.mesh.tint = this._tint, w.push(Y), I[C] = Y
								}
								I[C].total++
							}
							for (f = 0; f < L.length; f++) - 1 === w.indexOf(L[f]) && this.removeChild(L[f].mesh);
							for (f = 0; f < w.length; f++) w[f].mesh.parent !== this && this.addChild(w[f].mesh);
							for (var f in this._activePagesMeshData = w, I) {
								var N = (Y = I[f]).total;
								if (!((null === (t = Y.indices) || void 0 === t ? void 0 : t.length) > 6 * N) || Y.vertices.length < 2 * Yo.BATCHABLE_SIZE) Y.vertices = new Float32Array(8 * N), Y.uvs = new Float32Array(8 * N), Y.indices = new Uint16Array(6 * N);
								else
									for (var M = Y.total, R = Y.vertices, D = 4 * M * 2; D < R.length; D++) R[D] = 0;
								Y.mesh.size = 6 * N
							}
							for (f = 0; f < P; f++) {
								var k = (y = s[f]).position.x + b[y.line];
								this._roundPixels && (k = Math.round(k));
								var F, G = k * i,
									U = y.position.y * i,
									W = I[(F = y.texture).baseTexture.uid],
									H = F.frame,
									V = F._uvs,
									X = W.index++;
								W.indices[6 * X + 0] = 0 + 4 * X, W.indices[6 * X + 1] = 1 + 4 * X, W.indices[6 * X + 2] = 2 + 4 * X, W.indices[6 * X + 3] = 0 + 4 * X, W.indices[6 * X + 4] = 2 + 4 * X, W.indices[6 * X + 5] = 3 + 4 * X, W.vertices[8 * X + 0] = G, W.vertices[8 * X + 1] = U, W.vertices[8 * X + 2] = G + H.width * i, W.vertices[8 * X + 3] = U, W.vertices[8 * X + 4] = G + H.width * i, W.vertices[8 * X + 5] = U + H.height * i, W.vertices[8 * X + 6] = G, W.vertices[8 * X + 7] = U + H.height * i, W.uvs[8 * X + 0] = V.x0, W.uvs[8 * X + 1] = V.y0, W.uvs[8 * X + 2] = V.x1, W.uvs[8 * X + 3] = V.y1, W.uvs[8 * X + 4] = V.x2, W.uvs[8 * X + 5] = V.y2, W.uvs[8 * X + 6] = V.x3, W.uvs[8 * X + 7] = V.y3
							}
							for (var f in this._textWidth = c * i, this._textHeight = (n.y + e.lineHeight) * i, I) {
								var Y = I[f];
								if (0 !== this.anchor.x || 0 !== this.anchor.y)
									for (var z = 0, j = this._textWidth * this.anchor.x, K = this._textHeight * this.anchor.y, q = 0; q < Y.total; q++) Y.vertices[z++] -= j, Y.vertices[z++] -= K, Y.vertices[z++] -= j, Y.vertices[z++] -= K, Y.vertices[z++] -= j, Y.vertices[z++] -= K, Y.vertices[z++] -= j, Y.vertices[z++] -= K;
								this._maxLineHeight = g * i;
								var Z = Y.mesh.geometry.getBuffer("aVertexPosition"),
									$ = Y.mesh.geometry.getBuffer("aTextureCoord"),
									Q = Y.mesh.geometry.getIndex();
								Z.data = Y.vertices, $.data = Y.uvs, Q.data = Y.indices, Z.update(), $.update(), Q.update()
							}
							for (f = 0; f < s.length; f++) sr.push(s[f])
						}, e.prototype.updateTransform = function() {
							this.validate(), this.containerUpdateTransform()
						}, e.prototype.getLocalBounds = function() {
							return this.validate(), t.prototype.getLocalBounds.call(this)
						}, e.prototype.validate = function() {
							this.dirty && (this.updateText(), this.dirty = !1)
						}, Object.defineProperty(e.prototype, "tint", {
							get: function() {
								return this._tint
							},
							set: function(t) {
								if (this._tint !== t) {
									this._tint = t;
									for (var e = 0; e < this._activePagesMeshData.length; e++) this._activePagesMeshData[e].mesh.tint = t
								}
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "align", {
							get: function() {
								return this._align
							},
							set: function(t) {
								this._align !== t && (this._align = t, this.dirty = !0)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "fontName", {
							get: function() {
								return this._fontName
							},
							set: function(t) {
								if (!ir.available[t]) throw new Error('Missing BitmapFont "' + t + '"');
								this._fontName !== t && (this._fontName = t, this.dirty = !0)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "fontSize", {
							get: function() {
								return this._fontSize
							},
							set: function(t) {
								this._fontSize !== t && (this._fontSize = t, this.dirty = !0)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "anchor", {
							get: function() {
								return this._anchor
							},
							set: function(t) {
								"number" == typeof t ? this._anchor.set(t) : this._anchor.copyFrom(t)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "text", {
							get: function() {
								return this._text
							},
							set: function(t) {
								t = String(null == t ? "" : t), this._text !== t && (this._text = t, this.dirty = !0)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "maxWidth", {
							get: function() {
								return this._maxWidth
							},
							set: function(t) {
								this._maxWidth !== t && (this._maxWidth = t, this.dirty = !0)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "maxLineHeight", {
							get: function() {
								return this.validate(), this._maxLineHeight
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "textWidth", {
							get: function() {
								return this.validate(), this._textWidth
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "letterSpacing", {
							get: function() {
								return this._letterSpacing
							},
							set: function(t) {
								this._letterSpacing !== t && (this._letterSpacing = t, this.dirty = !0)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "roundPixels", {
							get: function() {
								return this._roundPixels
							},
							set: function(t) {
								t !== this._roundPixels && (this._roundPixels = t, this.dirty = !0)
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "textHeight", {
							get: function() {
								return this.validate(), this._textHeight
							},
							enumerable: !1,
							configurable: !0
						}), e.prototype._upgradeStyle = function(t) {
							if ("string" == typeof t.font) {
								var e = t.font.split(" ");
								t.fontName = 1 === e.length ? e[0] : e.slice(1).join(" "), e.length >= 2 && (t.fontSize = parseInt(e[0], 10))
							} else t.fontName = t.font.name, t.fontSize = "number" == typeof t.font.size ? t.font.size : parseInt(t.font.size, 10)
						}, e.prototype.destroy = function(e) {
							var i = this._textureCache;
							for (var n in i) i[n].destroy(), delete i[n];
							this._textureCache = null, t.prototype.destroy.call(this, e)
						}, e.registerFont = function(t, e) {
							return Pt("5.3.0", "PIXI.BitmapText.registerFont is deprecated, use PIXI.BitmapFont.install"), ir.install(t, e)
						}, Object.defineProperty(e, "fonts", {
							get: function() {
								return Pt("5.3.0", "PIXI.BitmapText.fonts is deprecated, use PIXI.BitmapFont.available"), ir.available
							},
							enumerable: !1,
							configurable: !0
						}), e.styleDefaults = {
							align: "left",
							tint: 16777215,
							maxWidth: 0,
							letterSpacing: 0
						}, e
					}(ce),
					rr = function() {
						function t() {}
						return t.add = function() {
							us.setExtensionXhrType("fnt", us.XHR_RESPONSE_TYPE.TEXT)
						}, t.use = function(e, i) {
							var n = tr(e.data);
							if (n)
								for (var s = t.getBaseUrl(this, e), o = n.parse(e.data), r = {}, a = function(t) {
										r[t.metadata.pageFile] = t.texture, Object.keys(r).length === o.page.length && (e.bitmapFont = ir.install(o, r, !0), i())
									}, l = 0; l < o.page.length; ++l) {
									var h = o.page[l].file,
										u = s + h,
										c = !1;
									for (var d in this.resources) {
										var p = this.resources[d];
										if (p.url === u) {
											p.metadata.pageFile = h, p.texture ? a(p) : p.onAfterMiddleware.add(a), c = !0;
											break
										}
									}
									if (!c) {
										var _ = {
											crossOrigin: e.crossOrigin,
											loadType: us.LOAD_TYPE.IMAGE,
											metadata: Object.assign({
												pageFile: h
											}, e.metadata.imageMetadata),
											parentResource: e
										};
										this.add(u, _, a)
									}
								} else i()
						}, t.getBaseUrl = function(e, i) {
							var n = i.isDataUrl ? "" : t.dirname(i.url);
							return i.isDataUrl && ("." === n && (n = ""), e.baseUrl && n && "/" === e.baseUrl.charAt(e.baseUrl.length - 1) && (n += "/")), (n = n.replace(e.baseUrl, "")) && "/" !== n.charAt(n.length - 1) && (n += "/"), n
						}, t.dirname = function(t) {
							var e = t.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
							return e === t ? "." : "" === e ? "/" : e
						}, t
					}(),
					ar = function(t, e) {
						return ar = Object.setPrototypeOf || {
							__proto__: []
						}
						instanceof Array && function(t, e) {
							t.__proto__ = e
						} || function(t, e) {
							for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
						}, ar(t, e)
					},
					lr = function(t) {
						function e(e) {
							void 0 === e && (e = 1);
							var i = t.call(this, Ln, "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n", {
								uAlpha: 1
							}) || this;
							return i.alpha = e, i
						}
						return function(t, e) {
							function i() {
								this.constructor = t
							}
							ar(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
						}(e, t), Object.defineProperty(e.prototype, "alpha", {
							get: function() {
								return this.uniforms.uAlpha
							},
							set: function(t) {
								this.uniforms.uAlpha = t
							},
							enumerable: !1,
							configurable: !0
						}), e
					}(tn),
					hr = function(t, e) {
						return hr = Object.setPrototypeOf || {
							__proto__: []
						}
						instanceof Array && function(t, e) {
							t.__proto__ = e
						} || function(t, e) {
							for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
						}, hr(t, e)
					};

				function ur(t, e) {
					function i() {
						this.constructor = t
					}
					hr(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
				}
				var cr, dr, pr, _r, mr, gr, fr, Sr, yr, vr, Tr, Er, br, Ar, Pr, Ir, wr, Lr = {
						5: [.153388, .221461, .250301],
						7: [.071303, .131514, .189879, .214607],
						9: [.028532, .067234, .124009, .179044, .20236],
						11: [.0093, .028002, .065984, .121703, .175713, .198596],
						13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641],
						15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448]
					},
					Cr = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "    gl_FragColor = vec4(0.0);", "    %blur%", "}"].join("\n");
				! function(t) {
					t[t.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t[t.WEBGL = 1] = "WEBGL", t[t.WEBGL2 = 2] = "WEBGL2"
				}(cr || (cr = {})),
				function(t) {
					t[t.UNKNOWN = 0] = "UNKNOWN", t[t.WEBGL = 1] = "WEBGL", t[t.CANVAS = 2] = "CANVAS"
				}(dr || (dr = {})),
				function(t) {
					t[t.COLOR = 16384] = "COLOR", t[t.DEPTH = 256] = "DEPTH", t[t.STENCIL = 1024] = "STENCIL"
				}(pr || (pr = {})),
				function(t) {
					t[t.NORMAL = 0] = "NORMAL", t[t.ADD = 1] = "ADD", t[t.MULTIPLY = 2] = "MULTIPLY", t[t.SCREEN = 3] = "SCREEN", t[t.OVERLAY = 4] = "OVERLAY", t[t.DARKEN = 5] = "DARKEN", t[t.LIGHTEN = 6] = "LIGHTEN", t[t.COLOR_DODGE = 7] = "COLOR_DODGE", t[t.COLOR_BURN = 8] = "COLOR_BURN", t[t.HARD_LIGHT = 9] = "HARD_LIGHT", t[t.SOFT_LIGHT = 10] = "SOFT_LIGHT", t[t.DIFFERENCE = 11] = "DIFFERENCE", t[t.EXCLUSION = 12] = "EXCLUSION", t[t.HUE = 13] = "HUE", t[t.SATURATION = 14] = "SATURATION", t[t.COLOR = 15] = "COLOR", t[t.LUMINOSITY = 16] = "LUMINOSITY", t[t.NORMAL_NPM = 17] = "NORMAL_NPM", t[t.ADD_NPM = 18] = "ADD_NPM", t[t.SCREEN_NPM = 19] = "SCREEN_NPM", t[t.NONE = 20] = "NONE", t[t.SRC_OVER = 0] = "SRC_OVER", t[t.SRC_IN = 21] = "SRC_IN", t[t.SRC_OUT = 22] = "SRC_OUT", t[t.SRC_ATOP = 23] = "SRC_ATOP", t[t.DST_OVER = 24] = "DST_OVER", t[t.DST_IN = 25] = "DST_IN", t[t.DST_OUT = 26] = "DST_OUT", t[t.DST_ATOP = 27] = "DST_ATOP", t[t.ERASE = 26] = "ERASE", t[t.SUBTRACT = 28] = "SUBTRACT", t[t.XOR = 29] = "XOR"
				}(_r || (_r = {})),
				function(t) {
					t[t.POINTS = 0] = "POINTS", t[t.LINES = 1] = "LINES", t[t.LINE_LOOP = 2] = "LINE_LOOP", t[t.LINE_STRIP = 3] = "LINE_STRIP", t[t.TRIANGLES = 4] = "TRIANGLES", t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN"
				}(mr || (mr = {})),
				function(t) {
					t[t.RGBA = 6408] = "RGBA", t[t.RGB = 6407] = "RGB", t[t.ALPHA = 6406] = "ALPHA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL"
				}(gr || (gr = {})),
				function(t) {
					t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z"
				}(fr || (fr = {})),
				function(t) {
					t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.FLOAT = 5126] = "FLOAT", t[t.HALF_FLOAT = 36193] = "HALF_FLOAT"
				}(Sr || (Sr = {})),
				function(t) {
					t[t.NEAREST = 0] = "NEAREST", t[t.LINEAR = 1] = "LINEAR"
				}(yr || (yr = {})),
				function(t) {
					t[t.CLAMP = 33071] = "CLAMP", t[t.REPEAT = 10497] = "REPEAT", t[t.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT"
				}(vr || (vr = {})),
				function(t) {
					t[t.OFF = 0] = "OFF", t[t.POW2 = 1] = "POW2", t[t.ON = 2] = "ON"
				}(Tr || (Tr = {})),
				function(t) {
					t[t.NPM = 0] = "NPM", t[t.UNPACK = 1] = "UNPACK", t[t.PMA = 2] = "PMA", t[t.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t[t.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t[t.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA"
				}(Er || (Er = {})),
				function(t) {
					t[t.NO = 0] = "NO", t[t.YES = 1] = "YES", t[t.AUTO = 2] = "AUTO", t[t.BLEND = 0] = "BLEND", t[t.CLEAR = 1] = "CLEAR", t[t.BLIT = 2] = "BLIT"
				}(br || (br = {})),
				function(t) {
					t[t.AUTO = 0] = "AUTO", t[t.MANUAL = 1] = "MANUAL"
				}(Ar || (Ar = {})),
				function(t) {
					t.LOW = "lowp", t.MEDIUM = "mediump", t.HIGH = "highp"
				}(Pr || (Pr = {})),
				function(t) {
					t[t.NONE = 0] = "NONE", t[t.SCISSOR = 1] = "SCISSOR", t[t.STENCIL = 2] = "STENCIL", t[t.SPRITE = 3] = "SPRITE"
				}(Ir || (Ir = {})),
				function(t) {
					t[t.NONE = 0] = "NONE", t[t.LOW = 2] = "LOW", t[t.MEDIUM = 4] = "MEDIUM", t[t.HIGH = 8] = "HIGH"
				}(wr || (wr = {}));
				var xr = function(t) {
						function e(e, i, n, s, o) {
							void 0 === i && (i = 8), void 0 === n && (n = 4), void 0 === s && (s = z.FILTER_RESOLUTION), void 0 === o && (o = 5);
							var r = this,
								a = function(t, e) {
									var i, n = Math.ceil(t / 2),
										s = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }",
										o = "";
									i = e ? "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
									for (var r = 0; r < t; r++) {
										var a = i.replace("%index%", r.toString());
										o += a = a.replace("%sampleIndex%", r - (n - 1) + ".0"), o += "\n"
									}
									return (s = s.replace("%blur%", o)).replace("%size%", t.toString())
								}(o, e),
								l = function(t) {
									for (var e, i = Lr[t], n = i.length, s = Cr, o = "", r = 0; r < t; r++) {
										var a = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;".replace("%index%", r.toString());
										e = r, r >= n && (e = t - r - 1), o += a = a.replace("%value%", i[e].toString()), o += "\n"
									}
									return (s = s.replace("%blur%", o)).replace("%size%", t.toString())
								}(o);
							return (r = t.call(this, a, l) || this).horizontal = e, r.resolution = s, r._quality = 0, r.quality = n, r.blur = i, r
						}
						return ur(e, t), e.prototype.apply = function(t, e, i, n) {
							if (i ? this.horizontal ? this.uniforms.strength = 1 / i.width * (i.width / e.width) : this.uniforms.strength = 1 / i.height * (i.height / e.height) : this.horizontal ? this.uniforms.strength = 1 / t.renderer.width * (t.renderer.width / e.width) : this.uniforms.strength = 1 / t.renderer.height * (t.renderer.height / e.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, 1 === this.passes) t.applyFilter(this, e, i, n);
							else {
								var s = t.getFilterTexture(),
									o = t.renderer,
									r = e,
									a = s;
								this.state.blend = !1, t.applyFilter(this, r, a, br.CLEAR);
								for (var l = 1; l < this.passes - 1; l++) {
									t.bindAndClear(r, br.BLIT), this.uniforms.uSampler = a;
									var h = a;
									a = r, r = h, o.shader.bind(this), o.geometry.draw(5)
								}
								this.state.blend = !0, t.applyFilter(this, a, i, n), t.returnFilterTexture(s)
							}
						}, Object.defineProperty(e.prototype, "blur", {
							get: function() {
								return this.strength
							},
							set: function(t) {
								this.padding = 1 + 2 * Math.abs(t), this.strength = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "quality", {
							get: function() {
								return this._quality
							},
							set: function(t) {
								this._quality = t, this.passes = t
							},
							enumerable: !1,
							configurable: !0
						}), e
					}(tn),
					Br = function(t) {
						function e(e, i, n, s) {
							void 0 === e && (e = 8), void 0 === i && (i = 4), void 0 === n && (n = z.FILTER_RESOLUTION), void 0 === s && (s = 5);
							var o = t.call(this) || this;
							return o.blurXFilter = new xr(!0, e, i, n, s), o.blurYFilter = new xr(!1, e, i, n, s), o.resolution = n, o.quality = i, o.blur = e, o.repeatEdgePixels = !1, o
						}
						return ur(e, t), e.prototype.apply = function(t, e, i, n) {
							var s = Math.abs(this.blurXFilter.strength),
								o = Math.abs(this.blurYFilter.strength);
							if (s && o) {
								var r = t.getFilterTexture();
								this.blurXFilter.apply(t, e, r, br.CLEAR), this.blurYFilter.apply(t, r, i, n), t.returnFilterTexture(r)
							} else o ? this.blurYFilter.apply(t, e, i, n) : this.blurXFilter.apply(t, e, i, n)
						}, e.prototype.updatePadding = function() {
							this._repeatEdgePixels ? this.padding = 0 : this.padding = 2 * Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength))
						}, Object.defineProperty(e.prototype, "blur", {
							get: function() {
								return this.blurXFilter.blur
							},
							set: function(t) {
								this.blurXFilter.blur = this.blurYFilter.blur = t, this.updatePadding()
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "quality", {
							get: function() {
								return this.blurXFilter.quality
							},
							set: function(t) {
								this.blurXFilter.quality = this.blurYFilter.quality = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "blurX", {
							get: function() {
								return this.blurXFilter.blur
							},
							set: function(t) {
								this.blurXFilter.blur = t, this.updatePadding()
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "blurY", {
							get: function() {
								return this.blurYFilter.blur
							},
							set: function(t) {
								this.blurYFilter.blur = t, this.updatePadding()
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "blendMode", {
							get: function() {
								return this.blurYFilter.blendMode
							},
							set: function(t) {
								this.blurYFilter.blendMode = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "repeatEdgePixels", {
							get: function() {
								return this._repeatEdgePixels
							},
							set: function(t) {
								this._repeatEdgePixels = t, this.updatePadding()
							},
							enumerable: !1,
							configurable: !0
						}), e
					}(tn),
					Or = function(t, e) {
						return Or = Object.setPrototypeOf || {
							__proto__: []
						}
						instanceof Array && function(t, e) {
							t.__proto__ = e
						} || function(t, e) {
							for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
						}, Or(t, e)
					},
					Nr = function(t) {
						function e() {
							var e = this,
								i = {
									m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]),
									uAlpha: 1
								};
							return (e = t.call(this, Cn, "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n", i) || this).alpha = 1, e
						}
						return function(t, e) {
							function i() {
								this.constructor = t
							}
							Or(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
						}(e, t), e.prototype._loadMatrix = function(t, e) {
							void 0 === e && (e = !1);
							var i = t;
							e && (this._multiply(i, this.uniforms.m, t), i = this._colorMatrix(i)), this.uniforms.m = i
						}, e.prototype._multiply = function(t, e, i) {
							return t[0] = e[0] * i[0] + e[1] * i[5] + e[2] * i[10] + e[3] * i[15], t[1] = e[0] * i[1] + e[1] * i[6] + e[2] * i[11] + e[3] * i[16], t[2] = e[0] * i[2] + e[1] * i[7] + e[2] * i[12] + e[3] * i[17], t[3] = e[0] * i[3] + e[1] * i[8] + e[2] * i[13] + e[3] * i[18], t[4] = e[0] * i[4] + e[1] * i[9] + e[2] * i[14] + e[3] * i[19] + e[4], t[5] = e[5] * i[0] + e[6] * i[5] + e[7] * i[10] + e[8] * i[15], t[6] = e[5] * i[1] + e[6] * i[6] + e[7] * i[11] + e[8] * i[16], t[7] = e[5] * i[2] + e[6] * i[7] + e[7] * i[12] + e[8] * i[17], t[8] = e[5] * i[3] + e[6] * i[8] + e[7] * i[13] + e[8] * i[18], t[9] = e[5] * i[4] + e[6] * i[9] + e[7] * i[14] + e[8] * i[19] + e[9], t[10] = e[10] * i[0] + e[11] * i[5] + e[12] * i[10] + e[13] * i[15], t[11] = e[10] * i[1] + e[11] * i[6] + e[12] * i[11] + e[13] * i[16], t[12] = e[10] * i[2] + e[11] * i[7] + e[12] * i[12] + e[13] * i[17], t[13] = e[10] * i[3] + e[11] * i[8] + e[12] * i[13] + e[13] * i[18], t[14] = e[10] * i[4] + e[11] * i[9] + e[12] * i[14] + e[13] * i[19] + e[14], t[15] = e[15] * i[0] + e[16] * i[5] + e[17] * i[10] + e[18] * i[15], t[16] = e[15] * i[1] + e[16] * i[6] + e[17] * i[11] + e[18] * i[16], t[17] = e[15] * i[2] + e[16] * i[7] + e[17] * i[12] + e[18] * i[17], t[18] = e[15] * i[3] + e[16] * i[8] + e[17] * i[13] + e[18] * i[18], t[19] = e[15] * i[4] + e[16] * i[9] + e[17] * i[14] + e[18] * i[19] + e[19], t
						}, e.prototype._colorMatrix = function(t) {
							var e = new Float32Array(t);
							return e[4] /= 255, e[9] /= 255, e[14] /= 255, e[19] /= 255, e
						}, e.prototype.brightness = function(t, e) {
							var i = [t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 1, 0];
							this._loadMatrix(i, e)
						}, e.prototype.greyscale = function(t, e) {
							var i = [t, t, t, 0, 0, t, t, t, 0, 0, t, t, t, 0, 0, 0, 0, 0, 1, 0];
							this._loadMatrix(i, e)
						}, e.prototype.blackAndWhite = function(t) {
							this._loadMatrix([.3, .6, .1, 0, 0, .3, .6, .1, 0, 0, .3, .6, .1, 0, 0, 0, 0, 0, 1, 0], t)
						}, e.prototype.hue = function(t, e) {
							t = (t || 0) / 180 * Math.PI;
							var i = Math.cos(t),
								n = Math.sin(t),
								s = 1 / 3,
								o = (0, Math.sqrt)(s),
								r = [i + (1 - i) * s, s * (1 - i) - o * n, s * (1 - i) + o * n, 0, 0, s * (1 - i) + o * n, i + s * (1 - i), s * (1 - i) - o * n, 0, 0, s * (1 - i) - o * n, s * (1 - i) + o * n, i + s * (1 - i), 0, 0, 0, 0, 0, 1, 0];
							this._loadMatrix(r, e)
						}, e.prototype.contrast = function(t, e) {
							var i = (t || 0) + 1,
								n = -.5 * (i - 1),
								s = [i, 0, 0, 0, n, 0, i, 0, 0, n, 0, 0, i, 0, n, 0, 0, 0, 1, 0];
							this._loadMatrix(s, e)
						}, e.prototype.saturate = function(t, e) {
							void 0 === t && (t = 0);
							var i = 2 * t / 3 + 1,
								n = -.5 * (i - 1),
								s = [i, n, n, 0, 0, n, i, n, 0, 0, n, n, i, 0, 0, 0, 0, 0, 1, 0];
							this._loadMatrix(s, e)
						}, e.prototype.desaturate = function() {
							this.saturate(-1)
						}, e.prototype.negative = function(t) {
							this._loadMatrix([-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0], t)
						}, e.prototype.sepia = function(t) {
							this._loadMatrix([.393, .7689999, .18899999, 0, 0, .349, .6859999, .16799999, 0, 0, .272, .5339999, .13099999, 0, 0, 0, 0, 0, 1, 0], t)
						}, e.prototype.technicolor = function(t) {
							this._loadMatrix([1.9125277891456083, -.8545344976951645, -.09155508482755585, 0, 11.793603434377337, -.3087833385928097, 1.7658908555458428, -.10601743074722245, 0, -70.35205161461398, -.231103377548616, -.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0], t)
						}, e.prototype.polaroid = function(t) {
							this._loadMatrix([1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0], t)
						}, e.prototype.toBGR = function(t) {
							this._loadMatrix([0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], t)
						}, e.prototype.kodachrome = function(t) {
							this._loadMatrix([1.1285582396593525, -.3967382283601348, -.03992559172921793, 0, 63.72958762196502, -.16404339962244616, 1.0835251566291304, -.05498805115633132, 0, 24.732407896706203, -.16786010706155763, -.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0], t)
						}, e.prototype.browni = function(t) {
							this._loadMatrix([.5997023498159715, .34553243048391263, -.2708298674538042, 0, 47.43192855600873, -.037703249837783157, .8609577587992641, .15059552388459913, 0, -36.96841498319127, .24113635128153335, -.07441037908422492, .44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0], t)
						}, e.prototype.vintage = function(t) {
							this._loadMatrix([.6279345635605994, .3202183420819367, -.03965408211312453, 0, 9.651285835294123, .02578397704808868, .6441188644374771, .03259127616149294, 0, 7.462829176470591, .0466055556782719, -.0851232987247891, .5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0], t)
						}, e.prototype.colorTone = function(t, e, i, n, s) {
							var o = ((i = i || 16770432) >> 16 & 255) / 255,
								r = (i >> 8 & 255) / 255,
								a = (255 & i) / 255,
								l = ((n = n || 3375104) >> 16 & 255) / 255,
								h = (n >> 8 & 255) / 255,
								u = (255 & n) / 255,
								c = [.3, .59, .11, 0, 0, o, r, a, t = t || .2, 0, l, h, u, e = e || .15, 0, o - l, r - h, a - u, 0, 0];
							this._loadMatrix(c, s)
						}, e.prototype.night = function(t, e) {
							var i = [-2 * (t = t || .1), -t, 0, 0, 0, -t, 0, t, 0, 0, 0, t, 2 * t, 0, 0, 0, 0, 0, 1, 0];
							this._loadMatrix(i, e)
						}, e.prototype.predator = function(t, e) {
							var i = [11.224130630493164 * t, -4.794486999511719 * t, -2.8746118545532227 * t, 0 * t, .40342438220977783 * t, -3.6330697536468506 * t, 9.193157196044922 * t, -2.951810836791992 * t, 0 * t, -1.316135048866272 * t, -3.2184197902679443 * t, -4.2375030517578125 * t, 7.476448059082031 * t, 0 * t, .8044459223747253 * t, 0, 0, 0, 1, 0];
							this._loadMatrix(i, e)
						}, e.prototype.lsd = function(t) {
							this._loadMatrix([2, -.4, .5, 0, 0, -.5, 2, -.4, 0, 0, -.4, -.5, 3, 0, 0, 0, 0, 0, 1, 0], t)
						}, e.prototype.reset = function() {
							this._loadMatrix([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], !1)
						}, Object.defineProperty(e.prototype, "matrix", {
							get: function() {
								return this.uniforms.m
							},
							set: function(t) {
								this.uniforms.m = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "alpha", {
							get: function() {
								return this.uniforms.uAlpha
							},
							set: function(t) {
								this.uniforms.uAlpha = t
							},
							enumerable: !1,
							configurable: !0
						}), e
					}(tn);
				Nr.prototype.grayscale = Nr.prototype.greyscale;
				var Mr = function(t, e) {
						return Mr = Object.setPrototypeOf || {
							__proto__: []
						}
						instanceof Array && function(t, e) {
							t.__proto__ = e
						} || function(t, e) {
							for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
						}, Mr(t, e)
					},
					Rr = function(t) {
						function e(e, i) {
							var n = this,
								s = new qt;
							return e.renderable = !1, (n = t.call(this, "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n", "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n", {
								mapSampler: e._texture,
								filterMatrix: s,
								scale: {
									x: 1,
									y: 1
								},
								rotation: new Float32Array([1, 0, 0, 1])
							}) || this).maskSprite = e, n.maskMatrix = s, null == i && (i = 20), n.scale = new jt(i, i), n
						}
						return function(t, e) {
							function i() {
								this.constructor = t
							}
							Mr(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
						}(e, t), e.prototype.apply = function(t, e, i, n) {
							this.uniforms.filterMatrix = t.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
							var s = this.maskSprite.worldTransform,
								o = Math.sqrt(s.a * s.a + s.b * s.b),
								r = Math.sqrt(s.c * s.c + s.d * s.d);
							0 !== o && 0 !== r && (this.uniforms.rotation[0] = s.a / o, this.uniforms.rotation[1] = s.b / o, this.uniforms.rotation[2] = s.c / r, this.uniforms.rotation[3] = s.d / r), t.applyFilter(this, e, i, n)
						}, Object.defineProperty(e.prototype, "map", {
							get: function() {
								return this.uniforms.mapSampler
							},
							set: function(t) {
								this.uniforms.mapSampler = t
							},
							enumerable: !1,
							configurable: !0
						}), e
					}(tn),
					Dr = function(t, e) {
						return Dr = Object.setPrototypeOf || {
							__proto__: []
						}
						instanceof Array && function(t, e) {
							t.__proto__ = e
						} || function(t, e) {
							for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
						}, Dr(t, e)
					},
					kr = function(t) {
						function e() {
							return t.call(this, "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputPixel;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputPixel.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n", 'varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputPixel;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it\'s\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputPixel.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n') || this
						}
						return function(t, e) {
							function i() {
								this.constructor = t
							}
							Dr(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
						}(e, t), e
					}(tn),
					Fr = function(t, e) {
						return Fr = Object.setPrototypeOf || {
							__proto__: []
						}
						instanceof Array && function(t, e) {
							t.__proto__ = e
						} || function(t, e) {
							for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
						}, Fr(t, e)
					},
					Gr = function(t) {
						function e(e, i) {
							void 0 === e && (e = .5), void 0 === i && (i = Math.random());
							var n = t.call(this, Cn, "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n", {
								uNoise: 0,
								uSeed: 0
							}) || this;
							return n.noise = e, n.seed = i, n
						}
						return function(t, e) {
							function i() {
								this.constructor = t
							}
							Fr(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
						}(e, t), Object.defineProperty(e.prototype, "noise", {
							get: function() {
								return this.uniforms.uNoise
							},
							set: function(t) {
								this.uniforms.uNoise = t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "seed", {
							get: function() {
								return this.uniforms.uSeed
							},
							set: function(t) {
								this.uniforms.uSeed = t
							},
							enumerable: !1,
							configurable: !0
						}), e
					}(tn),
					Ur = new qt;
				le.prototype._cacheAsBitmap = !1, le.prototype._cacheData = null;
				var Wr = function() {
					this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null
				};
				Object.defineProperties(le.prototype, {
					cacheAsBitmap: {
						get: function() {
							return this._cacheAsBitmap
						},
						set: function(t) {
							var e;
							this._cacheAsBitmap !== t && (this._cacheAsBitmap = t, t ? (this._cacheData || (this._cacheData = new Wr), (e = this._cacheData).originalRender = this.render, e.originalRenderCanvas = this.renderCanvas, e.originalUpdateTransform = this.updateTransform, e.originalCalculateBounds = this.calculateBounds, e.originalGetLocalBounds = this.getLocalBounds, e.originalDestroy = this.destroy, e.originalContainsPoint = this.containsPoint, e.originalMask = this._mask, e.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : ((e = this._cacheData).sprite && this._destroyCachedDisplayObject(), this.render = e.originalRender, this.renderCanvas = e.originalRenderCanvas, this.calculateBounds = e.originalCalculateBounds, this.getLocalBounds = e.originalGetLocalBounds, this.destroy = e.originalDestroy, this.updateTransform = e.originalUpdateTransform, this.containsPoint = e.originalContainsPoint, this._mask = e.originalMask, this.filterArea = e.originalFilterArea))
						}
					}
				}), le.prototype._renderCached = function(t) {
					!this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t))
				}, le.prototype._initCachedDisplayObject = function(t) {
					if (!this._cacheData || !this._cacheData.sprite) {
						var e = this.alpha;
						this.alpha = 1, t.batch.flush();
						var i = this.getLocalBounds(null, !0).clone();
						if (this.filters) {
							var n = this.filters[0].padding;
							i.pad(n)
						}
						i.ceil(z.RESOLUTION);
						var s = t.renderTexture.current,
							o = t.renderTexture.sourceFrame.clone(),
							r = t.renderTexture.destinationFrame.clone(),
							a = t.projection.transform,
							l = ti.create({
								width: i.width,
								height: i.height
							}),
							h = "cacheAsBitmap_" + bt();
						this._cacheData.textureCacheId = h, Re.addToCache(l.baseTexture, h), Qe.addToCache(l, h);
						var u = this.transform.localTransform.copyTo(Ur).invert().translate(-i.x, -i.y);
						this.render = this._cacheData.originalRender, t.render(this, l, !0, u, !1), t.projection.transform = a, t.renderTexture.bind(s, o, r), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null;
						var c = new no(l);
						c.transform.worldTransform = this.transform.worldTransform, c.anchor.x = -i.x / i.width, c.anchor.y = -i.y / i.height, c.alpha = e, c._bounds = this._bounds, this._cacheData.sprite = c, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = c.containsPoint.bind(c)
					}
				}, le.prototype._renderCachedCanvas = function(t) {
					!this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t))
				}, le.prototype._initCachedDisplayObjectCanvas = function(t) {
					if (!this._cacheData || !this._cacheData.sprite) {
						var e = this.getLocalBounds(null, !0),
							i = this.alpha;
						this.alpha = 1;
						var n = t.context,
							s = t._projTransform;
						e.ceil(z.RESOLUTION);
						var o = ti.create({
								width: e.width,
								height: e.height
							}),
							r = "cacheAsBitmap_" + bt();
						this._cacheData.textureCacheId = r, Re.addToCache(o.baseTexture, r), Qe.addToCache(o, r);
						var a = Ur;
						this.transform.localTransform.copyTo(a), a.invert(), a.tx -= e.x, a.ty -= e.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, o, !0, a, !1), t.context = n, t._projTransform = s, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null;
						var l = new no(o);
						l.transform.worldTransform = this.transform.worldTransform, l.anchor.x = -e.x / e.width, l.anchor.y = -e.y / e.height, l.alpha = i, l._bounds = this._bounds, this._cacheData.sprite = l, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = l.containsPoint.bind(l)
					}
				}, le.prototype._calculateCachedBounds = function() {
					this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID
				}, le.prototype._getCachedLocalBounds = function() {
					return this._cacheData.sprite.getLocalBounds(null)
				}, le.prototype._destroyCachedDisplayObject = function() {
					this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, Re.removeFromCache(this._cacheData.textureCacheId), Qe.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null
				}, le.prototype._cacheAsBitmapDestroy = function(t) {
					this.cacheAsBitmap = !1, this.destroy(t)
				}, le.prototype.name = null, ce.prototype.getChildByName = function(t, e) {
					for (var i = 0, n = this.children.length; i < n; i++)
						if (this.children[i].name === t) return this.children[i];
					if (e)
						for (i = 0, n = this.children.length; i < n; i++)
							if (this.children[i].getChildByName) {
								var s = this.children[i].getChildByName(t, !0);
								if (s) return s
							} return null
				}, le.prototype.getGlobalPosition = function(t, e) {
					return void 0 === t && (t = new jt), void 0 === e && (e = !1), this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x, t.y = this.position.y), t
				};
				var Hr = function(t, e) {
					return Hr = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(t, e) {
						t.__proto__ = e
					} || function(t, e) {
						for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
					}, Hr(t, e)
				};

				function Vr(t, e) {
					function i() {
						this.constructor = t
					}
					Hr(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
				}
				var Xr = function(t) {
						function e(e, i, n, s) {
							void 0 === e && (e = 100), void 0 === i && (i = 100), void 0 === n && (n = 10), void 0 === s && (s = 10);
							var o = t.call(this) || this;
							return o.segWidth = n, o.segHeight = s, o.width = e, o.height = i, o.build(), o
						}
						return Vr(e, t), e.prototype.build = function() {
							for (var t = this.segWidth * this.segHeight, e = [], i = [], n = [], s = this.segWidth - 1, o = this.segHeight - 1, r = this.width / s, a = this.height / o, l = 0; l < t; l++) {
								var h = l % this.segWidth,
									u = l / this.segWidth | 0;
								e.push(h * r, u * a), i.push(h / s, u / o)
							}
							var c = s * o;
							for (l = 0; l < c; l++) {
								var d = l % s,
									p = l / s | 0,
									_ = p * this.segWidth + d,
									m = p * this.segWidth + d + 1,
									g = (p + 1) * this.segWidth + d,
									f = (p + 1) * this.segWidth + d + 1;
								n.push(_, m, g, m, f, g)
							}
							this.buffers[0].data = new Float32Array(e), this.buffers[1].data = new Float32Array(i), this.indexBuffer.data = new Uint16Array(n), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update()
						}, e
					}(jo),
					Yr = function(t) {
						function e(e, i, n) {
							void 0 === e && (e = 200), void 0 === n && (n = 0);
							var s = t.call(this, new Float32Array(4 * i.length), new Float32Array(4 * i.length), new Uint16Array(6 * (i.length - 1))) || this;
							return s.points = i, s._width = e, s.textureScale = n, s.build(), s
						}
						return Vr(e, t), Object.defineProperty(e.prototype, "width", {
							get: function() {
								return this._width
							},
							enumerable: !1,
							configurable: !0
						}), e.prototype.build = function() {
							var t = this.points;
							if (t) {
								var e = this.getBuffer("aVertexPosition"),
									i = this.getBuffer("aTextureCoord"),
									n = this.getIndex();
								if (!(t.length < 1)) {
									e.data.length / 4 !== t.length && (e.data = new Float32Array(4 * t.length), i.data = new Float32Array(4 * t.length), n.data = new Uint16Array(6 * (t.length - 1)));
									var s = i.data,
										o = n.data;
									s[0] = 0, s[1] = 0, s[2] = 0, s[3] = 1;
									for (var r = 0, a = t[0], l = this._width * this.textureScale, h = t.length, u = 0; u < h; u++) {
										var c = 4 * u;
										if (this.textureScale > 0) {
											var d = a.x - t[u].x,
												p = a.y - t[u].y,
												_ = Math.sqrt(d * d + p * p);
											a = t[u], r += _ / l
										} else r = u / (h - 1);
										s[c] = r, s[c + 1] = 0, s[c + 2] = r, s[c + 3] = 1
									}
									var m = 0;
									for (u = 0; u < h - 1; u++) c = 2 * u, o[m++] = c, o[m++] = c + 1, o[m++] = c + 2, o[m++] = c + 2, o[m++] = c + 1, o[m++] = c + 3;
									i.update(), n.update(), this.updateVertices()
								}
							}
						}, e.prototype.updateVertices = function() {
							var t = this.points;
							if (!(t.length < 1)) {
								for (var e, i = t[0], n = 0, s = 0, o = this.buffers[0].data, r = t.length, a = 0; a < r; a++) {
									var l = t[a],
										h = 4 * a;
									s = -((e = a < t.length - 1 ? t[a + 1] : l).x - i.x), n = e.y - i.y;
									var u = Math.sqrt(n * n + s * s),
										c = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
									n /= u, s /= u, n *= c, s *= c, o[h] = l.x + n, o[h + 1] = l.y + s, o[h + 2] = l.x - n, o[h + 3] = l.y - s, i = l
								}
								this.buffers[0].update()
							}
						}, e.prototype.update = function() {
							this.textureScale > 0 ? this.build() : this.updateVertices()
						}, e
					}(jo),
					zr = function(t) {
						function e(e, i, n) {
							void 0 === n && (n = 0);
							var s = this,
								o = new Yr(e.height, i, n),
								r = new zo(e);
							return n > 0 && (e.baseTexture.wrapMode = T.REPEAT), (s = t.call(this, o, r) || this).autoUpdate = !0, s
						}
						return Vr(e, t), e.prototype._render = function(e) {
							var i = this.geometry;
							(this.autoUpdate || i._width !== this.shader.texture.height) && (i._width = this.shader.texture.height, i.update()), t.prototype._render.call(this, e)
						}, e
					}(Yo),
					jr = function(t) {
						function e(e, i, n) {
							var s = this,
								o = new Xr(e.width, e.height, i, n),
								r = new zo(Qe.WHITE);
							return (s = t.call(this, o, r) || this).texture = e, s
						}
						return Vr(e, t), e.prototype.textureUpdated = function() {
							this._textureID = this.shader.texture._updateID;
							var t = this.geometry;
							t.width = this.shader.texture.width, t.height = this.shader.texture.height, t.build()
						}, Object.defineProperty(e.prototype, "texture", {
							get: function() {
								return this.shader.texture
							},
							set: function(t) {
								this.shader.texture !== t && (this.shader.texture = t, this._textureID = -1, t.baseTexture.valid ? this.textureUpdated() : t.once("update", this.textureUpdated, this))
							},
							enumerable: !1,
							configurable: !0
						}), e.prototype._render = function(e) {
							this._textureID !== this.shader.texture._updateID && this.textureUpdated(), t.prototype._render.call(this, e)
						}, e.prototype.destroy = function(e) {
							this.shader.texture.off("update", this.textureUpdated, this), t.prototype.destroy.call(this, e)
						}, e
					}(Yo),
					Kr = function(t) {
						function e(e, i, n, s, o) {
							void 0 === e && (e = Qe.EMPTY);
							var r = this,
								a = new jo(i, n, s);
							a.getBuffer("aVertexPosition").static = !1;
							var l = new zo(e);
							return (r = t.call(this, a, l, null, o) || this).autoUpdate = !0, r
						}
						return Vr(e, t), Object.defineProperty(e.prototype, "vertices", {
							get: function() {
								return this.geometry.getBuffer("aVertexPosition").data
							},
							set: function(t) {
								this.geometry.getBuffer("aVertexPosition").data = t
							},
							enumerable: !1,
							configurable: !0
						}), e.prototype._render = function(e) {
							this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), t.prototype._render.call(this, e)
						}, e
					}(Yo),
					qr = function(t) {
						function e(e, i, n, s, o) {
							void 0 === i && (i = 10), void 0 === n && (n = 10), void 0 === s && (s = 10), void 0 === o && (o = 10);
							var r = t.call(this, Qe.WHITE, 4, 4) || this;
							return r._origWidth = e.orig.width, r._origHeight = e.orig.height, r._width = r._origWidth, r._height = r._origHeight, r._leftWidth = i, r._rightWidth = s, r._topHeight = n, r._bottomHeight = o, r.texture = e, r
						}
						return Vr(e, t), e.prototype.textureUpdated = function() {
							this._textureID = this.shader.texture._updateID, this._refresh()
						}, Object.defineProperty(e.prototype, "vertices", {
							get: function() {
								return this.geometry.getBuffer("aVertexPosition").data
							},
							set: function(t) {
								this.geometry.getBuffer("aVertexPosition").data = t
							},
							enumerable: !1,
							configurable: !0
						}), e.prototype.updateHorizontalVertices = function() {
							var t = this.vertices,
								e = this._getMinScale();
							t[9] = t[11] = t[13] = t[15] = this._topHeight * e, t[17] = t[19] = t[21] = t[23] = this._height - this._bottomHeight * e, t[25] = t[27] = t[29] = t[31] = this._height
						}, e.prototype.updateVerticalVertices = function() {
							var t = this.vertices,
								e = this._getMinScale();
							t[2] = t[10] = t[18] = t[26] = this._leftWidth * e, t[4] = t[12] = t[20] = t[28] = this._width - this._rightWidth * e, t[6] = t[14] = t[22] = t[30] = this._width
						}, e.prototype._getMinScale = function() {
							var t = this._leftWidth + this._rightWidth,
								e = this._width > t ? 1 : this._width / t,
								i = this._topHeight + this._bottomHeight,
								n = this._height > i ? 1 : this._height / i;
							return Math.min(e, n)
						}, Object.defineProperty(e.prototype, "width", {
							get: function() {
								return this._width
							},
							set: function(t) {
								this._width = t, this._refresh()
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "height", {
							get: function() {
								return this._height
							},
							set: function(t) {
								this._height = t, this._refresh()
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "leftWidth", {
							get: function() {
								return this._leftWidth
							},
							set: function(t) {
								this._leftWidth = t, this._refresh()
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "rightWidth", {
							get: function() {
								return this._rightWidth
							},
							set: function(t) {
								this._rightWidth = t, this._refresh()
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "topHeight", {
							get: function() {
								return this._topHeight
							},
							set: function(t) {
								this._topHeight = t, this._refresh()
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "bottomHeight", {
							get: function() {
								return this._bottomHeight
							},
							set: function(t) {
								this._bottomHeight = t, this._refresh()
							},
							enumerable: !1,
							configurable: !0
						}), e.prototype._refresh = function() {
							var t = this.texture,
								e = this.geometry.buffers[1].data;
							this._origWidth = t.orig.width, this._origHeight = t.orig.height;
							var i = 1 / this._origWidth,
								n = 1 / this._origHeight;
							e[0] = e[8] = e[16] = e[24] = 0, e[1] = e[3] = e[5] = e[7] = 0, e[6] = e[14] = e[22] = e[30] = 1, e[25] = e[27] = e[29] = e[31] = 1, e[2] = e[10] = e[18] = e[26] = i * this._leftWidth, e[4] = e[12] = e[20] = e[28] = 1 - i * this._rightWidth, e[9] = e[11] = e[13] = e[15] = n * this._topHeight, e[17] = e[19] = e[21] = e[23] = 1 - n * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update()
						}, e
					}(jr),
					Zr = function(t, e) {
						return Zr = Object.setPrototypeOf || {
							__proto__: []
						}
						instanceof Array && function(t, e) {
							t.__proto__ = e
						} || function(t, e) {
							for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
						}, Zr(t, e)
					},
					$r = function(t) {
						function e(e, i) {
							void 0 === i && (i = !0);
							var n = t.call(this, e[0] instanceof Qe ? e[0] : e[0].texture) || this;
							return n._textures = null, n._durations = null, n._autoUpdate = i, n._isConnectedToTicker = !1, n.animationSpeed = 1, n.loop = !0, n.updateAnchor = !1, n.onComplete = null, n.onFrameChange = null, n.onLoop = null, n._currentTime = 0, n._playing = !1, n._previousFrame = null, n.textures = e, n
						}
						return function(t, e) {
							function i() {
								this.constructor = t
							}
							Zr(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
						}(e, t), e.prototype.stop = function() {
							this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (fe.shared.remove(this.update, this), this._isConnectedToTicker = !1))
						}, e.prototype.play = function() {
							this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (fe.shared.add(this.update, this, pe.HIGH), this._isConnectedToTicker = !0))
						}, e.prototype.gotoAndStop = function(t) {
							this.stop();
							var e = this.currentFrame;
							this._currentTime = t, e !== this.currentFrame && this.updateTexture()
						}, e.prototype.gotoAndPlay = function(t) {
							var e = this.currentFrame;
							this._currentTime = t, e !== this.currentFrame && this.updateTexture(), this.play()
						}, e.prototype.update = function(t) {
							if (this._playing) {
								var e = this.animationSpeed * t,
									i = this.currentFrame;
								if (null !== this._durations) {
									var n = this._currentTime % 1 * this._durations[this.currentFrame];
									for (n += e / 60 * 1e3; n < 0;) this._currentTime--, n += this._durations[this.currentFrame];
									var s = Math.sign(this.animationSpeed * t);
									for (this._currentTime = Math.floor(this._currentTime); n >= this._durations[this.currentFrame];) n -= this._durations[this.currentFrame] * s, this._currentTime += s;
									this._currentTime += n / this._durations[this.currentFrame]
								} else this._currentTime += e;
								this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : i !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < i || this.animationSpeed < 0 && this.currentFrame > i) && this.onLoop(), this.updateTexture())
							}
						}, e.prototype.updateTexture = function() {
							var t = this.currentFrame;
							this._previousFrame !== t && (this._previousFrame = t, this._texture = this._textures[t], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame))
						}, e.prototype.destroy = function(e) {
							this.stop(), t.prototype.destroy.call(this, e), this.onComplete = null, this.onFrameChange = null, this.onLoop = null
						}, e.fromFrames = function(t) {
							for (var i = [], n = 0; n < t.length; ++n) i.push(Qe.from(t[n]));
							return new e(i)
						}, e.fromImages = function(t) {
							for (var i = [], n = 0; n < t.length; ++n) i.push(Qe.from(t[n]));
							return new e(i)
						}, Object.defineProperty(e.prototype, "totalFrames", {
							get: function() {
								return this._textures.length
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "textures", {
							get: function() {
								return this._textures
							},
							set: function(t) {
								if (t[0] instanceof Qe) this._textures = t, this._durations = null;
								else {
									this._textures = [], this._durations = [];
									for (var e = 0; e < t.length; e++) this._textures.push(t[e].texture), this._durations.push(t[e].time)
								}
								this._previousFrame = null, this.gotoAndStop(0), this.updateTexture()
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "currentFrame", {
							get: function() {
								var t = Math.floor(this._currentTime) % this._textures.length;
								return t < 0 && (t += this._textures.length), t
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "playing", {
							get: function() {
								return this._playing
							},
							enumerable: !1,
							configurable: !0
						}), Object.defineProperty(e.prototype, "autoUpdate", {
							get: function() {
								return this._autoUpdate
							},
							set: function(t) {
								t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (fe.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (fe.shared.add(this.update, this), this._isConnectedToTicker = !0))
							},
							enumerable: !1,
							configurable: !0
						}), e
					}(no),
					Qr = function(t, e) {
						return Qr = Object.setPrototypeOf || {
							__proto__: []
						}
						instanceof Array && function(t, e) {
							t.__proto__ = e
						} || function(t, e) {
							for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
						}, Qr(t, e)
					};

				function Jr(t, e) {
					function i() {
						this.constructor = t
					}
					Qr(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
				}
				var ta = "5.0.0";

				function ea() {
					var t = this;
					Object.defineProperties(t, {
						SVG_SIZE: {
							get: function() {
								return Pt(ta, "PIXI.utils.SVG_SIZE property has moved to PIXI.resources.SVGResource.SVG_SIZE"), t.SVGResource.SVG_SIZE
							}
						},
						TransformStatic: {
							get: function() {
								return Pt(ta, "PIXI.TransformStatic class has been removed, use PIXI.Transform"), t.Transform
							}
						},
						TransformBase: {
							get: function() {
								return Pt(ta, "PIXI.TransformBase class has been removed, use PIXI.Transform"), t.Transform
							}
						},
						TRANSFORM_MODE: {
							get: function() {
								return Pt(ta, "PIXI.TRANSFORM_MODE property has been removed"), {
									STATIC: 0,
									DYNAMIC: 1
								}
							}
						},
						WebGLRenderer: {
							get: function() {
								return Pt(ta, "PIXI.WebGLRenderer class has moved to PIXI.Renderer"), t.Renderer
							}
						},
						CanvasRenderTarget: {
							get: function() {
								return Pt(ta, "PIXI.CanvasRenderTarget class has moved to PIXI.utils.CanvasRenderTarget"), t.utils.CanvasRenderTarget
							}
						},
						loader: {
							get: function() {
								return Pt(ta, "PIXI.loader instance has moved to PIXI.Loader.shared"), t.Loader.shared
							}
						},
						FilterManager: {
							get: function() {
								return Pt(ta, "PIXI.FilterManager class has moved to PIXI.systems.FilterSystem"), t.systems.FilterSystem
							}
						},
						CanvasTinter: {
							get: function() {
								return Pt("5.2.0", "PIXI.CanvasTinter namespace has moved to PIXI.canvasUtils"), t.canvasUtils
							}
						},
						GroupD8: {
							get: function() {
								return Pt("5.2.0", "PIXI.GroupD8 namespace has moved to PIXI.groupD8"), t.groupD8
							}
						}
					}), t.accessibility = {}, Object.defineProperties(t.accessibility, {
						AccessibilityManager: {
							get: function() {
								return Pt("5.3.0", "PIXI.accessibility.AccessibilityManager moved to PIXI.AccessibilityManager"), t.AccessibilityManager
							}
						}
					}), t.interaction = {}, Object.defineProperties(t.interaction, {
						InteractionManager: {
							get: function() {
								return Pt("5.3.0", "PIXI.interaction.InteractionManager moved to PIXI.InteractionManager"), t.InteractionManager
							}
						},
						InteractionData: {
							get: function() {
								return Pt("5.3.0", "PIXI.interaction.InteractionData moved to PIXI.InteractionData"), t.InteractionData
							}
						},
						InteractionEvent: {
							get: function() {
								return Pt("5.3.0", "PIXI.interaction.InteractionEvent moved to PIXI.InteractionEvent"), t.InteractionEvent
							}
						}
					}), t.prepare = {}, Object.defineProperties(t.prepare, {
						BasePrepare: {
							get: function() {
								return Pt("5.2.1", "PIXI.prepare.BasePrepare moved to PIXI.BasePrepare"), t.BasePrepare
							}
						},
						Prepare: {
							get: function() {
								return Pt("5.2.1", "PIXI.prepare.Prepare moved to PIXI.Prepare"), t.Prepare
							}
						},
						CanvasPrepare: {
							get: function() {
								return Pt("5.2.1", "PIXI.prepare.CanvasPrepare moved to PIXI.CanvasPrepare"), t.CanvasPrepare
							}
						}
					}), t.extract = {}, Object.defineProperties(t.extract, {
						Extract: {
							get: function() {
								return Pt("5.2.1", "PIXI.extract.Extract moved to PIXI.Extract"), t.Extract
							}
						},
						CanvasExtract: {
							get: function() {
								return Pt("5.2.1", "PIXI.extract.CanvasExtract moved to PIXI.CanvasExtract"), t.CanvasExtract
							}
						}
					}), t.extras = {}, Object.defineProperties(t.extras, {
						TilingSprite: {
							get: function() {
								return Pt(ta, "PIXI.extras.TilingSprite class has moved to PIXI.TilingSprite"), t.TilingSprite
							}
						},
						TilingSpriteRenderer: {
							get: function() {
								return Pt(ta, "PIXI.extras.TilingSpriteRenderer class has moved to PIXI.TilingSpriteRenderer"), t.TilingSpriteRenderer
							}
						},
						AnimatedSprite: {
							get: function() {
								return Pt(ta, "PIXI.extras.AnimatedSprite class has moved to PIXI.AnimatedSprite"), t.AnimatedSprite
							}
						},
						BitmapText: {
							get: function() {
								return Pt(ta, "PIXI.extras.BitmapText class has moved to PIXI.BitmapText"), t.BitmapText
							}
						}
					}), t.TilingSprite.fromFrame = function(e, i, n) {
						return Pt("5.3.0", "TilingSprite.fromFrame is deprecated, use TilingSprite.from"), t.TilingSprite.from(e, {
							width: i,
							height: n
						})
					}, t.TilingSprite.fromImage = function(e, i, n, s) {
						return void 0 === s && (s = {}), Pt("5.3.0", "TilingSprite.fromImage is deprecated, use TilingSprite.from"), s && "object" != typeof s && (s = {
							scaleMode: arguments[4],
							resourceOptions: {
								crossorigin: arguments[3]
							}
						}), s.width = i, s.height = n, t.TilingSprite.from(e, s)
					}, Object.defineProperties(t.utils, {
						getSvgSize: {
							get: function() {
								return Pt(ta, "PIXI.utils.getSvgSize function has moved to PIXI.resources.SVGResource.getSize"), t.resources.SVGResource.getSize
							}
						}
					}), t.mesh = {}, Object.defineProperties(t.mesh, {
						Mesh: {
							get: function() {
								return Pt(ta, "PIXI.mesh.Mesh class has moved to PIXI.SimpleMesh"), t.SimpleMesh
							}
						},
						NineSlicePlane: {
							get: function() {
								return Pt(ta, "PIXI.mesh.NineSlicePlane class has moved to PIXI.NineSlicePlane"), t.NineSlicePlane
							}
						},
						Plane: {
							get: function() {
								return Pt(ta, "PIXI.mesh.Plane class has moved to PIXI.SimplePlane"), t.SimplePlane
							}
						},
						Rope: {
							get: function() {
								return Pt(ta, "PIXI.mesh.Rope class has moved to PIXI.SimpleRope"), t.SimpleRope
							}
						},
						RawMesh: {
							get: function() {
								return Pt(ta, "PIXI.mesh.RawMesh class has moved to PIXI.Mesh"), t.Mesh
							}
						},
						CanvasMeshRenderer: {
							get: function() {
								return Pt(ta, "PIXI.mesh.CanvasMeshRenderer class has moved to PIXI.CanvasMeshRenderer"), t.CanvasMeshRenderer
							}
						},
						MeshRenderer: {
							get: function() {
								return Pt(ta, "PIXI.mesh.MeshRenderer class has moved to PIXI.MeshRenderer"), t.MeshRenderer
							}
						}
					}), t.particles = {}, Object.defineProperties(t.particles, {
						ParticleContainer: {
							get: function() {
								return Pt(ta, "PIXI.particles.ParticleContainer class has moved to PIXI.ParticleContainer"), t.ParticleContainer
							}
						},
						ParticleRenderer: {
							get: function() {
								return Pt(ta, "PIXI.particles.ParticleRenderer class has moved to PIXI.ParticleRenderer"), t.ParticleRenderer
							}
						}
					}), t.ticker = {}, Object.defineProperties(t.ticker, {
						Ticker: {
							get: function() {
								return Pt(ta, "PIXI.ticker.Ticker class has moved to PIXI.Ticker"), t.Ticker
							}
						},
						shared: {
							get: function() {
								return Pt(ta, "PIXI.ticker.shared instance has moved to PIXI.Ticker.shared"), t.Ticker.shared
							}
						}
					}), t.loaders = {}, Object.defineProperties(t.loaders, {
						Loader: {
							get: function() {
								return Pt(ta, "PIXI.loaders.Loader class has moved to PIXI.Loader"), t.Loader
							}
						},
						Resource: {
							get: function() {
								return Pt(ta, "PIXI.loaders.Resource class has moved to PIXI.LoaderResource"), t.LoaderResource
							}
						},
						bitmapFontParser: {
							get: function() {
								return Pt(ta, "PIXI.loaders.bitmapFontParser function has moved to PIXI.BitmapFontLoader.use"), t.BitmapFontLoader.use
							}
						},
						parseBitmapFontData: {
							get: function() {
								Pt(ta, "PIXI.loaders.parseBitmapFontData function has removed")
							}
						},
						spritesheetParser: {
							get: function() {
								return Pt(ta, "PIXI.loaders.spritesheetParser function has moved to PIXI.SpritesheetLoader.use"), t.SpritesheetLoader.use
							}
						},
						getResourcePath: {
							get: function() {
								return Pt(ta, "PIXI.loaders.getResourcePath property has moved to PIXI.SpritesheetLoader.getResourcePath"), t.SpritesheetLoader.getResourcePath
							}
						}
					}), t.Loader.addPixiMiddleware = function(e) {
						return Pt(ta, "PIXI.loaders.Loader.addPixiMiddleware function is deprecated, use PIXI.loaders.Loader.registerPlugin"), t.loaders.Loader.registerPlugin({
							use: e()
						})
					};
					var e = function(t) {
						return "on" + t.charAt(0).toUpperCase() + t.slice(1)
					};
					Object.assign(t.Loader.prototype, {
						on: function(t) {
							var i = e(t);
							Pt(ta, "PIXI.Loader#on is completely deprecated, use PIXI.Loader#" + i + ".add")
						},
						once: function(t) {
							var i = e(t);
							Pt(ta, "PIXI.Loader#once is completely deprecated, use PIXI.Loader#" + i + ".once")
						},
						off: function(t) {
							var i = e(t);
							Pt(ta, "PIXI.Loader#off is completely deprecated, use PIXI.Loader#" + i + ".detach")
						}
					}), Object.defineProperty(t.extract, "WebGLExtract", {
						get: function() {
							return Pt(ta, "PIXI.extract.WebGLExtract method has moved to PIXI.Extract"), t.Extract
						}
					}), Object.defineProperty(t.prepare, "WebGLPrepare", {
						get: function() {
							return Pt(ta, "PIXI.prepare.WebGLPrepare class has moved to PIXI.Prepare"), t.Prepare
						}
					}), t.Container.prototype._renderWebGL = function(t) {
						Pt(ta, "PIXI.Container._renderWebGL method has moved to PIXI.Container._render"), this._render(t)
					}, t.Container.prototype.renderWebGL = function(t) {
						Pt(ta, "PIXI.Container.renderWebGL method has moved to PIXI.Container.render"), this.render(t)
					}, t.DisplayObject.prototype.renderWebGL = function(t) {
						Pt(ta, "PIXI.DisplayObject.renderWebGL method has moved to PIXI.DisplayObject.render"), this.render(t)
					}, t.Container.prototype.renderAdvancedWebGL = function(t) {
						Pt(ta, "PIXI.Container.renderAdvancedWebGL method has moved to PIXI.Container.renderAdvanced"), this.renderAdvanced(t)
					}, Object.defineProperties(t.settings, {
						TRANSFORM_MODE: {
							get: function() {
								return Pt(ta, "PIXI.settings.TRANSFORM_MODE property has been removed"), 0
							},
							set: function() {
								Pt(ta, "PIXI.settings.TRANSFORM_MODE property has been removed")
							}
						}
					});
					var i = t.BaseTexture;
					i.prototype.loadSource = function(e) {
						Pt(ta, "PIXI.BaseTexture.loadSource method has been deprecated");
						var i = t.resources.autoDetectResource(e);
						i.internal = !0, this.setResource(i), this.update()
					};
					var n = !1;
					Object.defineProperties(i.prototype, {
						hasLoaded: {
							get: function() {
								return Pt(ta, "PIXI.BaseTexture.hasLoaded property has been removed, use PIXI.BaseTexture.valid"), this.valid
							}
						},
						imageUrl: {
							get: function() {
								var t;
								return Pt(ta, "PIXI.BaseTexture.imageUrl property has been removed, use PIXI.BaseTexture.resource.url"), null === (t = this.resource) || void 0 === t ? void 0 : t.url
							},
							set: function(t) {
								Pt(ta, "PIXI.BaseTexture.imageUrl property has been removed, use PIXI.BaseTexture.resource.url"), this.resource && (this.resource.url = t)
							}
						},
						source: {
							get: function() {
								return Pt(ta, "PIXI.BaseTexture.source property has been moved, use `PIXI.BaseTexture.resource.source`"), this.resource.source
							},
							set: function(t) {
								Pt(ta, "PIXI.BaseTexture.source property has been moved, use `PIXI.BaseTexture.resource.source` if you want to set HTMLCanvasElement. Otherwise, create new BaseTexture."), this.resource && (this.resource.source = t)
							}
						},
						premultiplyAlpha: {
							get: function() {
								return Pt("5.2.0", "PIXI.BaseTexture.premultiplyAlpha property has been changed to `alphaMode`, see `PIXI.ALPHA_MODES`"), 0 !== this.alphaMode
							},
							set: function(t) {
								Pt("5.2.0", "PIXI.BaseTexture.premultiplyAlpha property has been changed to `alphaMode`, see `PIXI.ALPHA_MODES`"), this.alphaMode = Number(t)
							}
						},
						_id: {
							get: function() {
								return n || (Pt("5.2.0", "PIXI.BaseTexture._id batch local field has been changed to `_batchLocation`"), n = !0), this._batchLocation
							},
							set: function(t) {
								this._batchLocation = t
							}
						}
					}), i.fromImage = function(t, e, n, s) {
						Pt(ta, "PIXI.BaseTexture.fromImage method has been replaced with PIXI.BaseTexture.from");
						var o = {
							scale: s,
							crossorigin: e
						};
						return i.from(t, {
							scaleMode: n,
							resourceOptions: o
						})
					}, i.fromCanvas = function(t, e) {
						return Pt(ta, "PIXI.BaseTexture.fromCanvas method has been replaced with PIXI.BaseTexture.from"), i.from(t, {
							scaleMode: e
						})
					}, i.fromSVG = function(t, e, n, s) {
						Pt(ta, "PIXI.BaseTexture.fromSVG method has been replaced with PIXI.BaseTexture.from");
						var o = {
							scale: s,
							crossorigin: e
						};
						return i.from(t, {
							scaleMode: n,
							resourceOptions: o
						})
					}, Object.defineProperties(t.resources.ImageResource.prototype, {
						premultiplyAlpha: {
							get: function() {
								return Pt("5.2.0", "PIXI.resources.ImageResource.premultiplyAlpha property has been changed to `alphaMode`, see `PIXI.ALPHA_MODES`"), 0 !== this.alphaMode
							},
							set: function(t) {
								Pt("5.2.0", "PIXI.resources.ImageResource.premultiplyAlpha property has been changed to `alphaMode`, see `PIXI.ALPHA_MODES`"), this.alphaMode = Number(t)
							}
						}
					}), t.Point.prototype.copy = function(t) {
						return Pt(ta, "PIXI.Point.copy method has been replaced with PIXI.Point.copyFrom"), this.copyFrom(t)
					}, t.ObservablePoint.prototype.copy = function(t) {
						return Pt(ta, "PIXI.ObservablePoint.copy method has been replaced with PIXI.ObservablePoint.copyFrom"), this.copyFrom(t)
					}, t.Rectangle.prototype.copy = function(t) {
						return Pt(ta, "PIXI.Rectangle.copy method has been replaced with PIXI.Rectangle.copyFrom"), this.copyFrom(t)
					}, t.Matrix.prototype.copy = function(t) {
						return Pt(ta, "PIXI.Matrix.copy method has been replaced with PIXI.Matrix.copyTo"), this.copyTo(t)
					}, t.systems.StateSystem.prototype.setState = function(t) {
						return Pt("v5.1.0", "StateSystem.setState has been renamed to StateSystem.set"), this.set(t)
					}, Object.assign(t.systems.FilterSystem.prototype, {
						getRenderTarget: function(t, e) {
							return Pt(ta, "PIXI.FilterManager.getRenderTarget method has been replaced with PIXI.systems.FilterSystem#getFilterTexture"), this.getFilterTexture(null, e)
						},
						returnRenderTarget: function(t) {
							Pt(ta, "PIXI.FilterManager.returnRenderTarget method has been replaced with PIXI.systems.FilterSystem.returnFilterTexture"), this.returnFilterTexture(t)
						},
						calculateScreenSpaceMatrix: function(t) {
							Pt(ta, "PIXI.systems.FilterSystem.calculateScreenSpaceMatrix method is removed, use `(vTextureCoord * inputSize.xy) + outputFrame.xy` instead");
							var e = t.identity(),
								i = this.activeState,
								n = i.sourceFrame,
								s = i.destinationFrame;
							return e.translate(n.x / s.width, n.y / s.height), e.scale(s.width, s.height), e
						},
						calculateNormalizedScreenSpaceMatrix: function(t) {
							Pt(ta, "PIXI.systems.FilterManager.calculateNormalizedScreenSpaceMatrix method is removed, use `((vTextureCoord * inputSize.xy) + outputFrame.xy) / outputFrame.zw` instead.");
							var e = this.activeState,
								i = e.sourceFrame,
								n = e.destinationFrame,
								s = t.identity();
							s.translate(i.x / n.width, i.y / n.height);
							var o = n.width / i.width,
								r = n.height / i.height;
							return s.scale(o, r), s
						}
					}), Object.defineProperties(t.RenderTexture.prototype, {
						sourceFrame: {
							get: function() {
								return Pt(ta, "PIXI.RenderTexture.sourceFrame property has been removed"), this.filterFrame
							}
						},
						size: {
							get: function() {
								return Pt(ta, "PIXI.RenderTexture.size property has been removed"), this._frame
							}
						}
					});
					var s = function(t) {
							function e(e, i, n, s) {
								return Pt(ta, "PIXI.filters.BlurXFilter class is deprecated, use PIXI.filters.BlurFilterPass"), t.call(this, !0, e, i, n, s) || this
							}
							return Jr(e, t), e
						}(t.filters.BlurFilterPass),
						o = function(t) {
							function e(e, i, n, s) {
								return Pt(ta, "PIXI.filters.BlurYFilter class is deprecated, use PIXI.filters.BlurFilterPass"), t.call(this, !1, e, i, n, s) || this
							}
							return Jr(e, t), e
						}(t.filters.BlurFilterPass);
					Object.assign(t.filters, {
						BlurXFilter: s,
						BlurYFilter: o
					});
					var r = t.Sprite,
						a = t.Texture,
						l = t.Graphics;

					function h(t, e, i, n) {
						return Pt(ta, "PIXI.Sprite." + t + " method is deprecated, use PIXI.Sprite.from"), r.from(e, {
							resourceOptions: {
								scale: n,
								crossorigin: i
							}
						})
					}

					function u(t, e, i, n) {
						return Pt(ta, "PIXI.Texture." + t + " method is deprecated, use PIXI.Texture.from"), a.from(e, {
							resourceOptions: {
								scale: n,
								crossorigin: i
							}
						})
					}
					l.prototype.generateCanvasTexture || (l.prototype.generateCanvasTexture = function() {
						Pt(ta, 'PIXI.Graphics.generateCanvasTexture method is only available in "pixi.js-legacy"')
					}), Object.defineProperty(l.prototype, "graphicsData", {
						get: function() {
							return Pt(ta, "PIXI.Graphics.graphicsData property is deprecated, use PIXI.Graphics.geometry.graphicsData"), this.geometry.graphicsData
						}
					}), r.fromImage = h.bind(null, "fromImage"), r.fromSVG = h.bind(null, "fromSVG"), r.fromCanvas = h.bind(null, "fromCanvas"), r.fromVideo = h.bind(null, "fromVideo"), r.fromFrame = h.bind(null, "fromFrame"), a.fromImage = u.bind(null, "fromImage"), a.fromSVG = u.bind(null, "fromSVG"), a.fromCanvas = u.bind(null, "fromCanvas"), a.fromVideo = u.bind(null, "fromVideo"), a.fromFrame = u.bind(null, "fromFrame"), Object.defineProperty(t.AbstractRenderer.prototype, "autoResize", {
						get: function() {
							return Pt(ta, "PIXI.AbstractRenderer.autoResize property is deprecated, use PIXI.AbstractRenderer.autoDensity"), this.autoDensity
						},
						set: function(t) {
							Pt(ta, "PIXI.AbstractRenderer.autoResize property is deprecated, use PIXI.AbstractRenderer.autoDensity"), this.autoDensity = t
						}
					}), Object.defineProperty(t.Renderer.prototype, "textureManager", {
						get: function() {
							return Pt(ta, "PIXI.Renderer.textureManager property is deprecated, use PIXI.Renderer.texture"), this.texture
						}
					}), t.utils.mixins = {
						mixin: function() {
							Pt(ta, "PIXI.utils.mixins.mixin function is no longer available")
						},
						delayMixin: function() {
							Pt(ta, "PIXI.utils.mixins.delayMixin function is no longer available")
						},
						performMixins: function() {
							Pt(ta, "PIXI.utils.mixins.performMixins function is no longer available")
						}
					}, Object.defineProperty(t.BitmapText.prototype, "font", {
						get: function() {
							return Pt("5.3.0", "PIXI.BitmapText.font property is deprecated, use fontName, fontSize, tint or align properties"), {
								name: this._fontName,
								size: this._fontSize,
								tint: this._tint,
								align: this._align
							}
						},
						set: function(e) {
							if (Pt("5.3.0", "PIXI.BitmapText.font property is deprecated, use fontName, fontSize, tint or align properties"), e) {
								var i = {
									font: e
								};
								this._upgradeStyle(i), i.fontSize = i.fontSize || t.BitmapFont.available[i.fontName].size, this._fontName = i.fontName, this._fontSize = i.fontSize, this.dirty = !0
							}
						}
					})
				}
				In.registerPlugin("accessibility", me), In.registerPlugin("extract", Vn), In.registerPlugin("interaction", Ie), In.registerPlugin("particle", Ts), In.registerPlugin("prepare", Co), In.registerPlugin("batch", Gn), In.registerPlugin("tilingSprite", Go), ps.registerPlugin(rr), ps.registerPlugin(Oo), Un.registerPlugin(Se), Un.registerPlugin(_s);
				var ia = "5.3.12",
					na = {
						AlphaFilter: lr,
						BlurFilter: Br,
						BlurFilterPass: xr,
						ColorMatrixFilter: Nr,
						DisplacementFilter: Rr,
						FXAAFilter: kr,
						NoiseFilter: Gr
					}
			},
			74765: t => {
				"use strict";
				var e = String.prototype.replace,
					i = /%20/g,
					n = "RFC3986";
				t.exports = {
					default: n,
					formatters: {
						RFC1738: function(t) {
							return e.call(t, i, "+")
						},
						RFC3986: function(t) {
							return String(t)
						}
					},
					RFC1738: "RFC1738",
					RFC3986: n
				}
			},
			55373: (t, e, i) => {
				"use strict";
				var n = i(98636),
					s = i(62642),
					o = i(74765);
				t.exports = {
					formats: o,
					parse: s,
					stringify: n
				}
			},
			62642: (t, e, i) => {
				"use strict";
				var n = i(37720),
					s = Object.prototype.hasOwnProperty,
					o = Array.isArray,
					r = {
						allowDots: !1,
						allowEmptyArrays: !1,
						allowPrototypes: !1,
						allowSparse: !1,
						arrayLimit: 20,
						charset: "utf-8",
						charsetSentinel: !1,
						comma: !1,
						decodeDotInKeys: !0,
						decoder: n.decode,
						delimiter: "&",
						depth: 5,
						duplicates: "combine",
						ignoreQueryPrefix: !1,
						interpretNumericEntities: !1,
						parameterLimit: 1e3,
						parseArrays: !0,
						plainObjects: !1,
						strictNullHandling: !1
					},
					a = function(t) {
						return t.replace(/&#(\d+);/g, (function(t, e) {
							return String.fromCharCode(parseInt(e, 10))
						}))
					},
					l = function(t, e) {
						return t && "string" == typeof t && e.comma && t.indexOf(",") > -1 ? t.split(",") : t
					},
					h = function(t, e, i, n) {
						if (t) {
							var o = i.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t,
								r = /(\[[^[\]]*])/g,
								a = i.depth > 0 && /(\[[^[\]]*])/.exec(o),
								h = a ? o.slice(0, a.index) : o,
								u = [];
							if (h) {
								if (!i.plainObjects && s.call(Object.prototype, h) && !i.allowPrototypes) return;
								u.push(h)
							}
							for (var c = 0; i.depth > 0 && null !== (a = r.exec(o)) && c < i.depth;) {
								if (c += 1, !i.plainObjects && s.call(Object.prototype, a[1].slice(1, -1)) && !i.allowPrototypes) return;
								u.push(a[1])
							}
							return a && u.push("[" + o.slice(a.index) + "]"),
								function(t, e, i, n) {
									for (var s = n ? e : l(e, i), o = t.length - 1; o >= 0; --o) {
										var r, a = t[o];
										if ("[]" === a && i.parseArrays) r = i.allowEmptyArrays && "" === s ? [] : [].concat(s);
										else {
											r = i.plainObjects ? Object.create(null) : {};
											var h = "[" === a.charAt(0) && "]" === a.charAt(a.length - 1) ? a.slice(1, -1) : a,
												u = i.decodeDotInKeys ? h.replace(/%2E/g, ".") : h,
												c = parseInt(u, 10);
											i.parseArrays || "" !== u ? !isNaN(c) && a !== u && String(c) === u && c >= 0 && i.parseArrays && c <= i.arrayLimit ? (r = [])[c] = s : "__proto__" !== u && (r[u] = s) : r = {
												0: s
											}
										}
										s = r
									}
									return s
								}(u, e, i, n)
						}
					};
				t.exports = function(t, e) {
					var i = function(t) {
						if (!t) return r;
						if (void 0 !== t.allowEmptyArrays && "boolean" != typeof t.allowEmptyArrays) throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
						if (void 0 !== t.decodeDotInKeys && "boolean" != typeof t.decodeDotInKeys) throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
						if (null !== t.decoder && void 0 !== t.decoder && "function" != typeof t.decoder) throw new TypeError("Decoder has to be a function.");
						if (void 0 !== t.charset && "utf-8" !== t.charset && "iso-8859-1" !== t.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
						var e = void 0 === t.charset ? r.charset : t.charset,
							i = void 0 === t.duplicates ? r.duplicates : t.duplicates;
						if ("combine" !== i && "first" !== i && "last" !== i) throw new TypeError("The duplicates option must be either combine, first, or last");
						return {
							allowDots: void 0 === t.allowDots ? !0 === t.decodeDotInKeys || r.allowDots : !!t.allowDots,
							allowEmptyArrays: "boolean" == typeof t.allowEmptyArrays ? !!t.allowEmptyArrays : r.allowEmptyArrays,
							allowPrototypes: "boolean" == typeof t.allowPrototypes ? t.allowPrototypes : r.allowPrototypes,
							allowSparse: "boolean" == typeof t.allowSparse ? t.allowSparse : r.allowSparse,
							arrayLimit: "number" == typeof t.arrayLimit ? t.arrayLimit : r.arrayLimit,
							charset: e,
							charsetSentinel: "boolean" == typeof t.charsetSentinel ? t.charsetSentinel : r.charsetSentinel,
							comma: "boolean" == typeof t.comma ? t.comma : r.comma,
							decodeDotInKeys: "boolean" == typeof t.decodeDotInKeys ? t.decodeDotInKeys : r.decodeDotInKeys,
							decoder: "function" == typeof t.decoder ? t.decoder : r.decoder,
							delimiter: "string" == typeof t.delimiter || n.isRegExp(t.delimiter) ? t.delimiter : r.delimiter,
							depth: "number" == typeof t.depth || !1 === t.depth ? +t.depth : r.depth,
							duplicates: i,
							ignoreQueryPrefix: !0 === t.ignoreQueryPrefix,
							interpretNumericEntities: "boolean" == typeof t.interpretNumericEntities ? t.interpretNumericEntities : r.interpretNumericEntities,
							parameterLimit: "number" == typeof t.parameterLimit ? t.parameterLimit : r.parameterLimit,
							parseArrays: !1 !== t.parseArrays,
							plainObjects: "boolean" == typeof t.plainObjects ? t.plainObjects : r.plainObjects,
							strictNullHandling: "boolean" == typeof t.strictNullHandling ? t.strictNullHandling : r.strictNullHandling
						}
					}(e);
					if ("" === t || null == t) return i.plainObjects ? Object.create(null) : {};
					for (var u = "string" == typeof t ? function(t, e) {
							var i, h = {
									__proto__: null
								},
								u = e.ignoreQueryPrefix ? t.replace(/^\?/, "") : t,
								c = e.parameterLimit === 1 / 0 ? void 0 : e.parameterLimit,
								d = u.split(e.delimiter, c),
								p = -1,
								_ = e.charset;
							if (e.charsetSentinel)
								for (i = 0; i < d.length; ++i) 0 === d[i].indexOf("utf8=") && ("utf8=%E2%9C%93" === d[i] ? _ = "utf-8" : "utf8=%26%2310003%3B" === d[i] && (_ = "iso-8859-1"), p = i, i = d.length);
							for (i = 0; i < d.length; ++i)
								if (i !== p) {
									var m, g, f = d[i],
										S = f.indexOf("]="),
										y = -1 === S ? f.indexOf("=") : S + 1; - 1 === y ? (m = e.decoder(f, r.decoder, _, "key"), g = e.strictNullHandling ? null : "") : (m = e.decoder(f.slice(0, y), r.decoder, _, "key"), g = n.maybeMap(l(f.slice(y + 1), e), (function(t) {
										return e.decoder(t, r.decoder, _, "value")
									}))), g && e.interpretNumericEntities && "iso-8859-1" === _ && (g = a(g)), f.indexOf("[]=") > -1 && (g = o(g) ? [g] : g);
									var v = s.call(h, m);
									v && "combine" === e.duplicates ? h[m] = n.combine(h[m], g) : v && "last" !== e.duplicates || (h[m] = g)
								} return h
						}(t, i) : t, c = i.plainObjects ? Object.create(null) : {}, d = Object.keys(u), p = 0; p < d.length; ++p) {
						var _ = d[p],
							m = h(_, u[_], i, "string" == typeof t);
						c = n.merge(c, m, i)
					}
					return !0 === i.allowSparse ? c : n.compact(c)
				}
			},
			98636: (t, e, i) => {
				"use strict";
				var n = i(920),
					s = i(37720),
					o = i(74765),
					r = Object.prototype.hasOwnProperty,
					a = {
						brackets: function(t) {
							return t + "[]"
						},
						comma: "comma",
						indices: function(t, e) {
							return t + "[" + e + "]"
						},
						repeat: function(t) {
							return t
						}
					},
					l = Array.isArray,
					h = Array.prototype.push,
					u = function(t, e) {
						h.apply(t, l(e) ? e : [e])
					},
					c = Date.prototype.toISOString,
					d = o.default,
					p = {
						addQueryPrefix: !1,
						allowDots: !1,
						allowEmptyArrays: !1,
						arrayFormat: "indices",
						charset: "utf-8",
						charsetSentinel: !1,
						delimiter: "&",
						encode: !0,
						encodeDotInKeys: !1,
						encoder: s.encode,
						encodeValuesOnly: !1,
						format: d,
						formatter: o.formatters[d],
						indices: !1,
						serializeDate: function(t) {
							return c.call(t)
						},
						skipNulls: !1,
						strictNullHandling: !1
					},
					_ = {},
					m = function t(e, i, o, r, a, h, c, d, m, g, f, S, y, v, T, E, b, A) {
						for (var P, I = e, w = A, L = 0, C = !1; void 0 !== (w = w.get(_)) && !C;) {
							var x = w.get(e);
							if (L += 1, void 0 !== x) {
								if (x === L) throw new RangeError("Cyclic object value");
								C = !0
							}
							void 0 === w.get(_) && (L = 0)
						}
						if ("function" == typeof g ? I = g(i, I) : I instanceof Date ? I = y(I) : "comma" === o && l(I) && (I = s.maybeMap(I, (function(t) {
								return t instanceof Date ? y(t) : t
							}))), null === I) {
							if (h) return m && !E ? m(i, p.encoder, b, "key", v) : i;
							I = ""
						}
						if ("string" == typeof(P = I) || "number" == typeof P || "boolean" == typeof P || "symbol" == typeof P || "bigint" == typeof P || s.isBuffer(I)) return m ? [T(E ? i : m(i, p.encoder, b, "key", v)) + "=" + T(m(I, p.encoder, b, "value", v))] : [T(i) + "=" + T(String(I))];
						var B, O = [];
						if (void 0 === I) return O;
						if ("comma" === o && l(I)) E && m && (I = s.maybeMap(I, m)), B = [{
							value: I.length > 0 ? I.join(",") || null : void 0
						}];
						else if (l(g)) B = g;
						else {
							var N = Object.keys(I);
							B = f ? N.sort(f) : N
						}
						var M = d ? i.replace(/\./g, "%2E") : i,
							R = r && l(I) && 1 === I.length ? M + "[]" : M;
						if (a && l(I) && 0 === I.length) return R + "[]";
						for (var D = 0; D < B.length; ++D) {
							var k = B[D],
								F = "object" == typeof k && void 0 !== k.value ? k.value : I[k];
							if (!c || null !== F) {
								var G = S && d ? k.replace(/\./g, "%2E") : k,
									U = l(I) ? "function" == typeof o ? o(R, G) : R : R + (S ? "." + G : "[" + G + "]");
								A.set(e, L);
								var W = n();
								W.set(_, A), u(O, t(F, U, o, r, a, h, c, d, "comma" === o && E && l(I) ? null : m, g, f, S, y, v, T, E, b, W))
							}
						}
						return O
					};
				t.exports = function(t, e) {
					var i, s = t,
						h = function(t) {
							if (!t) return p;
							if (void 0 !== t.allowEmptyArrays && "boolean" != typeof t.allowEmptyArrays) throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
							if (void 0 !== t.encodeDotInKeys && "boolean" != typeof t.encodeDotInKeys) throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
							if (null !== t.encoder && void 0 !== t.encoder && "function" != typeof t.encoder) throw new TypeError("Encoder has to be a function.");
							var e = t.charset || p.charset;
							if (void 0 !== t.charset && "utf-8" !== t.charset && "iso-8859-1" !== t.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
							var i = o.default;
							if (void 0 !== t.format) {
								if (!r.call(o.formatters, t.format)) throw new TypeError("Unknown format option provided.");
								i = t.format
							}
							var n, s = o.formatters[i],
								h = p.filter;
							if (("function" == typeof t.filter || l(t.filter)) && (h = t.filter), n = t.arrayFormat in a ? t.arrayFormat : "indices" in t ? t.indices ? "indices" : "repeat" : p.arrayFormat, "commaRoundTrip" in t && "boolean" != typeof t.commaRoundTrip) throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
							var u = void 0 === t.allowDots ? !0 === t.encodeDotInKeys || p.allowDots : !!t.allowDots;
							return {
								addQueryPrefix: "boolean" == typeof t.addQueryPrefix ? t.addQueryPrefix : p.addQueryPrefix,
								allowDots: u,
								allowEmptyArrays: "boolean" == typeof t.allowEmptyArrays ? !!t.allowEmptyArrays : p.allowEmptyArrays,
								arrayFormat: n,
								charset: e,
								charsetSentinel: "boolean" == typeof t.charsetSentinel ? t.charsetSentinel : p.charsetSentinel,
								commaRoundTrip: t.commaRoundTrip,
								delimiter: void 0 === t.delimiter ? p.delimiter : t.delimiter,
								encode: "boolean" == typeof t.encode ? t.encode : p.encode,
								encodeDotInKeys: "boolean" == typeof t.encodeDotInKeys ? t.encodeDotInKeys : p.encodeDotInKeys,
								encoder: "function" == typeof t.encoder ? t.encoder : p.encoder,
								encodeValuesOnly: "boolean" == typeof t.encodeValuesOnly ? t.encodeValuesOnly : p.encodeValuesOnly,
								filter: h,
								format: i,
								formatter: s,
								serializeDate: "function" == typeof t.serializeDate ? t.serializeDate : p.serializeDate,
								skipNulls: "boolean" == typeof t.skipNulls ? t.skipNulls : p.skipNulls,
								sort: "function" == typeof t.sort ? t.sort : null,
								strictNullHandling: "boolean" == typeof t.strictNullHandling ? t.strictNullHandling : p.strictNullHandling
							}
						}(e);
					"function" == typeof h.filter ? s = (0, h.filter)("", s) : l(h.filter) && (i = h.filter);
					var c = [];
					if ("object" != typeof s || null === s) return "";
					var d = a[h.arrayFormat],
						_ = "comma" === d && h.commaRoundTrip;
					i || (i = Object.keys(s)), h.sort && i.sort(h.sort);
					for (var g = n(), f = 0; f < i.length; ++f) {
						var S = i[f];
						h.skipNulls && null === s[S] || u(c, m(s[S], S, d, _, h.allowEmptyArrays, h.strictNullHandling, h.skipNulls, h.encodeDotInKeys, h.encode ? h.encoder : null, h.filter, h.sort, h.allowDots, h.serializeDate, h.format, h.formatter, h.encodeValuesOnly, h.charset, g))
					}
					var y = c.join(h.delimiter),
						v = !0 === h.addQueryPrefix ? "?" : "";
					return h.charsetSentinel && ("iso-8859-1" === h.charset ? v += "utf8=%26%2310003%3B&" : v += "utf8=%E2%9C%93&"), y.length > 0 ? v + y : ""
				}
			},
			37720: (t, e, i) => {
				"use strict";
				var n = i(74765),
					s = Object.prototype.hasOwnProperty,
					o = Array.isArray,
					r = function() {
						for (var t = [], e = 0; e < 256; ++e) t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
						return t
					}(),
					a = function(t, e) {
						for (var i = e && e.plainObjects ? Object.create(null) : {}, n = 0; n < t.length; ++n) void 0 !== t[n] && (i[n] = t[n]);
						return i
					};
				t.exports = {
					arrayToObject: a,
					assign: function(t, e) {
						return Object.keys(e).reduce((function(t, i) {
							return t[i] = e[i], t
						}), t)
					},
					combine: function(t, e) {
						return [].concat(t, e)
					},
					compact: function(t) {
						for (var e = [{
								obj: {
									o: t
								},
								prop: "o"
							}], i = [], n = 0; n < e.length; ++n)
							for (var s = e[n], r = s.obj[s.prop], a = Object.keys(r), l = 0; l < a.length; ++l) {
								var h = a[l],
									u = r[h];
								"object" == typeof u && null !== u && -1 === i.indexOf(u) && (e.push({
									obj: r,
									prop: h
								}), i.push(u))
							}
						return function(t) {
							for (; t.length > 1;) {
								var e = t.pop(),
									i = e.obj[e.prop];
								if (o(i)) {
									for (var n = [], s = 0; s < i.length; ++s) void 0 !== i[s] && n.push(i[s]);
									e.obj[e.prop] = n
								}
							}
						}(e), t
					},
					decode: function(t, e, i) {
						var n = t.replace(/\+/g, " ");
						if ("iso-8859-1" === i) return n.replace(/%[0-9a-f]{2}/gi, unescape);
						try {
							return decodeURIComponent(n)
						} catch (t) {
							return n
						}
					},
					encode: function(t, e, i, s, o) {
						if (0 === t.length) return t;
						var a = t;
						if ("symbol" == typeof t ? a = Symbol.prototype.toString.call(t) : "string" != typeof t && (a = String(t)), "iso-8859-1" === i) return escape(a).replace(/%u[0-9a-f]{4}/gi, (function(t) {
							return "%26%23" + parseInt(t.slice(2), 16) + "%3B"
						}));
						for (var l = "", h = 0; h < a.length; ++h) {
							var u = a.charCodeAt(h);
							45 === u || 46 === u || 95 === u || 126 === u || u >= 48 && u <= 57 || u >= 65 && u <= 90 || u >= 97 && u <= 122 || o === n.RFC1738 && (40 === u || 41 === u) ? l += a.charAt(h) : u < 128 ? l += r[u] : u < 2048 ? l += r[192 | u >> 6] + r[128 | 63 & u] : u < 55296 || u >= 57344 ? l += r[224 | u >> 12] + r[128 | u >> 6 & 63] + r[128 | 63 & u] : (h += 1, u = 65536 + ((1023 & u) << 10 | 1023 & a.charCodeAt(h)), l += r[240 | u >> 18] + r[128 | u >> 12 & 63] + r[128 | u >> 6 & 63] + r[128 | 63 & u])
						}
						return l
					},
					isBuffer: function(t) {
						return !(!t || "object" != typeof t || !(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t)))
					},
					isRegExp: function(t) {
						return "[object RegExp]" === Object.prototype.toString.call(t)
					},
					maybeMap: function(t, e) {
						if (o(t)) {
							for (var i = [], n = 0; n < t.length; n += 1) i.push(e(t[n]));
							return i
						}
						return e(t)
					},
					merge: function t(e, i, n) {
						if (!i) return e;
						if ("object" != typeof i) {
							if (o(e)) e.push(i);
							else {
								if (!e || "object" != typeof e) return [e, i];
								(n && (n.plainObjects || n.allowPrototypes) || !s.call(Object.prototype, i)) && (e[i] = !0)
							}
							return e
						}
						if (!e || "object" != typeof e) return [e].concat(i);
						var r = e;
						return o(e) && !o(i) && (r = a(e, n)), o(e) && o(i) ? (i.forEach((function(i, o) {
							if (s.call(e, o)) {
								var r = e[o];
								r && "object" == typeof r && i && "object" == typeof i ? e[o] = t(r, i, n) : e.push(i)
							} else e[o] = i
						})), e) : Object.keys(i).reduce((function(e, o) {
							var r = i[o];
							return s.call(e, o) ? e[o] = t(e[o], r, n) : e[o] = r, e
						}), r)
					}
				}
			},
			96897: (t, e, i) => {
				"use strict";
				var n = i(70453),
					s = i(30041),
					o = i(30592)(),
					r = i(75795),
					a = i(69675),
					l = n("%Math.floor%");
				t.exports = function(t, e) {
					if ("function" != typeof t) throw new a("`fn` is not a function");
					if ("number" != typeof e || e < 0 || e > 4294967295 || l(e) !== e) throw new a("`length` must be a positive 32-bit integer");
					var i = arguments.length > 2 && !!arguments[2],
						n = !0,
						h = !0;
					if ("length" in t && r) {
						var u = r(t, "length");
						u && !u.configurable && (n = !1), u && !u.writable && (h = !1)
					}
					return (n || h || !i) && (o ? s(t, "length", e, !0, !0) : s(t, "length", e)), t
				}
			},
			920: (t, e, i) => {
				"use strict";
				var n = i(70453),
					s = i(38075),
					o = i(58859),
					r = i(69675),
					a = n("%WeakMap%", !0),
					l = n("%Map%", !0),
					h = s("WeakMap.prototype.get", !0),
					u = s("WeakMap.prototype.set", !0),
					c = s("WeakMap.prototype.has", !0),
					d = s("Map.prototype.get", !0),
					p = s("Map.prototype.set", !0),
					_ = s("Map.prototype.has", !0),
					m = function(t, e) {
						for (var i, n = t; null !== (i = n.next); n = i)
							if (i.key === e) return n.next = i.next, i.next = t.next, t.next = i, i
					};
				t.exports = function() {
					var t, e, i, n = {
						assert: function(t) {
							if (!n.has(t)) throw new r("Side channel does not contain " + o(t))
						},
						get: function(n) {
							if (a && n && ("object" == typeof n || "function" == typeof n)) {
								if (t) return h(t, n)
							} else if (l) {
								if (e) return d(e, n)
							} else if (i) return function(t, e) {
								var i = m(t, e);
								return i && i.value
							}(i, n)
						},
						has: function(n) {
							if (a && n && ("object" == typeof n || "function" == typeof n)) {
								if (t) return c(t, n)
							} else if (l) {
								if (e) return _(e, n)
							} else if (i) return function(t, e) {
								return !!m(t, e)
							}(i, n);
							return !1
						},
						set: function(n, s) {
							a && n && ("object" == typeof n || "function" == typeof n) ? (t || (t = new a), u(t, n, s)) : l ? (e || (e = new l), p(e, n, s)) : (i || (i = {
								key: {},
								next: null
							}), function(t, e, i) {
								var n = m(t, e);
								n ? n.value = i : t.next = {
									key: e,
									next: t.next,
									value: i
								}
							}(i, n, s))
						}
					};
					return n
				}
			},
			96825: (t, e, i) => {
				"use strict";
				i.r(e), i.d(e, {
					default: () => f
				});
				var n = i(85072),
					s = i.n(n),
					o = i(97825),
					r = i.n(o),
					a = i(77659),
					l = i.n(a),
					h = i(55056),
					u = i.n(h),
					c = i(10540),
					d = i.n(c),
					p = i(41113),
					_ = i.n(p),
					m = i(12610),
					g = {};
				g.styleTagTransform = _(), g.setAttributes = u(), g.insert = l().bind(null, "head"), g.domAPI = r(), g.insertStyleElement = d(), s()(m.A, g);
				const f = m.A && m.A.locals ? m.A.locals : void 0
			},
			97409: (t, e, i) => {
				"use strict";
				i.r(e), i.d(e, {
					default: () => f
				});
				var n = i(85072),
					s = i.n(n),
					o = i(97825),
					r = i.n(o),
					a = i(77659),
					l = i.n(a),
					h = i(55056),
					u = i.n(h),
					c = i(10540),
					d = i.n(c),
					p = i(41113),
					_ = i.n(p),
					m = i(34590),
					g = {};
				g.styleTagTransform = _(), g.setAttributes = u(), g.insert = l().bind(null, "head"), g.domAPI = r(), g.insertStyleElement = d(), s()(m.A, g);
				const f = m.A && m.A.locals ? m.A.locals : void 0
			},
			3950: (t, e, i) => {
				"use strict";
				i.r(e), i.d(e, {
					default: () => f
				});
				var n = i(85072),
					s = i.n(n),
					o = i(97825),
					r = i.n(o),
					a = i(77659),
					l = i.n(a),
					h = i(55056),
					u = i.n(h),
					c = i(10540),
					d = i.n(c),
					p = i(41113),
					_ = i.n(p),
					m = i(23917),
					g = {};
				g.styleTagTransform = _(), g.setAttributes = u(), g.insert = l().bind(null, "head"), g.domAPI = r(), g.insertStyleElement = d(), s()(m.A, g);
				const f = m.A && m.A.locals ? m.A.locals : void 0
			},
			93361: (t, e, i) => {
				"use strict";
				i.r(e), i.d(e, {
					default: () => f
				});
				var n = i(85072),
					s = i.n(n),
					o = i(97825),
					r = i.n(o),
					a = i(77659),
					l = i.n(a),
					h = i(55056),
					u = i.n(h),
					c = i(10540),
					d = i.n(c),
					p = i(41113),
					_ = i.n(p),
					m = i(98068),
					g = {};
				g.styleTagTransform = _(), g.setAttributes = u(), g.insert = l().bind(null, "head"), g.domAPI = r(), g.insertStyleElement = d(), s()(m.A, g);
				const f = m.A && m.A.locals ? m.A.locals : void 0
			},
			85072: t => {
				"use strict";
				var e = [];

				function i(t) {
					for (var i = -1, n = 0; n < e.length; n++)
						if (e[n].identifier === t) {
							i = n;
							break
						} return i
				}

				function n(t, n) {
					for (var o = {}, r = [], a = 0; a < t.length; a++) {
						var l = t[a],
							h = n.base ? l[0] + n.base : l[0],
							u = o[h] || 0,
							c = "".concat(h, " ").concat(u);
						o[h] = u + 1;
						var d = i(c),
							p = {
								css: l[1],
								media: l[2],
								sourceMap: l[3],
								supports: l[4],
								layer: l[5]
							};
						if (-1 !== d) e[d].references++, e[d].updater(p);
						else {
							var _ = s(p, n);
							n.byIndex = a, e.splice(a, 0, {
								identifier: c,
								updater: _,
								references: 1
							})
						}
						r.push(c)
					}
					return r
				}

				function s(t, e) {
					var i = e.domAPI(e);
					return i.update(t),
						function(e) {
							if (e) {
								if (e.css === t.css && e.media === t.media && e.sourceMap === t.sourceMap && e.supports === t.supports && e.layer === t.layer) return;
								i.update(t = e)
							} else i.remove()
						}
				}
				t.exports = function(t, s) {
					var o = n(t = t || [], s = s || {});
					return function(t) {
						t = t || [];
						for (var r = 0; r < o.length; r++) {
							var a = i(o[r]);
							e[a].references--
						}
						for (var l = n(t, s), h = 0; h < o.length; h++) {
							var u = i(o[h]);
							0 === e[u].references && (e[u].updater(), e.splice(u, 1))
						}
						o = l
					}
				}
			},
			77659: t => {
				"use strict";
				var e = {};
				t.exports = function(t, i) {
					var n = function(t) {
						if (void 0 === e[t]) {
							var i = document.querySelector(t);
							if (window.HTMLIFrameElement && i instanceof window.HTMLIFrameElement) try {
								i = i.contentDocument.head
							} catch (t) {
								i = null
							}
							e[t] = i
						}
						return e[t]
					}(t);
					if (!n) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
					n.appendChild(i)
				}
			},
			10540: t => {
				"use strict";
				t.exports = function(t) {
					var e = document.createElement("style");
					return t.setAttributes(e, t.attributes), t.insert(e, t.options), e
				}
			},
			55056: (t, e, i) => {
				"use strict";
				t.exports = function(t) {
					var e = i.nc;
					e && t.setAttribute("nonce", e)
				}
			},
			97825: t => {
				"use strict";
				t.exports = function(t) {
					if ("undefined" == typeof document) return {
						update: function() {},
						remove: function() {}
					};
					var e = t.insertStyleElement(t);
					return {
						update: function(i) {
							! function(t, e, i) {
								var n = "";
								i.supports && (n += "@supports (".concat(i.supports, ") {")), i.media && (n += "@media ".concat(i.media, " {"));
								var s = void 0 !== i.layer;
								s && (n += "@layer".concat(i.layer.length > 0 ? " ".concat(i.layer) : "", " {")), n += i.css, s && (n += "}"), i.media && (n += "}"), i.supports && (n += "}");
								var o = i.sourceMap;
								o && "undefined" != typeof btoa && (n += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(o)))), " */")), e.styleTagTransform(n, t, e.options)
							}(e, t, i)
						},
						remove: function() {
							! function(t) {
								if (null === t.parentNode) return !1;
								t.parentNode.removeChild(t)
							}(e)
						}
					}
				}
			},
			41113: t => {
				"use strict";
				t.exports = function(t, e) {
					if (e.styleSheet) e.styleSheet.cssText = t;
					else {
						for (; e.firstChild;) e.removeChild(e.firstChild);
						e.appendChild(document.createTextNode(t))
					}
				}
			},
			89787: function(t, e, i) {
				"use strict";
				var n = this && this.__createBinding || (Object.create ? function(t, e, i, n) {
						void 0 === n && (n = i);
						var s = Object.getOwnPropertyDescriptor(e, i);
						s && !("get" in s ? !e.__esModule : s.writable || s.configurable) || (s = {
							enumerable: !0,
							get: function() {
								return e[i]
							}
						}), Object.defineProperty(t, n, s)
					} : function(t, e, i, n) {
						void 0 === n && (n = i), t[n] = e[i]
					}),
					s = this && this.__setModuleDefault || (Object.create ? function(t, e) {
						Object.defineProperty(t, "default", {
							enumerable: !0,
							value: e
						})
					} : function(t, e) {
						t.default = e
					}),
					o = this && this.__importStar || function(t) {
						if (t && t.__esModule) return t;
						var e = {};
						if (null != t)
							for (var i in t) "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
						return s(e, t), e
					};
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), Promise.resolve().then((() => o(i(82859))));
				const r = o(i(82859));
				window.PIXI = r, i(77323);
				const a = i(91980),
					l = i(22088),
					h = i(2425),
					u = i(1394),
					c = i(68610),
					d = i(37881),
					p = i(21802);
				window.NolimitLauncher = a.NolimitLauncher.instance;
				const _ = i(9661);
				a.NolimitLauncher.instance.launch([new u.Leprechaun, new l.SlotKeypad, new h.NolimitPromotionPlugin(new _.GaelicGoldPromoPanelConfig), new c.NolimitGameIntroPlugin(new d.LeprechaunIntroConfig), new p.NolimitSlotAudio])
			},
			9661: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.GaelicGoldPromoPanelConfig = void 0;
				const n = i(71855),
					s = i(88458),
					o = i(14108),
					r = i(1394),
					a = i(4621),
					l = i(4773),
					h = i(23110),
					u = i(63114),
					c = i(56005),
					d = i(57244);
				e.GaelicGoldPromoPanelConfig = class {
					constructor() {}
					getActionSpinOptions() {
						return {
							gameName: "GaelicGold",
							hasActionSpin: !0,
							graphics: {
								backgroundTextureName: a.LeprechaunGameAssets.MAIN_GAME_BACKGROUND
							},
							automaticPickGame: {
								header: () => r.Leprechaun.api.translations.translate("Note: Features will be auto-selected during bonus trigger."),
								optionSelection: t => {
									let e = [];
									for (let i = 0; i < t.pickedIndexesAfter.length; i++) 0 == t.pickedIndexesAfter[i] && e.push(i);
									return e = d.MathHelper.shuffleArray(e), e[0]
								},
								type: s.ASBonusPickOptions.PICK_MODE,
								pickNeededForModes: [c.LeprechaunGameMode.FS_PICK],
								pickNeededForBuyFeatures: []
							},
							getParsedData: (t, e, i) => ({
								totalWin: parseFloat(t.accumulatedRoundWin),
								totalSpinWinnings: this.getWin(t, e, i),
								wasFeatureBuy: t.wasFeatureBuy,
								freeSpinTriggeredThisSpin: this.isFreeSpinTriggered(t),
								isBigWin: this.isBigWin(t),
								winType: s.WINTYPE.NORMAL,
								featureName: this.getFeatureName(t),
								isRoundComplete: this.isRoundComplete(t),
								isBonusEnd: this.isBonusEnd(t),
								isWinCapHit: !1
							})
						}
					}
					onActionSpinPlaySound(t) {
						t == o.ActionSpinSound.WIN ? h.SlotGame.sound.playEffect(l.LeprechaunSoundConfig.instance.AS_WIN) : t == o.ActionSpinSound.BIG_WIN && h.SlotGame.sound.playEffect(l.LeprechaunSoundConfig.instance.AS_WIN_BIG)
					}
					isBigWin(t) {
						const e = parseFloat(t.totalSpinWinnings),
							i = parseFloat(t.playedBetValue);
						let s = n.Helper.ceilToDecimals(e / i, 2);
						if (t.wasFeatureBuy) {
							const o = u.LeprechaunGameModuleConfig.featurePrice.getBuyFeaturePrice(i, t.wasFeatureBuy);
							return s = n.Helper.ceilToDecimals(e / o, 2), s >= 1
						}
						return s >= 15
					}
					getWin(t, e, i) {
						return parseFloat(t.totalSpinWinnings)
					}
					getFeatureName(t) {
						return t.nextMode == c.LeprechaunGameMode.FREESPIN || t.mode == c.LeprechaunGameMode.FREESPIN || t.nextMode == c.LeprechaunGameMode.FS_PICK || t.mode == c.LeprechaunGameMode.FS_PICK ? "RAINBOW SPINS" : ""
					}
					isLegalStopOnBonusMode(t) {
						return t.mode == c.LeprechaunGameMode.NORMAL && t.nextMode == c.LeprechaunGameMode.FS_PICK
					}
					isFreeSpinTriggered(t) {
						return t.mode == c.LeprechaunGameMode.NORMAL && t.nextMode == c.LeprechaunGameMode.FS_PICK
					}
					isRoundComplete(t) {
						return t.mode != c.LeprechaunGameMode.FS_PICK
					}
					isBonusEnd(t) {
						return t.mode === c.LeprechaunGameMode.FREESPIN && t.nextMode === c.LeprechaunGameMode.NORMAL
					}
				}
			},
			1394: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Leprechaun = void 0;
				const n = i(23110),
					s = i(63114),
					o = i(99069);
				class r extends n.SlotGame {
					constructor() {
						super(s.LeprechaunGameModuleConfig.instance)
					}
					createWinFieldController() {
						return new o.REWinFieldController
					}
					getNoWinGameData() {
						return {
							reels: [
								["M3", "M5", "L4", "L2", "M1", "M4", "L1"],
								["L2", "M3", "L3", "L1", "M5", "L3", "L2"],
								["M3", "L3", "M1", "L1", "L3", "L2", "M4"]
							],
							evaluatedArea: [
								["L4", "L2", "M1"],
								["L3", "L1", "M5"],
								["M1", "L1", "L3"]
							],
							betLineWins: [],
							totalBetLineSpinWinnings: 0,
							totalSpinWinnings: 0,
							totalSpinWinningsNonMultiplied: 0,
							accumulatedRoundWin: 0,
							playedBetValue: 100,
							nearWinReels: [!1, !1, !1],
							reelsNextSpin: "BASE_REELSET",
							mode: "NORMAL",
							nextMode: "NORMAL",
							bonusFeatureTriggered: !1,
							playerSelection: -1,
							doReelNudge: [!1, !1, !1],
							extraSymbolsOnTop: [
								["L1", "L3"],
								["L1", "L3"],
								["L1", "L3"]
							],
							multiplierOnReel: [0, 0, 0],
							numberOfFreespinsPlayed: 0,
							freespinsLeft: 0,
							freespinMultiplier: 1,
							freespinNbrOfLines: 5,
							pickedIndexesBefore: [!1, !1, !1, !1, !1, !1, !1, !1, !1],
							pickedIndexesAfter: [!1, !1, !1, !1, !1, !1, !1, !1, !1],
							revealedBefore: ["", "", "", "", "", "", "", "", ""],
							revealedAfter: ["", "", "", "", "", "", "", "", ""],
							thisPickedIndex: -1,
							thisRevealedPicked: "",
							pickedExtraSpins: 0,
							pickedExtraLines: 0,
							pickedExtraMultiplier: 0,
							addedNumberOfFreespins: [0, 0, 0],
							addedMultiplier: [0, 0, 0],
							addedLines: [0, 0],
							possibleReveals: [],
							featureBuyTimesBetValue: [{
								name: "FREESPIN",
								type: "FREESPIN",
								price: 50
							}],
							featureBet: !1,
							wasFeatureBuy: !1
						}
					}
				}
				e.Leprechaun = r
			},
			92829: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunFontConfig = void 0;
				const n = i(77616);
				class s {}
				e.LeprechaunFontConfig = s, s.FONTS = {
					OpenSans_Regular: {
						fontFamily: "Open Sans",
						src: [{
							url: "fonts/OpenSans-Regular.woff2",
							format: n.FontType.WOFF2
						}, {
							url: "fonts/OpenSans-Regular.woff",
							format: n.FontType.WOFF
						}, {
							url: "fonts/OpenSans-Regular.ttf",
							format: n.FontType.TTF
						}],
						fontWeight: n.FontWeight.NORMAL,
						fontStyle: n.FontStyle.NORMAL
					},
					OpenSans_Light: {
						fontFamily: "Open Sans",
						src: [{
							url: "fonts/OpenSans-Light.woff2",
							format: n.FontType.WOFF2
						}, {
							url: "fonts/OpenSans-Light.woff",
							format: n.FontType.WOFF
						}, {
							url: "fonts/OpenSans-Light.ttf",
							format: n.FontType.TTF
						}],
						fontWeight: n.FontWeight.LIGHT,
						fontStyle: n.FontStyle.NORMAL
					},
					OpenSans_Bold: {
						fontFamily: "Open Sans",
						src: [{
							url: "fonts/OpenSans-Bold.woff2",
							format: n.FontType.WOFF2
						}, {
							url: "fonts/OpenSans-Bold.woff",
							format: n.FontType.WOFF
						}, {
							url: "fonts/OpenSans-Bold.ttf",
							format: n.FontType.TTF
						}],
						fontWeight: n.FontWeight.BOLD,
						fontStyle: n.FontStyle.NORMAL
					},
					OpenSans_ExtraBold: {
						fontFamily: "Open Sans",
						src: [{
							url: "fonts/OpenSans-ExtraBold.woff2",
							format: n.FontType.WOFF2
						}, {
							url: "fonts/OpenSans-ExtraBold.woff",
							format: n.FontType.WOFF
						}, {
							url: "fonts/OpenSans-ExtraBold.ttf",
							format: n.FontType.TTF
						}],
						fontWeight: n.FontWeight.EXTRA_BOLD,
						fontStyle: n.FontStyle.NORMAL
					},
					OpenSans_ExtraBoldItalic: {
						fontFamily: "Open Sans",
						src: [{
							url: "fonts/OpenSans-ExtraBoldItalic.woff2",
							format: n.FontType.WOFF2
						}, {
							url: "fonts/OpenSans-ExtraBoldItalic.woff",
							format: n.FontType.WOFF
						}, {
							url: "fonts/OpenSans-ExtraBoldItalic.ttf",
							format: n.FontType.TTF
						}],
						fontWeight: n.FontWeight.EXTRA_BOLD,
						fontStyle: n.FontStyle.ITALIC
					}
				}
			},
			4621: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunGameAssets = void 0;
				const n = i(88424),
					s = i(88240),
					o = i(54707),
					r = i(90394),
					a = i(87691);
				class l {
					static getSymbolStateTexturePath(t, e = null) {
						return null == e || "" == e ? t + "/" + t : t + "/" + t + "_" + e
					}
					static getSymbolStateTextures(t, e = null) {
						return s.GameResources.getTextures(l.getSymbolStateTexturePath(t, e))
					}
				}
				e.LeprechaunGameAssets = l, l.INTRO_BACKGROUND = "resources/images/intro/Intro_BG.jpg", l.INTRO_LOGO = "resources/images/intro/introLogo.png", l.MAIN_GAME_BACKGROUND = l.INTRO_BACKGROUND, l.FREESPIN_BACKGROUND = l.INTRO_BACKGROUND, l.PICK_AND_CLICK_BACKGROUND = "pncGrayMultSmall", l.MINI_PAYTABLE_PORTRAIT = "miniPayTableBGPortrait", l.MINI_PAYTABLE_LANSCAPE = "miniPayTableBGLandscape", l.RESOURCES_GROUPS = {
					intro: [{
						name: "fonts",
						autoLoad: [n.AssetQualityLevel.HIGH],
						assets: [new r.BitmapFontAsset("numbersOpenSans800", "fonts/bitmapfonts/NumbersOpenSans800.fnt"), new r.BitmapFontAsset("numbersWinCountUp", "fonts/bitmapfonts/NumbersWinCountUp.fnt"), new r.BitmapFontAsset("numbersWinMultiplier", "fonts/bitmapfonts/NumbersWinMultiplier.fnt")]
					}],
					main: [{
						name: "mainJpegHighQuality",
						autoLoad: [n.AssetQualityLevel.HIGH],
						assets: [new o.TextureAsset("mainHighQuality0", "sheets/mainHighQuality/mainHighQuality0.json")],
						animations: {
							wildWriteOnText: "WildText_WriteOn/WildText_",
							bigWinText0: "bigwin/BW_1",
							bigWinText1: "bigwin/BW_2",
							bigWinText2: "bigwin/BW_3",
							X1: "Multiplier/x1",
							X2: "Multiplier/x2",
							X3: "Multiplier/x3",
							X4: "Multiplier/x4",
							X5: "Multiplier/x5",
							X1_blur: "Multiplier/x1_blur",
							X2_blur: "Multiplier/x2_blur",
							X3_blur: "Multiplier/x3_blur",
							X4_blur: "Multiplier/x4_blur",
							X5_blur: "Multiplier/x5_blur"
						}
					}, {
						name: "bonusAnimationHighQuality",
						autoLoad: [n.AssetQualityLevel.HIGH],
						assets: [new o.TextureAsset("bonusAnimationHighQuality0", "sheets/bonusAnimationHighQuality/bonusAnimationHighQuality0.json")],
						animations: {
							bonusLand: "Bonus_Land_15FPS/Bonus_Land_",
							bonusFloating: "BonusFloating15FPS/BonusFloating_"
						}
					}, {
						name: "mainYellow",
						autoLoad: [n.AssetQualityLevel.HIGH],
						assets: [new o.TextureAsset("mainYellow0", "sheets/mainYellow/mainYellow0.json")],
						animations: {
							reelFrame: "Reel_frame",
							bigWinCoin2: "coinGold/CoinGold_",
							wildBg: "W"
						}
					}, {
						name: "main",
						assets: [new o.TextureAsset("main0", "sheets/main/main0.json")],
						animations: {
							foreground: "Foreground"
						}
					}, {
						name: "mainSingleColor",
						assets: [new o.TextureAsset("mainSingleColor0", "sheets/mainSingleColor/mainSingleColor0.json")],
						animations: {
							reelBackground: "Game_Reels",
							cloud0: "Clouds/BG_Cloud1",
							cloud1: "Clouds/BG_Cloud2",
							cloud2: "Clouds/BG_Cloud3",
							bigWinCoin1: "bigwin/coinSilver/CoinSilver_"
						}
					}, {
						name: "mainJpegHighQuality",
						autoLoad: [n.AssetQualityLevel.HIGH],
						assets: [new o.TextureAsset("miniPayTableBGPortrait", "images/miniPaytable/PaytableBG_portrait.jpg"), new o.TextureAsset("miniPayTableBGLandscape", "images/miniPaytable/PaytableBG_Landscape.jpg")]
					}, {
						name: "mainJpeg",
						assets: [new o.TextureAsset("mainJpeg0", "sheets/mainJpeg/mainJpeg0.json"), new o.TextureAsset("mainJpeg1", "sheets/mainJpeg/mainJpeg1.json"), new o.TextureAsset("mainJpeg2", "sheets/mainJpeg/mainJpeg2.json"), new o.TextureAsset("mainJpeg3", "sheets/mainJpeg/mainJpeg3.json"), new o.TextureAsset("mainJpeg4", "sheets/mainJpeg/mainJpeg4.json"), new o.TextureAsset("mainJpeg5", "sheets/mainJpeg/mainJpeg5.json"), new o.TextureAsset("mainJpeg6", "sheets/mainJpeg/mainJpeg6.json"), new o.TextureAsset("mainJpeg7", "sheets/mainJpeg/mainJpeg7.json")],
						animations: {
							rainbowBonusIdle: "BonusIdle/Bonus_Idle_00",
							raindrop: "raindrop",
							bgSky: "Background/BG_Sky_halfSize",
							bgRipples0: "Background/ShoreRipples/bg_ripples_1",
							bgRipples1: "Background/ShoreRipples/bg_ripples_2",
							bgRipples2: "Background/ShoreRipples/bg_ripples_3",
							wildNudgeBg: "W_RainbowFrame/W_RainbowFrame_",
							wildNudgeSparkles: "nudge_VFX/nudge_VFX_",
							rainbowBetLine: "RainbowLine/RainbowLine_",
							splashRing: "SplashRing",
							rainbowTail: "RainbowHighlight",
							defaultParticle: "Default-Particle_2",
							symIdleAnimation: "FX_Symbol_Idle/FX_Sym_Idle_",
							winSplash: "FX_Explosion/FX_Explosion_",
							winStar: "Win_FX/Win_FX_StarSplash_",
							hotZone: "FX_HotZone_A/FX_HotZone_A_",
							hotZoneWin: "FX_HotZone/FX_HotZone_",
							reelExcitement: "Reel_Excitement/Reel_Excitement_",
							bigWinTextStar: "FX_BW_Stars/FX_BW_Stars_",
							bigWinTextEffect0: "FX_BW1/FX_BW_1_000",
							bigWinTextEffect1: "FX_BW2/FX_BW_2_000",
							bigWinTextEffect2: "FX_BW3/FX_BW_3_000",
							symWinBgAnimation: "FX_Sym_Win/FX_Sym_Win_"
						}
					}, {
						name: "mainRainbow",
						assets: [new o.TextureAsset("mainRainbow0", "sheets/mainRainbow/mainRainbow0.json")],
						animations: {
							pncRainbow: "rainbow",
							bgRainbow: "BG_Rainbow_Screen"
						}
					}, {
						name: "pncJpeg",
						assets: [new o.TextureAsset("pncJpeg0", "sheets/pncJpeg/pncJpeg0.json")],
						animations: {
							pncGrayMultSmall: "BG/graymultsmall",
							pncCircle: "Circle",
							highCoinGlow: "HighCoinGlow",
							pncStoneGlow: "stoneglow",
							pncSelectring: "SelectRing/selectring_",
							pncSparkleBurst: "sparkleburst/sparkleburst_"
						}
					}, {
						name: "pncHighQuality",
						assets: [new o.TextureAsset("pncHighQuality0", "sheets/pncHighQuality/pncHighQuality0.json")],
						animations: {
							pncStartCoin: "StartCoin",
							pncRainbowIcon: "rainbowIcon",
							pncSpinsIcon: "SpinsIcon"
						}
					}, {
						name: "pncCoins",
						assets: [new o.TextureAsset("pncCoins0", "sheets/pncCoins/pncCoins0.json")],
						animations: {
							pncCoinFlip: "Coin/CoinFlip/CoinFlip_",
							pncCircleCollected: "Coin/CoinFlip/CoinFlip_00000",
							pncStoneBlue: "Stones/stoneBlue",
							pncStoneYellow: "Stones/stoneyellow",
							pncStoneTurquoise: "Stones/stoneturquoise",
							pncStoneRed: "Stones/stonered",
							pncStonePurple: "Stones/stonepurple",
							pncStonePink: "Stones/stonepink",
							pncStoneOrange: "Stones/stoneorange",
							pncStoneGreen: "Stones/stonegreen",
							pncStoneGray: "Stones/stonegray"
						}
					}, {
						name: "betlineNumber",
						assets: [new o.TextureAsset("betlineNumber0", "sheets/betlineNumber/betlineNumber0.json")],
						animations: {
							bigWinCoin0: "bigwin/coinCopper/CoinCopper_",
							cloverBurst: "CloverBurstFX/CloverBurstFX_",
							multiplierClover: "MultiplierClover",
							betlineNumber1Left: "LeftSide/1_Left",
							betlineNumber2Left: "LeftSide/2_Left",
							betlineNumber3Left: "LeftSide/3_Left",
							betlineNumber4Left: "LeftSide/4_Left",
							betlineNumber5Left: "LeftSide/5_Left",
							betlineNumber1LeftWin: "LeftSide/1_Left_Win",
							betlineNumber2LeftWin: "LeftSide/2_Left_Win",
							betlineNumber3LeftWin: "LeftSide/3_Left_Win",
							betlineNumber4LeftWin: "LeftSide/4_Left_Win",
							betlineNumber5LeftWin: "LeftSide/5_Left_Win",
							betlineNumber1Right: "RightSide/1_Right",
							betlineNumber2Right: "RightSide/2_Right",
							betlineNumber3Right: "RightSide/3_Right",
							betlineNumber4Right: "RightSide/4_Right",
							betlineNumber5Right: "RightSide/5_Right",
							betlineNumber1RightWin: "RightSide/1_Right_Win",
							betlineNumber2RightWin: "RightSide/2_Right_Win",
							betlineNumber3RightWin: "RightSide/3_Right_Win",
							betlineNumber4RightWin: "RightSide/4_Right_Win",
							betlineNumber5RightWin: "RightSide/5_Right_Win",
							betline_1: "Betline/Betline_1",
							betline_2: "Betline/Betline_2",
							betline_3: "Betline/Betline_3",
							betline_4: "Betline/Betline_4",
							betline_5: "Betline/Betline_5",
							betlineNumber6: "6",
							betlineNumber6Win: "6_Win",
							betlineNumber7: "7",
							betlineNumber7Win: "7_Win",
							betlineNumber8: "8",
							betlineNumber8Win: "8_Win",
							betlineNumber9: "9",
							betlineNumber9Win: "9_Win"
						}
					}, {
						name: "spine",
						assets: [new a.SpineAsset("wLand", "spine/Wild/W_Land.json"), new a.SpineAsset("leprechaunPick", "spine/LeprechaunPick/LeprechaunPick.json")]
					}, {
						name: "symbols",
						autoLoad: [n.AssetQualityLevel.HIGH],
						assets: [new o.TextureAsset("symbols0", "sheets/symbols/symbols0.json")],
						animations: {
							miniPayTableM1: "miniPaytable/paytable_sym_M1",
							miniPayTableM2: "miniPaytable/paytable_sym_M2",
							miniPayTableM3: "miniPaytable/paytable_sym_M3",
							miniPayTableM4: "miniPaytable/paytable_sym_M4",
							miniPayTableM5: "miniPaytable/paytable_sym_M5",
							miniPayTableL1: "miniPaytable/paytable_sym_L"
						}
					}]
				}
			},
			48002: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunGameConfig = void 0;
				const n = i(88240),
					s = i(89951),
					o = i(42226),
					r = i(13006),
					a = i(4621);
				class l {
					constructor() {
						if (this.BROWSER_FPS = 30, this.GAME_WIDTH = 1280, this.GAME_HEIGHT = 720, this.DEFAULT_LAYER_SCALE_OPTION = {
								desktop: {
									landscape: s.LayerScaleOption.FIT_WINDOW
								},
								mobile: {
									landscape: s.LayerScaleOption.FIT_WINDOW,
									portrait: s.LayerScaleOption.REELS_FIT_WINDOW
								}
							}, this.LAYERS = {
								BACKGROUND: {
									name: "background"
								},
								BACKGROUND_ELEMENTS: {
									name: "backgroundElements"
								},
								BACKGROUND_ANIMATION: {
									name: "backgroundAnimation"
								},
								REEL_BACKGROUND: {
									name: "reelBackground"
								},
								HOTZONE: {
									name: "hotzone"
								},
								SYMBOLS: {
									name: "symbols"
								},
								REEL_FRAME: {
									name: "reelFrame"
								},
								LOGO: {
									name: "logo"
								},
								SYMBOL_BACKGROUND: {
									name: "symbolBackground"
								},
								REEL_ATTENTION: {
									name: "reelAttention"
								},
								SYMBOL_WIN_ANIMATION: {
									name: "symbolWinAnimation"
								},
								BET_LINES: {
									name: "betLines"
								},
								BET_LINE_NUMBERS: {
									name: "betline_Numbers"
								},
								WIN_PRESENTATIONS: {
									name: "winPresentations"
								},
								FOREGROUND: {
									name: "foreground"
								},
								MULTIPLIER: {
									name: "multiplier"
								},
								BIG_WIN_FOUNTAIN: {
									name: "bigWinFountain"
								},
								BIG_WIN: {
									name: "bigWin"
								},
								WIN_COUNT_UP: {
									name: "winCountUp"
								},
								FREESPIN_INTRO: {
									name: "freespinIntro"
								},
								INTRO: {
									name: "introScreen"
								},
								TWEAK_MODULE: {
									name: "tweakModule"
								}
							}, this.BET_WIN_MODE = 1, this.SPIN_MODE = 0, this.REEL_AREA_POS_X = 0, this.REEL_AREA_POS_Y = 120, this.REEL_AREA_WIDTH = 760, this.REEL_AREA_HEIGHT = 526, this.SYMBOL_STATES = {
								normal: {
									prio: 0,
									keyword: "normal",
									texturesCreator: (t, e) => a.LeprechaunGameAssets.getSymbolStateTextures(t),
									fpsGetter: (t, e) => 15,
									offsetGetter: (t, e) => t.indexOf("B") > -1 ? [-4, -26] : [0, 0]
								},
								nudge: {
									prio: 1,
									keyword: "nudge",
									symbols: ["W"],
									texturesCreator: (t, e) => n.GameResources.getTextures(t)
								},
								floating: {
									prio: 2,
									keyword: "floating",
									symbols: ["B"],
									texturesCreator: (t, e) => n.GameResources.getTextures("bonusFloating"),
									fpsGetter: (t, e) => 15,
									offsetGetter: (t, e) => [-4, -26]
								},
								landing: {
									prio: 3,
									keyword: "landing",
									symbols: ["B"],
									texturesCreator: (t, e) => n.GameResources.getTextures("bonusLand"),
									fpsGetter: (t, e) => 15,
									offsetGetter: (t, e) => [-4, -26]
								},
								idle: {
									prio: 4,
									keyword: "idle",
									texturesCreator: (t, e) => a.LeprechaunGameAssets.getSymbolStateTextures(t),
									fpsGetter: (t, e) => 15,
									offsetGetter: (t, e) => t.indexOf("B") > -1 ? [-4, -26] : [0, 0]
								},
								spin: {
									prio: 5,
									keyword: "spin",
									texturesCreator: (t, e) => a.LeprechaunGameAssets.getSymbolStateTextures(t, e)
								},
								noWin: {
									prio: 6,
									keyword: "noWin",
									texturesCreator: (t, e) => a.LeprechaunGameAssets.getSymbolStateTextures(t),
									offsetGetter: (t, e) => t.indexOf("B") > -1 ? [-4, -26] : [0, 0]
								},
								win: {
									prio: 7,
									keyword: "win",
									texturesCreator: (t, e) => a.LeprechaunGameAssets.getSymbolStateTextures(t, e),
									offsetGetter: (t, e) => t.indexOf("B") > -1 ? [-4, -26] : [0, 0]
								},
								hidden: {
									prio: 8,
									keyword: "hidden"
								}
							}, this.STACKED_SYMBOLS = {
								W: {
									totalNum: [3, 3, 3],
									reels: [0, 1, 2]
								}
							}, this.SYMBOL_WIDTH = 196, this.SYMBOL_HEIGHT = 168, this.SYMBOL_BOTTOM_PADDING = 6, this.REELS_NUM = 3, this.SPACE_BETWEEN_REELS = 10, this.REEL_DISPLAY_POSITIONS = [
								[60 + .5 * this.SYMBOL_WIDTH, 0],
								[60 + 1.5 * this.SYMBOL_WIDTH + this.SPACE_BETWEEN_REELS, 0],
								[60 + 2.5 * this.SYMBOL_WIDTH + 2 * this.SPACE_BETWEEN_REELS, 0]
							], this.SYMBOLS_NUM_IN_REEL = [2, 2, 3, 2, 2], this.REEL_SPIN_TIME = .9, this.REEL_FAST_SPIN_SPIN_TIME = .1, this.MIN_STOPPING_TIME = 1.3, this.REEL_SPIN_START_SYMBOL_CHANGE_TO_SPIN_STATE_DURATION = .15, this.REEL_SPIN_START_SYMBOL_CHANGE_TO_SPIN_STATE_DELAY = .25, this.REEL_SPIN_START_EASE = r.Back.easeIn.config(4), this.REEL_SPIN_STOP_SYMBOL_CHANGE_FROM_SPIN_STATE_DURATION = .05, this.REEL_SPIN_STOP_SYMBOL_CHANGE_FROM_SPIN_STATE_DELAY = 0, this.REEL_SPIN_STOP_ELASTIC_CONFIG = [1.5, .95], this.REEL_SPIN_QUICK_STOP_ELASTIC_CONFIG = [1.2, .75], this.REEL_SPIN_START_SPEED = .3, this.REEL_SPIN_SPIN_SPEED = .03, this.REEL_NEAR_WIN_SPIN_SPEED = .03, this.REEL_SPIN_STOP_SPEED = .2, this.REEL_SPIN_QUICK_STOP_SPEED = .3, this.REEL_STOP_DELAY = .3, this.REEL_QUICK_STOP_DELAY = 0, this.REEL_NEAR_WIN_STOP_DELAY = 2, this.REEL_SETS = {
								BASE_REELSET: [
									["L1", "L1", "L1", "M1", "M3", "L2", "M2", "M4", "L3", "L4", "M2", "L1", "M3", "L4", "L1", "L2", "M4", "L1", "L2", "M5", "L3", "L3", "L3", "M3", "L1", "M3", "L2", "M2", "M5", "L4", "M4", "M4", "M4", "M5", "M2", "L2", "L1", "M4", "L4", "L3", "L2", "L2", "L2", "L1", "M1", "L1", "L2", "M4", "M3", "M1", "M2", "M2", "M2", "L2", "M5", "M4", "L1", "L2", "M2", "M1", "L4", "L4", "L4", "L3", "L1", "M3", "L2", "M4", "M3", "L2", "M5", "M5", "M5", "L4", "M4", "L2", "L1", "L3", "L4", "M3", "M1", "M1", "M1", "L1", "M4", "L1", "M5", "L2", "L4", "L1", "M3", "M3", "M3", "L2", "M4", "L3", "L1", "L2", "M1", "L4", "W", "W", "W", "L1", "L1", "L1", "M1", "M3", "L2", "M2", "M4", "L3", "L4", "M2", "L1", "M3", "L4", "L1", "L2", "M4", "L1", "L2", "M5", "L3", "L3", "L3", "M3", "L1", "M3", "L2", "M2", "M5", "L4", "M4", "M4", "M4", "M5", "M2", "L2", "L1", "M4", "L4", "L3", "L2", "L2", "L2", "L1", "M1", "L1", "L2", "M4", "M3", "M1", "M2", "M2", "M2", "L2", "M5", "M4", "L1", "L2", "M2", "M1", "L4", "L4", "L4", "L3", "L1", "M3", "L2", "M4", "M3", "L2", "M5", "M5", "M5", "L4", "M4", "L2", "L1", "L3", "L4", "M3", "M1", "M1", "M1", "L1", "M4", "L1", "M5", "L2", "L4", "L1", "M3", "M3", "M3", "L2", "M4", "L3", "L1", "L2", "M1", "L4"],
									["M3", "L4", "M2", "L1", "L3", "L2", "M5", "L4", "M1", "L3", "B", "M4", "L1", "M5", "M1", "L2", "L3", "M4", "M2", "L3", "M3", "L1", "L3", "L2", "M4", "L4", "L1", "L2", "L4", "L3", "L1", "L1", "L1", "M4", "L4", "M3", "L2", "L4", "M4", "L1", "M1", "M3", "L2", "M3", "L1", "M1", "L2", "L4", "L3", "M4", "M1", "M1", "M1", "L1", "L4", "M5", "L3", "L2", "M4", "L3", "L4", "L4", "L4", "M2", "M3", "M4", "L2", "M5", "M3", "L1", "M2", "M5", "L2", "L3", "M5", "M4", "L1", "M5", "L2", "L3", "W", "W", "W", "L1", "M3", "L2", "M4", "M3", "L3", "L2", "M5", "M4", "L3", "L2", "L2", "L2", "M1", "M4", "L1", "M3", "M5", "L3", "L4", "L1", "M3", "M5", "L2", "M3", "M2", "L3", "L2", "M3", "M4", "M2", "M2", "M2", "L3", "M2", "L1", "L2", "M1", "L3", "M4", "L1", "M3", "L2", "L4", "L3", "M1", "L1", "M4", "M3", "M5", "M5", "M5", "M2", "L4", "L2", "M3", "M5", "L1", "L4", "M3", "M2", "L3", "L1", "M4", "L3", "M1", "L2", "M4", "M3", "L3", "M1", "L2", "L4", "M4", "L3", "L1", "M3", "M4", "L3", "L1", "M5", "M4", "L1", "L2", "M3", "M4", "L3", "L1", "M2", "M3", "M3", "M3", "M1", "L1", "M5", "L2", "L3", "M4", "M3", "M2", "L1", "M4", "L1", "M3", "L2", "L4", "M5", "M3", "L2", "B", "M4", "L3", "M3", "M2", "L1", "L2", "M5", "M1", "M3", "L3", "L3", "L3", "M4", "M2", "L3", "L2", "M4", "M3", "L1", "L3", "M1", "M2", "M3", "L2", "L4", "M4", "L1", "M5", "L3", "M4", "M4", "M4", "L1", "M2", "M3", "L4", "M4", "L2", "L3", "L3", "M2", "M4", "L1", "M5", "L2", "L1", "M5", "L3", "M1", "M4", "M3", "L2", "L4", "M4", "L1", "M4", "L2", "M3", "L1", "W", "W", "W", "M3", "L4", "M2", "L1", "L3", "L2", "M5", "L4", "M1", "L3", "M4", "L1", "M5", "M1", "L2", "L3", "M4", "M2", "L3", "M3", "L1", "L3", "L2", "M4", "L3", "L1", "L2", "L4", "L3", "L1", "L1", "L1", "M4", "M4", "M3", "L2", "L4", "M4", "L1", "M1", "M3", "L2", "M3", "L1", "M1", "L2", "L4", "L3", "M4", "M1", "M1", "M1", "L1", "L4", "M5", "L3", "L2", "M4", "L3", "L4", "L4", "L4", "M2", "M3", "M4", "L2", "M5", "M3", "L1", "M2", "M5", "L2", "L3", "M5", "M4", "L1", "M5", "L2", "L3", "L1", "M3", "L2", "M4", "M3", "L3", "L2", "M5", "M4", "L3", "L2", "L2", "L2", "M1", "M4", "L1", "M3", "M5", "L3", "L4", "L1", "M3", "M5", "L2", "M3", "M2", "L3", "L2", "M3", "M4", "M2", "M2", "M2", "L3", "M2", "L1", "L2", "M1", "L3", "M4", "L1", "M3", "L2", "L4", "L3", "M1", "L1", "M4", "M3", "M5", "M5", "M5", "M2", "L4", "L2", "M3", "M5", "L1", "L4", "M3", "M2", "L3", "L1", "M4", "L3", "M1", "L2", "M4", "M3", "L3", "M1", "L2", "L4", "M4", "L3", "L1", "M3", "M4", "L3", "L1", "M5", "M4", "L1", "L2", "M3", "M4", "L3", "L1", "M2", "M3", "M3", "M3", "M1", "L1", "M5", "L2", "L3", "M4", "M3", "M2", "L1", "M4", "L1", "M3", "L2", "L4", "M5", "M3", "L2", "B", "M4", "L3", "M3", "M2", "L1", "L2", "M5", "M1", "M3", "L3", "L3", "L3", "M4", "M2", "L3", "L2", "M4", "M3", "L1", "L3", "M1", "M2", "M3", "L2", "L4", "M4", "L1", "M5", "L3", "M4", "M4", "M4", "L1", "M2", "M3", "L4", "M4", "L2", "L3", "L3", "M2", "M4", "L1", "M5", "L2", "L1", "M5", "L3", "M1", "M4", "M3", "L2", "L4", "M4", "L1", "M4", "L2", "M3", "L1"],
									["L1", "L1", "L1", "M5", "M4", "L2", "L4", "M2", "M3", "L2", "L3", "L3", "L3", "M2", "M4", "L1", "M2", "L3", "M3", "L1", "M4", "M4", "M4", "L3", "L1", "L1", "L3", "L2", "M4", "L4", "L2", "L2", "L2", "M3", "L3", "M4", "L1", "M1", "M3", "L1", "M2", "M2", "M2", "L1", "M3", "L3", "L2", "L1", "M3", "M4", "L4", "L4", "L4", "M4", "L3", "M2", "M5", "L3", "M2", "M1", "M5", "M5", "M5", "L1", "L3", "M4", "M3", "M5", "L2", "L1", "M1", "M1", "M1", "L1", "L3", "M3", "L2", "L1", "M4", "L1", "M3", "M3", "M3", "M2", "L1", "L2", "M4", "M5", "L1", "L2", "L3", "L3", "L3", "L1", "M5", "M3", "M3", "L1", "M1", "M3", "W", "W", "W", "L1", "L1", "L1", "M5", "M4", "L2", "L4", "M2", "M3", "L2", "L3", "L3", "L3", "M2", "M4", "L1", "M2", "L3", "M3", "L1", "M4", "M4", "M4", "L3", "L1", "L1", "L3", "L2", "M4", "L3", "L2", "L2", "L2", "M3", "L3", "M4", "L1", "M1", "M3", "L1", "M2", "M2", "M2", "L1", "M3", "L3", "L2", "L1", "M3", "M4", "L4", "L4", "L4", "M4", "L3", "M2", "M5", "L3", "M2", "M1", "M5", "M5", "M5", "L1", "L3", "M4", "M3", "M5", "L2", "L1", "M1", "M1", "M1", "L1", "L3", "M3", "L2", "L1", "M4", "L1", "M3", "M3", "M3", "M2", "L1", "L2", "M4", "M5", "L1", "L2", "L3", "L3", "L3", "L1", "M5", "M3", "M3", "L1", "M1", "M3", "L1", "L1", "L1", "M5", "M4", "L2", "L4", "M2", "M3", "L2", "L3", "L3", "L3", "M2", "M4", "L1", "M2", "L3", "M3", "L1", "M4", "M4", "M4", "L3", "L1", "L1", "L3", "L2", "M4", "L1", "L2", "L2", "L2", "M3", "L3", "M4", "L1", "M1", "M3", "L1", "M2", "M2", "M2", "L1", "M3", "L3", "L2", "L1", "M3", "M4", "L4", "L4", "L4", "M4", "L3", "M2", "M5", "L3", "M2", "M1", "M5", "M5", "M5", "L1", "L3", "M4", "M3", "M5", "L2", "L1", "M1", "M1", "M1", "L1", "L3", "M3", "L2", "L1", "M4", "L1", "M3", "M3", "M3", "M2", "L1", "L2", "M4", "M5", "L1", "L2", "L3", "L3", "L3", "L1", "M5", "M3", "M3", "L1", "M1", "M3"]
								],
								FREESPIN_REELSET: [
									["L3", "L2", "M5", "M4", "L1", "M5", "L2", "L3", "M4", "M5", "M2", "M4", "M3", "M5", "L1", "M2", "M5", "M3", "L2", "L1", "M5", "L2", "L3", "M5", "L2", "L1", "M4", "M5", "L1", "L2", "M4", "L1", "M5", "L2", "L1", "M5", "L2", "L3", "M5", "L1", "L4", "W", "W", "W", "M1", "M5", "M3", "M2", "M5", "L3", "L2", "M5", "L1", "L3", "L2", "M5", "M1", "L2", "L1", "M3", "M5", "L3", "M3", "L1", "M5", "M3", "L2", "L1", "M4", "M5", "L2", "W", "W", "W", "M3", "L1", "L3", "M2", "M5", "L2", "M4", "L3", "M3", "M4", "M2", "M1", "M4", "M3", "L1", "M5", "L2", "L1", "M5", "L2", "M1", "M5", "L2", "L4", "L1", "M2", "L2", "L1", "M4", "L2", "M5", "M3", "M4", "L1", "L2", "M5", "M4", "L1", "M1", "L2", "L1", "M1", "L2", "L1", "M5", "L2", "L1", "M5", "L2", "M4", "L1", "M2", "M3", "M1", "M4", "M3", "L2", "M5", "L3", "L1", "M3", "M4", "M5", "L1", "M4", "L2", "M5", "M4", "M3", "M5", "M4", "L2", "M3", "M5", "L4", "L2", "M1", "M4", "L1", "L2", "L3", "L1", "L2", "L3", "M5", "M4", "L1", "M3", "L3", "M2", "L2", "L1", "L3", "M4", "L1", "M5", "L2", "M4", "M1", "W", "W", "W", "L1", "M5", "M2", "L3", "M5", "M2", "L2", "M5", "M4", "L2", "L3", "M5", "L2", "M4", "M5", "L1", "M4", "M5", "L3", "L1", "L2", "L3", "L1", "L2", "M3", "L1", "L4", "L2", "M4", "M5", "M2", "L1", "M4", "M2", "L2", "M4", "M5", "L3", "M3", "M1", "L3", "L1", "M5", "L3", "L1", "M3", "M5", "L1", "M3", "L3", "M4", "M3", "L1", "M5", "M2", "M4", "L1", "M3", "M2", "M5", "L2", "L1", "L3", "M4", "M2", "L1", "M4", "L3", "M5", "M1", "L1", "L3", "L2", "M5", "L1", "M2", "M5", "L1", "L3", "L2", "M5", "M2", "L2", "M5", "L3", "M4", "L1", "L3", "L2", "M5", "M4", "L1", "M5", "L2", "L3", "M4", "M5", "M2", "M4", "M3", "M5", "L1", "M2", "M5", "M3", "L2", "L1", "M5", "L2", "L3", "M5", "L2", "L1", "M4", "M5", "L1", "L2", "M4", "L1", "M5", "L2", "L1", "M5", "L2", "L3", "M5", "L1", "L4", "M1", "M5", "M3", "M2", "M5", "L3", "L2", "M5", "L1", "L3", "L2", "M5", "M1", "L2", "L1", "M3", "M5", "L3", "M3", "L1", "M5", "M3", "L2", "L1", "M4", "M5", "L2", "M3", "L1", "L3", "M2", "M5", "L2", "M4", "L3", "M3", "M4", "M2", "M1", "M4", "M3", "L1", "M5", "L2", "L1", "M5", "L2", "M1", "M5", "L2", "L4", "L1", "M2", "W", "W", "W", "L2", "L1", "M4", "L2", "M5", "M3", "M4", "L1", "L2", "M5", "M4", "L1", "M1", "L2", "L1", "M1", "L2", "L1", "M5", "L2", "L1", "M5", "L2", "M4", "L1", "M2", "M3", "M1", "M4", "M3", "L2", "M5", "L3", "L1", "M3", "M4", "M5", "L1", "M4", "L2", "M5", "M4", "M3", "M5", "M4", "L2", "M3", "M5", "L4", "L2", "M1", "M4", "L1", "L2", "L3", "L1", "L2", "L3", "M5", "M4", "L1", "M3", "L3", "M2", "L2", "L1", "L3", "M4", "L1", "M5", "L2", "M4", "M1", "L1", "M5", "M2", "L3", "M5", "M2", "L2", "M5", "M4", "L2", "L3", "M5", "L2", "M4", "M5", "L1", "M4", "M5", "L3", "L1", "L2", "L3", "L1", "L2", "M3", "L1", "L4", "L2", "M4", "M5", "M2", "L1", "M4", "M2", "L2", "M4", "M5", "L3", "M3", "M1", "L3", "L1", "M5", "L3", "L1", "M3", "M5", "L1", "M3", "L3", "M4", "M3", "L1", "M5", "M2", "M4", "L1", "M3", "M2", "M5", "L2", "L1", "L3", "M4", "M2", "L1", "M4", "L3", "M5", "M1", "L1", "L3", "L2", "M5", "L1", "M2", "M5", "L1", "L3", "L2", "M5", "M2", "L2", "M5", "L3", "M4", "L1"],
									["L2", "M5", "L3", "L2", "L1", "L3", "M4", "M3", "L3", "L2", "L1", "M2", "L2", "L3", "M3", "M4", "M5", "L3", "M2", "M4", "M3", "L3", "M1", "L2", "M2", "L3", "L1", "M5", "M1", "M3", "L4", "L3", "L2", "M3", "M4", "L3", "L2", "M4", "L1", "M2", "M3", "L3", "L1", "M2", "M3", "L3", "L2", "M2", "L3", "M4", "L1", "W", "W", "W", "L3", "L2", "M3", "M5", "L3", "M4", "L2", "M3", "M4", "L1", "M3", "L2", "L3", "L1", "M2", "L3", "L2", "M5", "M3", "M4", "L3", "M3", "M5", "L3", "M4", "L2", "L1", "M3", "L2", "L3", "L4", "M3", "L2", "L1", "L3", "M1", "M5", "L2", "M4", "M3", "L3", "M4", "M5", "M3", "M2", "M4", "M3", "L2", "L1", "M3", "M4", "L3", "L2", "M3", "L3", "L1", "W", "W", "W", "M5", "L3", "L2", "M3", "M1", "L2", "M2", "M4", "M3", "M5", "L3", "M4", "M3", "L3", "M4", "M1", "L2", "M2", "L3", "M3", "L2", "L3", "M4", "L2", "M3", "L4", "L3", "M5", "M1", "M3", "L3", "M5", "M3", "L2", "L3", "L1", "L2", "L3", "M4", "M3", "L1", "M2", "L2", "L3", "M3", "M4", "L2", "M3", "L3", "M1", "M4", "L1", "L3", "L2", "M4", "L3", "L2", "L1", "L3", "M3", "M2", "L2", "M3", "L3", "M4", "L2", "L3", "L1", "L2", "M4", "L3", "M3", "L2", "L3", "M3", "M4", "L4", "M5", "L3", "L1", "L2", "L3", "M2", "L2", "M3", "M1", "M4", "W", "W", "W", "L3", "L2", "M5", "M3", "M4", "M5", "M2", "L1", "L2", "L3", "M1", "L2", "L3", "M4", "M3", "L3", "L2", "M4", "M3", "L3", "M4", "L2", "L1", "L3", "M4", "L1", "M3", "L3", "M1", "M3", "L4", "W", "W", "W", "M5", "L1", "L3", "L2", "M3", "L3", "L2", "L1", "M4", "L3", "L2", "M4", "L3", "L2", "M3", "M4", "M2", "L3", "M5", "M2", "M4", "L3", "M2", "L2", "M5", "M2", "L2", "M4", "L3", "L2", "M5", "L1", "L3", "L2", "M3", "L3", "L2", "L1", "M4", "L3", "L2", "M2", "L3", "M5", "M2", "L1", "M4", "M5", "M3", "M2", "M4", "M3", "L2", "L1", "M3", "M4", "L3", "L2", "M3", "L3", "L1", "M5", "L3", "L2", "M3", "M1", "L2", "M2", "M4", "M3", "M5", "L3", "M4", "M3", "L3", "M4", "M1", "L2", "M2", "L3", "M3", "L2", "L3", "M4", "L2", "M3", "L4", "L3", "M5", "M1", "M3", "L3", "M5", "M3", "L2", "L3", "L1", "L2", "L3", "W", "W", "W", "M4", "M3", "L1", "M2", "L2", "L3", "M3", "M4", "L2", "M3", "L3", "M1", "M4", "L1", "L3", "L2", "M4", "L3", "L2", "L1", "L3", "M3", "M2", "L2", "M3", "L3", "M4", "L2", "L3", "L1", "L2", "M4", "L3", "M3", "L2", "L3", "M3", "M4", "L4", "M5", "L3", "L1", "L2", "L3", "M2", "L2", "M3", "M1", "M4", "W", "W", "W", "L3", "L2", "M5", "M3", "M4", "M5", "M2", "L1", "L2", "L3", "M1", "L2", "L3", "M4", "M3", "L3", "L2", "M4", "M3", "L3", "M4", "L2", "L1", "L3", "M4", "L1", "M3", "L3", "M1", "M3", "L4", "M5", "L1", "L3", "L2", "M3", "L3", "L2", "L1", "M4", "L3", "L2", "M4", "L3", "L2", "M3", "M4", "M2", "L3", "M5", "M2", "M4", "L3", "M2", "L2", "M5", "M2", "L2", "M4", "L3", "L2", "M5", "L1", "L3", "L2", "M3", "L3", "L2", "L1", "M4", "L3", "L2", "M2", "L3", "M5", "M2", "L1", "L2", "M4", "L3", "L2", "M3", "M4", "M2", "L3", "M5", "M2", "M4", "L3", "M2", "L2", "M5", "M2", "L2", "M4", "L3", "L2", "M5", "L1", "L3", "L2", "M3", "L3", "L2", "L1", "M4", "L3", "L2", "M2", "L3", "M5", "M2", "L1", "M4", "M5", "M3", "M2", "M4", "M3", "L2", "L1", "M3", "M4", "L3", "L2", "M3", "L3", "L1", "M5", "L3", "L2", "M3", "M1", "L2", "M2", "M4", "M3", "M5", "L3", "M4", "M3", "L3", "M4", "M1", "L2", "M2", "L3", "M3", "L2", "L3", "M4", "L2", "M3", "L4", "L3", "M5", "M1", "M3", "L3", "M5", "M3", "L2", "L3", "L1", "L2", "L3", "M4", "M3", "L1", "M2", "L2", "L3", "M3", "M4", "L2", "M3", "L3", "M1", "M4", "L1", "L3", "L2", "M4", "L3", "L2", "L1", "L3", "M3", "M2", "L2", "M3", "L3", "M4", "L2", "L3", "L1", "L2", "M4", "L3", "M3", "L2", "L3", "M3", "M4", "L4", "M5", "L3", "L1", "L2", "L3", "M2", "L2", "M3", "M1", "M4", "L3", "L2", "M5", "M3", "M4", "M5", "M2", "L1", "L2", "L3", "M1", "L2", "L3", "M4", "M3", "L3", "L2", "M4", "M3", "L3", "M4", "L2", "L1", "L3", "M4", "L1", "M3", "L3", "M1", "M3", "L4", "M5", "L1", "L3", "L2", "M3", "L3", "L2", "L1", "M4", "L3", "L2", "M4", "L3", "L2", "M3", "M4", "M2", "L3", "M5", "M2", "M4", "L3", "M2", "L2", "M5", "M2", "L2", "M4", "L3", "L2", "M5", "L1", "L3", "L2", "M3", "L3", "L2", "L1", "M4", "L3", "L2", "M2", "L3", "M5", "M2", "L1", "M5", "L3", "L1", "L2", "L3", "M2", "L2", "M3", "M1", "M4", "L3", "L2", "M5", "M3", "M4", "M5", "M2", "L1", "L2", "L3"],
									["L1", "L2", "L3", "L1", "M4", "M5", "L1", "M2", "M5", "M3", "L1", "L3", "M5", "M3", "L1", "L3", "L2", "M3", "L3", "M4", "M5", "L3", "M4", "M5", "L3", "M1", "L1", "L3", "M3", "M4", "L4", "L3", "M3", "M2", "M1", "M5", "M4", "L1", "L2", "M5", "L3", "M4", "L1", "M3", "M4", "L1", "L3", "M5", "L1", "L3", "M5", "M3", "L3", "M4", "L1", "L3", "M2", "M4", "L3", "L2", "M5", "W", "W", "W", "M4", "L2", "L1", "L3", "M3", "L1", "M4", "M5", "M3", "M4", "L1", "M2", "M4", "L3", "M5", "M1", "L3", "L2", "L1", "M5", "L3", "L1", "M3", "L2", "L3", "M4", "M5", "L2", "L1", "M3", "L4", "M4", "L1", "L3", "M1", "M4", "L1", "M1", "M5", "L3", "M4", "L1", "M5", "M3", "L1", "L3", "M4", "L1", "M5", "L3", "M2", "L4", "M5", "M3", "M2", "L1", "L3", "L2", "M1", "M5", "L3", "M1", "L2", "L3", "L1", "M4", "L2", "L1", "L3", "M1", "M4", "L3", "L1", "L2", "L3", "M4", "M5", "L3", "M2", "M4", "M5", "L1", "L3", "M5", "M4", "L1", "L2", "M5", "L1", "M4", "L2", "L3", "M4", "L1", "L3", "L2", "L1", "M2", "M1", "L3", "M4", "L1", "L4", "L3", "L2", "M5", "W", "W", "W", "L3", "M1", "L1", "L3", "M3", "L2", "M4", "M3", "L2", "M4", "L1", "M1", "M4", "M3", "M5", "L1", "M4", "L4", "M5", "L3", "M4", "M1", "M5", "L3", "M4", "M5", "M3", "L3", "M1", "L1", "L3", "L2", "M4", "M3", "L3", "L2", "M3", "M1", "M4", "M2", "L1", "M5", "M4", "L1", "M5", "L3", "M4", "M3", "L1", "L3", "M4", "M5", "M3", "L2", "L3", "M4", "M5", "L1", "L3", "M4", "M2", "M3", "M1", "M2", "M5", "L3", "M1", "M5", "L4", "L1", "M3", "L3", "M5", "L2", "M1", "L3", "M4", "M5", "L3", "M2", "M5", "L2", "L3", "M5", "M4", "L1", "M5", "L3", "M4"]
								]
							}, this.WIN_RATIOS = {
								normalWin: [{
									ratio: 0,
									text: "Tiny Win",
									duration: 0,
									type: o.WinRatioType.TINY
								}, {
									ratio: 1.5,
									text: "Small Win",
									duration: .671,
									type: o.WinRatioType.SMALL
								}, {
									ratio: 3,
									text: "Medium Win",
									duration: 1.22,
									type: o.WinRatioType.MEDIUM
								}, {
									ratio: 5,
									text: "Large Win",
									duration: 1.159,
									type: o.WinRatioType.LARGE
								}],
								bigWin: [{
									ratio: 15,
									text: "Big Win",
									duration: 4,
									type: o.WinRatioType.BIG_WIN
								}, {
									ratio: 25,
									text: "Mega Win",
									duration: 3.902,
									type: o.WinRatioType.MEGA_WIN
								}, {
									ratio: 50,
									text: "Super Mega Win",
									duration: 3.902,
									type: o.WinRatioType.SUPER_MEGA_WIN
								}]
							}, this.WIN_COUNTUP_BITMAP_STYLE = {
								font: {
									name: "NumbersWinCountUp",
									size: 23
								},
								tint: parseInt("#ffffff".replace(/^#/, ""), 16)
							}, this.PERFORMANCE_LOGGER = !0, this.WIN_BELOW_STAKE = !1, l.instance) throw new Error("LeprechaunGameConfig.constructor() - Instantiation failed: Singleton.")
					}
				}
				e.LeprechaunGameConfig = l, l.instance = new l
			},
			63114: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunGameModuleConfig = void 0;
				const n = i(75367),
					s = i(49707),
					o = i(56665),
					r = i(44747),
					a = i(21155),
					l = i(47206),
					h = i(77616),
					u = i(50946),
					c = i(66943),
					d = i(52195),
					p = i(88878),
					_ = i(34359),
					m = i(33702),
					g = i(50755),
					f = i(92383),
					S = i(5044),
					y = i(23287),
					v = i(92829),
					T = i(4621),
					E = i(48002),
					b = i(4773),
					A = i(372),
					P = i(31544),
					I = i(92066),
					w = i(68270),
					L = i(89991),
					C = i(6),
					x = i(85271),
					B = i(76359),
					O = i(67155),
					N = i(20334),
					M = i(72149),
					R = i(47851),
					D = i(47912),
					k = i(21028),
					F = i(17162),
					G = i(66816),
					U = i(24911),
					W = i(77720),
					H = i(46593),
					V = i(85239),
					X = i(24320),
					Y = i(30261),
					z = i(17318),
					j = i(4564),
					K = i(56549),
					q = i(1042),
					Z = i(80109),
					$ = i(30552);
				class Q {
					constructor() {
						if (this.GAME_CONFIG = E.LeprechaunGameConfig.instance, this.SOUND_CONFIG = b.LeprechaunSoundConfig.instance, this.FONTS_CONFIG = v.LeprechaunFontConfig.FONTS, this.RESOURCES_CONFIG = T.LeprechaunGameAssets.RESOURCES_GROUPS, this.SERVER_PARSER = () => new F.LeprechaunServerDataParser, this.PARSED_INIT_DATA = (t, e) => new k.LeprechaunParsedInitData(t, e), this.PARSED_GAME_DATA = (t, e) => new D.LeprechaunParsedGameData(t, e), this.SPIN_CONTROLLER = () => new U.LeprechaunSpinController, this.REELS = () => new N.LeprechaunReels, this.REEL_AREA_VIEW = () => new x.LeprechaunReelAreaView, this.REEL_CONTROLLER = t => new B.LeprechaunReelController(t), this.REEL_PART_ANIMATOR = t => 1 === t ? new O.LeprechaunReelPartAnimator(t) : new a.NudgeSpinReelPartAnimator(t), this.REEL_PART_CREATOR = () => new s.ReelPartCreator(((t, e, i) => (i.offsetGetter = (t, e) => t.indexOf("B") > -1 ? [-4, -26] : [0, 0], t.indexOf("W") > -1 ? new X.LeprechaunReelSymbolWild(t, e, i) : t.indexOf("B") > -1 ? new H.LeprechaunReelSymbolBonus(t, e, i) : new W.LeprechaunReelSymbol(t, e, i)))), this.SYMBOL_STATE_CREATOR = () => new V.LeprechaunReelSymbolStateCreator, this.REEL_STOP_PRESENTATIONS = [t => new M.StopHotZoneController(t), t => new R.WildTextWriteOn(t)], this.PICK_AND_CLICKS = [() => new I.LeprechaunPickNClick("LeprechaunPickNClick", {
								viewCreator: (t, e) => new w.LeprechaunPickNClickScreen({
									layer: E.LeprechaunGameConfig.instance.LAYERS.FREESPIN_INTRO.name,
									onButtonClickCallback: t,
									recreateButtons: !1,
									mobileScale: 1,
									portraitScale: 1
								}, e),
								showWinPresentations: !1
							})], this.SCREENS = [() => new L.LeprechaunOutroController({
								viewCreator: (t, e) => new C.LeprechaunOutroView({
									layer: E.LeprechaunGameConfig.instance.LAYERS.FREESPIN_INTRO.name,
									onButtonClickCallback: t,
									mobileScale: 1,
									portraitScale: 1
								})
							})], this.ZERO_BETS = [() => new l.FreespinZeroBetController], this.WIN_PRESENTATIONS = [
								[t => new Z.LeprechaunNudgeWildController(t)],
								[t => new q.LeprechaunNoWinPresentationController(t)],
								[t => new K.LeprechaunInitialWPController(t)],
								[t => new z.LeprechaunBigWinController(t)]
							], this.INDIVIDUAL_WIN_PRESENTATION = () => new j.LeprechaunBetLineWinIndividualWPController({
								symbolTimeOffsetCalculator: (t, e, i) => 0
							}), this.GAME_FEATURE_CREATOR = () => {
								o.UserAgent.isMobile || new r.SymbolIdleAnimationController({
									startTime: 3,
									minInterval: .1,
									maxInterval: 3
								});
								const t = {
									values: ["M1", "M2", "M3", "M4", "M5", "L1"],
									symbols: ["M1", "M2", "M3", "M4", "M5", "L1"],
									background: {
										color: "#ffffff",
										alpha: .3
									},
									textStyle: {
										fontFamily: "Open Sans",
										fontSize: 22,
										fontWeight: h.FontWeight.EXTRA_BOLD,
										dropShadow: !0,
										wordWrap: !0,
										wordWrapWidth: 90,
										dropShadowAlpha: .6,
										dropShadowAngle: 89.5,
										dropShadowBlur: 7,
										dropShadowColor: "#1a1740",
										dropShadowDistance: 1,
										fill: ["#fffdec", "#fff2a8", "#ffc133"]
									}
								};
								new y.LeprechaunSymbolIdleAnimation, new f.PortraitPaytable(t), new g.LandscapePaytable(t), new u.BackgroundSound, Q.nearwinBackground = new P.NearWinBackground, Q.hotZone = new S.HotZone, Q.bonusWinEffect = new m.BonusWinEffect, Q.symbolWinAnimation = new Y.SymbolWinAnimation, Q.logo = new A.Logo, Q.soundPlayer = new G.SoundPlayer, new c.LeprechaunBackground({
									layer: n.GameConfig.instance.LAYERS.BACKGROUND.name,
									backgroundImages: {
										NORMAL: {
											image: T.LeprechaunGameAssets.MAIN_GAME_BACKGROUND,
											offset: new PIXI.Point(-480, -480)
										},
										FREESPIN: {
											image: T.LeprechaunGameAssets.FREESPIN_BACKGROUND,
											offset: new PIXI.Point(-480, -480)
										},
										FREESPIN_PICKS: {
											image: T.LeprechaunGameAssets.PICK_AND_CLICK_BACKGROUND,
											offset: new PIXI.Point(-480, -480)
										}
									},
									stretch: !1
								}), new _.LeprechaunBetlinesView({
									map: [4, 2, 1, 3, 5, 5, 2, 1, 3, 4]
								}, (t => new p.LeprechaunBetlineNumber(t, {
									layer: n.GameConfig.instance.LAYERS.BET_LINE_NUMBERS.name,
									width: 40,
									height: 40,
									horizontalPadding: 0,
									verticalPadding: [0, 0],
									textStyleNormal: {
										fontFamily: "Open Sans"
									},
									textStyleWin: {
										fontFamily: "Open Sans"
									},
									textWinScale: 1
								})), ((t, e, i) => new d.LeprechaunBetline(t, e, i, {
									staticLineLayer: n.GameConfig.instance.LAYERS.BET_LINES.name,
									styles: [{
										lineWidth: 6,
										color: 15595102,
										alpha: 1
									}, {
										lineWidth: 2,
										color: 16777215,
										alpha: 1
									}],
									numberOffsetX: 0,
									pointOverlapVerticalOffset: 8
								}))), Q.featurePrice = new $.FeaturePrice
							}, Q.instance) throw new Error("LeprechaunGameModuleConfig.constructor() - Instantiation failed: Singleton.")
					}
				}
				e.LeprechaunGameModuleConfig = Q, Q.instance = new Q
			},
			4773: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunSoundConfig = void 0;
				class i {
					constructor() {
						if (this.AS_WIN = "asWin", this.AS_WIN_BIG = "asWinBig", this.MAIN_GAME_AMBIANCE = "background-music-main", this.FREE_SPIN_AMBIANCE = "background-music-bonus", this.BONUS_GAME_AMBIANCE = "background-music-pick", this.REELS_SPINNING_START_ON_SPIN_START = "wheels-spinning", this.REELS_DEFAULT_BOUNCE = ["reel-one-landing", "reel-one-landing", "reel-one-landing"], this.WIN_BIG = "bigwin", this.WIN_BIG_END = ["bigwinEnds1", "bigwinEnds1", "bigwinEnds1"], this.COUNT_UP = "countup", this.COUNT_UP_ENDS = "countupEnds", this.SYMBOL_WIN_HIT = "winHit", this.NUDGE_START = "wildLanding", this.NUDGE_NO_WIN_1 = "wildNudgeNoWin1", this.NUDGE_NO_WIN_2 = "wildNudgeNoWin2", this.NUDGE_ABORT = "wildNudgeAbort", this.WILD_NUDGES = ["wildNudge1", "wildNudge2"], this.ANTICIPATION = "anticipation", this.ANTICIPATION_BONUS = "anticipation2", this.BONUS_COLLECTS = ["bonusCollectsToPosition1", "bonusCollectsToPosition2"], this.RAINBOW_LINES = ["rainbow1", "rainbow2"], this.BONUS_WIN = "bonusWin", this.BONUS_FAIL = "bonusFail", this.BONUS_STAR_OUT2 = "bonusStarsOut2", this.BONUS_STAR_IN = "bonusStarsIn", this.BONUS_STAR_PICK = "bonusStarPick", this.BONUS_STAR_END = "bonusStarToCenter", this.BONUS_STAR_PICK_EXPAND = "bonusStarPickExpand", this.BONUS_PLING = ["bonusPling1", "bonusPling2"], this.BONUS_START = "bonusContinue", this.BONUS_END_SWEEEP = "bonusEndsSweep", this.BONUS_END = "bonusEnds", i.instance) throw new Error("LeprechaunSoundConfig.constructor() - Instantiation failed: Singleton.")
					}
				}
				e.LeprechaunSoundConfig = i, i.instance = new i, i.TINY_WIN = "winTiny", i.SMALL_WIN = "winSmall", i.MEDIUM_WIN = "winMedium", i.LARGE_WIN = "winLarge", i.BIG_WIN_START = "bigwinInitialWin"
			},
			78341: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BackgroundAnimations = void 0;
				const n = i(85206),
					s = i(88240),
					o = i(34785),
					r = i(86082),
					a = i(7615),
					l = i(73044),
					h = i(48002),
					u = i(13006),
					c = i(46109);
				class d extends l.BaseView {
					constructor() {
						super(), this.cloudYs = [226, -112, 152], this.cloudStartPos = [116, 286, 1062], this.cloudEndPos = [382, 460, 1284], this.fwOffset = 280, this._layer = n.StageManager.getLayer(h.LeprechaunGameConfig.instance.LAYERS.BACKGROUND_ANIMATION.name)
					}
					initAnimations() {
						const t = this.fwOffset;
						this._clouds = o.ArrayHelper.initArrayWithValues(3, (t => {
							const e = new PIXI.Sprite(s.GameResources.getTextures(`cloud${t}`)[0]);
							return e.anchor.set(.5, .5), e.position.set(0, this.cloudYs[t]), this._layer.addChild(e), e
						})), this._foreground = new PIXI.Sprite(s.GameResources.getTextures("foreground")[0]), this._foreground.anchor.set(.5, .5), this._foreground.position.set(360, 660), this._layer.addChild(this._foreground), this._rainDrops = this.createEmitters(s.GameResources.getTextures("raindrop"), r.ParticleConfigs.rainDrops), this._emitter = this.createEmitters([s.GameResources.getTextures("defaultParticle")[0]], r.ParticleConfigs.sparkleParticles), this._sparkleParticlesSmall = this.createEmitters([s.GameResources.getTextures("defaultParticle")[0]], r.ParticleConfigs.sparkleParticlesSmall), this._bgRipples0 = this.createSprite("bgRipples0", [313 - t, 524], .55), this._bgRipples1 = this.createSprite("bgRipples1", [527 - t, 673], .95), this._bgRipples2 = this.createSprite("bgRipples2", [1005 - t, 480], .25), this._splashRingUpper = this.createEmitters([s.GameResources.getTextures("splashRing")[0]], r.ParticleConfigs.splashRingUpper), this._splashRingLower = this.createEmitters([s.GameResources.getTextures("splashRing")[0]], r.ParticleConfigs.splashRingLower), this._splashRingMid = this.createEmitters([s.GameResources.getTextures("splashRing")[0]], r.ParticleConfigs.splashRingMid), new u.TimelineMax({
							delay: 0,
							repeat: -1,
							repeatDelay: 1.485
						}).add((new u.TimelineLite).add([u.TweenLite.to(this._bgRipples0, 2.5, {
							x: 296 - t,
							y: 545
						}), u.TweenLite.to(this._bgRipples0.scale, 2.5, {
							x: 1.09,
							y: 1.09
						}), u.TweenLite.to(this._bgRipples0, 1, {
							alpha: 1
						}), u.TweenLite.to(this._bgRipples0, 1.485, {
							alpha: 0,
							delay: 1
						})])), new u.TimelineMax({
							delay: 0,
							repeat: -1,
							repeatDelay: 1.485
						}).add((new u.TimelineLite).add([u.TweenLite.to(this._bgRipples1, 2, {
							x: 513 - t,
							y: 683
						}), u.TweenLite.to(this._bgRipples1.scale, 2, {
							x: 1.2,
							y: 1.2
						}), u.TweenLite.to(this._bgRipples1, .8, {
							alpha: 1
						}), u.TweenLite.to(this._bgRipples1, 36 * .033, {
							alpha: 0,
							delay: .8
						})])), new u.TimelineMax({
							delay: 0,
							repeat: -1,
							repeatDelay: 1.32
						}).add((new u.TimelineLite).add([u.TweenLite.to(this._bgRipples2, 2.112, {
							x: 976 - t,
							y: 490
						}), u.TweenLite.to(this._bgRipples2.scale, 2.112, {
							x: .9,
							y: .9
						}), u.TweenLite.to(this._bgRipples2, .792, {
							alpha: .8
						}), u.TweenLite.to(this._bgRipples2, 1.32, {
							alpha: 0,
							delay: .792
						})])), this.playCloudAnimation()
					}
					createSprite(t, e, i) {
						const n = new PIXI.Sprite(s.GameResources.getTextures(t)[0]);
						return n.alpha = 0, n.blendMode = PIXI.BLEND_MODES.ADD, n.anchor.set(.5, .5), n.position.set(e[0], e[1]), this._layer.addChild(n), n
					}
					createEmitters(t, e) {
						const i = new a.Emitter(this._layer, [{
							framerate: 30,
							loop: !0,
							hasLoaded: !0,
							textures: t
						}], e);
						return i.particleConstructor = a.AnimatedParticle, c.LeParticlesManager.addEmitter(i, !0), i
					}
					onResize(t) {}
					playCloudAnimation() {
						this._cloudPanningTimeLine = new u.TimelineLite, this._clouds && this._clouds.length > 0 && this._clouds.forEach(((t, e) => {
							t.position.x = this.cloudStartPos[e], this._cloudPanningTimeLine.add(this.getCloudAnimation(t, e), e)
						}))
					}
					getCloudAnimation(t, e) {
						const i = this.fwOffset,
							n = new u.TimelineLite({
								onComplete: () => {
									t.position.x = this.cloudStartPos[e] - i, this.getCloudAnimation(t, e), n.pause(), n.kill()
								}
							});
						return n.to(t, 20, {
							x: this.cloudEndPos[e] - i
						}), n.to(t, 20, {
							x: this.cloudStartPos[e] - i
						}), n
					}
				}
				e.BackgroundAnimations = d
			},
			50946: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BackgroundSound = void 0;
				const n = i(52409),
					s = i(330),
					o = i(15904),
					r = i(83673),
					a = i(23110),
					l = i(4773),
					h = i(46289);
				class u extends h.BaseController {
					constructor() {
						super(), this._mode = r.GameMode.NORMAL, this.addEventListeners()
					}
					addEventListeners() {
						n.EventHandler.addEventListener(this, s.ServerEvent.INIT_DATA_PARSED, (t => this.parsedInitData(t.params[0]))), n.EventHandler.addEventListener(this, o.ScreenEvent.GAME_START, (t => this.onGameReady()))
					}
					parsedInitData(t) {
						this._mode = t.mode, this._isRestore = t.isRestoreState
					}
					onGameReady() {
						if (this._isRestore) {
							const t = l.LeprechaunSoundConfig.instance,
								e = this._mode === r.GameMode.FREESPIN ? t.FREE_SPIN_AMBIANCE : t.BONUS_GAME_AMBIANCE;
							a.SlotGame.sound.fadeAmbience(0, 50), a.SlotGame.sound.playAmbience(e), a.SlotGame.sound.fadeAmbience(1, 50), this._isRestore = !1
						}
					}
				}
				e.BackgroundSound = u
			},
			66943: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunBackground = void 0;
				const n = i(85206),
					s = i(69221),
					o = i(88240),
					r = i(48002),
					a = i(78341),
					l = i(13006);
				class h extends s.StillImageBackground {
					constructor(t) {
						super(t), this._backgroundAnimations = new a.BackgroundAnimations
					}
					initAnimations() {
						super.initAnimations();
						const t = n.StageManager.getLayer(r.LeprechaunGameConfig.instance.LAYERS.BACKGROUND_ELEMENTS.name),
							e = n.StageManager.getLayer(r.LeprechaunGameConfig.instance.LAYERS.REEL_BACKGROUND.name);
						this._bgSky = this.createSprite("bgSky", t), this._bgSky.scale.set(2), this._bgRainbow = this.createSprite("bgRainbow", t), this._bgRainbow.blendMode = PIXI.BLEND_MODES.SCREEN, this._reelBackground = new PIXI.Sprite(o.GameResources.getTextures("reelBackground")[0]), this._reelBackground.anchor.set(.5, .5), this._reelBackground.position.set(360, 380), e.addChild(this._reelBackground);
						const i = new PIXI.Sprite(o.GameResources.getTextures("reelFrame")[0]);
						i.anchor.set(.5, .5), i.position.set(360, 380), n.StageManager.getLayer(r.LeprechaunGameConfig.instance.LAYERS.REEL_FRAME.name).addChild(i), l.TweenMax.to(this._bgRainbow, 5, {
							alpha: .6,
							ease: l.Power2.easeOut,
							yoyoEase: l.Power2.easeOut,
							repeat: -1,
							repeatDelay: .1
						})
					}
					createSprite(t, e) {
						const i = new PIXI.Sprite(o.GameResources.getTextures(t)[0]);
						return i.anchor.set(.5, .5), i.position.set(360, 26), e.addChild(i), i
					}
				}
				e.LeprechaunBackground = h
			},
			52195: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunBetline = void 0;
				const n = i(52409),
					s = i(83673),
					o = i(88240),
					r = i(330),
					a = i(23110),
					l = i(85206),
					h = i(56682),
					u = i(57244),
					c = i(14023),
					d = i(7057),
					p = i(13006),
					_ = i(48002),
					m = i(4773),
					g = i(15807);
				var f = PIXI.BitmapText;
				class S extends c.PolyBetLine {
					constructor(t, e, i, n) {
						super(t, e, i, n), this._toShow = !1, this._y = [340, 195, 485, 340, 340, 314, 374, 536, 166], this.addMultiplierEventListeners(), this._winAmount = new f(this.index.toString(), {
							fontName: "NumbersWinCountUp",
							fontSize: 20
						}), this._winMultiplier = new f("0", {
							fontName: "NumbersWinMultiplier",
							fontSize: 14
						}), this._winAmount.visible = !1, this._winMultiplier.visible = !1, this.addChild(this._winAmount), this.addChild(this._winMultiplier), this._winAmount.x = _.LeprechaunGameConfig.instance.GAME_WIDTH / 2, this._winAmount.y = this._y[t - 1] - 2, this._winMultiplier.x = _.LeprechaunGameConfig.instance.GAME_WIDTH / 2, this._winMultiplier.y = this._y[t - 1] - 10, this.addFeatureEventListeners()
					}
					addFeatureEventListeners() {
						n.EventHandler.addEventListener(this, g.LeprechaunBetlineEvent.SHOW_WIN_BET_LINE_WINS, (t => this.onShowWinBetLineWin(t.params[0])))
					}
					addMultiplierEventListeners() {
						n.EventHandler.addEventListener(this, r.ServerEvent.GAME_DATA_PARSED, (t => this.parsedGameData(t.params[0])))
					}
					parsedGameData(t) {
						this._betlineData = t.betWins, this._toShow = !1, this.index < 6 ? this._toShow = !0 : t.mode === s.GameMode.FREESPIN && this.index <= 5 + 2 * t.pickedExtraLines && (this._toShow = !0, t.nextMode === s.GameMode.NORMAL && t.singleWin <= 0 && (this._toShow = !1))
					}
					onShowWinBetLineWin(t) {
						t === this.index && this.showWin(!0)
					}
					showStatic() {
						this._toShow && this.showWin(!1)
					}
					draw(t, e, i) {
						const n = [-1, 1, -1, 1];
						if (this.index > 5) {
							const t = new d.TimelineSprite(o.GameResources.getTextures("rainbowBetLine"));
							t.blendMode = PIXI.BLEND_MODES.ADD, t.anchor.set(0, .5), t.scale.set(1, n[this.index - 6]), t.x = 0, t.y = (this.index % 3 == 0 ? 124 : 385) + _.LeprechaunGameConfig.instance.REEL_AREA_POS_Y, t.hide(), this._rainbowLine = t, this.addChild(t), l.StageManager.getLayer(i.staticLineLayer).addChild(this)
						} else {
							const t = new PIXI.Sprite(o.GameResources.getTextures("betline_" + this.index)[0]);
							t.anchor.set(0, 0), t.x = -34, t.y = 36, this.addChild(t), l.StageManager.getLayer(i.staticLineLayer).addChild(this), this.alpha = 0
						}
					}
					animateShow() {
						return this.index > 5 && this._rainbowLine ? (this.alpha = 1, (new p.TimelineLite).add([() => {
							a.SlotGame.sound.playEffect(m.LeprechaunSoundConfig.instance.RAINBOW_LINES[this.index % 2])
						}, this._rainbowLine.getAnimationAutoShowHide(!0, !0)])) : new p.TimelineLite
					}
					showWin(t = !1) {
						this.index > 5 && this._rainbowLine ? (this.alpha = 1, this._rainbowLine.getAnimationAutoShowHide(!0, !1)) : super.showWin();
						const e = this.index;
						this._winAmount.visible = !1, this._winMultiplier.visible = !1, t && this._betlineData.forEach((t => {
							if (t.betLineIndex === e - 1) {
								if (this._winAmount.visible = !0, this._winAmount.text = t.amount.toFixed(2).toString(), this._winAmount.scale.set(1, 1), this._winAmount.width > 550) {
									const t = u.MathHelper.roundToDecimals(550 / this._winAmount.width, 2);
									this._winAmount.scale.set(t, t)
								}
								this._winAmount.x = h.Helper.getSymbolPositions(1, 1)[0] - this._winAmount.width / 2, t.multiplier > 1 ? (this._winAmount.x = h.Helper.getSymbolPositions(1, 1)[0] - this._winAmount.width, this._winMultiplier.visible = !0, this._winMultiplier.text = (" X" + t.multiplier).toString(), this._winMultiplier.x = h.Helper.getSymbolPositions(1, 1)[0]) : (this._winMultiplier.visible = !1, this._winMultiplier.text = ""), this._winAmount.x = h.Helper.getSymbolPositions(1, 1)[0] - (this._winAmount.width + this._winMultiplier.width) / 2, this._winMultiplier.x = this._winAmount.x + this._winAmount.width
							}
						}))
					}
					hideAll() {
						this.index > 5 && this._rainbowLine || super.hideAll(), this._winAmount.visible = !1, this._winMultiplier.visible = !1
					}
				}
				e.LeprechaunBetline = S
			},
			15807: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunBetlineEvent = void 0;
				const n = i(53108);
				class s extends n.BetLineEvent {}
				e.LeprechaunBetlineEvent = s, s.SHOW_WIN_BET_LINE_WINS = "betLineEvent_showBetLineWinWinAmount", s.SHOW_RAINBOW_NUMBER = "betLineEvent_showRainbowNumber", s.HIDE_RAINBOW_NUMBER = "betLineEvent_hideRainbowNumber", s.BET_LINE_SHOWN = "betLineEvent_betlineShown"
			},
			88878: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunBetlineNumber = void 0;
				const n = i(85206),
					s = i(88240),
					o = i(15807),
					r = i(52409),
					a = i(13006),
					l = i(77016),
					h = i(17045);
				class u extends l.BetLineNumber {
					constructor(t, e) {
						super(t, e), this._showRainbowNumbers = !1, this._config = e, this.addMultiplierEventListeners()
					}
					addMultiplierEventListeners() {
						r.EventHandler.addEventListener(this, o.LeprechaunBetlineEvent.SHOW_WIN_BET_LINE_WINS, (t => this.onShowWinBetLineWin(t.params[0]))), r.EventHandler.addEventListener(this, o.LeprechaunBetlineEvent.HIDE_RAINBOW_NUMBER, (t => this.onHideRainbowNumbers()))
					}
					draw(t) {
						const e = this.index > 5 ? "" : "Left";
						this._normalText = new PIXI.Sprite(s.GameResources.getTextures(`betlineNumber${this.index}${e}`)[0]), this._normalText.anchor.set(.5, .5), this._normalText.alpha = 0, this.addChild(this._normalText), this._winText = new PIXI.Sprite(s.GameResources.getTextures(`betlineNumber${this.index}${e}Win`)[0]), this._winText.anchor.set(.5, .5), this._winText.alpha = 0, this.addChild(this._winText), n.StageManager.getLayer(t.layer).addChild(this)
					}
					onShowWinBetLineWin(t) {
						t === this.index && this.showWin()
					}
					animateShow() {
						this._showRainbowNumbers = !0, this.killAllTweens(), this._normalTextAlphaTween = a.TweenLite.to(this._normalText, .1, {
							alpha: 1
						}), this._normalTextScaleTween = a.TweenLite.fromTo(this._normalText.scale, 1, {
							x: 0,
							y: 0
						}, {
							x: 1,
							y: 1,
							ease: a.Elastic.easeOut
						})
					}
					showMouseOver() {
						!this._showRainbowNumbers && this.index > 5 || (this.killAllTweens(), this._normalTextAlphaTween = a.TweenLite.to(this._normalText, .1, {
							alpha: 0
						}), this._winTextAlphaTween = a.TweenLite.to(this._winText, .1, {
							alpha: 1
						}))
					}
					showMouseOut() {
						!this._showRainbowNumbers && this.index > 5 || (this.killAllTweens(), this._normalTextAlphaTween = a.TweenLite.to(this._normalText, .1, {
							alpha: 1
						}), this._winTextAlphaTween = a.TweenLite.to(this._winText, .1, {
							alpha: 0
						}))
					}
					showWin() {
						this.killAllTweens(), this._normalTextAlphaTween = a.TweenLite.to(this._normalText, .1, {
							alpha: 0
						}), this._winTextAlphaTween = a.TweenLite.to(this._winText, .1, {
							alpha: 1
						}), this._normalTextScaleTween = a.TweenLite.to(this._normalText.scale, .17, {
							x: this._config.textWinScale,
							y: this._config.textWinScale
						}), this._winTextScaleTween = a.TweenLite.to(this._winText.scale, .17, {
							x: this._config.textWinScale,
							y: this._config.textWinScale
						})
					}
					showNormal() {
						!this._showRainbowNumbers && this.index > 5 || (this.killAllTweens(), this._normalTextAlphaTween = a.TweenLite.to(this._normalText, .33, {
							alpha: 1
						}), this._winTextAlphaTween = a.TweenLite.to(this._winText, .33, {
							alpha: 0
						}), this._normalTextScaleTween = a.TweenLite.to(this._normalText.scale, .33, {
							x: 1,
							y: 1
						}), this._winTextScaleTween = a.TweenLite.to(this._winText.scale, .33, {
							x: 1,
							y: 1
						}))
					}
					killAllTweens() {
						this._normalTextAlphaTween && this._normalTextAlphaTween.isActive() && (this._normalTextAlphaTween.pause(), this._normalTextAlphaTween.kill()), this._normalTextScaleTween && this._normalTextScaleTween.isActive() && (this._normalTextScaleTween.pause(), this._normalTextScaleTween.kill()), this._winTextAlphaTween && this._winTextAlphaTween.isActive() && (this._winTextAlphaTween.pause(), this._winTextAlphaTween.kill()), this._winTextScaleTween && this._winTextScaleTween.isActive() && (this._winTextScaleTween.pause(), this._winTextScaleTween.kill())
					}
					onHideRainbowNumbers() {
						this.index < 6 || (this._showRainbowNumbers = !1, this.killAllTweens(), this._normalText.alpha = 0, this._winText.alpha = 0)
					}
					setPosition(t, e) {
						const i = t / 2,
							n = Math.floor(e / i);
						this._normalText.anchor.set(0 === n ? 1 : 0, .5), this._winText.anchor.set(0 === n ? 1 : 0, .5);
						const o = this.index > 5 ? "" : 0 === n ? "Left" : "Right";
						this._normalText.texture = s.GameResources.getTextures(`betlineNumber${this.index}${o}`)[0], this._winText.texture = s.GameResources.getTextures(`betlineNumber${this.index}${o}Win`)[0];
						const r = h.LeprechaunHelper.getBetlineNumerPos(this.index, n)[0],
							a = h.LeprechaunHelper.getBetlineNumerPos(this.index, n)[1];
						return this.x = r, this.y = a, [r, a, n]
					}
				}
				e.LeprechaunBetlineNumber = u
			},
			34359: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunBetlinesView = void 0;
				const n = i(68093),
					s = i(52409),
					o = i(330),
					r = i(15807),
					a = i(13006),
					l = i(15904),
					h = i(83673),
					u = i(34785);
				class c extends n.BetLinesView {
					constructor(t, e, i) {
						super(t, e, i), this._isRestore = !1, this._isFirstNormalSpin = !1, this._ssNumberFactoryMethod = e, this._ssLineFactoryMethod = i, this._ssBetlineConfig = t
					}
					addEventListeners() {
						s.EventHandler.addEventListener(this, o.ServerEvent.INIT_DATA_PARSED, (t => this.parsedInitData(t.params[0]))), s.EventHandler.addEventListener(this, o.ServerEvent.GAME_DATA_PARSED, (t => this.parsedGameData(t.params[0]))), s.EventHandler.addEventListener(this, r.LeprechaunBetlineEvent.SHOW_RAINBOW_NUMBER, (t => this.onShowRainbowLineNumber(t.params[0]))), s.EventHandler.addEventListener(this, l.ScreenEvent.GAME_READY, (t => this.onGameReady()))
					}
					parsedGameData(t) {
						this._isFirstNormalSpin = t.mode === h.GameMode.FREESPIN && t.nextMode === h.GameMode.NORMAL
					}
					parsedInitData(t) {
						if (this._ssBetLinesData = t.betLines.concat(t.betLines), this._ssBetLinesData.length != this._ssBetlineConfig.map.length) throw new Error(`Error: There are only ${this._ssBetlineConfig.map.length} betLines in the config order while the server sends ${this._ssBetLinesData.length} lines.`);
						this._dataInitialized = !0, this._pickedExtraLines = t.addedLines, this.draw(), t.isRestoreState && t.pickedExtraLines > 0 && t.mode === h.GameMode.FREESPIN && (this._isRestore = !0)
					}
					onGameReady() {
						if (this._isRestore) {
							this._isRestore = !1;
							let t = u.ArrayHelper.arraySum(this._pickedExtraLines);
							this.onShowRainbowLineNumber(t)
						}
					}
					onShowRainbowLineNumber(t) {
						if (t <= 0) return;
						if (this._betLineNumbers.length < 11)
							for (let t = 0; t < 8; t++)
								if (t < 4) {
									const e = this._ssNumberFactoryMethod(t + 6),
										i = e.setPosition(10, t);
									this._betLineNumbers.push(e);
									const n = this._ssLineFactoryMethod(t + 6, i, this._ssBetLinesData[t - 1]);
									this._betLines.push(n)
								} else {
									const e = this._ssNumberFactoryMethod(t + 2);
									e.setPosition(8, t), this._betLineNumbers.push(e)
								} const e = new a.TimelineLite;
						for (let i = 0; i < t; i++) e.add((() => {
							this._betLineNumbers[10 + i].animateShow(), this._betLineNumbers[14 + i].animateShow()
						}), 0), e.add(this._betLines[5 + i].animateShow(), .4 * i)
					}
					draw() {
						if (!this._resourcesLoaded || !this._dataInitialized) return;
						const t = this._ssBetlineConfig.map,
							e = t.length;
						for (let i = 0; i < e; i++) {
							const e = this._ssNumberFactoryMethod(t[i]),
								n = e.setPosition(this._ssBetLinesData.length, i);
							if (this._betLineNumbers.push(e), i < 5) {
								const e = this._ssLineFactoryMethod(t[i], n, this._ssBetLinesData[t[i] - 1]);
								this._betLines.push(e)
							}
						}
					}
				}
				e.LeprechaunBetlinesView = c
			},
			3848: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.TweenParticleEmitter = void 0;
				const n = i(13006),
					s = i(7615);
				i(7615);
				class o extends PIXI.Container {
					get emitter() {
						return this._emitter
					}
					constructor(t, e, i = !1) {
						super(), this.currentTime = 0, this._prevTime = 0, this._emitterConfig = e, i ? (this._emitter = new s.Emitter(this, [{
							framerate: 30,
							loop: !0,
							hasLoaded: !0,
							textures: t
						}], e), this._emitter.particleConstructor = s.AnimatedParticle) : this._emitter = new s.Emitter(this, t, e), this._totalDuration = this._emitter.emitterLifetime + this._emitter.maxLifetime
					}
					reset() {
						this._currentTween && (this._currentTween.isActive() && this._currentTween.progress(1), this._currentTween.kill()), this.currentTime = 0, this._prevTime = 0
					}
					onStart() {
						this._emitter.emit = !0
					}
					onUpdate() {
						let t = Math.abs(this.currentTime - this._prevTime);
						this._emitter.update(t), this._prevTime = this.currentTime
					}
					getAnimation(t = n.Linear.easeNone) {
						this._emitter.emit = !1, this._emitter.cleanup(), this.reset(), this._emitter.emitterLifetime = this._emitterConfig.emitterLifetime ? this._emitterConfig.emitterLifetime : 0, this._totalDuration = this._emitter.emitterLifetime + this._emitter.maxLifetime, this._currentTween = new n.TweenLite(this, this._totalDuration, {
							currentTime: this._totalDuration,
							ease: t,
							onStart: () => this.onStart(),
							onUpdate: () => this.onUpdate()
						})
					}
				}
				e.TweenParticleEmitter = o
			},
			33702: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.BonusWinEffect = void 0;
				const n = i(73044),
					s = i(88240),
					o = i(85206),
					r = i(56682),
					a = i(7057),
					l = i(13006),
					h = i(48002);
				class u extends n.BaseView {
					constructor() {
						super(), this._layer = o.StageManager.getLayer(h.LeprechaunGameConfig.instance.LAYERS.HOTZONE.name)
					}
					initAnimations() {
						this._winStar = new a.TimelineSprite(s.GameResources.getTextures("winSplash")), this._winStar.blendMode = PIXI.BLEND_MODES.ADD, this._winStar.hide(), this._winStar.scale.set(4, 4), this._winStar.anchor.set(.5, .5), this._layer.addChild(this._winStar)
					}
					onResize(t) {
						this._winStar.position.set(r.Helper.getSymbolPositions(1, 1)[0], r.Helper.getSymbolPositions(1, 1)[1])
					}
					playAnimation() {
						const t = new l.TimelineLite;
						return t.add(this._winStar.getAnimationAutoShowHide(!0, !0)), t
					}
				}
				e.BonusWinEffect = u
			},
			90561: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunButton = e.ButtonState = void 0;
				const n = i(13006),
					s = i(88240);
				var o;
				! function(t) {
					t[t.disabled = 0] = "disabled", t[t.deactive = 1] = "deactive", t[t.idle = 2] = "idle", t[t.over = 3] = "over", t[t.down = 4] = "down"
				}(o || (e.ButtonState = o = {}));
				class r extends PIXI.Sprite {
					set enabled(t) {
						this._enabled != t && (this._enabled = t, this.setState(this._enabled ? o.idle : o.disabled))
					}
					get enabled() {
						return this._enabled
					}
					get width() {
						return this._currentState.width
					}
					constructor(t, e, i = 30) {
						super(), this._glow = new PIXI.Sprite(s.GameResources.getTextures("pncStoneGlow")[0]), this._glow.anchor.set(.5, .5), this._glow.position.set(0, 0), this._glow.blendMode = PIXI.BLEND_MODES.ADD, this._glow.visible = !1, this.addChild(this._glow), this._idleState = this.createState(t), this._disabledState = this.createState(t), this._deactiveState = this.createState(t), this._overState = this.createState(t), this._downState = this.createState(t), this._onClickedCallback = e, this.init()
					}
					createState(t) {
						let e = new PIXI.Sprite(t);
						return this.addChild(e), e.visible = !1, e.anchor.set(.5, .5), e
					}
					setState(t, e = !0) {
						switch (this._glow.visible = t === o.over, this._idleState.visible = !1, this._disabledState.visible = !1, this._deactiveState.visible = !1, t) {
							case o.disabled:
								this._currentState = this._disabledState;
								break;
							case o.idle:
								this._currentState = this._idleState;
								break;
							case o.deactive:
								this._currentState = this._deactiveState;
								break;
							case o.over:
								this._currentState = this._overState;
								break;
							case o.down:
								this._currentState = this._downState;
								break;
							default:
								throw new Error(`Button.setState(): Illegal button state ${t}`)
						}
						this._currentState.visible = !0
					}
					init() {
						this._enabled = !0, this.interactive = !0, this.buttonMode = !0, this.anchor.set(.5, .5), this.on("pointerdown", this.onDown), this.on("pointerout", this.onIdle), this.on("pointerover", this.onOver), this.on("pointertap", this.onUp), this.setState(o.idle)
					}
					onIdle() {
						this._enabled && this.setState(o.idle)
					}
					onOver() {
						this._enabled && (CustomWiggle.create("wiggle", {
							wiggles: 10,
							type: "easeInOut"
						}), (new n.TimelineLite).add((new n.TimelineLite).to(this, 2, {
							rotation: Math.PI / 6,
							ease: "wiggle"
						})), this.setState(o.over))
					}
					onDown() {
						this._enabled && this.setState(o.down)
					}
					onUp() {
						this._enabled && (this._onClickedCallback(), this._enabled = !1)
					}
					click() {
						this.onUp()
					}
				}
				e.LeprechaunButton = r
			},
			50755: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LandscapePaytable = void 0;
				const n = i(85206),
					s = i(56682),
					o = i(75367),
					r = i(66493),
					a = i(64543),
					l = i(48002),
					h = i(52475),
					u = i(52409),
					c = i(57284),
					d = i(56665);
				class p extends a.MiniPayTable {
					constructor(t) {
						super(t)
					}
					addEventListeners() {
						super.addEventListeners(), u.EventHandler.addEventListener(this, c.StageEvent.LEFT_HANDED_SETTING, (t => this.onResizeContainer(t.params[0])))
					}
					onResize(t) {
						super.onResize(t);
						const e = n.StageManager.getLayer(l.LeprechaunGameConfig.instance.LAYERS.FOREGROUND.name);
						t.orientation === r.Orientation.PORTRAIT || .5 * (t.width - o.GameConfig.instance.REEL_AREA_WIDTH) < 234 ? e.removeChild(this) : (e.addChild(this), o.GameConfig.instance.SYMBOL_WIDTH, s.Helper.getSymbolPositions(0, 0)[0], this._wrapper.scale.set(.8, .8), this._wrapper.x = -147, this._wrapper.y = 120, this._panel.y = -14, this._symbolSprites.forEach(((t, e) => {
							t.symbol.x = 80, t.symbol.y = 32 + 99 * e
						})))
					}
					onResizeContainer(t) {
						if (!this._wrapper || !d.UserAgent.isMobile) return;
						const e = t.width / t.height < 1.4,
							i = o.GameConfig.instance.SYMBOL_WIDTH,
							n = s.Helper.getSymbolPositions(0, 0)[0],
							r = s.Helper.getSymbolPositions(2, 0)[0];
						this._wrapper.x = h.GameSetting.isLeftHanded ? r + i : e ? n - 1.15 * i : -147
					}
				}
				e.LandscapePaytable = p
			},
			64543: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.MiniPayTable = void 0;
				const n = i(73044),
					s = i(34785),
					o = i(52409),
					r = i(330),
					a = i(59848),
					l = i(57244),
					h = i(15904),
					u = i(66493),
					c = i(88240),
					d = i(4621);
				class p extends n.BaseView {
					constructor(t) {
						super(), this._symbolSprites = [], this._xOffset = 0, this._hasParsedInitData = !1, this._config = t
					}
					addEventListeners() {
						o.EventHandler.addEventListener(this, a.BalanceEvent.CURRENT_BET, (t => this.onChangeBet(t.params[0]))), o.EventHandler.addEventListener(this, r.ServerEvent.INIT_DATA_PARSED, (t => this.onInitGameDataParsed(t.params[0]))), o.EventHandler.addEventListener(this, h.ScreenEvent.GAME_READY, (t => this.update()))
					}
					onInitGameDataParsed(t) {
						this._hasParsedInitData = !0, this._symbolValues = t.symbolValues
					}
					update() {
						this._hasParsedInitData && this._symbolSprites.forEach(((t, e) => {
							const i = this._symbolValues[this._config.values[e]][3] * l.MathHelper.roundToDecimals(this._currentBet / 5, 2);
							t.text.text = i.toFixed(i >= 10 && Number.isInteger(i) ? 0 : 2).toString()
						}))
					}
					onChangeBet(t) {
						this._currentBet = parseFloat(t), this.update()
					}
					initAnimations() {
						this._wrapper = new PIXI.Sprite, this._panel = new PIXI.Sprite(c.GameResources.getTextures(d.LeprechaunGameAssets.MINI_PAYTABLE_PORTRAIT)[0]), this._panel.blendMode = PIXI.BLEND_MODES.MULTIPLY, this._panel.anchor.set(0), this._panel.position.set(0, 0), this._wrapper.addChild(this._panel), this.addChild(this._wrapper), this._symbolSprites = s.ArrayHelper.initArrayWithValues(this._config.symbols.length, (t => this.createSymbolContainer(t)))
					}
					createSymbolContainer(t) {
						const e = new PIXI.Sprite,
							i = new PIXI.Sprite(c.GameResources.getTextures("miniPayTable" + this._config.symbols[t])[0]);
						i.scale.set(.35, .35), i.anchor.set(.5, .5);
						const n = new PIXI.Text((10 * l.MathHelper.roundToDecimals(this._currentBet / 5, 2)).toFixed(2).toString(), this._config.textStyle);
						return n.anchor.set(.5, 0), n.position.set(0, i.height / 2), i.position.set(0, i.height / 2 - n.height), e.addChild(n), e.addChild(i), this._wrapper.addChild(e), {
							symbol: e,
							text: n
						}
					}
					onResize(t) {
						this._panel.texture = c.GameResources.getTextures(t.orientation === u.Orientation.PORTRAIT ? d.LeprechaunGameAssets.MINI_PAYTABLE_PORTRAIT : d.LeprechaunGameAssets.MINI_PAYTABLE_LANSCAPE)[0], this._xOffset = t.orientation === u.Orientation.PORTRAIT ? 0 : 80, this.update()
					}
				}
				e.MiniPayTable = p
			},
			92383: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PortraitPaytable = void 0;
				const n = i(85206),
					s = i(56682),
					o = i(75367),
					r = i(48002),
					a = i(66493),
					l = i(64543);
				class h extends l.MiniPayTable {
					constructor(t) {
						super(t)
					}
					onResize(t) {
						if (super.onResize(t), t.orientation != a.Orientation.PORTRAIT) return void n.StageManager.getLayer(r.LeprechaunGameConfig.instance.LAYERS.FOREGROUND.name).removeChild(this);
						this._wrapper.scale.set(1, 1);
						const e = t.width / t.height >= .73,
							i = e ? .8 : 1;
						n.StageManager.getLayer(r.LeprechaunGameConfig.instance.LAYERS.FOREGROUND.name).addChild(this);
						const l = o.GameConfig.instance.SYMBOL_WIDTH,
							h = o.GameConfig.instance.SYMBOL_HEIGHT,
							u = s.Helper.getSymbolPositions(0, 0)[0],
							c = s.Helper.getSymbolPositions(0, 0)[1];
						this._wrapper.scale.set(i, i), this._wrapper.x = u - .87 * l + (e ? 70 : 0) + 6, this._wrapper.y = c - 1.8 * h + (e ? 40 : 0), this._panel.y = 0, this._symbolSprites.forEach(((t, e) => {
							t.symbol.x = 70 + 120 * e, t.symbol.y = 60
						}))
					}
				}
				e.PortraitPaytable = h
			},
			56005: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunGameMode = void 0;
				const n = i(83673);
				class s extends n.GameMode {}
				e.LeprechaunGameMode = s, s.FS_PICK = "FREESPIN_PICKS"
			},
			5044: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.HotZone = void 0;
				const n = i(46289),
					s = i(53873),
					o = i(52409),
					r = i(32696);
				class a extends n.BaseController {
					constructor() {
						super(), this._view = new s.HotZoneView, this.addEventListener()
					}
					addEventListener() {
						o.EventHandler.addEventListener(this, r.SpinEvent.BEFORE_START, (t => this.onSpinStart()))
					}
					onSpinStart() {
						this._view.show()
					}
					hide(t) {
						this._view.hide(t)
					}
					playHotZoneWinStar() {
						this._view.playHotZoneWinStar()
					}
					stopHotZoneWinStar() {
						this._view.stopHotZoneWinStar()
					}
				}
				e.HotZone = a
			},
			53873: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.HotZoneView = void 0;
				const n = i(73044),
					s = i(88240),
					o = i(85206),
					r = i(56682),
					a = i(7057),
					l = i(13006),
					h = i(48002);
				class u extends n.BaseView {
					constructor() {
						super(), this._layer = o.StageManager.getLayer(h.LeprechaunGameConfig.instance.LAYERS.HOTZONE.name)
					}
					initAnimations() {
						this._hotZoneStar = new a.TimelineSprite(s.GameResources.getTextures("hotZone")), this._hotZoneStar.blendMode = PIXI.BLEND_MODES.ADD, this._hotZoneStar.alpha = .6, this._hotZoneStar.hide(), this._hotZoneStar.anchor.set(.5, .5), this._hotZoneStar.position.set(r.Helper.getSymbolPositions(1, 1)[0], r.Helper.getSymbolPositions(1, 1)[1]), this._layer.addChild(this._hotZoneStar), this._hotZoneWinStar = new a.TimelineSprite(s.GameResources.getTextures("hotZoneWin")), this._hotZoneWinStar.blendMode = PIXI.BLEND_MODES.ADD, this._hotZoneWinStar.hide(), this._hotZoneWinStar.anchor.set(.5, .5), this._hotZoneWinStar.position.set(r.Helper.getSymbolPositions(1, 1)[0], r.Helper.getSymbolPositions(1, 1)[1]), this._layer.addChild(this._hotZoneWinStar)
					}
					onResize(t) {
						this._hotZoneStar.position.set(r.Helper.getSymbolPositions(1, 1)[0], r.Helper.getSymbolPositions(1, 1)[1])
					}
					show() {
						(new l.TimelineLite).add([this._hotZoneStar.getAnimationAutoShowHide(!0, !0), l.TweenLite.fromTo(this._hotZoneStar, .5, {
							alpha: 0
						}, {
							alpha: .6
						})])
					}
					hide(t) {
						(new l.TimelineLite).add([l.TweenLite.fromTo(this._hotZoneStar, t ? 0 : .3, {
							alpha: .6
						}, {
							alpha: 0
						}), () => {
							this._hotZoneStar.hide()
						}])
					}
					stopHotZoneWinStar() {
						this._hotZoneWinStar.stopLoop(), this._hotZoneWinStar.hide()
					}
					playHotZoneWinStar() {
						(new l.TimelineLite).add([() => {
							this.hide(!0), this._hotZoneWinStar.show(), this._hotZoneWinStar.playLoop()
						}, l.TweenLite.fromTo(this._hotZoneWinStar, .2, {
							alpha: 0
						}, {
							alpha: 1
						})])
					}
				}
				e.HotZoneView = u
			},
			23287: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunSymbolIdleAnimation = void 0;
				const n = i(44747),
					s = i(63114),
					o = i(57244),
					r = i(75367);
				class a extends n.SymbolIdleAnimationController {
					constructor(t) {
						super(t)
					}
					playIdleAnimation() {
						if (!this._hasSymbolIdle) return;
						const t = o.MathHelper.randomNumberInRange(0, r.GameConfig.instance.REELS_NUM - 1),
							e = o.MathHelper.randomNumberInRange(0, r.GameConfig.instance.SYMBOLS_NUM_IN_REEL[2] - 1);
						s.LeprechaunGameModuleConfig.symbolWinAnimation.playIdleAnimation(t, e, !1)
					}
				}
				e.LeprechaunSymbolIdleAnimation = a
			},
			37881: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunIntroConfig = void 0;
				const n = i(92047),
					s = i(61e3),
					o = i(72468),
					r = i(23110),
					a = i(58295),
					l = i(40745),
					h = i(4621),
					u = i(1394),
					c = i(49490),
					d = i(77616);
				class p {
					constructor() {
						this.colors = {
							slideShowColors: {
								backgroundColor: 0,
								bulletColor: 16777215
							},
							stampColor: 16777215
						}, this.stampConfig = {
							xWays: !1,
							xNudge: !0,
							volatility: n.Volatility.MEDIUM
						}, this._winUpTo = "Win more than", this._timesBet = " 9 800x ", this._bet = "bet"
					}
					gameClientConfigurationApplied(t) {
						u.Leprechaun.api.gameClientConfiguration.explicitContentWarning && (u.Leprechaun.api.gameClientConfiguration.explicitContentWarning = !1)
					}
					init() {
						const t = new s.ImgLoader(o.NolimitApplication.resourcePath);
						return t.add(p.INTRO_BG, p.INTRO_BG), t.add(p.INTRO_LOGO, p.INTRO_LOGO), t.add(p.INTRO_FEATURE_1, p.INTRO_FEATURE_1), t.add(p.INTRO_FEATURE_2, p.INTRO_FEATURE_2), t.add(p.INTRO_DIVIDER, p.INTRO_DIVIDER), t.load().then((t => (this.initGraphics(), this)))
					}
					initGraphics() {
						this.background = new PIXI.Container;
						const t = new PIXI.Sprite(s.ImgLoader.getImgTexture(p.INTRO_BG));
						t.anchor.set(.5, .5), this.background.addChild(t), this.borderTop = new PIXI.Container;
						const e = new PIXI.TilingSprite(s.ImgLoader.getImgTexture(p.INTRO_DIVIDER), 1680, 126);
						e.anchor.set(.5, .5), this.borderTop.addChild(e), this.borderBottom = new PIXI.Container;
						const i = new PIXI.TilingSprite(s.ImgLoader.getImgTexture(p.INTRO_DIVIDER), 1680, 126);
						i.anchor.set(.5, .5), this.borderBottom.addChild(i), this.logo = new PIXI.Container;
						const n = new PIXI.Sprite(s.ImgLoader.getImgTexture(p.INTRO_LOGO));
						n.anchor.set(.5, .5), n.scale.set(.6, .6), this.logo.addChild(n);
						const o = new PIXI.Container;
						o.position.set(10, -165);
						const h = new PIXI.TextStyle({
								fill: "#ffffff",
								fontFamily: "Open Sans",
								fontSize: 28,
								fontStyle: d.FontStyle.NORMAL,
								fontWeight: d.FontWeight.NORMAL,
								wordWrap: !0,
								wordWrapWidth: 340,
								breakWords: !0
							}),
							_ = l.Translation.translate(this._winUpTo) + this._timesBet + l.Translation.translate(this._bet) + "!",
							m = "\n\n\n" + r.SlotGame.api.translations.translate("Coins awards extra spin, increased multiplier or added rainbow lines in Rainbow Spins!"),
							g = r.SlotGame.api.translations.translate("Each nudge increases the Wild multiplier by 1!");
						this.pages = [new a.SlideShowPage(s.ImgLoader.getImgTexture(p.INTRO_FEATURE_1), m), new a.SlideShowPage(s.ImgLoader.getImgTexture(p.INTRO_FEATURE_2), g)], this.pages[0].addChild(o), u.Leprechaun.api.gameClientConfiguration.isSet ? !1 !== u.Leprechaun.api.gameClientConfiguration.showLowProbabilityGfx && o.addChild(new PIXI.Text(_, h)) : u.Leprechaun.api.events.once(c.APIEvent.GAME_CLIENT_CONFIGURATION_APPLIED, (() => {
							!1 !== u.Leprechaun.api.gameClientConfiguration.showLowProbabilityGfx && o.addChild(new PIXI.Text(_, h))
						}))
					}
				}
				e.LeprechaunIntroConfig = p, p.INTRO_BG = h.LeprechaunGameAssets.INTRO_BACKGROUND, p.INTRO_LOGO = h.LeprechaunGameAssets.INTRO_LOGO, p.INTRO_FEATURE_1 = "resources/images/intro/Intro_Feature_1.png", p.INTRO_FEATURE_2 = "resources/images/intro/Intro_Feature_2.png", p.INTRO_DIVIDER = "resources/images/intro/Intro_Divider.png"
			},
			99069: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.REWinFieldController = void 0;
				const n = i(91265),
					s = i(23110),
					o = i(63114);
				class r extends n.WinFieldController {
					showWinField(t, e = !1, i = !1) {
						if (this.shouldShow()) {
							if (t = null != t ? t : this._totalWin, !e && (i || this._shouldShowTotalWin || this._shouldNextShowTotalWin)) return void s.SlotGame.keypad.setWin(t, !0, o.LeprechaunGameModuleConfig.featurePrice.isWinBelowStake());
							s.SlotGame.keypad.setWin(t)
						}
					}
				}
				e.REWinFieldController = r
			},
			372: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Logo = void 0;
				const n = i(73044),
					s = i(52409),
					o = i(75367),
					r = i(83673),
					a = i(88240),
					l = i(15904),
					h = i(330),
					u = i(85206),
					c = i(56682),
					d = i(7057),
					p = i(77616),
					_ = i(13006),
					m = i(15807),
					g = i(4621),
					f = i(48002);
				class S extends n.BaseView {
					constructor() {
						super(), this._pickedExtraMultiplier = 0
					}
					addEventListeners() {
						s.EventHandler.addEventListener(this, h.ServerEvent.INIT_DATA_PARSED, (t => this.parsedInitData(t.params[0]))), s.EventHandler.addEventListener(this, m.LeprechaunBetlineEvent.HIDE_RAINBOW_NUMBER, (t => this.hideMultiplier())), s.EventHandler.addEventListener(this, l.ScreenEvent.GAME_READY, (t => this.onGameReady()))
					}
					parsedInitData(t) {
						t.mode === r.GameMode.FREESPIN && t.isRestoreState && (this._pickedExtraMultiplier = t.freespinMultiplier, this._isRestore = !0)
					}
					onGameReady() {
						this._isRestore && (this._isRestore = !1, this._isFreespin = !0, this._multiplierBg.alpha = 1, this._multiplierBg.position.set(c.Helper.getSymbolPositions(2, 0)[0], this.getPosY() - 44), this._multiplierBg.scale.set(1, 1), this._multiplier.text = "x" + this._pickedExtraMultiplier.toString(), this._logo.position.set(o.GameConfig.instance.REEL_AREA_POS_X + 60, this.getPosY()))
					}
					initAnimations() {
						const t = new PIXI.Sprite(a.GameResources.getTextures(g.LeprechaunGameAssets.INTRO_LOGO)[0]);
						t.scale.set(.6, .6), t.anchor.set(0, 1), u.StageManager.getLayer(f.LeprechaunGameConfig.instance.LAYERS.LOGO.name).addChild(t), this._logo = t;
						const e = new PIXI.Sprite(a.GameResources.getTextures("multiplierClover")[0]);
						e.anchor.set(.5, .5), u.StageManager.getLayer(f.LeprechaunGameConfig.instance.LAYERS.LOGO.name).addChild(e), this._multiplierBg = e;
						const i = new d.TimelineSprite(a.GameResources.getTextures("winStar"));
						i.anchor.set(.5, .5), i.scale.set(.5, .5), i.blendMode = PIXI.BLEND_MODES.ADD, i.hide();
						const n = new PIXI.Text("", {
							fontWeight: p.FontWeight.EXTRA_BOLD,
							fontFamily: "Open Sans",
							fontSize: 32,
							dropShadow: !0,
							dropShadowAngle: 89.5,
							dropShadowBlur: 2,
							dropShadowColor: "#2d6916",
							dropShadowDistance: 4,
							fill: "#fffdec"
						});
						n.anchor.set(.5, .5), n.position.set(0, 0), e.addChild(n), e.addChild(i), this._multiplier = n, this._multiplierHighlightAnim = i, this._multiplierBg.alpha = 0
					}
					showMultiplier(t) {
						this._isFreespin = !0, this._multiplierBg.alpha = 0, this._multiplierBg.position.set(c.Helper.getSymbolPositions(2, 0)[0], this.getPosY() - 44), this._multiplierBg.scale.set(3, 3), this._multiplier.text = "x" + t.toString(), this._logo.position.set(o.GameConfig.instance.REEL_AREA_POS_X + 60, this.getPosY()), (new _.TimelineLite).add([_.TweenLite.to(this._multiplierBg, .1, {
							alpha: 1
						}), _.TweenLite.to(this._multiplierBg.scale, .5, {
							x: 1,
							y: 1
						})])
					}
					hideMultiplier() {
						this._isFreespin = !1, this._logo.position.set(c.Helper.getSymbolPositions(1, 0)[0] - .5 * this._logo.width, this.getPosY()), _.TweenLite.to(this._multiplierBg.scale, .17, {
							x: .8,
							y: .8
						}), _.TweenLite.to(this._multiplierBg, .1, {
							alpha: 0
						})
					}
					onResize(t) {
						const e = c.Helper.getSymbolPositions(1, 0)[0],
							i = c.Helper.getSymbolPositions(2, 0)[0];
						this._logo.position.set(this._isFreespin ? o.GameConfig.instance.REEL_AREA_POS_X + 60 : e - .5 * this._logo.width, this.getPosY()), this._multiplierBg.position.set(i, this.getPosY() - 44)
					}
					getPosY() {
						return o.GameConfig.instance.REEL_AREA_POS_Y
					}
					playMultiplierAnimation() {
						_.TweenMax.fromTo(this._multiplierBg.scale, .1, {
							x: 1,
							y: 1
						}, {
							x: 1.3,
							y: 1.3,
							yoyo: !0,
							repeat: 1
						}), this._multiplierHighlightAnim.getAnimationAutoShowHide(!0, !0)
					}
				}
				e.Logo = S
			},
			31544: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.NearWinBackground = void 0;
				const n = i(73044),
					s = i(52409),
					o = i(91812),
					r = i(88240),
					a = i(330),
					l = i(23110),
					h = i(32696),
					u = i(85206),
					c = i(34785),
					d = i(56682),
					p = i(52601),
					_ = i(7057),
					m = i(13006),
					g = i(48002),
					f = i(4773);
				class S extends n.BaseView {
					constructor() {
						super(), this._bonusFeatureTriggered = !1, this._layer = u.StageManager.getLayer(g.LeprechaunGameConfig.instance.LAYERS.FOREGROUND.name)
					}
					addEventListeners() {
						s.EventHandler.addEventListener(this, h.SpinEvent.BEFORE_START, (t => this.onSpinStart())), s.EventHandler.addEventListener(this, a.ServerEvent.GAME_DATA_PARSED, (t => this.onGameDataParsed(t.params[0]))), s.EventHandler.addEventListener(this, p.SpinReelEvent.REEL_ON_NEAR_WIN, (t => this.onPlayReelNearWinAttention(t.params[0]))), s.EventHandler.addEventListener(this, o.ReelEvent.REEL_STOP_SPIN_ANIMATION_COMPLETE, (t => this.onReelSpinAnimationComplete(t.params[0])))
					}
					initAnimations() {
						this._nearWinBGs = c.ArrayHelper.initArrayWithValues(3, (t => this.createBG(t))), this._layer.addChild(this)
					}
					onGameDataParsed(t) {
						this._bonusFeatureTriggered = t.bonusFeatureTriggered
					}
					createBG(t) {
						const e = new _.TimelineSprite(r.GameResources.getTextures("reelExcitement"));
						return e.blendMode = PIXI.BLEND_MODES.ADD, e.hide(), e.anchor.set(.5, .5), e.position.set(d.Helper.getSymbolPositions(t, 1)[0], d.Helper.getSymbolPositions(t, 1)[1] + 20), this.addChild(e), e
					}
					onSpinStart() {
						this._activeReelId = -1
					}
					onPlayReelNearWinAttention(t) {
						this._activeReelId = t, this._nearWinBGs[t].alpha = 1, this._nearWinBGs[t].show(), this._nearWinBGs[t].playLoop(), l.SlotGame.sound.playEffect(f.LeprechaunSoundConfig.instance.ANTICIPATION)
					}
					onReelSpinAnimationComplete(t) {
						t.reelId == this._activeReelId && this._nearWinBGs.forEach(((t, e) => {
							t.hide(), t.stopLoop()
						}))
					}
					hide(t) {
						(new m.TimelineLite).add([m.TweenLite.to(this._nearWinBGs[t], .3, {
							alpha: 0
						}), () => {
							this._nearWinBGs[t].hide(), this._nearWinBGs[t].stopLoop()
						}])
					}
				}
				e.NearWinBackground = S
			},
			64989: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.CoinsFountain = void 0;
				const n = i(73044),
					s = i(75367),
					o = i(46109),
					r = i(88240),
					a = i(7615),
					l = i(56682);
				class h extends n.BaseView {
					constructor(t) {
						super(), this._screenHeightRange = [720, 1760], this._startSpeedRange = [650, 950], this._coinsConfigs = [{
							alpha: {
								start: 1,
								end: 1
							},
							scale: {
								start: .5,
								end: .8,
								minimumScaleMultiplier: 1
							},
							color: {
								start: "#ffffff",
								end: "#ffffff"
							},
							speed: {
								start: 700,
								end: 350,
								minimumSpeedMultiplier: 2
							},
							acceleration: {
								x: 0,
								y: 1500
							},
							maxSpeed: 0,
							startRotation: {
								min: 235,
								max: 310
							},
							noRotation: !1,
							rotationSpeed: {
								min: 10,
								max: 70
							},
							lifetime: {
								min: 2,
								max: 2
							},
							blendMode: "normal",
							frequency: .06,
							emitterLifetime: -1,
							maxParticles: 150,
							pos: {
								x: s.GameConfig.instance.GAME_WIDTH / 2,
								y: s.GameConfig.instance.GAME_HEIGHT + 40
							},
							addAtBack: !1,
							spawnType: "rect",
							spawnRect: {
								x: -100,
								y: -25,
								w: 200,
								h: 50
							}
						}, {
							alpha: {
								start: 1,
								end: 1
							},
							scale: {
								start: .7,
								end: 1,
								minimumScaleMultiplier: 1
							},
							color: {
								start: "#ffffff",
								end: "#ffffff"
							},
							speed: {
								start: 700,
								end: 350,
								minimumSpeedMultiplier: 2
							},
							acceleration: {
								x: 0,
								y: 1500
							},
							maxSpeed: 0,
							startRotation: {
								min: 235,
								max: 310
							},
							noRotation: !1,
							rotationSpeed: {
								min: 20,
								max: 40
							},
							lifetime: {
								min: 2,
								max: 2
							},
							blendMode: "normal",
							frequency: .06,
							emitterLifetime: -1,
							maxParticles: 200,
							pos: {
								x: s.GameConfig.instance.GAME_WIDTH / 2,
								y: s.GameConfig.instance.GAME_HEIGHT + 40
							},
							addAtBack: !1,
							spawnType: "rect",
							spawnRect: {
								x: -100,
								y: -25,
								w: 200,
								h: 50
							}
						}, {
							alpha: {
								start: 1,
								end: 1
							},
							scale: {
								start: .7,
								end: 1,
								minimumScaleMultiplier: 1
							},
							color: {
								start: "#ffffff",
								end: "#ffffff"
							},
							speed: {
								start: 700,
								end: 350,
								minimumSpeedMultiplier: 2
							},
							acceleration: {
								x: 0,
								y: 1500
							},
							maxSpeed: 0,
							startRotation: {
								min: 235,
								max: 310
							},
							noRotation: !1,
							rotationSpeed: {
								min: 20,
								max: 40
							},
							lifetime: {
								min: 2,
								max: 2
							},
							blendMode: "normal",
							frequency: .1,
							emitterLifetime: -1,
							maxParticles: 200,
							pos: {
								x: s.GameConfig.instance.GAME_WIDTH / 2,
								y: s.GameConfig.instance.GAME_HEIGHT + 40
							},
							addAtBack: !1,
							spawnType: "rect",
							spawnRect: {
								x: -100,
								y: -25,
								w: 200,
								h: 50
							}
						}], this._isPlaying = !1, this._layer = t
					}
					initAnimations() {
						this._coinsEmiters = [], this._coinsConfigs.forEach(((t, e) => {
							const i = new a.Emitter(this._layer, [{
								framerate: 30,
								loop: !0,
								hasLoaded: !0,
								textures: r.GameResources.getTextures(`bigWinCoin${e}`)
							}], t);
							i.particleConstructor = a.AnimatedParticle, o.LeParticlesManager.addEmitter(i, !1), this._coinsEmiters.push(i)
						}))
					}
					startFountain(t) {
						this._isPlaying = !0, this._isResizeDirty && this.onResize(this._resizeData), this._coinsEmiters.forEach(((e, i) => {
							i <= t && (e.emit = !0)
						}))
					}
					stopFountain() {
						this._isPlaying = !1, this._coinsEmiters.forEach((t => {
							t.emit = !1
						}))
					}
					onResize(t) {
						if (this._resizeData = t, !this._isPlaying) return void(this._isResizeDirty = !0);
						this._isResizeDirty = !1;
						let e = Math.round(t.height / this._layer.scale.y);
						e = Math.max(this._screenHeightRange[0], Math.min(e, this._screenHeightRange[1]));
						const i = Math.round((e - this._screenHeightRange[0]) * (this._startSpeedRange[1] - this._startSpeedRange[0]) / (this._screenHeightRange[1] - this._screenHeightRange[0]) + this._startSpeedRange[0]),
							n = Math.round((t.height - this._layer.y) / this._layer.scale.y) + 40,
							s = l.Helper.getSymbolPositions(1, 1)[0];
						this._coinsEmiters.forEach(((t, e) => {
							const o = i * (1.2 + .05 * e);
							t.cleanup(), t.startSpeed = new a.PropertyNode(o, o), t.spawnPos.y = n, t.spawnPos.x = s
						}))
					}
				}
				e.CoinsFountain = h
			},
			86082: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.ParticleConfigs = void 0;
				class i {}
				e.ParticleConfigs = i, i.splashRingUpper = {
					alpha: {
						start: 1,
						end: 0
					},
					scale: {
						start: .25,
						end: 1.5,
						minimumScaleMultiplier: .5
					},
					color: {
						start: "#ffffff",
						end: "#ffffff"
					},
					speed: {
						start: 0,
						end: 0,
						minimumSpeedMultiplier: 1
					},
					acceleration: {
						x: 0,
						y: 0
					},
					maxSpeed: 0,
					startRotation: {
						min: 0,
						max: 360
					},
					noRotation: !0,
					rotationSpeed: {
						min: 0,
						max: 10
					},
					lifetime: {
						min: 1,
						max: 1.8
					},
					blendMode: "add",
					frequency: .8,
					emitterLifetime: -1,
					maxParticles: 3,
					pos: {
						x: 0,
						y: 620
					},
					addAtBack: !1,
					spawnType: "ring",
					spawnCircle: {
						x: 0,
						y: 0,
						r: 13,
						minR: 5
					}
				}, i.splashRingMid = {
					alpha: {
						start: 1,
						end: 0
					},
					scale: {
						start: .2,
						end: 1.5,
						minimumScaleMultiplier: .5
					},
					color: {
						start: "#ffffff",
						end: "#ffffff"
					},
					speed: {
						start: 0,
						end: 0,
						minimumSpeedMultiplier: 1
					},
					acceleration: {
						x: 0,
						y: 0
					},
					maxSpeed: 0,
					startRotation: {
						min: 0,
						max: 360
					},
					noRotation: !0,
					rotationSpeed: {
						min: 0,
						max: 10
					},
					lifetime: {
						min: .7,
						max: 1.5
					},
					blendMode: "add",
					frequency: 1,
					emitterLifetime: -1,
					maxParticles: 2,
					pos: {
						x: 250,
						y: 710
					},
					addAtBack: !1,
					spawnType: "ring",
					spawnCircle: {
						x: 0,
						y: 0,
						r: 16,
						minR: 5
					}
				}, i.splashRingLower = {
					alpha: {
						start: 1,
						end: 0
					},
					scale: {
						start: .25,
						end: 2,
						minimumScaleMultiplier: .5
					},
					color: {
						start: "#ffffff",
						end: "#ffffff"
					},
					speed: {
						start: 0,
						end: 0,
						minimumSpeedMultiplier: 1
					},
					acceleration: {
						x: 0,
						y: 0
					},
					maxSpeed: 0,
					startRotation: {
						min: 0,
						max: 360
					},
					noRotation: !0,
					rotationSpeed: {
						min: 0,
						max: 10
					},
					lifetime: {
						min: 1,
						max: 1.4
					},
					blendMode: "add",
					frequency: .5,
					emitterLifetime: -1,
					maxParticles: 2,
					pos: {
						x: 550,
						y: 780
					},
					addAtBack: !1,
					spawnType: "ring",
					spawnCircle: {
						x: 0,
						y: 0,
						r: 40,
						minR: 5
					}
				}, i.rainDrops = {
					alpha: {
						start: 0,
						end: .66
					},
					scale: {
						start: 2.5,
						end: .01,
						minimumScaleMultiplier: .5
					},
					color: {
						start: "#ffffff",
						end: "#ffffff"
					},
					speed: {
						start: 397,
						end: 413,
						minimumSpeedMultiplier: 1
					},
					acceleration: {
						x: 0,
						y: 0
					},
					maxSpeed: 0,
					startRotation: {
						min: 90,
						max: 90
					},
					noRotation: !0,
					rotationSpeed: {
						min: 0,
						max: 0
					},
					lifetime: {
						min: .47,
						max: 2
					},
					blendMode: "add",
					ease: [{
						s: 0,
						cp: .379,
						e: .548
					}, {
						s: .548,
						cp: .717,
						e: .676
					}, {
						s: .676,
						cp: .635,
						e: 1
					}],
					frequency: .1,
					emitterLifetime: -1,
					maxParticles: 20,
					pos: {
						x: 360,
						y: 0
					},
					addAtBack: !1,
					spawnType: "rect",
					spawnRect: {
						x: -640,
						y: -280,
						w: 1280,
						h: 20
					}
				}, i.sparkleParticles = {
					alpha: {
						start: 0,
						end: 1
					},
					scale: {
						start: .5,
						end: .01,
						minimumScaleMultiplier: 1
					},
					color: {
						start: "#ffffff",
						end: "#ffffff"
					},
					speed: {
						start: 0,
						end: 0,
						minimumSpeedMultiplier: 1
					},
					acceleration: {
						x: 0,
						y: 0
					},
					maxSpeed: 0,
					startRotation: {
						min: 0,
						max: 50
					},
					noRotation: !1,
					rotationSpeed: {
						min: 0,
						max: 9
					},
					lifetime: {
						min: .86,
						max: 1.5
					},
					blendMode: "add",
					frequency: .8,
					emitterLifetime: -1,
					maxParticles: 4,
					pos: {
						x: 360,
						y: 0
					},
					addAtBack: !1,
					spawnType: "rect",
					spawnRect: {
						x: 0,
						y: 0,
						w: 438,
						h: 158
					}
				}, i.sparkleParticlesSmall = {
					alpha: {
						start: 0,
						end: 1
					},
					scale: {
						start: .4,
						end: .01,
						minimumScaleMultiplier: 1
					},
					color: {
						start: "#ffffff",
						end: "#ffffff"
					},
					speed: {
						start: 0,
						end: 0,
						minimumSpeedMultiplier: 1
					},
					acceleration: {
						x: 0,
						y: 0
					},
					maxSpeed: 0,
					startRotation: {
						min: 0,
						max: 50
					},
					noRotation: !1,
					rotationSpeed: {
						min: 0,
						max: 9
					},
					lifetime: {
						min: .86,
						max: 2.13
					},
					blendMode: "add",
					frequency: .7,
					emitterLifetime: -1,
					maxParticles: 2,
					pos: {
						x: 154,
						y: 100
					},
					addAtBack: !1,
					spawnType: "rect",
					spawnRect: {
						x: 0,
						y: 0,
						w: 160,
						h: 96
					}
				}, i.sparkleParticlesPNC = {
					alpha: {
						start: 0,
						end: 1
					},
					scale: {
						start: .4,
						end: .01,
						minimumScaleMultiplier: 1
					},
					color: {
						start: "#ffffff",
						end: "#ffffff"
					},
					speed: {
						start: 0,
						end: 0,
						minimumSpeedMultiplier: 1
					},
					acceleration: {
						x: 0,
						y: 0
					},
					maxSpeed: 0,
					startRotation: {
						min: 0,
						max: 50
					},
					noRotation: !1,
					rotationSpeed: {
						min: 0,
						max: 9
					},
					lifetime: {
						min: .86,
						max: 2.13
					},
					blendMode: "add",
					frequency: .5,
					emitterLifetime: -1,
					maxParticles: 5,
					pos: {
						x: 360,
						y: 360
					},
					addAtBack: !1,
					spawnType: "rect",
					spawnRect: {
						x: 0,
						y: 0,
						w: 900,
						h: 300
					}
				}
			},
			22353: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.Rainbow = void 0;
				const n = i(73044),
					s = i(88240),
					o = i(59854),
					r = i(7615),
					a = i(86082),
					l = i(13006);
				class h extends n.BaseView {
					constructor() {
						super()
					}
					initAnimations() {}
					createRainbow(t) {
						this._rainbow = new PIXI.Sprite(s.GameResources.getTextures("pncRainbow")[0]), this._rainbow.anchor.set(.5, .5), this._rainbow.position.set(0, 208), this._rainbow.scale.set(4, 4), t.addChild(this._rainbow), this._rainbowParticles = new r.Emitter(t, [{
							framerate: 30,
							loop: !0,
							hasLoaded: !0,
							textures: [s.GameResources.getTextures("defaultParticle")[0]]
						}], a.ParticleConfigs.sparkleParticlesPNC), this._rainbowParticles.particleConstructor = r.AnimatedParticle, o.ParticlesManager.addEmitter(this._rainbowParticles, !1)
					}
					show(t = !1) {
						(new l.TimelineLite).add([() => {
							this._rainbowParticles.emit = !0
						}, l.TweenLite.to(this._rainbow, t ? 0 : 1, {
							alpha: 1
						})])
					}
					hide() {
						this._rainbowParticles.emit = !1, this._rainbow.alpha = 0
					}
					animateHide() {
						return (new l.TimelineLite).add([() => {
							this._rainbowParticles.emit = !1
						}, l.TweenLite.to(this._rainbow, .6, {
							alpha: 0
						})])
					}
				}
				e.Rainbow = h
			},
			719: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.CollectMeter = void 0;
				const n = i(73044),
					s = i(52409),
					o = i(44679),
					r = i(88240),
					a = i(23110),
					l = i(66493),
					h = i(40745),
					u = i(34785),
					c = i(56682),
					d = i(57244),
					p = i(77616),
					_ = i(13006),
					m = i(15807),
					g = i(63114),
					f = i(4773);
				class S extends n.BaseView {
					constructor() {
						super(), this.COLLECT_LINE_TEXTS = [
							["EXTRA_SPINS", "EXTRA SPINS", "+2", "+"],
							["EXTRA_LINES", "RAINBOW LINES", "+2", ""],
							["EXTRA_MULTIPLIER", "MULTIPLIER", "+1", "x"]
						], this.COLLECT_LINE_Y = [110, 190, 270], this.COLLECT_LINE_DOTS_NR = [3, 2, 3], this._meterNameTextStyle = {
							fontFamily: "Open Sans",
							fontSize: 40,
							fill: 16777215,
							fontWeight: p.FontWeight.EXTRA_BOLD
						}, this._coinTextStyle = {
							fontFamily: "Open Sans",
							fontSize: 44,
							fontWeight: p.FontWeight.EXTRA_BOLD,
							align: "center",
							wordWrap: !0,
							wordWrapWidth: 300,
							dropShadow: !0,
							dropShadowAngle: 89.5,
							dropShadowBlur: 1,
							dropShadowColor: "#6a3c40",
							dropShadowDistance: 4,
							fill: ["#fffdec", "#fff2a8", "#ffc133"],
							lineJoin: "round",
							miterLimit: 7,
							stroke: "#6a3c40",
							strokeThickness: 4
						}, this._dotValueStyle = {
							fontFamily: "Open Sans",
							fontSize: 38,
							fontWeight: p.FontWeight.EXTRA_BOLD,
							wordWrap: !0,
							align: "center",
							wordWrapWidth: 100,
							dropShadow: !0,
							dropShadowAngle: 89.5,
							dropShadowBlur: 1,
							dropShadowColor: "#6a3c40",
							dropShadowDistance: 4,
							fill: ["#fffdec", "#fff2a8", "#ffc133"],
							lineJoin: "round",
							miterLimit: 7,
							stroke: "#6a3c40",
							strokeThickness: 4
						}, this._coinResultNumberStyle = {
							fontFamily: "Open Sans",
							fontSize: 130,
							fontWeight: p.FontWeight.EXTRA_BOLD,
							wordWrap: !0,
							align: "center",
							wordWrapWidth: 300,
							breakWords: !0,
							dropShadow: !0,
							dropShadowAngle: 89.5,
							dropShadowBlur: 1,
							dropShadowColor: "#6a3c40",
							dropShadowDistance: 4,
							fill: ["#fffdec", "#fff2a8", "#ffc133"],
							lineJoin: "round",
							miterLimit: 7,
							stroke: "#6a3c40",
							strokeThickness: 4
						}, this._resultPos = [
							[300, 20],
							[-300, -150],
							[-300, 90]
						], this._resultScale = .8
					}
					createMeter(t) {
						this._resultWrapper = new PIXI.Sprite, this._resultWrapper.position.set(360, 360), this.addChild(this._resultWrapper), this._collectMeters = [], this._coinTextStyle.fontSize = this.getMeterNameFontSize(), this.COLLECT_LINE_TEXTS.forEach(((t, e) => {
							this._collectMeters.push(this.createCollectFiled(t, this.COLLECT_LINE_DOTS_NR[e], e))
						})), t.addChild(this)
					}
					getMeterNameFontSize() {
						let t = 44;
						return this.COLLECT_LINE_TEXTS.forEach(((e, i) => {
							e[1] = h.Translation.translate(e[1]), e[1].split(" ").forEach((e => {
								e.length > 10 && (t = 28)
							}))
						})), t
					}
					show() {
						_.TweenLite.to(this, .5, {
							alpha: 1
						}), this._collectMeters.forEach((t => {
							t.dots.forEach((t => {
								t.visible = !0
							})), t.text.visible = !0, t.result.visible = !1, t.result.alpha = 1
						}))
					}
					getDot(t, e) {
						let i = new PIXI.Sprite;
						if (i.name = "", this._collectMeters.forEach((n => {
								t === n.name && (i = n.dots[e], i.name = n.mark)
							})), !i) throw new Error("Undefined picked option name.");
						return i
					}
					updateCollectLine(t, e, i) {
						this._collectMeters.forEach((n => {
							n.name === t && this.updateDots(n, e, i)
						}))
					}
					updateDots(t, e, i) {
						t.dots[e].texture = r.GameResources.getTextures("pncCircleCollected")[0], t.dots[e].blendMode = PIXI.BLEND_MODES.NORMAL, t.dots[e].scale.set(.2, .2), t.dotNames[e].text = t.mark + i.toString(), t.dotNames[e].style.fontSize = i > 9 ? 32 : 38, t.dotNames[e].visible = !0, t.collected += i, (t.mark.indexOf("+") > -1 && i > 3 || t.mark.indexOf("x") > -1 && i > 2) && _.TweenLite.fromTo(t.dotGlows[e], .2, {
							alpha: 0
						}, {
							alpha: 1
						})
					}
					updateAllDots(t) {
						this._collectMeters.forEach((e => {
							const i = t[e.name].pickedNumber;
							for (let n = 0; n < i; n++) this.updateDots(e, n, t[e.name].value[n])
						}))
					}
					updateMeterData(t) {
						this._collectMeters.forEach((e => {
							const i = t[e.name].pickedNumber;
							e.collected = 0;
							for (let n = 0; n < i; n++) e.collected += t[e.name].value[n]
						}))
					}
					createCollectFiled(t, e, i) {
						const n = t[1],
							s = new PIXI.Text(n, this._meterNameTextStyle);
						c.Helper.shrinkTextWidth(n, s, 270), s.position.set(-98, this.COLLECT_LINE_Y[i]), s.anchor.set(1, .5), this.addChild(s);
						let o = [],
							a = [];
						const l = u.ArrayHelper.initArrayWithValues(e, (e => {
								const n = new PIXI.Sprite(r.GameResources.getTextures("highCoinGlow")[0]);
								n.anchor.set(.5, .5), n.scale.set(.6, .6), n.position.set(146 * e + i % 2 * 78, this.COLLECT_LINE_Y[i]), n.blendMode = PIXI.BLEND_MODES.ADD, n.alpha = 0;
								const s = new PIXI.Sprite(r.GameResources.getTextures("pncCircle")[0]);
								s.anchor.set(.5, .5), s.scale.set(.9, .9), s.position.set(146 * e + i % 2 * 78, this.COLLECT_LINE_Y[i]), s.blendMode = PIXI.BLEND_MODES.ADD, s.name = t[1];
								const l = new PIXI.Text(t[2], this._dotValueStyle);
								return l.anchor.set(.5, .5), l.position.set(146 * e + i % 2 * 78 + 2, this.COLLECT_LINE_Y[i]), l.visible = !1, o.push(l), a.push(n), this.addChild(n), this.addChild(s), this.addChild(l), s
							})),
							h = new PIXI.Sprite(r.GameResources.getTextures("pncCircleCollected")[0]);
						h.anchor.set(.5, .5), h.position.set(this._resultPos[i][0] - 360, this._resultPos[i][1] - 360), h.scale.set(this._resultScale), h.name = t[1], this._resultWrapper.addChild(h);
						const d = new PIXI.Text(n, this._coinTextStyle);
						d.anchor.set(.5, 0), d.position.set(3, 12), h.visible = !1, h.addChild(d);
						const p = new PIXI.Text("+", this._coinResultNumberStyle);
						return p.anchor.set(.5, .5), p.position.set(0, 35 - .5 * p.height), h.addChild(p), {
							id: i,
							meterFactor: Number(t[2].replace(/^\D+/g, "")),
							text: s,
							result: h,
							resultNumber: p,
							dots: l,
							dotGlows: a,
							dotNames: o,
							collected: 0,
							name: t[0],
							mark: t[3]
						}
					}
					reset() {
						this._collectMeters.forEach(((t, e) => {
							t.dots.forEach(((e, i) => {
								this.resetDot(t, e, i)
							})), t.text.visible = !1, t.result.visible = !1, t.result.position.set(this._resultPos[e][0], this._resultPos[e][1]), t.result.scale.set(this._resultScale), t.collected = "EXTRA_MULTIPLIER" === t.name ? 1 : 0
						}))
					}
					resetDot(t, e, i) {
						e.texture = r.GameResources.getTextures("pncCircle")[0], e.blendMode = PIXI.BLEND_MODES.ADD, e.scale.set(.9, .9), e.visible = !1, t.dotNames[i].visible = !1, t.dotGlows[i].alpha = 0
					}
					showResult(t) {
						const e = new _.TimelineLite;
						this.updateMeterData(t);
						let i = 0;
						return this._collectMeters.forEach((t => {
							if (e.add([() => {
									t.result.visible = !0, t.resultNumber.text = "-", t.dots.forEach(((e, i) => {
										this.resetDot(t, e, i)
									})), t.text.visible = !1
								}, _.TweenLite.to(t.result, .2, {
									alpha: 1
								})], 0), t.collected > 0) {
								const n = Math.min(d.MathHelper.floorToDecimals(3 / t.collected, 2), .4);
								for (let s = 0; s < t.collected; s++) e.add([() => {
									t.resultNumber.text = `${t.mark}${s+1}`, a.SlotGame.sound.playEffect(f.LeprechaunSoundConfig.instance.BONUS_PLING[i % 2]), i++
								}, _.TweenLite.fromTo(t.resultNumber.scale, n, {
									x: .8,
									y: .8
								}, {
									x: 1,
									y: 1,
									ease: _.Elastic.easeOut
								})])
							}
						})), e
					}
					updateGamePanel() {
						const t = new _.TimelineLite;
						let e = 0,
							i = 0;
						return [2, 0, 1].forEach((n => {
							const r = this._collectMeters[n],
								l = r.collected > 0 ? 1 : 0;
							switch (t.add([_.TweenLite.to(r.result, l, {
									alpha: 0
								}), _.TweenLite.to(r.result.scale, l, {
									x: 0,
									y: 0
								})], e), r.name) {
								case "EXTRA_SPINS":
									r.collected > 0 && (t.add([_.TweenLite.to(r.result, l, {
										x: this._endPosFS[0],
										y: this._endPosFS[1]
									}), () => {
										a.SlotGame.sound.playEffect(f.LeprechaunSoundConfig.instance.BONUS_COLLECTS[i % 2]), i++
									}], e), t.add((() => {
										a.SlotGame.keypad.setZeroBetSpinCounter(5 + r.collected)
									}), e + l), e += l);
									break;
								case "EXTRA_LINES":
									r.collected > 0 && (t.add([_.TweenLite.to(r.result, l, {
										x: this._endPosLines[0],
										y: this._endPosLines[1]
									}), () => {
										a.SlotGame.sound.playEffect(f.LeprechaunSoundConfig.instance.BONUS_COLLECTS[i % 2]), i++
									}], e), t.add((() => {
										s.EventHandler.dispatchEvent(new o.GameEvent(m.LeprechaunBetlineEvent.SHOW_RAINBOW_NUMBER, r.collected))
									})), e += 1.2 * r.collected + l, t.add((() => {}), e));
									break;
								case "EXTRA_MULTIPLIER":
									r.collected > 0 && (t.add([_.TweenLite.to(r.result, l, {
										x: this._endPosMultiplier[0],
										y: this._endPosMultiplier[1]
									}), () => {
										a.SlotGame.sound.playEffect(f.LeprechaunSoundConfig.instance.BONUS_COLLECTS[i % 2]), i++
									}], e), t.add((() => {
										g.LeprechaunGameModuleConfig.logo.showMultiplier(r.collected + 1)
									})), e += l)
							}
						})), t
					}
					onResize(t) {
						const e = t.orientation === l.Orientation.PORTRAIT;
						this._resultScale = e ? .6 : .8, this._resultPos = [
							[-60, -390],
							[-660, -560],
							[-660, -220]
						], this._endPosFS = e ? [-360, -90] : [100, -240], this._endPosLines = e ? [-725, -577] : [-671, -560], this._endPosMultiplier = e ? [-95, -657] : [-140, -635];
						let i = e ? .86 : 1;
						this.scale.set(i, i)
					}
				}
				e.CollectMeter = S
			},
			64825: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunPCNCoin = void 0;
				const n = i(88240),
					s = i(7057),
					o = i(77616),
					r = i(13006);
				class a extends PIXI.Sprite {
					get coin() {
						return this._coin
					}
					get coinIcon() {
						return this._coinIcon
					}
					get coinValue() {
						return this._coinValue
					}
					get isHighVale() {
						const t = this._coinValue.text,
							e = Number(t.substring(1));
						return t.indexOf("+") > -1 && e > 3 || t.indexOf("x") > -1 && e > 2
					}
					constructor(t) {
						super();
						const e = {
								fontFamily: "Open Sans",
								fontSize: 90,
								fontWeight: o.FontWeight.EXTRA_BOLD,
								wordWrap: !0,
								align: "center",
								wordWrapWidth: 300,
								dropShadow: !0,
								dropShadowAngle: 89.4,
								dropShadowColor: "#6a3c40",
								dropShadowDistance: 5,
								fill: "#e7e2d5",
								stroke: "#6a3c40",
								strokeThickness: 8,
								lineJoin: "round"
							},
							i = new PIXI.Sprite,
							r = new PIXI.Sprite(n.GameResources.getTextures("highCoinGlow")[0]);
						r.anchor.set(.5, .5), r.position.set(0, 0), r.blendMode = PIXI.BLEND_MODES.ADD, r.alpha = 0;
						const a = new s.TimelineSprite(n.GameResources.getTextures("winStar"));
						a.anchor.set(.5, .5), a.position.set(0, 0), a.scale.set(.8, .8), a.blendMode = PIXI.BLEND_MODES.ADD, a.hide();
						const l = new PIXI.Sprite(n.GameResources.getTextures("pncCircleCollected")[0]);
						l.anchor.set(.5, .5), l.scale.set(.3, .3), i.addChild(r), i.addChild(a), i.addChild(l);
						const h = new PIXI.Sprite;
						h.anchor.set(.5, 1), h.position.set(0, 0), h.visible = !1, l.addChild(h);
						const u = new PIXI.Text("", e);
						u.anchor.set(.5, .5), u.position.set(0, 0), l.addChild(u), this._coin = i, this._glow = a, this._highlight = r, this._coinValue = u, this._coinIcon = h
					}
					getIconTexture(t) {
						const e = t.indexOf("+") > -1;
						e || t.length < 2 ? (this._coinIcon.visible = !0, this._coinIcon.texture = n.GameResources.getTextures(e ? "pncSpinsIcon" : "pncRainbowIcon")[0]) : this._coinIcon.visible = !1
					}
					setStoneState(t, e, i) {
						if (!e) return this.coinIcon.visible = !1, void this.coinValue.position.set(0, 0);
						this.coin.alpha = 1, this._highlight.alpha = 0, this._glow.hide(), this.coinValue.text = t;
						const n = t.indexOf("+") > -1 || t.length < 2;
						if (this.coinValue.style.fontSize = t.length > 4 ? 80 : 140, this.getIconTexture(t), this.coinValue.position.set(0, n ? 62 : 0), this.coin.visible = !0, this.isHighVale)
							if (i) {
								const t = new r.TimelineLite;
								t.add([this._glow.getAnimationAutoShowHide(!0, !0), r.TweenLite.to(this._highlight, .2, {
									alpha: 1
								})]), t.add(this._glow.getAnimationAutoShowHide(!0, !0)), t.add([this._glow.getAnimationAutoShowHide(!0, !0), r.TweenLite.to(this._highlight, .5, {
									alpha: 0
								})])
							} else r.TweenLite.fromTo(this._highlight, .2, {
								alpha: 0
							}, {
								alpha: 1
							})
					}
					reset() {}
				}
				e.LeprechaunPCNCoin = a
			},
			92066: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunPickNClick = void 0;
				const n = i(59848),
					s = i(53108),
					o = i(52409),
					r = i(44679),
					a = i(83673),
					l = i(10403),
					h = i(15904),
					u = i(23110),
					c = i(57284),
					d = i(46334),
					p = i(13006),
					_ = i(63114),
					m = i(4773),
					g = i(68921);
				class f extends l.PickAndClickController {
					constructor(t, e) {
						super(t, e, !0), this._isBigWin = !1, this._gameView = this._view
					}
					addFeatureEventHandlers() {
						o.EventHandler.addEventListener(this, g.PncEvent.LAST_PICK, (t => this.finish()))
					}
					parseFeatureGameData(t) {
						if (this._isBigWin = t.isBigWin, this._nextMode = t.nextMode, this._thisRevealedPicked = t.thisRevealedPicked, this._pickedData = t.pickedData, this._totalPicked = t.pickedExtraLines + t.pickedExtraMultiplier + t.pickedExtraSpins, !this._thisRevealedPicked && 8 === this._totalPicked) return this._gameView.hideAllButtons(), void this.finish();
						if (!t.pickedIndexesAfter || !this._thisRevealedPicked) return;
						const e = this._thisRevealedPicked.indexOf("+") > -1,
							i = 1 === this._thisRevealedPicked.length ? "EXTRA_LINES" : e ? "EXTRA_SPINS" : "EXTRA_MULTIPLIER";
						this._gameView.updateAllButtons(t.pickedIndexesAfter), this._gameView.doCollectAnimation(this._thisRevealedPicked, this._pickedData[i], t.playerSelection, t.pickedIndexesAfter, i, (() => this.onShowComplete()))
					}
					calculateIsTriggered(t) {
						return this._totalPicked = t.pickedExtraLines + t.pickedExtraMultiplier + t.pickedExtraSpins, "START" === t.thisRevealedPicked && (this._totalPicked = 0, this.finish()), "FREESPIN_PICKS" === t.nextMode || "FREESPIN_PICKS" === t.mode && 8 === this._totalPicked && "START" !== t.thisRevealedPicked
					}
					calculateIsRestoreTriggered(t) {
						return this._nextMode = t.nextMode, "FREESPIN_PICKS" === t.mode
					}
					parseButtonConfigs(t) {
						return t.pickedIndexesBefore
					}
					onButtonClick(t) {
						u.SlotGame.sound.playEffect(m.LeprechaunSoundConfig.instance.BONUS_STAR_PICK), this._view.enableButtons(!1), d.Logger.logDev("Selected index - " + t), o.EventHandler.dispatchEvent(new r.GameEvent(n.BalanceEvent.PICK_AND_CLICK, t))
					}
					show(t) {
						this._isBigWin && this._gameView.addDelayToStart(), this.hideKeypad(), this._gameView.createContinueButtons((() => this.onCloseComplete())), this._view.show(this._buttonConfigs, this._serverData, (() => this.onShowComplete())), o.EventHandler.dispatchEvent(new r.GameEvent(s.BetLineEvent.SET_ENABLED, !1)), o.EventHandler.dispatchEvent(new r.GameEvent(s.BetLineEvent.HIDE_ALL_BET_LINES)), o.EventHandler.dispatchEvent(new r.GameEvent(c.StageEvent.WANT_RESIZE)), this.doTransitions && this.doTransitions(), this._gameView.resetDelay()
					}
					onCloseComplete() {
						const t = new p.TimelineLite({
								paused: !0
							}),
							e = this._gameView.updateGamePanel();
						t.add([() => {
							this.showKeypad(), u.SlotGame.keypad.setZeroBetSpinCounter(5), _.LeprechaunGameModuleConfig.logo.showMultiplier(1)
						}, e]), t.add((() => {
							this._gameView.removeView(), d.Logger.logDev(`Close PickAndClick ${this.moduleName}`), this.reset(), this.showKeypad(), u.SlotGame.winFieldController.showWinField(), this.dispatchCompleteEvent(), o.EventHandler.dispatchEvent(new r.GameEvent(s.BetLineEvent.SET_ENABLED, !0)), o.EventHandler.dispatchEvent(new r.GameEvent(c.StageEvent.WANT_RESIZE)), u.SlotGame.autoPlay.turnOffAutoplayOnBonus && u.SlotGame.autoPlay.turnOffAutoplayOnBonus()
						}), e.duration()), t.play()
					}
					playReplay() {
						this._nextMode !== a.GameMode.FREESPIN && this._view.clickButton(0, !0)
					}
					dispatchCompleteEvent() {
						o.EventHandler.dispatchEvent(new r.GameEvent(h.ScreenEvent.PICK_AND_CLICK_CLOSED, this._showWinPresentations))
					}
					finish() {
						this._totalPicked = 0, this.close()
					}
				}
				e.LeprechaunPickNClick = f
			},
			68270: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunPickNClickScreen = e.isNumber = void 0;
				const n = i(74233),
					s = i(376),
					o = i(52409),
					r = i(44679),
					a = i(5398),
					l = i(88240),
					h = i(23110),
					u = i(66493),
					c = i(40745),
					d = i(34785),
					p = i(56682),
					_ = i(57244),
					m = i(7057),
					g = i(77616),
					f = i(13006),
					S = i(90561),
					y = i(4621),
					v = i(63114),
					T = i(4773),
					E = i(22353),
					b = i(719),
					A = i(64825),
					P = i(68921);

				function I(t) {
					return "number" == typeof t && t == t
				}
				i(34720), e.isNumber = I;
				class w extends a.PickAndClickView {
					constructor(t, e = !1) {
						super(t, e), this.STONE_POS_PORTRAIT = [
							[-574, -608],
							[-360, -646],
							[-122, -604],
							[-486, -503],
							[-242, -503],
							[-576, -356],
							[-126, -362],
							[-516, -779],
							[-236, -779]
						], this.STONE_POS_LANDSCAPE = [
							[-775, -498],
							[-598, -584],
							[-368, -630],
							[-150, -582],
							[45, -506],
							[-785, -272],
							[-494, -394],
							[-218, -398],
							[64, -284]
						], this.BUTTON_COLORS = ["Red", "Yellow", "Green", "Gray", "Orange", "Blue", "Pink", "Purple", "Turquoise"], this.DEFAULT_BUTTON_SIZE = new PIXI.Point(240, 64), this.PICK_STONE_TEXT = "Pick a coin", this.INTRO_EXPLAIN_TEXT_0 = "You won 5 Rainbow Spins", this.INTRO_EXPLAIN_TEXT_1 = "Coins award added lines, multipliers and spins.", this._startTime = 8, this._minInterval = 8, this._maxInterval = 12, this._isPlaying = !1, this._addDelay = !1, this._portraitScale = 1.2, this._buttons = [], this._collectMeter = new b.CollectMeter, this._rainbowView = new E.Rainbow
					}
					initAnimations() {
						super.initAnimations(), this._bonusSymbolTriggerSprite = new PIXI.Sprite, this._bonusSymbolTriggerSprite.anchor.set(.5, .5);
						const t = new PIXI.Sprite(l.GameResources.getTextures("B/B")[0]);
						t.position.set(0, 0), t.anchor.set(.5, .5);
						const e = new m.TimelineSprite(l.GameResources.getTextures("rainbowBonusIdle"), 15);
						e.anchor.set(.5, 1), e.hide(), e.position.set(0, 58), e.blendMode = PIXI.BLEND_MODES.ADD, this._bonusSymbolTriggerAnimation = e, this._bonusSymbolTriggerSprite.addChild(e), this._bonusSymbolTriggerSprite.addChild(t), this._bonusSymbolTriggerSprite.position.set(-4, -16)
					}
					createContinueButton(t) {
						const e = c.Translation.translate("CONTINUE"),
							i = this.getScaledButtonTextStyle(),
							n = new s.NineSliceButton(t, ` ${e} `, i, {
								cornerRadius: 12,
								lineThickness: 2,
								lineColor: 16777215,
								lineAlpha: 1,
								backgroundColor: 0,
								backgroundAlpha: 0
							});
						return n.enabled = !1, n
					}
					createStartButton(t) {
						const e = new S.LeprechaunButton(l.GameResources.getTextures("pncStartCoin")[0], (() => t()));
						return e.anchor.set(.5, .5), e.enabled = !1, e
					}
					getScaledButtonTextStyle() {
						const t = {
							fontFamily: "Open Sans",
							fontStyle: g.FontStyle.ITALIC,
							fontSize: 34,
							fill: "#ffffff",
							fontWeight: g.FontWeight.EXTRA_BOLD
						};
						if (!I(t.fontSize)) throw new Error("Error: IntoView.getScaledButtonTextStyle(): please use number fontSize!");
						return t.fontSize = t.fontSize * this._deviceScale, t
					}
					createGameGraphics() {
						const t = {
								fontFamily: "Open Sans",
								fontSize: 38,
								wordWrap: !0,
								wordWrapWidth: 530,
								breakWords: !0,
								fontWeight: g.FontWeight.EXTRA_BOLD,
								fill: 16777215,
								dropShadow: !0,
								dropShadowAngle: 8,
								dropShadowBlur: 10,
								dropShadowDistance: 4,
								padding: 6
							},
							e = {
								fontFamily: "Open Sans",
								fontSize: 22,
								wordWrap: !0,
								wordWrapWidth: 700,
								breakWords: !0,
								fontWeight: g.FontWeight.EXTRA_BOLD,
								fill: 16777215,
								dropShadow: !0,
								dropShadowAngle: 8,
								dropShadowBlur: 10,
								dropShadowDistance: 4,
								padding: 6
							},
							i = new PIXI.Container;
						this._container = i, this._buttonsWrapper = new PIXI.Sprite, this._container.position.set(360, 360), this._buttonsWrapper.position.set(360, 360), this._rainbowView.createRainbow(i), this._collectMeter.createMeter(i);
						const n = " " + c.Translation.translate(this.PICK_STONE_TEXT) + " ";
						return this._pickText = this.createText(n, t, 40), p.Helper.shrinkTextWidth(n, this._pickText, 400), this._introExplainText0 = this.createText(c.Translation.translate(this.INTRO_EXPLAIN_TEXT_0), e, 160), this._introExplainText1 = this.createText(c.Translation.translate(this.INTRO_EXPLAIN_TEXT_1), e, 200), this._coinFlipAnimationText = this.createText("", t, 0), this._coinFlipAnimationText.style.fontSize = 70, this._coinFlipAnimationIcon = new PIXI.Sprite, this._coinFlipAnimationIcon.anchor.set(.5, .5), this._coinFlipAnimationIcon.scale.set(.5, .5), this._coinFlipAnimationIcon.position.set(0, -70), this._coinFlipAnimationIcon.alpha = 0, this._coinFlipAnimation = new m.TimelineSprite(l.GameResources.getTextures("pncCoinFlip")), this._coinFlipAnimation.anchor.set(.5, .5), this._coinFlipAnimation.hide(), this._sparkleBurst = new m.TimelineSprite(l.GameResources.getTextures("pncSparkleBurst")), this._sparkleBurst.blendMode = PIXI.BLEND_MODES.ADD, this._sparkleBurst.anchor.set(.5, .5), this._sparkleBurst.hide(), this._bonusSymbolTriggerAnimation = new m.TimelineSprite(l.GameResources.getTextures("bonusIdleRainbow"), 15), this._bonusSymbolTriggerAnimation.anchor.set(.5, .5), this._bonusSymbolTriggerAnimation.hide(), this._fsStartAnimation = new PIXI.spine.Spine(l.GameResources.getSpineAsset("leprechaunPick")), this._fsStartAnimation.autoUpdate = !0, this._fsStartAnimation.position.set(0, -98), this._fsStartAnimation.state.setEmptyAnimation(0, 0), this._coinFlipAnimation.visible = !1, this._coinFlipAnimation.addChild(this._coinFlipAnimationText), this._coinFlipAnimation.addChild(this._coinFlipAnimationIcon), this._buttonsWrapper.addChild(this._pickText), i.addChild(this._buttonsWrapper), i
					}
					createBackground() {
						const t = new PIXI.Sprite(l.GameResources.getTextures(y.LeprechaunGameAssets.PICK_AND_CLICK_BACKGROUND)[0]);
						return t.scale.set(8, 8), t.anchor.set(.5, .5), t.position.set(360, 360), t.blendMode = PIXI.BLEND_MODES.MULTIPLY, t
					}
					createButton(t, e, i) {
						const n = new S.LeprechaunButton(l.GameResources.getTextures("pncStone" + this.BUTTON_COLORS[t])[0], (() => {
							i(e, this._autoClicked)
						}));
						return n.anchor.set(.5, .5), this._buttonsWrapper.addChild(n), n
					}
					createButtons(t) {
						const e = [];
						return this._clickedCoins = d.ArrayHelper.initArrayWithValues(this.BUTTON_COLORS.length, (t => {
							const e = new A.LeprechaunPCNCoin(t);
							return this._buttonsWrapper.addChild(e.coin), e
						})), d.ArrayHelper.initArrayWithValues(this.BUTTON_COLORS.length, (t => {
							const i = this.createButton(t, t, this._onButtonClickCallback);
							i.enabled = !1, e.push(i)
						})), e
					}
					createText(t, e, i) {
						const n = new PIXI.Text(t, e);
						return n.anchor.set(.5, .5), n.position.set(0, i), n.alpha = 0, n
					}
					createContinueButtons(t) {
						this._button || (this._button = this.createContinueButton((() => {
							t(), h.SlotGame.sound.playEffect(T.LeprechaunSoundConfig.instance.BONUS_START), h.SlotGame.sound.fadeAmbience(0, 1e3), h.SlotGame.sound.playAmbience(T.LeprechaunSoundConfig.instance.FREE_SPIN_AMBIANCE), h.SlotGame.sound.fadeAmbience(1, 1e3)
						})), this._startButton = this.createStartButton((() => {
							t(), h.SlotGame.sound.playEffect(T.LeprechaunSoundConfig.instance.BONUS_START), h.SlotGame.sound.fadeAmbience(0, 1e3), h.SlotGame.sound.playAmbience(T.LeprechaunSoundConfig.instance.FREE_SPIN_AMBIANCE), h.SlotGame.sound.fadeAmbience(1, 1e3)
						}))), this._button.visible = !1, this._container.addChild(this._button), this._startButton.visible = !1, this._container.addChild(this._startButton)
					}
					startPresentation(t, e) {
						this.reset();
						const i = t;
						if (i.isRestoreSelectedAll) return this.hideAllButtons(), this.visible = !0, this._rainbowView.show(!0), this._background.alpha = 1, this._container.addChild(this._fsStartAnimation), this._fsStartAnimation.visible = !0, this._collectMeter.show(), this._collectMeter.showResult(t.pickedData).progress(1), this._fsStartAnimation.position.set(0, 0), this._fsStartAnimation.scale.set(1.3, 1.3), this._pickText.alpha = 0, v.LeprechaunGameModuleConfig.hotZone.stopHotZoneWinStar(), this._container.addChild(this._button), void(new f.TimelineLite).add(new n.SpineTween(this._fsStartAnimation, 0, "animation")).add((() => {
							this._container.addChild(this._startButton), this._button.visible = !0, this._button.enabled = !0, this._startButton.visible = !0, this._startButton.enabled = !0
						}));
						const s = new f.TimelineLite({
							paused: !0
						});
						s.add((() => {
							v.LeprechaunGameModuleConfig.hotZone.hide(!0), this.hideAllButtons(), this.visible = !0
						})), i.isRestoreState || s.add([() => {
							this._bonusSymbolTriggerAnimation.show(), this._bonusSymbolTriggerAnimation.playLoop(), this._container.addChild(this._bonusSymbolTriggerSprite)
						}, f.TweenLite.to(this._bonusSymbolTriggerSprite.scale, .495, {
							x: 1.3,
							y: 1.3
						}), f.TweenLite.to(this._bonusSymbolTriggerSprite, 1, {
							alpha: 1
						})], 0), i.isRestoreState ? s.add(this.showAllButtonsOnRestore()) : s.add(this.showAllButtons(t.possibleReveals)), s.add((() => this.setButtonStates(i))), s.add([() => {
							this._collectMeter.show(), e && e()
						}, f.TweenLite.fromTo(this._pickText, .132, {
							alpha: 0
						}, {
							alpha: i.isRestoreSelectedAll ? 0 : 1
						})]), v.LeprechaunGameModuleConfig.hotZone.stopHotZoneWinStar(), s.play()
					}
					setButtonStates(t) {
						t.isRestoreState && this._collectMeter.updateAllDots({
							EXTRA_LINES: {
								value: t.addedLines,
								pickedNumber: t.pickedExtraLines
							},
							EXTRA_MULTIPLIER: {
								value: t.addedMultiplier,
								pickedNumber: t.pickedExtraMultiplier
							},
							EXTRA_SPINS: {
								value: t.addedNumberOfFreespins,
								pickedNumber: t.pickedExtraSpins
							}
						}), this._buttons.forEach(((e, i) => {
							const n = this._clickedCoins[i];
							if (e.position.set(this._stonePos[i][0], this._stonePos[i][1]), n.coin.position.set(this._stonePos[i][0], this._stonePos[i][1]), t.isRestoreState)
								if (t.pickedIndexesBefore) {
									const s = t.pickedIndexesBefore[i];
									e.visible = !s, e.enabled = !s, n.setStoneState(t.revealedBefore[i], s, !1)
								} else e.enabled = !0, e.visible = !0;
							else e.enabled = !0, e.visible = !0, n.coin.visible = !1, n.coinValue.text = ""
						}))
					}
					showAllButtons(t) {
						const e = new f.TimelineLite,
							i = [.6, .3, .2, .3, .4, .4, .3, .3, .6];
						return e.add([() => {
							h.SlotGame.sound.playEffect(T.LeprechaunSoundConfig.instance.BONUS_STAR_IN), this._container.addChild(this._introExplainText0), this._container.addChild(this._introExplainText1), this._introExplainText0.alpha = 0, this._introExplainText1.alpha = 0
						}, f.TweenLite.fromTo(this._introExplainText0, .5, {
							alpha: 0
						}, {
							alpha: 1
						}), f.TweenLite.fromTo(this._introExplainText1, .5, {
							alpha: 0
						}, {
							alpha: 1
						})], 0), this._clickedCoins.forEach(((n, s) => {
							const o = t[s];
							e.add([() => {
								this._buttons[s].alpha = 0, this._buttons[s].position.set(-360, -360), this._buttons[s].visible = !0, n.setStoneState(o, !0, !0)
							}, f.TweenLite.fromTo(n.coin, 1, {
								x: -360,
								y: -360
							}, {
								x: this._stonePos[s][0],
								y: this._stonePos[s][1],
								ease: f.Power2.easeOut
							})], i[s]), e.add([f.TweenLite.to(n.coin, .5, {
								x: -360,
								y: -360
							}), f.TweenLite.to(n.coin, .5, {
								alpha: 0
							})], 4.3), e.add([() => {
								n.coinValue.text = "", n.coinIcon.visible = !1, n.coin.visible = !1, n.coin.alpha = 1, n.coin.position.set(this._stonePos[s][0], this._stonePos[s][1])
							}, f.TweenLite.to(this._buttons[s], .5, {
								x: this._stonePos[s][0],
								y: this._stonePos[s][1],
								ease: f.Power2.easeOut
							}), f.TweenLite.to(this._buttons[s], .5, {
								alpha: 1
							})], 4.7 + i[s])
						})), e.add([() => {
							this._rainbowView.show(!1)
						}, f.TweenLite.to(this._background, .6, {
							alpha: 1
						})], 1.4), e.add((() => {
							this._bonusSymbolTriggerSprite.alpha = 0, this._bonusSymbolTriggerAnimation.hide(), this._bonusSymbolTriggerAnimation.stopLoop(), this._container.removeChild(this._bonusSymbolTriggerSprite), this._container.removeChild(this._introExplainText0), this._container.removeChild(this._introExplainText1), this._introExplainText0.alpha = 0, this._introExplainText1.alpha = 0
						}), 5.1), e.add([() => {
							h.SlotGame.sound.playEffect(T.LeprechaunSoundConfig.instance.BONUS_STAR_OUT2), this.onIdle()
						}], 4.3), e
					}
					showAllButtonsOnRestore() {
						const t = new f.TimelineLite;
						return t.add([() => {
							this._rainbowView.show(!0), this.onIdle()
						}, f.TweenLite.to(this._background, 0, {
							alpha: 1
						})], 0), t
					}
					doCollectAnimation(t, e, i, n, s, a) {
						this._collectAnimation && this._collectAnimation.isActive() && (this._collectAnimation.progress(1), this._collectAnimation.kill()), this._collectAnimation = new f.TimelineLite({
							paused: !0
						});
						const l = e.value[e.pickedNumber - 1],
							h = this._collectMeter.getDot(s, e.pickedNumber - 1);
						this.playRevealAnimation(t, i, this._collectAnimation), this._collectAnimation.add([f.TweenLite.to(this._coinFlipAnimation.scale, .2, {
							x: .2,
							y: .2
						}), f.TweenLite.to(this._coinFlipAnimation, .2, {
							x: h.position.x,
							y: h.position.y
						})]), this._collectAnimation.add((() => {
							this._clickedCoins[i].setStoneState(t, !0, !1);
							let h = 0;
							this._coinFlipAnimation.hide(), this._collectMeter.updateCollectLine(s, e.pickedNumber - 1, l), this._buttons.forEach(((t, e) => {
								t.enabled = !n[e], h += n[e] ? 0 : 1
							})), h < 2 && o.EventHandler.dispatchEvent(new r.GameEvent(P.PncEvent.LAST_PICK)), a()
						})), this._collectAnimation.play()
					}
					playRevealAnimation(t, e, i) {
						const n = this._buttons[e];
						this._coinFlipAnimation.position.set(n.position.x + 360, n.position.y + 360), this._coinFlipAnimation.scale.set(.36, .36), this._container.addChild(this._coinFlipAnimation), this._container.addChild(this._sparkleBurst), this.getIconTexture(t, this._coinFlipAnimationIcon), this._coinFlipAnimationIcon.visible = !1, this._coinFlipAnimationText.text = " " + t + " ", this._coinFlipAnimationText.visible = !1, this._coinFlipAnimationText.alpha = 1, this._coinFlipAnimation.alpha = 1, this._collectAnimation.add([() => {
							this.enableButtons(!1), n.visible = !1, this._sparkleBurst.scale.set(1, 1), this._sparkleBurst.position.set(n.position.x + 360, n.position.y + 360)
						}, this._sparkleBurst.getAnimationAutoShowHide(!0, !0)], 0), this._collectAnimation.add([() => {
							h.SlotGame.sound.playEffect(T.LeprechaunSoundConfig.instance.BONUS_STAR_PICK_EXPAND)
						}, this._coinFlipAnimation.getAnimationAutoShowHide(!0, !1, [0]), f.TweenLite.to(this._coinFlipAnimation, .5, {
							x: 0,
							y: 0
						}), f.TweenLite.to(this._coinFlipAnimation.scale, .5, {
							x: 1,
							y: 1
						}), f.TweenLite.to(this._coinFlipAnimationText, .2, {
							alpha: 1
						}), f.TweenLite.to(this._coinFlipAnimationIcon, .2, {
							alpha: t.indexOf("x") > -1 || t.length > 3 ? 0 : 1
						})], 0), this._collectAnimation.add(this._coinFlipAnimation.getAnimationAutoShowHide(!0, !1), "0.5"), this._collectAnimation.add([() => {
							this._sparkleBurst.position.set(0, 0), this._sparkleBurst.scale.set(3.5, 3.5)
						}, this._sparkleBurst.getAnimationAutoShowHide(!0, !0)], "0.86"), this._collectAnimation.add([() => {
							this._coinFlipAnimationText.visible = !0, this._coinFlipAnimationIcon.visible = !0
						}, f.TweenLite.to(this._coinFlipAnimationText, 1, {
							alpha: 1
						}), f.TweenLite.to(this._coinFlipAnimation.scale, .5, {
							x: 1.1,
							y: 1.1
						})], "0.8")
					}
					showStartCoin(t, e, i) {
						this._collectAnimation && this._collectAnimation.isActive() && (this._collectAnimation.progress(1), this._collectAnimation.kill()), this._collectAnimation = new f.TimelineLite;
						let n = t.length > 0 ? e : -1;
						n < 0 && i.forEach(((t, e) => {
							t || (n = e)
						}));
						const s = this._buttons[n];
						return this._fsStartAnimation.position.set(s.position.x, s.position.y - 200), this._fsStartAnimation.scale.set(.4, .4), this.playRevealAnimation("START", n, this._collectAnimation), this._collectAnimation.add([f.TweenLite.to(this._coinFlipAnimation, .2, {
							alpha: 0
						}), f.TweenLite.to(this._pickText, .2, {
							alpha: 0
						})]), this._collectAnimation
					}
					updateAllButtons(t) {
						this._buttons && 0 !== this._buttons.length && t.forEach(((t, e) => {
							this._buttons[e].visible = !t, this._clickedCoins[e].coin.visible = t, this._buttons[e].enabled = !t
						}))
					}
					hideAllButtons() {
						this._buttons.forEach(((t, e) => {
							t.visible = !1, this._clickedCoins[e].coin.visible = !1, t.enabled = !1
						}))
					}
					stopPresentation(t, e) {
						const i = new f.TimelineLite({
							paused: !0
						});
						this._collectAnimation && this._collectAnimation.isActive() && this._collectAnimation.progress(1), this.onIdleStop(), this.enableButtons(!1), this._container.addChild(this._fsStartAnimation), this._fsStartAnimation.visible = !0, i.add(this.showStartCoin(t.possibleReveals, t.playerSelection, t.pickedIndexesAfter)), i.add([() => {
							this._pickText.alpha = 0, h.SlotGame.sound.playEffect(T.LeprechaunSoundConfig.instance.BONUS_STAR_END), this.hideAllButtons()
						}, f.TweenLite.to(this._fsStartAnimation, .99, {
							x: 0,
							y: 0,
							ease: f.Power3.easeIn
						}), f.TweenLite.to(this._fsStartAnimation.scale, .99, {
							x: 1.3,
							y: 1.3,
							ease: f.Power3.easeIn
						})]), i.add([new n.SpineTween(this._fsStartAnimation, 0, "animation"), this._collectMeter.showResult(t.pickedData)]), i.add((() => {
							this._container.addChild(this._button), this._button.visible = !0, this._button.enabled = !0, this._container.addChild(this._startButton), this._startButton.visible = !0, this._startButton.enabled = !0
						})), i.play(0)
					}
					updateGamePanel() {
						const t = new f.TimelineLite;
						return t.add([() => {
							this._button.visible = !1, this._startButton.visible = !1
						}, f.TweenLite.to(this._background, .2, {
							alpha: 0
						}), new n.SpineTween(this._fsStartAnimation, 0, "animation"), this._rainbowView.animateHide()]), t.add([() => {
							this._fsStartAnimation.visible = !1
						}, this._collectMeter.updateGamePanel()]), t.add((() => {
							this.reset()
						})), t
					}
					onResizeGameGraphics(t) {
						this._isResizeDirty = !1;
						const e = t.height / t.width;
						if (e < 1.32 && e > .85) return this._buttonsWrapper.position.set(300, t.orientation === u.Orientation.PORTRAIT ? 334 : 286), void this._buttonsWrapper.scale.set(.85, .85);
						this._buttonsWrapper.scale.set(1, 1), this._buttonsWrapper.position.set(360, 360)
					}
					reset() {
						this._introExplainText0.alpha = 0, this._introExplainText1.alpha = 0, this._bonusSymbolTriggerSprite.scale.set(1, 1), this._bonusSymbolTriggerSprite.alpha = 0, this._bonusSymbolTriggerAnimation.hide(), this._bonusSymbolTriggerAnimation.stopLoop(), this._collectMeter.reset(), this._rainbowView.hide(), this._fsStartAnimation && (this.removeChild(this._fsStartAnimation), this._fsStartAnimation.state.clearTrack(0), this._fsStartAnimation.skeleton.setToSetupPose(), this._fsStartAnimation.visible = !1), this._coinFlipAnimationText.visible = !1, this._coinFlipAnimationIcon.visible = !1, this._coinFlipAnimation.hide(), this._background.alpha = 0, this._collectAnimation && (this._collectAnimation.isActive() && this._collectAnimation.progress(1), this._collectAnimation.kill())
					}
					removeView() {
						this._layer.removeChild(this), this._isShowing = !1, this._autoClicked = !1
					}
					getIconTexture(t, e) {
						const i = t.indexOf("+") > -1;
						i || t.length < 2 ? (e.visible = !0, e.texture = l.GameResources.getTextures(i ? "pncSpinsIcon" : "pncRainbowIcon")[0]) : e.visible = !1
					}
					addDelayToStart() {
						this._addDelay = !0
					}
					resetDelay() {
						this._addDelay = !1
					}
					onResizeButtons(t) {
						const e = t.orientation === u.Orientation.PORTRAIT,
							i = e ? this.STONE_POS_PORTRAIT : this.STONE_POS_LANDSCAPE;
						this.visible && (this._pickText.position.set(-360, e ? -407 : -495), this._buttons.forEach(((t, e) => {
							t.position.set(i[e][0], i[e][1]), this._clickedCoins[e].coin.position.set(i[e][0], i[e][1])
						})), this._stonePos = i, this.onResizeButton(t))
					}
					onResizeButton(t) {
						this._orientationScale = 1;
						const e = this.getScaledButtonSize();
						this._button.setSize(e.x, e.y, this._layer.scale.x * this._orientationScale), this.setButtonPosition(t)
					}
					getScaledButtonSize() {
						const t = this.DEFAULT_BUTTON_SIZE;
						return new PIXI.Point(t.x * this._deviceScale, t.y * this._deviceScale)
					}
					setButtonPosition(t) {
						this._button.position.set(0, .35 * this._screenHeight), this._startButton.position.set(-22, -6)
					}
					onResizeBackground(t) {}
					playIdleAnimation(t, e) {
						this._isPlaying && (CustomWiggle.create("wiggle", {
							wiggles: 3,
							type: "easeInOut"
						}), this._buttons.forEach((t => {
							t.visible && (new f.TimelineLite).add((new f.TimelineLite).to(t, 2, {
								rotation: Math.PI / 6,
								ease: "wiggle"
							}))
						})), this._idleTimer = f.TweenLite.to(this, t, {
							onComplete: () => this.playIdleAnimation(_.MathHelper.randomNumberInRange(this._minInterval, this._maxInterval), !0)
						}))
					}
					onIdleStop() {
						this._isPlaying = !1, this._idleTimer && (this._idleTimer.pause(), this._idleTimer.kill(), this._idleTimer = null)
					}
					onIdle() {
						this._isPlaying = !0, this.playIdleAnimation(this._startTime, !1)
					}
					wait() {}
				}
				e.LeprechaunPickNClickScreen = w
			},
			68921: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.PncEvent = void 0;
				class i {}
				e.PncEvent = i, i.LAST_PICK = "pncEvent_lastPick"
			},
			89991: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunOutroController = void 0;
				const n = i(53108),
					s = i(52409),
					o = i(44679),
					r = i(23110),
					a = i(32696),
					l = i(49775),
					h = i(15807);
				class u extends l.FreespinOutroController {
					constructor(t) {
						super(t), this._hasWin = !1, this._toHideExtraBetlineNumber = !1
					}
					parseFeatureGameData(t) {
						this._hasWin = t.singleWin > 0
					}
					addFeatureEventHandlers() {
						s.EventHandler.addEventListener(this, a.SpinEvent.START, (t => this.onSpinStart()))
					}
					onSpinStart() {
						this._toHideExtraBetlineNumber && (this._toHideExtraBetlineNumber = !1, s.EventHandler.dispatchEvent(new o.GameEvent(h.LeprechaunBetlineEvent.HIDE_RAINBOW_NUMBER)))
					}
					show() {
						return this.shouldShow() && (this._toHideExtraBetlineNumber = !0, this._view.show(this._serverData, (() => this.onShowComplete())), this.hideKeypad(), s.EventHandler.dispatchEvent(new o.GameEvent(n.BetLineEvent.SET_ENABLED, !1)), s.EventHandler.dispatchEvent(new o.GameEvent(n.BetLineEvent.HIDE_ALL_BET_LINES)), this._isShowing = !0), this.doTransitions && this.doTransitions(), r.SlotGame.keypad.setZeroBetSpinCounter(-1), this._isShowing
					}
					close() {
						this._toHideExtraBetlineNumber = this._hasWin, this._hasWin || s.EventHandler.dispatchEvent(new o.GameEvent(h.LeprechaunBetlineEvent.HIDE_RAINBOW_NUMBER)), super.close()
					}
				}
				e.LeprechaunOutroController = u
			},
			6: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunOutroView = void 0;
				const n = i(28054),
					s = i(23110),
					o = i(66493),
					r = i(40745),
					a = i(56682),
					l = i(77616),
					h = i(13006),
					u = i(4773),
					c = i(16182),
					d = i(22353),
					p = i(63114);
				class _ extends n.ScreenView {
					constructor(t, e = !0) {
						super(t, e), this._winBlowStake = !1, this.YOU_WON_TEXT = "You won", this.SPINS_PLAYES_TEXT = "Spins played", this.textStyle = {
							fontFamily: "Open Sans",
							fontSize: 40,
							fontWeight: l.FontWeight.EXTRA_BOLD,
							wordWrap: !0,
							wordWrapWidth: 600,
							breakWords: !0,
							dropShadow: !0,
							dropShadowAngle: 89.5,
							dropShadowBlur: 1,
							dropShadowColor: "#6a3c40",
							dropShadowDistance: 4,
							fill: ["#fffdec", "#fff2a8", "#ffc133"],
							lineJoin: "round",
							miterLimit: 7,
							stroke: "#6a3c40",
							strokeThickness: 4
						}, this.numberStyle = {
							font: {
								name: "NumbersWinCountUp",
								size: 26
							},
							tint: parseInt("#ffffff".replace(/^#/, ""), 16)
						}, this._winCountUp = new c.LeprechaunInitialWinCountUp(this.numberStyle), this._rainbowView = new d.Rainbow
					}
					createGameGraphics() {
						const t = new PIXI.Container;
						return this._infoPanel = new PIXI.Container, this._dimmer = new PIXI.Sprite(PIXI.Texture.WHITE), this._dimmer.anchor.set(.5, .5), this._dimmer.position.set(360, 360), this._dimmer.tint = 0, this._dimmer.alpha = .5, this.addChild(this._dimmer), this._rainbowView.createRainbow(t), this._youWinText = new PIXI.Text(r.Translation.translate(this.YOU_WON_TEXT), this.textStyle), this._youWinText.anchor.set(.5), this._youWinText.position.set(0, -170), this._spinsPlayed = new PIXI.Text(r.Translation.translate(this.SPINS_PLAYES_TEXT), this.textStyle), this._spinsPlayed.anchor.set(.5), this._spinsPlayed.position.set(0, 50), a.Helper.shrinkTextWidth(this.SPINS_PLAYES_TEXT, this._spinsPlayed, 700), this._spinsPlayedNumber = new PIXI.BitmapText(r.Translation.translate(this.SPINS_PLAYES_TEXT), this.numberStyle), this._spinsPlayedNumber.position.set(0, 100), this.reset(), this._winCountUp.position.set(0, -56), this._infoPanel.addChild(this._youWinText), this._infoPanel.addChild(this._spinsPlayed), this._infoPanel.addChild(this._spinsPlayedNumber), t.addChild(this._winCountUp), t.addChild(this._infoPanel), this._container = t, t
					}
					onResizeGameGraphics(t) {
						t.orientation == o.Orientation.PORTRAIT ? this._infoPanel.scale.set(1.3, 1.3) : this._infoPanel.scale.set(1, 1), this._container.position.set(360, 360), this._dimmer.width = t.width + 100, this._dimmer.height = t.height + 100
					}
					startPresentation(t, e) {
						const i = t.totalWin > 0;
						this._winBlowStake = p.LeprechaunGameModuleConfig.featurePrice.isWinBelowStake(), this.alpha = 0;
						const n = new h.TimelineLite({
							paused: !0,
							onComplete: () => {
								this._button.visible = !0, super.startPresentation(t, e)
							}
						});
						n.add((() => {
							this._rainbowView.show(!0), this._button.visible = !1, this._spinsPlayed.visible = !0, this._spinsPlayedNumber.visible = !0, this._spinsPlayedNumber.text = t.numberOfFreespinsPlayed.toString(), this._spinsPlayed.position.y = i ? 50 : -30, this._spinsPlayedNumber.position.x = 0 - this._spinsPlayedNumber.width / 2, this._spinsPlayedNumber.position.y = i ? 100 : 30, this._youWinText.visible = i && !this._winBlowStake, this._winCountUp.visible = !1
						})), n.add([h.TweenLite.fromTo(this, 1, {
							alpha: 0
						}, {
							alpha: 1
						}), () => {
							!this._winBlowStake && s.SlotGame.sound.playEffect(u.LeprechaunSoundConfig.instance.BONUS_END_SWEEEP)
						}]), n.add((() => {
							!this._winBlowStake && s.SlotGame.sound.playEffect(u.LeprechaunSoundConfig.instance.BONUS_END), s.SlotGame.sound.fadeAmbience(0, 50), s.SlotGame.sound.playAmbience(u.LeprechaunSoundConfig.instance.MAIN_GAME_AMBIANCE), s.SlotGame.sound.fadeAmbience(1, 50)
						})), i && (n.add([() => {
							this._winCountUp.visible = !0, !this._winBlowStake && s.SlotGame.sound.playEffect(u.LeprechaunSoundConfig.instance.COUNT_UP)
						}, this._winCountUp.getCountUpAnimation(0, t.totalWin, this._winBlowStake ? 0 : 2.37, 1)]), n.add((() => {
							s.SlotGame.sound.stopEffect(u.LeprechaunSoundConfig.instance.COUNT_UP), !this._winBlowStake && s.SlotGame.sound.playEffect(u.LeprechaunSoundConfig.instance.COUNT_UP_ENDS)
						}))), n.play(0)
					}
					reset() {
						this._rainbowView.hide(), this._youWinText.visible = !1, this._winCountUp.visible = !1, this._spinsPlayed.visible = !1, this._spinsPlayedNumber.visible = !1
					}
					playSound() {
						this._playSoundCallback && this._playSoundCallback()
					}
					setButtonPosition(t) {
						const e = .9 * t.height - .5 * (t.height - 720);
						this._button.position.set(360, e)
					}
					createAutoCloseTimer() {
						const t = super.createAutoCloseTimer();
						return t.visible = !1, t
					}
					onResizeButton(t) {
						this._orientationScale = 1, super.onResizeButton(t)
					}
				}
				e.LeprechaunOutroView = _
			},
			85271: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunReelAreaView = void 0;
				const n = i(75367),
					s = i(53397),
					o = i(23792),
					r = i(23110),
					a = i(13006),
					l = i(48002),
					h = i(63114),
					u = i(4773);
				class c extends s.ReelAreaView {
					constructor(t) {
						super(t)
					}
					liftReelUp(t, e) {
						const i = l.LeprechaunGameConfig.instance.REEL_DISPLAY_POSITIONS[1],
							s = l.LeprechaunGameConfig.instance.SYMBOL_HEIGHT;
						a.TweenLite.to(t, 3 * n.GameConfig.instance.REEL_NEAR_WIN_SPIN_SPEED, {
							y: i[1] - s - e * s
						})
					}
					onSlowMotionStop(t, e, i) {
						const s = new a.TimelineLite,
							c = l.LeprechaunGameConfig.instance.REEL_DISPLAY_POSITIONS[1],
							d = l.LeprechaunGameConfig.instance.SYMBOL_HEIGHT,
							p = o.Reels.getSymbol(1, e + 1);
						return s.add((() => {
							r.SlotGame.sound.playEffect(u.LeprechaunSoundConfig.instance.ANTICIPATION_BONUS)
						})), s.add(a.TweenLite.to(t, 2.4, {
							y: c[1] + (i ? -.5 : .5) * d
						})), s.add(a.TweenLite.to(t, 2, {
							y: c[1] + (i ? -.5 : .5) * d
						})), s.add([p.changeState({
							state: l.LeprechaunGameConfig.instance.SYMBOL_STATES.landing,
							fadeInDuration: 0,
							onCompleteCallback: () => {
								p.changeState({
									state: n.GameConfig.instance.SYMBOL_STATES.normal
								})
							}
						}), () => {
							"B" === o.Reels.getSymbol(1, 1).symName ? (r.SlotGame.sound.playEffect(u.LeprechaunSoundConfig.instance.BONUS_WIN), r.SlotGame.sound.fadeAmbience(0, 50), r.SlotGame.sound.playAmbience(u.LeprechaunSoundConfig.instance.BONUS_GAME_AMBIANCE), r.SlotGame.sound.fadeAmbience(1, 50), h.LeprechaunGameModuleConfig.bonusWinEffect.playAnimation()) : (r.SlotGame.sound.playEffect(u.LeprechaunSoundConfig.instance.BONUS_FAIL), h.LeprechaunGameModuleConfig.hotZone.hide(!0), h.LeprechaunGameModuleConfig.hotZone.stopHotZoneWinStar())
						}, a.TweenLite.to(t, .6, {
							y: c[1],
							ease: a.Elastic.easeOut
						})]), s
					}
				}
				e.LeprechaunReelAreaView = c
			},
			76359: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunReelController = void 0;
				const n = i(52559),
					s = i(52601),
					o = i(52409),
					r = i(44679),
					a = i(46334);
				class l extends n.NudgeSpinReelController {
					constructor(t) {
						super(t), this._bonusFeatureTriggered = !1, this._gameDataParsed = !1, this._spinStarted = !1, this._nearWinReels = [!1, !1, !1]
					}
					onGameDataParsed(t) {
						this._nearWinReels = [!1, !1, !1], super.onGameDataParsed(t), this._bonusFeatureTriggered = t.bonusFeatureTriggered, this._bonusFeatureTriggered && (this._nearWinReels[1] = !0), this._gameDataParsed = !0, this.tryStartNearWin()
					}
					onSpinStartedCompleted() {
						super.onSpinStartedCompleted(), this._spinStartedTime = Date.now(), this._spinStarted = !0, this.tryStartNearWin()
					}
					tryStartNearWin() {
						0 == this.reelId && this._spinStarted && this._gameDataParsed && this._nearWinReels[0] && (a.Logger.logDev("reel0 starts near win!"), o.EventHandler.dispatchEvent(new r.GameEvent(s.SpinReelEvent.REEL_TRY_NEAR_WIN, 0)))
					}
					stopSpin(t, e) {
						if (this._nearWinReels[0] && 0 === this.reelId) {
							const t = (Date.now() - this._spinStartedTime) / 1e3;
							e = Math.max(0, e - t + (this.reelId > 0 ? 1 : 0))
						}
						return this.resetNearWinState(), super.stopSpin(t, e)
					}
					resetNearWinState() {
						this._spinStarted = !1, this._gameDataParsed = !1
					}
				}
				e.LeprechaunReelController = l
			},
			67155: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunReelPartAnimator = void 0;
				const n = i(13006),
					s = i(52409),
					o = i(330),
					r = i(48002),
					a = i(75367),
					l = i(21155);
				class h extends l.NudgeSpinReelPartAnimator {
					constructor(t) {
						super(t), this._bonusFeatureTriggered = !1, this.addEventListeners()
					}
					addEventListeners() {
						s.EventHandler.addEventListener(this, o.ServerEvent.GAME_DATA_PARSED, (t => this.parsedGameData(t.params[0])))
					}
					parsedGameData(t) {
						this._bonusFeatureTriggered = t.bonusFeatureTriggered
					}
					getSpinStopEase() {
						const t = r.LeprechaunGameConfig.instance.REEL_SPIN_STOP_ELASTIC_CONFIG;
						return this._bonusFeatureTriggered ? n.Linear.easeNone : n.Elastic.easeOut.config(t[0], t[1])
					}
					getSpinQuickStopEase() {
						const t = a.GameConfig.instance.REEL_SPIN_QUICK_STOP_ELASTIC_CONFIG;
						return this._bonusFeatureTriggered ? n.Linear.easeNone : n.Elastic.easeOut.config(t[0], t[1])
					}
					calculationStopSpinSpeed() {
						return this._bonusFeatureTriggered ? a.GameConfig.instance.REEL_NEAR_WIN_SPIN_SPEED : super.calculationStopSpinSpeed()
					}
				}
				e.LeprechaunReelPartAnimator = h
			},
			20334: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunReels = void 0;
				const n = i(52409),
					s = i(95831),
					o = i(44679),
					r = i(23792);
				class a extends r.Reels {
					constructor() {
						super()
					}
					addEventListeners() {
						super.addEventListeners(), n.EventHandler.addEventListener(this, s.LeprechaunReelAreaEvents.LIFT_REEL, (t => this.liftReels(t.params[0]))), n.EventHandler.addEventListener(this, s.LeprechaunReelAreaEvents.SLOW_MOTION_STOP, (t => this.onSlowMotionStop(t.params[0])))
					}
					liftReels(t) {
						r.Reels._reelAreaView.liftReelUp(r.Reels._reels[t.reelId].view, t.bounceStartPos), n.EventHandler.dispatchEvent(new o.GameEvent(s.LeprechaunReelAreaEvents.SLOW_MOTION_STOPPING))
					}
					onSlowMotionStop(t) {
						return r.Reels._reelAreaView.onSlowMotionStop(r.Reels._reels[t.reelId].view, t.startPos, t.bounceUpwards)
					}
				}
				e.LeprechaunReels = a
			},
			95831: (t, e) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunReelAreaEvents = void 0;
				class i {}
				e.LeprechaunReelAreaEvents = i, i.LIFT_REEL = "reelAreaEvent_liftReel", i.SLOW_MOTION_STOP = "reelAreaEvent_slowMotionStop", i.SLOW_MOTION_STOPPING = "reelAreaEvent_slowMotionStopping"
			},
			72149: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.StopHotZoneController = void 0;
				const n = i(3043),
					s = i(63114);
				class o extends n.ReelStopPresentationController {
					constructor(t) {
						super(t, "StopHotZoneController"), this._bonusFeatureTriggered = !1
					}
					parseFeatureGameData(t) {
						this._bonusFeatureTriggered = t.bonusFeatureTriggered
					}
					onReelBounce(t) {
						this.tryPlayBouncePresentation(t) || this.dispatchCompleteEvent(t.reelId)
					}
					tryPlayBouncePresentation(t) {
						return 1 === t.reelId && !this._bonusFeatureTriggered && (s.LeprechaunGameModuleConfig.hotZone.hide(t.fastSpin || t.quickStop), this.dispatchCompleteEvent(t.reelId), !0)
					}
				}
				e.StopHotZoneController = o
			},
			47851: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.WildTextWriteOn = void 0;
				const n = i(3043),
					s = i(23792),
					o = i(13006),
					r = i(23110),
					a = i(4773);
				class l extends n.ReelStopPresentationController {
					constructor(t) {
						super(t, "WildTextWriteOn"), this._hasEntireWilds = [], this._hasWilds = [], this._hasWin = !1
					}
					parseFeatureGameData(t) {
						this._hasEntireWilds = [], this._hasWilds = [], this._hasWin = t.singleWin > 0, t.reels.forEach(((e, i) => {
							this._hasEntireWilds.push("W*0" === e[2]), this._hasWilds.push(t.doReelNudge[i])
						}))
					}
					onReelBounce(t) {
						this.tryPlayBouncePresentation(t) || this.dispatchCompleteEvent(t.reelId)
					}
					tryPlayBouncePresentation(t) {
						const e = t.reelId;
						if (this._hasWilds[e] && r.SlotGame.sound.playEffect(a.LeprechaunSoundConfig.instance.NUDGE_START), this._hasEntireWilds[e]) {
							const i = s.Reels.getSymbol(e, 0),
								n = new o.TimelineLite;
							return n.add(i.playWriteOnWild()), n.add((() => this.dispatchCompleteEvent(t.reelId))), this._hasWin || n.progress(1), !0
						}
						return !1
					}
				}
				e.WildTextWriteOn = l
			},
			30552: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.FeaturePrice = void 0;
				const n = i(52409),
					s = i(330),
					o = i(1394);
				e.FeaturePrice = class {
					constructor() {
						this.addEventListeners()
					}
					getBuyFeaturePrice(t, e) {
						var i;
						const n = o.Leprechaun.api.betFeatureController.getActiveBetFeature();
						if (n) return n.getTotalCost();
						{
							const e = o.Leprechaun.api.freeBets.hasFreeBets() ? o.Leprechaun.api.freeBets.getBet() : o.Leprechaun.api.betLevel.getLevel();
							return t || (null === (i = o.Leprechaun.model.gameData) || void 0 === i ? void 0 : i.playedBetValue) || parseFloat(e)
						}
					}
					isWinBelowStake() {
						return o.Leprechaun.api.gameClientConfiguration.belowStakeWinRestriction && this.getAccumulatedRoundWin() <= this.getBuyFeaturePrice()
					}
					addEventListeners() {
						n.EventHandler.addEventListener(this, s.ServerEvent.GAME_DATA_PARSED, (t => this.onGameDataParsed(t.params[0]))), n.EventHandler.addEventListener(this, s.ServerEvent.INIT_DATA_PARSED, (t => this.onInitDataParsed(t.params[0])))
					}
					onGameDataParsed(t) {
						this._gameData = t
					}
					onInitDataParsed(t) {
						this._initData = t
					}
					getAccumulatedRoundWin() {
						var t;
						return +((null === (t = this._gameData) || void 0 === t ? void 0 : t.accumulatedRoundWin) || this._initData.accumulatedRoundWin)
					}
				}
			},
			17162: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunServerDataParser = void 0;
				const n = i(75367),
					s = i(83857),
					o = i(17206),
					r = i(56005);
				class a extends s.SpinServerDataParser {
					constructor() {
						super()
					}
					parseBetWins(t) {
						switch (n.GameConfig.instance.BET_WIN_MODE) {
							case 1:
								return this.parseBetLineData(t.betLineWins);
							case 2:
								return t.betWayWins;
							default:
								throw new Error("ServerDataParser.parseBetWins(): Invalid BetWinMode from GameConfig!")
						}
					}
					parseBetLineData(t) {
						let e = [];
						return t.forEach((t => {
							t.amount > 0 && e.push(t)
						})), e
					}
					parseDoReelNudge(t) {
						return t.doReelNudge.concat()
					}
					parseExtraSymbolsOnTop(t, e) {
						return t.mode === r.LeprechaunGameMode.FS_PICK ? t.extraSymbolsOnTop : o.ServerDataParser.parseStackedSymbolsInReels(t.extraSymbolsOnTop, e)
					}
				}
				e.LeprechaunServerDataParser = a
			},
			47912: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunParsedGameData = void 0;
				const n = i(56005),
					s = i(93035),
					o = i(34785),
					r = i(75367);
				class a extends s.SpinParsedGameData {
					get accumulatedRoundWin() {
						return this._accumulatedRoundWin
					}
					constructor(t, e) {
						super(t, e), this._doReelNudge = e.parseDoReelNudge(t), this._extraSymbolsOnTop = e.parseExtraSymbolsOnTop(t, o.ArrayHelper.initArrayWithValues(r.GameConfig.instance.REELS_NUM, (t => this.reels[t][0]))), this._bonusWin = t.bonusFeatureTriggered, this._bonusFeatureTriggered = t.reels[1].indexOf("B") > 1 && t.reels[1].indexOf("B") < 5, this._playerSelection = t.playerSelection, this._pickedIndexesAfter = t.pickedIndexesAfter, this._pickedIndexesBefore = t.pickedIndexesBefore, this._revealedBefore = t.revealedBefore, this._possibleReveals = t.possibleReveals, this._thisRevealedPicked = t.thisRevealedPicked, this._pickedExtraLines = t.pickedExtraLines, this._pickedExtraMultiplier = t.pickedExtraMultiplier, this._pickedExtraSpins = t.pickedExtraSpins, this._addedLines = t.addedLines, this._addedMultiplier = t.addedMultiplier, this._freespinMultiplier = t.freespinMultiplier, this._addedNumberOfFreespins = t.addedNumberOfFreespins, this._multiplierOnReel = t.multiplierOnReel, this._pickedData = {
							EXTRA_LINES: {
								value: t.addedLines,
								pickedNumber: t.pickedExtraLines
							},
							EXTRA_MULTIPLIER: {
								value: t.addedMultiplier,
								pickedNumber: t.pickedExtraMultiplier
							},
							EXTRA_SPINS: {
								value: t.addedNumberOfFreespins,
								pickedNumber: t.pickedExtraSpins
							}
						}, this._accumulatedRoundWin = t.accumulatedRoundWin
					}
					get pickedData() {
						return this._pickedData
					}
					get freespinMultiplier() {
						return this._freespinMultiplier
					}
					get pickedExtraLines() {
						return this._pickedExtraLines
					}
					get pickedExtraMultiplier() {
						return this._pickedExtraMultiplier
					}
					get pickedExtraSpins() {
						return this._pickedExtraSpins
					}
					get possibleReveals() {
						return this._possibleReveals
					}
					get pickedIndexesAfter() {
						return this._pickedIndexesAfter
					}
					get thisRevealedPicked() {
						return this._thisRevealedPicked
					}
					get pickedIndexesBefore() {
						return this._pickedIndexesBefore
					}
					get extraSymbolsOnTop() {
						return this._extraSymbolsOnTop
					}
					get bonusFeatureTriggered() {
						return this._bonusFeatureTriggered
					}
					get doReelNudge() {
						return this._doReelNudge
					}
					get bonusWin() {
						return this._bonusWin
					}
					get playerSelection() {
						return this._playerSelection
					}
					get multiplierOnReel() {
						return this._multiplierOnReel
					}
					isFeatureTotalWin(t) {
						return this.mode === n.LeprechaunGameMode.FS_PICK
					}
					isNextFeatureTotalWin(t) {
						return this.nextMode === n.LeprechaunGameMode.FS_PICK
					}
				}
				e.LeprechaunParsedGameData = a
			},
			21028: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunParsedInitData = void 0;
				const n = i(82210),
					s = i(56005);
				class o extends n.ParsedInitData {
					get accumulatedRoundWin() {
						return this._accumulatedRoundWin
					}
					get featureBuyTimesBetValue() {
						return this._featureBuyTimesBetValue
					}
					constructor(t, e) {
						super(t, e), this._pickedIndexesBefore = t.pickedIndexesBefore, this._playerSelection = t.playerSelection, this._pickedExtraLines = t.pickedExtraLines, this._pickedExtraMultiplier = t.pickedExtraMultiplier, this._pickedExtraSpins = t.pickedExtraSpins, this._isRestoreSelectedAll = t.mode === s.LeprechaunGameMode.FS_PICK && "FREESPIN" === t.nextMode, this._addedLines = t.addedLines, this._addedMultiplier = t.addedMultiplier, this._addedNumberOfFreespins = t.addedNumberOfFreespins, this._freespinMultiplier = t.freespinMultiplier, this._revealedBefore = t.revealedBefore, this._possibleReveals = t.possibleReveals, this._pickedData = {
							EXTRA_LINES: {
								value: t.addedLines,
								pickedNumber: t.pickedExtraLines
							},
							EXTRA_MULTIPLIER: {
								value: t.addedMultiplier,
								pickedNumber: t.pickedExtraMultiplier
							},
							EXTRA_SPINS: {
								value: t.addedNumberOfFreespins,
								pickedNumber: t.pickedExtraSpins
							}
						}, this._featureBuyTimesBetValue = t.featureBuyTimesBetValue, this._accumulatedRoundWin = t.accumulatedRoundWin
					}
					get pickedData() {
						return this._pickedData
					}
					get possibleReveals() {
						return this._possibleReveals
					}
					get revealedBefore() {
						return this._revealedBefore
					}
					get freespinMultiplier() {
						return this._freespinMultiplier
					}
					get addedNumberOfFreespins() {
						return this._addedNumberOfFreespins
					}
					get addedMultiplier() {
						return this._addedMultiplier
					}
					get addedLines() {
						return this._addedLines
					}
					get isRestoreSelectedAll() {
						return this._isRestoreSelectedAll
					}
					get pickedExtraLines() {
						return this._pickedExtraLines
					}
					get pickedExtraMultiplier() {
						return this._pickedExtraMultiplier
					}
					get pickedExtraSpins() {
						return this._pickedExtraSpins
					}
					get pickedIndexesBefore() {
						return this._pickedIndexesBefore
					}
					get playerSelection() {
						return this._playerSelection
					}
					isFeatureTotalWin(t) {
						return this.mode === s.LeprechaunGameMode.FS_PICK
					}
					isNextFeatureTotalWin(t) {
						return this.nextMode === s.LeprechaunGameMode.FS_PICK
					}
				}
				e.LeprechaunParsedInitData = o
			},
			66816: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SoundPlayer = void 0;
				const n = i(23110),
					s = i(42226),
					o = i(4773);
				e.SoundPlayer = class {
					constructor() {}
					playNormalWinSound(t) {
						let e = "";
						switch (t.type) {
							case s.WinRatioType.TINY:
								e = o.LeprechaunSoundConfig.TINY_WIN;
								break;
							case s.WinRatioType.SMALL:
								e = o.LeprechaunSoundConfig.SMALL_WIN;
								break;
							case s.WinRatioType.MEDIUM:
								e = o.LeprechaunSoundConfig.MEDIUM_WIN;
								break;
							case s.WinRatioType.LARGE:
								e = o.LeprechaunSoundConfig.LARGE_WIN;
								break;
							case s.WinRatioType.BIG_WIN:
							case s.WinRatioType.MEGA_WIN:
							case s.WinRatioType.SUPER_MEGA_WIN:
								n.SlotGame.sound.fadeAmbience(0, 1e3), e = o.LeprechaunSoundConfig.BIG_WIN_START;
								break;
							default:
								e = ""
						}
						n.SlotGame.sound.playEffect(e)
					}
				}
			},
			24911: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunSpinController = void 0;
				const n = i(72519);
				class s extends n.SpinController {
					constructor() {
						super(), this._nearWinReels = [!1, !1, !1]
					}
					parseGameData(t) {
						this._nearWinReels = [!1, !1, !1], t.nearWinReels && (this._nearWinReels = t.nearWinReels)
					}
					getSpinTime() {
						return this._nearWinReels[0] ? Math.max(.1, n.SpinController.MIN_SPIN_TIME) : super.getSpinTime()
					}
				}
				e.LeprechaunSpinController = s
			},
			77720: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunReelSymbol = void 0;
				const n = i(55058),
					s = i(13006),
					o = i(48002);
				class r extends n.StateReelSymbol {
					constructor(t, e, i) {
						super(t, e, i)
					}
					addNewStateAnimation(t, e, i, n) {
						super.addNewStateAnimation(t, e, i, n), e.state.keyword == o.LeprechaunGameConfig.instance.SYMBOL_STATES.win.keyword && this.symName.indexOf("W") < 0 && (t.add(new s.TweenLite(this.scale, .2, {
							x: .7,
							y: .7
						})), t.add(new s.TweenLite(this.scale, .5, {
							x: 1.05,
							y: 1.05,
							ease: s.Back.easeOut.config(1.7)
						})), t.add(new s.TweenLite(this.scale, .3, {
							x: 1,
							y: 1
						})))
					}
				}
				e.LeprechaunReelSymbol = r
			},
			46593: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunReelSymbolBonus = void 0;
				const n = i(75367),
					s = i(88240),
					o = i(7057),
					r = i(77720);
				class a extends r.LeprechaunReelSymbol {
					constructor(t, e, i) {
						super(t, e, i)
					}
					initAnimations() {
						this._rainbowTail || (this._rainbowTail = this.createRainbowTail()), this._rainbowIdle || (this._rainbowIdle = this.createRainbowIdle())
					}
					addNewStateAnimation(t, e, i, s) {
						super.addNewStateAnimation(t, e, i, s), e.state.keyword === n.GameConfig.instance.SYMBOL_STATES.normal.keyword && this.visible ? t.add((() => {
							this._rainbowIdle || (this._rainbowIdle = this.createRainbowIdle()), this._rainbowIdle.show(), this._rainbowIdle.playLoop()
						}), s) : this._rainbowIdle && (this._rainbowIdle.stopLoop(), this._rainbowIdle.hide()), e.state.keyword === n.GameConfig.instance.SYMBOL_STATES.spin.keyword && this.visible ? t.add((() => this.playRainbowTail()), s) : this.stopRainbowTail()
					}
					createRainbowTail() {
						const t = new PIXI.Sprite(s.GameResources.getTextures("rainbowTail")[0]);
						return t.anchor.set(.5, 1), t.alpha = 0, t.position.set(0, 98), t.blendMode = PIXI.BLEND_MODES.ADD, t
					}
					createRainbowIdle() {
						const t = new o.TimelineSprite(s.GameResources.getTextures("rainbowBonusIdle"), 15);
						return t.anchor.set(.5, 1), t.hide(), t.position.set(0, 58), t.blendMode = PIXI.BLEND_MODES.ADD, this.addChild(t), t
					}
					playRainbowTailSound() {}
					playRainbowTail() {
						this._rainbowTail || (this._rainbowTail = this.createRainbowTail()), this.addChild(this._rainbowTail), this._rainbowTail.alpha = 1, this.parent && this.parent.addChild(this), this.playRainbowTailSound && this.playRainbowTailSound()
					}
					stopRainbowTail() {
						this._rainbowTail && (this._rainbowTail.alpha = 0)
					}
					reset(t) {
						super.reset(t), this._rainbowTail && this.removeChild(this._rainbowTail)
					}
					initState(t) {
						return !!super.initState(t) && (this._rainbowTail && this.addChild(this._rainbowTail), !0)
					}
				}
				e.LeprechaunReelSymbolBonus = a
			},
			85239: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunReelSymbolStateCreator = void 0;
				const n = i(71404);
				class s extends n.ReelSymbolStateCreator {
					constructor() {
						super()
					}
					getBasicStateAnimation(t, e, i) {
						const n = super.getBasicStateAnimation(t, e, i);
						return "B" !== t.symName || ("floating" === e && n.playLoop(), "landing" === e && n.getAnimationAutoShowHide(!0, !1)), n
					}
					noWinStateCreator(t, e, i) {
						const n = this.getBasicStateAnimation(t, e, i);
						return n && (n.tint = 5592405), n
					}
				}
				e.LeprechaunReelSymbolStateCreator = s
			},
			24320: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunReelSymbolWild = void 0;
				const n = i(74233),
					s = i(75367),
					o = i(88240),
					r = i(7057),
					a = i(13006),
					l = i(48002),
					h = i(77720);
				class u extends h.LeprechaunReelSymbol {
					constructor(t, e, i) {
						super(t, e, i), this._currentMultiplier = 1
					}
					initAnimations() {
						this._background || (this._background = new PIXI.Sprite(o.GameResources.getTextures("wildBg")[0]), this._background.anchor.set(.5, .5), this._background.position.set(0, -172), this.addChild(this._background)), this._nudgeAnimation || (this._nudgeAnimation = new PIXI.spine.Spine(o.GameResources.getSpineAsset("wLand")), this._nudgeAnimation.autoUpdate = !0, this._nudgeAnimation.position.set(0, -172), this._nudgeAnimation.state.setEmptyAnimation(0, 0)), this._winFrames || (this._winFrames = new r.TimelineSprite(o.GameResources.getTextures("wildNudgeBg")), this._winFrames.blendMode = PIXI.BLEND_MODES.ADD, this._winFrames.anchor.set(.5, .5), this._winFrames.scale.set(2, 2), this._winFrames.position.set(0, -172), this._winFrames.hide(), this.addChild(this._winFrames)), this._wildNudgeSparkles || (this._wildNudgeSparkles = new r.TimelineSprite(o.GameResources.getTextures("wildNudgeSparkles")), this._wildNudgeSparkles.blendMode = PIXI.BLEND_MODES.ADD, this._wildNudgeSparkles.anchor.set(.5, .5), this._wildNudgeSparkles.scale.set(2, 2), this._wildNudgeSparkles.position.set(0, -172), this.addChild(this._wildNudgeSparkles)), this._multiplierPatch || (this._multiplierPatch = new PIXI.Sprite(o.GameResources.getTextures("X1")[0]), this._multiplierPatch.anchor.set(.5, .5), this._multiplierPatch.position.set(-18, -178)), this._writeOnText || (this._writeOnText = new r.TimelineSprite(o.GameResources.getTextures("wildWriteOnText")), this._writeOnText.anchor.set(.5, .5), this._writeOnText.position.set(0, 0), this._writeOnText.getAnimation([30, 30]))
					}
					initState(t) {
						return !!super.initState(t) && (this._multiplierPatch && this.addChild(this._multiplierPatch), this._writeOnText && this.addChild(this._writeOnText), !0)
					}
					addNewStateAnimation(t, e, i, r) {
						super.addNewStateAnimation(t, e, i, r);
						const h = "X" + (this._currentMultiplier ? this._currentMultiplier : 1) + (e.state.keyword === s.GameConfig.instance.SYMBOL_STATES.spin.keyword ? "_blur" : "");
						this._multiplierPatch.texture = o.GameResources.getTextures(h)[0], e.state.keyword === s.GameConfig.instance.SYMBOL_STATES.spin.keyword ? t.add([a.TweenLite.to(this._writeOnText, e.fadeInDuration, {
							alpha: 0
						}), a.TweenLite.to(this._multiplierPatch, e.fadeInDuration, {
							alpha: 0
						})], r) : this._multiplierPatch && (this._multiplierPatch.alpha = 1), e.state.keyword !== s.GameConfig.instance.SYMBOL_STATES.win.keyword && e.state.keyword !== l.LeprechaunGameConfig.instance.SYMBOL_STATES.nudge.keyword || (this._winFrames && t.add((() => {
							this._winFrames.show(), this._winFrames.playLoop()
						}), r), this._nudgeAnimation && (e.state.keyword === l.LeprechaunGameConfig.instance.SYMBOL_STATES.nudge.keyword ? (this._multiplierPatch.alpha = 1, this.addChild(this._nudgeAnimation), this.addChild(this._multiplierPatch), this.addChild(this._writeOnText), t.add(new n.SpineTween(this._nudgeAnimation, 0, "animation", -1), r)) : (this._nudgeAnimation.state.clearTrack(0), this._nudgeAnimation.skeleton.setToSetupPose())))
					}
					stopNudgeAnimation() {
						this._nudgeAnimation && (this._nudgeAnimation.state.clearTrack(0), this._nudgeAnimation.skeleton.setToSetupPose())
					}
					reset(t) {
						this._nudgeAnimation && (this.removeChild(this._nudgeAnimation), this._nudgeAnimation.state.clearTrack(0), this._nudgeAnimation.skeleton.setToSetupPose(), this._nudgeAnimation = null), this._winFrames && (this.removeChild(this._winFrames), this._winFrames.stopLoop(), this._winFrames.hide()), this._writeOnText && (this._writeOnText.hide(), this.removeChild(this._writeOnText)), this._wildNudgeSparkles && (this.removeChild(this._wildNudgeSparkles), this._wildNudgeSparkles.stopLoop(), this._wildNudgeSparkles.hide()), this._multiplierPatch && this.removeChild(this._multiplierPatch), super.reset(t)
					}
					playWriteOn() {
						this._multiplierPatch && (this._multiplierPatch.alpha = 1, this.addChild(this._multiplierPatch))
					}
					playWriteOnWild() {
						return this.playWriteOn(), this._writeOnText.alpha = 1, this.addChild(this._writeOnText), this._writeOnText.getAnimationAutoShowHide(!0, !1)
					}
					playNudgeSparkles() {
						this._wildNudgeSparkles && this._wildNudgeSparkles.getAnimation()
					}
					updateMultiplier(t, e) {
						const i = new a.TimelineLite,
							n = "X" + t.toString();
						return null !== this._multiplierPatch && (this.stack ? this.stack.symbols.forEach((s => {
							s && i.add(s.updateMultiplierInternal(t, s === this && e, n), 0)
						})) : i.add(this.updateMultiplierInternal(t, e, n), 0)), i
					}
					updateMultiplierInternal(t, e, i) {
						this._currentMultiplier = t;
						const n = new a.TimelineLite;
						return n.add((() => {
							this._multiplierPatch.texture = o.GameResources.getTextures(i)[0]
						}), 0), e && (n.add(a.TweenLite.fromTo(this._multiplierPatch.scale, .07, {
							x: 1,
							y: 1
						}, {
							x: 2,
							y: 2
						})), n.add(a.TweenLite.to(this._multiplierPatch.scale, .07, {
							x: 2,
							y: 2
						})), n.add(a.TweenLite.to(this._multiplierPatch.scale, .17, {
							x: 1,
							y: 1
						}))), n
					}
				}
				e.LeprechaunReelSymbolWild = u
			},
			30261: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.SymbolWinAnimation = void 0;
				const n = i(73044),
					s = i(52409),
					o = i(75367),
					r = i(88240),
					a = i(32696),
					l = i(85206),
					h = i(56682),
					u = i(7057),
					c = i(13006),
					d = i(48002);
				class p extends n.BaseView {
					constructor() {
						super(), this._winBackground = [], this._cloverBurst = [], this._symIdleAnimation = [], this._layer = l.StageManager.getLayer(d.LeprechaunGameConfig.instance.LAYERS.SYMBOL_WIN_ANIMATION.name)
					}
					addEventListeners() {
						s.EventHandler.addEventListener(this, a.SpinEvent.BEFORE_START, (t => this.resetAnimation()))
					}
					initAnimations() {
						this._winBackground = [], this._cloverBurst = [], this._symIdleAnimation = [];
						for (let t = 0; t < 3; t++) {
							const t = [],
								e = [],
								i = [];
							for (let n = 0; n < 3; n++) {
								const n = new u.TimelineSprite(r.GameResources.getTextures("symWinBgAnimation"));
								n.anchor.set(.5, .5), n.position.set(0, 0), n.hide(), n.blendMode = PIXI.BLEND_MODES.ADD;
								const s = new u.TimelineSprite(r.GameResources.getTextures("cloverBurst"));
								s.anchor.set(.5, .5), s.position.set(0, 0), s.hide();
								const o = new u.TimelineSprite(r.GameResources.getTextures("symIdleAnimation"));
								o.anchor.set(.5, .5), o.position.set(0, 0), o.hide(), o.blendMode = PIXI.BLEND_MODES.ADD, t.push(n), e.push(s), i.push(o)
							}
							this._winBackground.push(t), this._cloverBurst.push(e), this._symIdleAnimation.push(i)
						}
					}
					playSymbolWinAnimation(t, e) {
						const i = this._winBackground[t][e],
							n = this._cloverBurst[t][e],
							s = h.Helper.getSymbolPositions(t, e, !0),
							o = new c.TimelineLite;
						return o.add([() => {
							i.hide(), n.hide(), this._layer.addChild(i), this._layer.addChild(n), i.position.set(s[0], s[1]), n.position.set(s[0], s[1])
						}, n.getAnimationAutoShowHide(!0, !0), i.getAnimationAutoShowHide(!0, !0)]), o
					}
					playIdleAnimation(t, e, i) {
						const n = this._symIdleAnimation[t][e],
							s = h.Helper.getSymbolPositions(t, e, !0);
						i && (s[1] = o.GameConfig.instance.REEL_AREA_POS_Y - 70);
						const r = new c.TimelineLite;
						return r.add([() => {
							this._layer.addChild(n), n.position.set(s[0], s[1]), n.blendMode = PIXI.BLEND_MODES.ADD
						}, n.getAnimationAutoShowHide(!0, !0)]), r
					}
					resetWinAnimation() {
						this._winBackground.forEach((t => {
							t.forEach((t => {
								this._layer.removeChild(t), t.hide()
							}))
						})), this._cloverBurst.forEach((t => {
							t.forEach((t => {
								this._layer.removeChild(t), t.hide()
							}))
						}))
					}
					resetAnimation() {
						this.resetWinAnimation(), this._symIdleAnimation.forEach((t => {
							t.forEach((t => {
								this._layer.removeChild(t), t.hide()
							}))
						}))
					}
				}
				e.SymbolWinAnimation = p
			},
			17318: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunBigWinController = void 0;
				const n = i(23110),
					s = i(85206),
					o = i(42352),
					r = i(13006),
					a = i(48002),
					l = i(4773),
					h = i(21526),
					u = i(6063);
				class c extends o.StepCountUpBigWinController {
					constructor(t) {
						super(t, {
							skipLastLevelCountUpIfSmall: !1,
							skippableOnEachLevel: !1
						}), this._isEnding = !1, this._gameView = new u.LeprechaunBigWinView, this._winCountUp = new h.LeprechaunBigWinCountUp, this._winCountUp.position.set(360, 450), s.StageManager.getLayer(a.LeprechaunGameConfig.instance.LAYERS.WIN_COUNT_UP.name).addChild(this._winCountUp)
					}
					playBigWinSound() {
						n.SlotGame.sound.playEffect(l.LeprechaunSoundConfig.instance.WIN_BIG), n.SlotGame.sound.fadeAmbience(0, 1e3)
					}
					playBigWinCountUp(t, e) {
						const i = new r.TimelineLite;
						if (0 === t) {
							this._winCountUpTimeline = new r.TimelineLite({
								paused: !0
							});
							let t = 0,
								e = 0;
							for (; t <= this._winLevel;) e += this._winRatios[t].duration, t++;
							this._winCountUpTimeline.add(this.playCountUp(0, this._gameData.singleWin, e)), this._winCountUpTimeline.play(0)
						}
						return i
					}
					getBigWinLevelAnimation(t) {
						const e = new r.TimelineLite;
						return e.add(this._gameView.getBigWinLevelAnimation(t, this._winRatios[t])), t === this._winLevel && e.add([this._gameView.playEndingAnimation(this._winLevel, this._winCountUp, this._gameData.totalWin), () => {
							this._isEnding = !0, n.SlotGame.sound.fadeAmbience(1, 2e3), n.SlotGame.sound.stopEffect(l.LeprechaunSoundConfig.instance.WIN_BIG), n.SlotGame.sound.playEffect(l.LeprechaunSoundConfig.instance.WIN_BIG_END[this._winLevel])
						}]), e
					}
					playCountUp(t, e, i, n = 0) {
						return this._winCountUp.getCountUpAnimation(t, e, i)
					}
					playEndingAnimation(t) {
						this._winCountUpTimeline && (this._winCountUpTimeline.isActive() && this._winCountUpTimeline.pause(), this._winCountUpTimeline = null), this._winCountUp.abort(this._gameData.singleWin, t), n.SlotGame.winFieldController.showWinField(this._gameData.totalWin), t && (this._isEnding || (n.SlotGame.sound.fadeAmbience(1, 2e3), n.SlotGame.sound.stopEffect(l.LeprechaunSoundConfig.instance.WIN_BIG), n.SlotGame.sound.playEffect(l.LeprechaunSoundConfig.instance.WIN_BIG_END[this._winLevel])), this._gameView.playAbortedEndingAnimation(this._winLevel)), this._isEnding = !1
					}
					stopAllSounds() {}
				}
				e.LeprechaunBigWinController = c
			},
			21526: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunBigWinCountUp = void 0;
				const n = i(68744),
					s = i(13006);
				class o extends n.BitmapWinCountUp {
					constructor() {
						super({
							font: {
								name: "NumbersWinCountUp",
								size: 38
							},
							tint: parseInt("#ffffff".replace(/^#/, ""), 16)
						})
					}
					initAnimations() {
						super.initAnimations()
					}
					getCountUpAnimation(t, e, i) {
						const n = new s.TimelineLite;
						return n.add([() => {
							this._countUp.alpha = 1, this._countUp.visible = !0
						}, this._countUp.getCountUpAnimation(t, e, {
							duration: i,
							ease: 0 == t ? s.Power3.easeInOut : s.Power2.easeOut
						}), s.TweenLite.fromTo(this._countUpContainer.scale, 1, {
							x: .5,
							y: .5
						}, {
							x: 1,
							y: 1,
							ease: s.Elastic.easeOut.config(2, 1)
						})]), n
					}
					getCountUpEndAnimation(t) {}
					getAbortAnimation(t) {
						const e = new s.TimelineLite;
						return e.add([() => {
							this._countUp.alpha = 1, this._countUp.visible = !0
						}, s.TweenLite.fromTo(this._countUpContainer.scale, .2, {
							x: .5,
							y: .5
						}, {
							x: 1,
							y: 1,
							ease: s.Elastic.easeOut.config(2, 1)
						}), this._countUp.getCountUpAnimation(t, t, {
							duration: .01
						})]), e
					}
					getEndingAnimation() {
						const t = new s.TimelineLite;
						return t.add(s.TweenLite.to(this._countUp, .2, {
							alpha: 0
						}), "+=0.8"), t
					}
				}
				e.LeprechaunBigWinCountUp = o
			},
			6063: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunBigWinView = void 0;
				const n = i(73044),
					s = i(88240),
					o = i(85206),
					r = i(34785),
					a = i(56682),
					l = i(7057),
					h = i(13006),
					u = i(48002),
					c = i(64989);
				class d extends n.BaseView {
					constructor() {
						super(), this.TEXTS = [{
							text: "Big Win",
							style: {
								fontFamily: "Open Sans",
								fontSize: 80,
								fontWeight: "bold",
								fill: ["#ffffff", "#00ccff"],
								dropShadow: !0,
								dropShadowColor: "#000000",
								dropShadowBlur: 4,
								dropShadowAngle: Math.PI / 2,
								dropShadowDistance: 3,
								wordWrap: !0,
								wordWrapWidth: 440
							}
						}, {
							text: "Mega Win",
							style: {
								fontFamily: "Open Sans",
								fontSize: 80,
								fontWeight: "bold",
								fill: ["#ffffff", "#ffcc00"],
								dropShadow: !0,
								dropShadowColor: "#000000",
								dropShadowBlur: 4,
								dropShadowAngle: Math.PI / 2,
								dropShadowDistance: 3,
								wordWrap: !0,
								wordWrapWidth: 440
							}
						}, {
							text: "Super Mega Win",
							style: {
								fontFamily: "Open Sans",
								fontSize: 80,
								fontWeight: "bold",
								fill: ["#ffffff", "#ff0099"],
								dropShadow: !0,
								dropShadowColor: "#000000",
								dropShadowBlur: 4,
								dropShadowAngle: Math.PI / 2,
								dropShadowDistance: 3,
								wordWrap: !1,
								wordWrapWidth: 440
							}
						}], this._isShowing = !1, this._coinContainer = new PIXI.Container, this._layer = o.StageManager.getLayer(u.LeprechaunGameConfig.instance.LAYERS.BIG_WIN.name), this._dimmer = new PIXI.Sprite(PIXI.Texture.WHITE), this._dimmer.anchor.set(.5, .5), this._dimmer.position.set(360, 360), this._dimmer.tint = 0, this._dimmer.alpha = 0, this._layer.addChild(this._dimmer), this._coinsFountain = new c.CoinsFountain(this._layer)
					}
					initAnimations() {
						this._winSplash = new l.TimelineSprite(s.GameResources.getTextures("winSplash")), this._winSplash.blendMode = PIXI.BLEND_MODES.ADD, this._winSplash.hide(), this._winSplash.scale.set(4, 4), this._winSplash.anchor.set(.5, .5), this._winStar = new l.TimelineSprite(s.GameResources.getTextures("winStar")), this._winStar.blendMode = PIXI.BLEND_MODES.ADD, this._winStar.hide(), this._winStar.scale.set(3, 3), this._winStar.anchor.set(.5, .5), this._layer.addChild(this._winStar), this._textContainer = new PIXI.Sprite, this._textContainer.anchor.set(.5, .5), this._textContainer.position.set(a.Helper.getSymbolPositions(1, 0)[0], a.Helper.getSymbolPositions(1, 0)[1] - 30), this._layer.addChild(this._textContainer), this._texts = r.ArrayHelper.initArrayWithValues(this.TEXTS.length, (t => {
							const e = new PIXI.Sprite(s.GameResources.getTextures("bigWinText" + t)[0]);
							return e.y = -e.height / 2, e.x = -e.width / 2, e.alpha = 0, this._textContainer.addChild(e), e
						})), this._textsEffect = r.ArrayHelper.initArrayWithValues(this.TEXTS.length, (t => {
							const e = new l.TimelineSprite(s.GameResources.getTextures("bigWinTextEffect" + t));
							return e.scale.set(2, 2), e.y = -e.height / 2, e.x = -e.width / 2, e.blendMode = PIXI.BLEND_MODES.ADD, e.hide(), this._textContainer.addChild(e), e
						})), this._winTextStar = new l.TimelineSprite(s.GameResources.getTextures("bigWinTextStar")), this._winTextStar.scale.set(2, 2), this._winTextStar.y = -this._winTextStar.height / 2, this._winTextStar.x = -this._winTextStar.width / 2, this._winTextStar.blendMode = PIXI.BLEND_MODES.ADD, this._winTextStar.hide(), this._textContainer.addChild(this._winTextStar)
					}
					onResize(t) {
						this._isResizeDirty = !1, this._dimmer.width = t.width + 100, this._dimmer.height = t.height + 100, this._winStar.x = 360, this._winStar.y = 360, this._winSplash.x = 360, this._winSplash.y = 360, this._coinContainer.y = 0 - .5 * (t.height - 720)
					}
					getBigWinLevelAnimation(t, e) {
						this._layer.addChild(this._winSplash);
						const i = new h.TimelineLite;
						return this._textsEffect.forEach(((t, e) => {
							t.hide()
						})), i.add([() => {
							this._winTextStar.hide(), this._winTextStar.stopLoop(), this._isShowing = !0, this._coinsFountain.startFountain(t)
						}, this.updateBigWinLevelAnimation(t), this._textsEffect[t].getAnimationAutoShowHide(!0, !0), h.TweenLite.to(this._dimmer, .1, {
							alpha: .6
						}), h.TweenLite.to(this, e.duration, {
							alpha: 1
						})], 0), i.add((() => {
							this._winTextStar.show(), this._winTextStar.playLoop()
						}), .66), t < 1 && (this._winStar.alpha = 1, i.add(this._winStar.getAnimationAutoShowHide(!0, !0), 0)), i
					}
					updateBigWinLevelAnimation(t) {
						const e = new h.TimelineLite;
						return this._texts.forEach(((e, i) => {
							e.alpha = i === t ? 1 : 0
						})), e.add([() => {
							this._layer.addChild(this._textContainer), this._winSplash.alpha = 1
						}, h.TweenLite.fromTo(this._textContainer, .231, {
							alpha: 0
						}, {
							alpha: 1
						}), this._winSplash.getAnimationAutoShowHide(!0, !0), h.TweenLite.fromTo(this._textContainer.scale, .231, {
							x: 2,
							y: 2
						}, {
							x: 1,
							y: 1
						})], 0), this._isShowing = !0, e
					}
					playEndingAnimation(t, e, i) {
						const n = new h.TimelineLite;
						return n.add([() => {
							this._texts.forEach(((e, i) => {
								e.alpha = i === t ? 1 : 0
							})), this._coinsFountain.stopFountain(), this._winTextStar.hide(), this._winTextStar.stopLoop()
						}, h.TweenLite.to(this._winSplash, .2, {
							alpha: 0
						}), h.TweenLite.to(this._winStar, .2, {
							alpha: 0
						}), h.TweenLite.to(this._dimmer, 1, {
							alpha: .6
						}), h.TweenLite.to(this._texts[t], 1, {
							alpha: 0
						})], 0), [0, .122, .244].forEach((t => {
							n.add((() => {
								e.getCountUpEndAnimation(i)
							}), t)
						})), n.add(h.TweenLite.to(this._dimmer, 1, {
							alpha: 0
						})), n.add((() => {
							this._isShowing = !1, this.reset()
						})), n
					}
					playAbortedEndingAnimation(t) {
						const e = new h.TimelineLite;
						e.add([() => {
							this._texts.forEach(((e, i) => {
								e.alpha = i === t ? 1 : 0
							})), this._textsEffect.forEach((t => {
								t.hide()
							})), this._coinsFountain.stopFountain(), this._winTextStar.hide(), this._winTextStar.stopLoop()
						}, h.TweenLite.to(this._winSplash, .2, {
							alpha: 0
						}), h.TweenLite.to(this._winStar, .2, {
							alpha: 0
						}), h.TweenLite.to(this._dimmer, 1, {
							alpha: 0
						}), h.TweenLite.to(this._texts[t], 1, {
							alpha: 0
						})]), e.add((() => {
							this._isShowing = !1, this.reset()
						}))
					}
					reset() {
						this._textContainer.scale.set(1, 1), this._winSplash.hide(), this._winStar.hide(), this._textsEffect.forEach((t => {
							t.hide()
						})), this._texts.forEach((t => {
							t.alpha = 0
						}))
					}
				}
				e.LeprechaunBigWinView = d
			},
			4564: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunBetLineWinIndividualWPController = void 0;
				const n = i(44679),
					s = i(13006),
					o = i(52409),
					r = i(53108),
					a = i(75129),
					l = i(34785),
					h = i(15807),
					u = i(48002),
					c = i(85206),
					d = i(23792),
					p = i(63114),
					_ = i(23110),
					m = i(4773);
				class g extends a.BetLineWinIndividualWPController {
					constructor(t, e = "BetLineIndividualWin", i) {
						super(t, e, i), this._reelsNum = 3, this._symbolsNum = 3
					}
					parseFeatureGameData(t) {
						this._totalWin = t.singleWin, this._symbolWinStates = l.ArrayHelper.initArrayWithValues(this._reelsNum, (() => l.ArrayHelper.initArrayWithValues(this._symbolsNum, (() => !1)))), this._betWinsData.forEach((t => {
							for (let e = 0; e < t.nrOfSymbols; e++) {
								const i = t.betLine[e];
								this._symbolWinStates[e][i] = !0
							}
						}))
					}
					startWinPresentation() {
						super.startWinPresentation(), this._totalWinText || this.createTotalWinText()
					}
					createTotalWinText() {
						this._totalWinText = new PIXI.BitmapText("0", {
							fontName: "NumbersWinCountUp",
							fontSize: 28
						}), this._totalWinText.visible = !1, c.StageManager.getLayer(u.LeprechaunGameConfig.instance.LAYERS.FOREGROUND.name).addChild(this._totalWinText)
					}
					getLineAnimation(t) {
						const e = new s.TimelineLite;
						e.add((() => {
							o.EventHandler.dispatchEvent(new n.GameEvent(r.BetLineEvent.HIDE_ALL_BET_LINES)), t.betLineIndex > 4 && _.SlotGame.sound.playEffect(m.LeprechaunSoundConfig.instance.RAINBOW_LINES[this._currentIndex % 2]), o.EventHandler.dispatchEvent(new n.GameEvent(h.LeprechaunBetlineEvent.SHOW_WIN_BET_LINE_WINS, t.betLineIndex + 1))
						}));
						for (let i = 0; i < t.nrOfSymbols; i++) {
							const n = d.Reels.getSymbol(i, t.betLine[i]);
							n && (this.addSymbolWinAnimationToTimeline(t, e, this._config.symbolTimeOffsetCalculator(e.totalDuration(), i, t.betLine[i]), n, i, t.betLine[i]), this._winSymbols.push(n))
						}
						return e
					}
					addSymbolWinAnimationToTimeline(t, e, i, n, s, o) {
						super.addSymbolWinAnimationToTimeline(t, e, i, n, s, o), e.add(p.LeprechaunGameModuleConfig.symbolWinAnimation.playIdleAnimation(s, o, !1), i)
					}
					stopWinPresentation(t) {
						super.stopWinPresentation(t), this._totalWinText || this.createTotalWinText(), this._totalWinText.visible = !1, p.LeprechaunGameModuleConfig.symbolWinAnimation.resetWinAnimation()
					}
				}
				e.LeprechaunBetLineWinIndividualWPController = g
			},
			56549: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunInitialWPController = void 0;
				const n = i(75367),
					s = i(83673),
					o = i(55058),
					r = i(23110),
					a = i(85206),
					l = i(34785),
					h = i(95968),
					u = i(13006),
					c = i(48002),
					d = i(63114),
					p = i(4773),
					_ = i(16182),
					m = i(77284),
					g = i(1394);
				class f extends h.SequentiallyBetLineInitialWPController {
					constructor(t) {
						super(t), this._reelsNum = n.GameConfig.instance.REELS_NUM, this._symbolsNum = n.GameConfig.instance.SYMBOLS_NUM_IN_REEL[2], this._gameView = new m.LeprechaunInitialWPView, this._winCountUp = new _.LeprechaunInitialWinCountUp(c.LeprechaunGameConfig.instance.WIN_COUNTUP_BITMAP_STYLE), this._winCountUp.position.set(n.GameConfig.instance.REEL_AREA_WIDTH / 2 - 20, 360), a.StageManager.getLayer(c.LeprechaunGameConfig.instance.LAYERS.WIN_COUNT_UP.name).addChild(this._winCountUp)
					}
					hasWin() {
						return this._hasStarted = !1, this._gameData.singleWin > 0
					}
					parseFeatureGameData(t) {
						this._symbolWinStates = l.ArrayHelper.initArrayWithValues(this._reelsNum, (() => l.ArrayHelper.initArrayWithValues(this._symbolsNum, (() => !1)))), this._betWinsData.forEach((t => {
							for (let e = 0; e < t.nrOfSymbols; e++) {
								const i = t.betLine[e];
								if (this._symbolWinStates[e][i] = !0, null != n.GameConfig.instance.STACKED_SYMBOLS) {
									const t = o.StateReelSymbol.parseStackedSymbolName(this._gameData.reels[e][i + n.GameConfig.instance.SYMBOLS_NUM_IN_REEL[1]], e);
									if (t.isStacked)
										for (let s = 0; s < t.totalNum; s++) this._symbolWinStates[e][Math.min(n.GameConfig.instance.SYMBOLS_NUM_IN_REEL[2] - 1, Math.max(0, s - t.index + i))] = !0
								}
							}
						})), c.LeprechaunGameConfig.instance.WIN_BELOW_STAKE = g.Leprechaun.api.gameClientConfiguration.belowStakeWinRestriction && t.singleWin <= t.playedBetValue
					}
					startWinPresentation() {
						this._hasStarted = !0, super.startWinPresentation(), !c.LeprechaunGameConfig.instance.WIN_BELOW_STAKE && d.LeprechaunGameModuleConfig.soundPlayer.playNormalWinSound(this._gameData.currentWinRatioConfig)
					}
					addSymbolWinAnimationToTimeline(t, e, i, s, o, a) {
						const l = s.changeState({
							state: n.GameConfig.instance.SYMBOL_STATES.win,
							fadeInDuration: .1
						});
						return c.LeprechaunGameConfig.instance.WIN_BELOW_STAKE || e.add(d.LeprechaunGameModuleConfig.symbolWinAnimation.playSymbolWinAnimation(o, a), i), e.add([l, () => {
							if (!c.LeprechaunGameConfig.instance.WIN_BELOW_STAKE) {
								const t = p.LeprechaunSoundConfig.instance.SYMBOL_WIN_HIT;
								r.SlotGame.sound.playEffect(t)
							}
						}], i), this.getNextSymbolAnimationTimeOffset(l.totalDuration())
					}
					getNextSymbolAnimationTimeOffset(t) {
						return c.LeprechaunGameConfig.instance.WIN_BELOW_STAKE ? 0 : .2
					}
					getNextBetWinAnimationTimeOffset(t) {
						return .3
					}
					addWinCountUpToTimeline(t) {
						if (this._gameData.isBigWin) return;
						this._gameData.totalWin, this._gameData.singleWin;
						const e = this._gameData.currentWinRatioConfig.duration,
							i = new u.TimelineLite,
							n = this._gameData.mode === s.GameMode.FREESPIN ? this._gameData.freespinMultiplier : this._gameData.currentMultiplier;
						i.add(this._winCountUp.getCountUpAnimation(0, this._gameData.singleWin, e, n)), t.add([i, () => {
							e > 1 && this._gameView.playClovers(e > 1.5 ? 1 : 0)
						}], 0);
						const o = i.duration();
						t.add((() => r.SlotGame.winFieldController.showWinField()), o)
					}
					stopWinPresentation(t) {
						!t || this._hasStarted || c.LeprechaunGameConfig.instance.WIN_BELOW_STAKE || r.SlotGame.sound.playEffect(p.LeprechaunSoundConfig.instance.COUNT_UP_ENDS), d.LeprechaunGameModuleConfig.symbolWinAnimation.resetWinAnimation(), this._winCountUp.abort(this._gameData.singleWin, t, this._gameData.currentMultiplier, this._gameData.isBigWin), this._gameData.isBigWin || r.SlotGame.winFieldController.showWinField(), super.stopWinPresentation(t)
					}
				}
				e.LeprechaunInitialWPController = f
			},
			77284: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunInitialWPView = void 0;
				const n = i(73044),
					s = i(88240),
					o = i(66493),
					r = i(85206),
					a = i(7615),
					l = i(3848),
					h = i(48002);
				class u extends n.BaseView {
					constructor() {
						super(), this._layer = r.StageManager.getLayer(h.LeprechaunGameConfig.instance.LAYERS.WIN_PRESENTATIONS.name)
					}
					initAnimations() {
						const t = s.GameResources.getTextures("bigWinCoin1"),
							e = s.GameResources.getTextures("bigWinCoin0");
						this._coinParticles = new l.TweenParticleEmitter(t, {
							alpha: {
								start: 1,
								end: 1
							},
							scale: {
								start: .35,
								end: .35,
								minimumScaleMultiplier: .5
							},
							color: {
								start: "#ffffff",
								end: "#ffffff"
							},
							speed: {
								start: 700,
								end: 350,
								minimumSpeedMultiplier: 1.3
							},
							acceleration: {
								x: 0,
								y: 1500
							},
							maxSpeed: 0,
							startRotation: {
								min: -110,
								max: -70
							},
							noRotation: !1,
							rotationSpeed: {
								min: -400,
								max: 400
							},
							lifetime: {
								min: 2.1,
								max: 2.1
							},
							blendMode: "normal",
							frequency: .002,
							emitterLifetime: .15,
							maxParticles: 50,
							pos: {
								x: 0,
								y: 0
							},
							addAtBack: !1,
							spawnType: "rect",
							spawnRect: {
								x: -100,
								y: -25,
								w: 200,
								h: 50
							}
						}), this._cloverParticles = new l.TweenParticleEmitter(e, {
							alpha: {
								start: 1,
								end: 1
							},
							scale: {
								start: .35,
								end: .35,
								minimumScaleMultiplier: .5
							},
							color: {
								start: "#ffffff",
								end: "#ffffff"
							},
							speed: {
								start: 700,
								end: 350,
								minimumSpeedMultiplier: 1.3
							},
							acceleration: {
								x: 0,
								y: 1500
							},
							maxSpeed: 0,
							startRotation: {
								min: -110,
								max: -70
							},
							noRotation: !1,
							rotationSpeed: {
								min: -400,
								max: 400
							},
							lifetime: {
								min: 2.1,
								max: 2.1
							},
							blendMode: "normal",
							frequency: .002,
							emitterLifetime: .15,
							maxParticles: 50,
							pos: {
								x: 0,
								y: 0
							},
							addAtBack: !1,
							spawnType: "rect",
							spawnRect: {
								x: -100,
								y: -25,
								w: 200,
								h: 50
							}
						}), this._layer.addChild(this._cloverParticles), this._layer.addChild(this._coinParticles)
					}
					playClovers(t) {
						this._coinParticles.emitter.maxParticles = 0 === t ? 20 : 30, this._coinParticles.getAnimation(), this._cloverParticles.emitter.maxParticles = 0 === t ? 20 : 30, this._cloverParticles.getAnimation()
					}
					onResize(t) {
						const e = Math.round((t.height - this._layer.y) / this._layer.scale.y) + 40,
							i = t.orientation === o.Orientation.PORTRAIT ? 1450 : 1e3;
						this._coinParticles.y = e, this._coinParticles.x = 360, this._coinParticles.emitter.startSpeed = new a.PropertyNode(i, i), this._cloverParticles.y = e, this._cloverParticles.x = 360, this._cloverParticles.emitter.startSpeed = new a.PropertyNode(i, i)
					}
				}
				e.LeprechaunInitialWPView = u
			},
			16182: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunInitialWinCountUp = void 0;
				const n = i(75367),
					s = i(88240),
					o = i(57244),
					r = i(68744),
					a = i(7057),
					l = i(13006),
					h = i(63114);
				class u extends r.BitmapWinCountUp {
					constructor(t) {
						super(t), this._isCountUpSoundPlaying = !1, this._hasCountUpEndSoundPlayed = !1
					}
					initAnimations() {
						this._starAnimation = new a.TimelineSprite(s.GameResources.getTextures("winStar")), this._starAnimation.anchor.set(.5, .5), this._starAnimation.position.set(0, 0), this._starAnimation.hide(), this._starAnimation.blendMode = PIXI.BLEND_MODES.ADD, this.addChild(this._starAnimation), super.initAnimations()
					}
					getScale(t) {
						return 1 + .1 * (t - 1)
					}
					getCountUpAnimation(t, e, i, s) {
						const r = o.MathHelper.floorToDecimals(e / s, 2),
							a = new l.TimelineLite;
						if (a.add([() => {
								this._countUp.maxTextWidth = .9 * n.GameConfig.instance.REEL_AREA_WIDTH / this.getScale(s), this._countUp.alpha = 1, this._countUp.visible = !0, this._countUpContainer.scale.set(1, 1), i > .01 && (this._isCountUpSoundPlaying = !0)
							}, this._starAnimation.getAnimationAutoShowHide(!0, !0), this._countUp.getCountUpAnimation(t, r, {
								duration: i,
								ease: l.Power3.easeInOut
							})]), s > 1) {
							const t = s,
								e = r * t,
								i = this.getScale(t);
							a.add([() => {
								h.LeprechaunGameModuleConfig.logo.playMultiplierAnimation()
							}, this._countUp.getCountUpAnimation(e, e, {
								duration: .01
							}), this._starAnimation.getAnimationAutoShowHide(!0, !0), l.TweenLite.to(this._countUpContainer.scale, .3, {
								x: i,
								y: i,
								ease: l.Elastic.easeOut.config(2, 1)
							})])
						}
						return a
					}
					abort(t, e, i, n) {
						return n ? null : (this._starAnimation.hide(), super.abort(t, e, i))
					}
					getAbortAnimation(t, e) {
						const i = new l.TimelineLite;
						if (i.add([() => {
								this._countUp.maxTextWidth = .9 * n.GameConfig.instance.REEL_AREA_WIDTH / this.getScale(e), this._countUp.alpha = 1, this._countUp.visible = !0, this._countUpContainer.scale.set(1, 1)
							}, this._countUp.getCountUpAnimation(t, t, {
								duration: .01
							})]), e > 1) {
							const t = this.getScale(e);
							i.add(l.TweenLite.to(this._countUpContainer.scale, .2, {
								x: t,
								y: t,
								ease: l.Elastic.easeOut.config(2, 1)
							}), 0)
						}
						return i
					}
					getEndingAnimation() {
						const t = new l.TimelineLite({
							onComplete: () => {
								this._isCountUpSoundPlaying = !1, this._hasCountUpEndSoundPlayed = !1
							}
						});
						return t.add(l.TweenLite.to(this._countUp, .8, {
							alpha: 0
						}), 0), t
					}
				}
				e.LeprechaunInitialWinCountUp = u
			},
			1042: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunNoWinPresentationController = void 0;
				const n = i(35829);
				class s extends n.NoWinSymbolsWinPresentationController {
					constructor(t) {
						super(t, {
							noWinStateFadeInDuration: 0
						})
					}
					parseFeatureGameData(t) {
						super.parseFeatureGameData(t), t.bonusWin && this._symbolWinStates && (this._symbolWinStates[1][1] = !0)
					}
				}
				e.LeprechaunNoWinPresentationController = s
			},
			80109: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunNudgeWildController = void 0;
				const n = i(75367),
					s = i(23792),
					o = i(23110),
					r = i(34785),
					a = i(43635),
					l = i(13006),
					h = i(48002),
					u = i(4773);
				class c extends a.NudgeStackedSymbolWPController {
					constructor(t) {
						super(t, {
							nudgeStepSpeed: .6,
							stackedSymbolKeyword: "W"
						}), this._nudgeCompleted = !0, this._currentSoundId = 0, this._isAborted = !1, this._nudgeSoundIndex = [0, 1, 0, 1, 0, 1]
					}
					startWinPresentation() {
						this._isAborted = !1, this._nudgeCompleted = !1, this._currentSoundId = 0, super.startWinPresentation()
					}
					playNudgeStepStart(t, e) {
						this.playNudgeSounds(t, e);
						const i = s.Reels.getSymbol(t, this._nudgeSymbolId[t]);
						i && i.changeState({
							state: h.LeprechaunGameConfig.instance.SYMBOL_STATES.nudge,
							setStack: !0,
							fadeInDuration: .3
						})
					}
					getNoWinNudgeSpeed() {
						return .3
					}
					playNudgeSounds(t, e) {
						Math.abs(this._steps[t]) >= 1 && !this._isAborted && o.SlotGame.sound.playEffect(u.LeprechaunSoundConfig.instance.WILD_NUDGES[this._nudgeSoundIndex[this._currentSoundId++]])
					}
					playNudgeAbortSound() {
						this._isAborted = !0, this.stopAllNudgeSound(), o.SlotGame.sound.playEffect(u.LeprechaunSoundConfig.instance.NUDGE_ABORT)
					}
					stopAllNudgeSound() {
						o.SlotGame.sound.stopEffect(u.LeprechaunSoundConfig.instance.NUDGE_NO_WIN_2), o.SlotGame.sound.stopEffect(u.LeprechaunSoundConfig.instance.NUDGE_NO_WIN_1), o.SlotGame.sound.stopEffect(u.LeprechaunSoundConfig.instance.WILD_NUDGES[0]), o.SlotGame.sound.stopEffect(u.LeprechaunSoundConfig.instance.WILD_NUDGES[1])
					}
					playOnNudgeStepComplete(t, e) {
						if (this.getReelNoWinNudge(t) && !this._isAborted) 1 === Math.abs(this._steps[t]) ? o.SlotGame.sound.playEffect(u.LeprechaunSoundConfig.instance.NUDGE_NO_WIN_1) : 1 === Math.abs(e) && o.SlotGame.sound.playEffect(u.LeprechaunSoundConfig.instance.NUDGE_NO_WIN_2);
						else {
							const e = s.Reels.getSymbol(t, this._nudgeSymbolId[t]);
							e && (e.playNudgeSparkles(), e.updateMultiplier(Math.abs(this._nudgedSteps[t]) + 1, !0))
						}
					}
					playOnReelNudgeComplete(t, e) {
						const i = s.Reels.getSymbol(t, this._nudgeSymbolId[t]);
						if (i)
							if (i.stopNudgeAnimation(), this.getReelNoWinNudge(t)) i.stack.symbols.forEach((e => {
								e && (e.updateMultiplier(Math.abs(this._nudgedSteps[t]) + 1, !1), e.playWriteOnWild().progress(1))
							}));
							else {
								const n = new l.TimelineLite;
								n.add((() => {
									i.playWriteOn(), this._writeMultiplierStates[t] = !1, this.checkComplete()
								})), n.add(i.playWriteOnWild()), n.timeScale(e ? 20 : 1), this._writeMultiplierTimelines.push(n), this._writeMultiplierStates[t] = !0
							}
					}
					playOnAllNudgeComplete() {
						this._nudgeCompleted = !0, this.checkComplete()
					}
					checkComplete() {
						this._nudgeCompleted && !this._writeMultiplierStates.some((t => t)) && this.finish()
					}
					abortWinPresentation() {
						super.abortWinPresentation(), this._isAborted = !0, this._writeMultiplierTimelines.forEach((t => {
							t && t.isActive() && t.timeScale(20)
						})), this._nudgeSymbolId.forEach(((t, e) => {
							if (-1 === t) return;
							const i = s.Reels.getSymbol(e, t);
							i && i.stack.symbols.forEach((t => {
								t.updateMultiplier(Math.abs(this._steps[e]) + 1, !1), t.playWriteOnWild().progress(1)
							}))
						}))
					}
					resetFeature() {
						super.resetFeature(), this._currentSoundId = 0, this._writeMultiplierTimelines = [], this._writeMultiplierStates = r.ArrayHelper.initArrayWithValues(n.GameConfig.instance.REELS_NUM, (() => !1))
					}
				}
				e.LeprechaunNudgeWildController = c
			},
			46109: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeParticlesManager = void 0, i(7615);
				const n = i(52409),
					s = i(44679),
					o = i(57284),
					r = i(46334),
					a = i(13006);
				class l {
					constructor() {
						if (l._instance) throw new Error("Error: LeParticlesManager.constructor() - Instantiation failed: Singleton.");
						l._instance = this, l._emitters = [], n.EventHandler.dispatchEvent(new s.GameEvent(o.StageEvent.ADD_TO_RENDER_LOOP, (() => this.update())))
					}
					createMainLoop() {
						a.TweenLite.ticker.addEventListener("tick", this.animate, this)
					}
					handleContextLost(t) {
						a.TweenLite.ticker.removeEventListener("tick", this.animate, this), r.Logger.logDev(t.type, t)
					}
					update() {
						if (l._instance || new l, 0 === l._emitters.length) return;
						let t = Date.now();
						for (let e = 0; e < l._emitters.length; e++) l._emitters[e].update(.001 * (t - l._elapsed));
						l._elapsed = t
					}
					animate() {
						this.update()
					}
					static addEmitter(t, e = !0) {
						l._instance || new l, this._instance.createMainLoop(), l._emitters.push(t), t.emit = e, l._elapsed = Date.now(), l._instance.update()
					}
					static removeEmitter(t, e = !1) {
						l._instance || new l;
						const i = l._emitters.indexOf(t);
						return -1 !== i && (l._emitters.splice(i, 1), t.emit = !1, t.destroy(), l._elapsed = Date.now(), l._instance.update(), e && l._emitters.length, !0)
					}
				}
				e.LeParticlesManager = l
			},
			17045: (t, e, i) => {
				"use strict";
				Object.defineProperty(e, "__esModule", {
					value: !0
				}), e.LeprechaunHelper = void 0;
				const n = i(56682),
					s = i(48002);
				class o extends n.Helper {
					static getBetlineNumerPos(t, e) {
						const i = [59, 670],
							n = s.LeprechaunGameConfig.instance.REEL_AREA_POS_Y;
						return t < 6 ? [i[e] + [
							[0, 0, 0, 0, 0],
							[2, -1, 3, 8, 2]
						][e][t - 1], n + [246, 110, 391, 59, 443, 245, 111, 391, 440, 60][t + 5 * e - 1]] : [i[e], n + [24, 483, 289, 206][t - 6]]
					}
				}
				e.LeprechaunHelper = o
			},
			61270: function(t, e, i) {
				var n;
				t = i.nmd(t),
					function(s) {
						e && e.nodeType, t && t.nodeType;
						var o = "object" == typeof i.g && i.g;
						o.global !== o && o.window !== o && o.self;
						var r, a = 2147483647,
							l = 36,
							h = 26,
							u = 38,
							c = 700,
							d = /^xn--/,
							p = /[^\x20-\x7E]/,
							_ = /[\x2E\u3002\uFF0E\uFF61]/g,
							m = {
								overflow: "Overflow: input needs wider integers to process",
								"not-basic": "Illegal input >= 0x80 (not a basic code point)",
								"invalid-input": "Invalid input"
							},
							g = l - 1,
							f = Math.floor,
							S = String.fromCharCode;

						function y(t) {
							throw new RangeError(m[t])
						}

						function v(t, e) {
							for (var i = t.length, n = []; i--;) n[i] = e(t[i]);
							return n
						}

						function T(t, e) {
							var i = t.split("@"),
								n = "";
							return i.length > 1 && (n = i[0] + "@", t = i[1]), n + v((t = t.replace(_, ".")).split("."), e).join(".")
						}

						function E(t) {
							for (var e, i, n = [], s = 0, o = t.length; s < o;)(e = t.charCodeAt(s++)) >= 55296 && e <= 56319 && s < o ? 56320 == (64512 & (i = t.charCodeAt(s++))) ? n.push(((1023 & e) << 10) + (1023 & i) + 65536) : (n.push(e), s--) : n.push(e);
							return n
						}

						function b(t) {
							return v(t, (function(t) {
								var e = "";
								return t > 65535 && (e += S((t -= 65536) >>> 10 & 1023 | 55296), t = 56320 | 1023 & t), e + S(t)
							})).join("")
						}

						function A(t, e) {
							return t + 22 + 75 * (t < 26) - ((0 != e) << 5)
						}

						function P(t, e, i) {
							var n = 0;
							for (t = i ? f(t / c) : t >> 1, t += f(t / e); t > g * h >> 1; n += l) t = f(t / g);
							return f(n + (g + 1) * t / (t + u))
						}

						function I(t) {
							var e, i, n, s, o, r, u, c, d, p, _, m = [],
								g = t.length,
								S = 0,
								v = 128,
								T = 72;
							for ((i = t.lastIndexOf("-")) < 0 && (i = 0), n = 0; n < i; ++n) t.charCodeAt(n) >= 128 && y("not-basic"), m.push(t.charCodeAt(n));
							for (s = i > 0 ? i + 1 : 0; s < g;) {
								for (o = S, r = 1, u = l; s >= g && y("invalid-input"), ((c = (_ = t.charCodeAt(s++)) - 48 < 10 ? _ - 22 : _ - 65 < 26 ? _ - 65 : _ - 97 < 26 ? _ - 97 : l) >= l || c > f((a - S) / r)) && y("overflow"), S += c * r, !(c < (d = u <= T ? 1 : u >= T + h ? h : u - T)); u += l) r > f(a / (p = l - d)) && y("overflow"), r *= p;
								T = P(S - o, e = m.length + 1, 0 == o), f(S / e) > a - v && y("overflow"), v += f(S / e), S %= e, m.splice(S++, 0, v)
							}
							return b(m)
						}

						function w(t) {
							var e, i, n, s, o, r, u, c, d, p, _, m, g, v, T, b = [];
							for (m = (t = E(t)).length, e = 128, i = 0, o = 72, r = 0; r < m; ++r)(_ = t[r]) < 128 && b.push(S(_));
							for (n = s = b.length, s && b.push("-"); n < m;) {
								for (u = a, r = 0; r < m; ++r)(_ = t[r]) >= e && _ < u && (u = _);
								for (u - e > f((a - i) / (g = n + 1)) && y("overflow"), i += (u - e) * g, e = u, r = 0; r < m; ++r)
									if ((_ = t[r]) < e && ++i > a && y("overflow"), _ == e) {
										for (c = i, d = l; !(c < (p = d <= o ? 1 : d >= o + h ? h : d - o)); d += l) T = c - p, v = l - p, b.push(S(A(p + T % v, 0))), c = f(T / v);
										b.push(S(A(c, 0))), o = P(i, g, n == s), i = 0, ++n
									}++ i, ++e
							}
							return b.join("")
						}
						r = {
							version: "1.4.1",
							ucs2: {
								decode: E,
								encode: b
							},
							decode: I,
							encode: w,
							toASCII: function(t) {
								return T(t, (function(t) {
									return p.test(t) ? "xn--" + w(t) : t
								}))
							},
							toUnicode: function(t) {
								return T(t, (function(t) {
									return d.test(t) ? I(t.slice(4).toLowerCase()) : t
								}))
							}
						}, void 0 === (n = function() {
							return r
						}.call(e, i, e, t)) || (t.exports = n)
					}()
			},
			88835: (t, e, i) => {
				"use strict";
				var n = i(61270);

				function s() {
					this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null
				}
				var o = /^([a-z0-9.+-]+:)/i,
					r = /:[0-9]*$/,
					a = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,
					l = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "\t"]),
					h = ["'"].concat(l),
					u = ["%", "/", "?", ";", "#"].concat(h),
					c = ["/", "?", "#"],
					d = /^[+a-z0-9A-Z_-]{0,63}$/,
					p = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
					_ = {
						javascript: !0,
						"javascript:": !0
					},
					m = {
						javascript: !0,
						"javascript:": !0
					},
					g = {
						http: !0,
						https: !0,
						ftp: !0,
						gopher: !0,
						file: !0,
						"http:": !0,
						"https:": !0,
						"ftp:": !0,
						"gopher:": !0,
						"file:": !0
					},
					f = i(55373);

				function S(t, e, i) {
					if (t && "object" == typeof t && t instanceof s) return t;
					var n = new s;
					return n.parse(t, e, i), n
				}
				s.prototype.parse = function(t, e, i) {
					if ("string" != typeof t) throw new TypeError("Parameter 'url' must be a string, not " + typeof t);
					var s = t.indexOf("?"),
						r = -1 !== s && s < t.indexOf("#") ? "?" : "#",
						l = t.split(r);
					l[0] = l[0].replace(/\\/g, "/");
					var S = t = l.join(r);
					if (S = S.trim(), !i && 1 === t.split("#").length) {
						var y = a.exec(S);
						if (y) return this.path = S, this.href = S, this.pathname = y[1], y[2] ? (this.search = y[2], this.query = e ? f.parse(this.search.substr(1)) : this.search.substr(1)) : e && (this.search = "", this.query = {}), this
					}
					var v = o.exec(S);
					if (v) {
						var T = (v = v[0]).toLowerCase();
						this.protocol = T, S = S.substr(v.length)
					}
					if (i || v || S.match(/^\/\/[^@/]+@[^@/]+/)) {
						var E = "//" === S.substr(0, 2);
						!E || v && m[v] || (S = S.substr(2), this.slashes = !0)
					}
					if (!m[v] && (E || v && !g[v])) {
						for (var b, A, P = -1, I = 0; I < c.length; I++) - 1 !== (w = S.indexOf(c[I])) && (-1 === P || w < P) && (P = w);
						for (-1 !== (A = -1 === P ? S.lastIndexOf("@") : S.lastIndexOf("@", P)) && (b = S.slice(0, A), S = S.slice(A + 1), this.auth = decodeURIComponent(b)), P = -1, I = 0; I < u.length; I++) {
							var w; - 1 !== (w = S.indexOf(u[I])) && (-1 === P || w < P) && (P = w)
						} - 1 === P && (P = S.length), this.host = S.slice(0, P), S = S.slice(P), this.parseHost(), this.hostname = this.hostname || "";
						var L = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
						if (!L)
							for (var C = this.hostname.split(/\./), x = (I = 0, C.length); I < x; I++) {
								var B = C[I];
								if (B && !B.match(d)) {
									for (var O = "", N = 0, M = B.length; N < M; N++) B.charCodeAt(N) > 127 ? O += "x" : O += B[N];
									if (!O.match(d)) {
										var R = C.slice(0, I),
											D = C.slice(I + 1),
											k = B.match(p);
										k && (R.push(k[1]), D.unshift(k[2])), D.length && (S = "/" + D.join(".") + S), this.hostname = R.join(".");
										break
									}
								}
							}
						this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), L || (this.hostname = n.toASCII(this.hostname));
						var F = this.port ? ":" + this.port : "",
							G = this.hostname || "";
						this.host = G + F, this.href += this.host, L && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== S[0] && (S = "/" + S))
					}
					if (!_[T])
						for (I = 0, x = h.length; I < x; I++) {
							var U = h[I];
							if (-1 !== S.indexOf(U)) {
								var W = encodeURIComponent(U);
								W === U && (W = escape(U)), S = S.split(U).join(W)
							}
						}
					var H = S.indexOf("#"); - 1 !== H && (this.hash = S.substr(H), S = S.slice(0, H));
					var V = S.indexOf("?");
					if (-1 !== V ? (this.search = S.substr(V), this.query = S.substr(V + 1), e && (this.query = f.parse(this.query)), S = S.slice(0, V)) : e && (this.search = "", this.query = {}), S && (this.pathname = S), g[T] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
						F = this.pathname || "";
						var X = this.search || "";
						this.path = F + X
					}
					return this.href = this.format(), this
				}, s.prototype.format = function() {
					var t = this.auth || "";
					t && (t = (t = encodeURIComponent(t)).replace(/%3A/i, ":"), t += "@");
					var e = this.protocol || "",
						i = this.pathname || "",
						n = this.hash || "",
						s = !1,
						o = "";
					this.host ? s = t + this.host : this.hostname && (s = t + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (s += ":" + this.port)), this.query && "object" == typeof this.query && Object.keys(this.query).length && (o = f.stringify(this.query, {
						arrayFormat: "repeat",
						addQueryPrefix: !1
					}));
					var r = this.search || o && "?" + o || "";
					return e && ":" !== e.substr(-1) && (e += ":"), this.slashes || (!e || g[e]) && !1 !== s ? (s = "//" + (s || ""), i && "/" !== i.charAt(0) && (i = "/" + i)) : s || (s = ""), n && "#" !== n.charAt(0) && (n = "#" + n), r && "?" !== r.charAt(0) && (r = "?" + r), e + s + (i = i.replace(/[?#]/g, (function(t) {
						return encodeURIComponent(t)
					}))) + (r = r.replace("#", "%23")) + n
				}, s.prototype.resolve = function(t) {
					return this.resolveObject(S(t, !1, !0)).format()
				}, s.prototype.resolveObject = function(t) {
					if ("string" == typeof t) {
						var e = new s;
						e.parse(t, !1, !0), t = e
					}
					for (var i = new s, n = Object.keys(this), o = 0; o < n.length; o++) {
						var r = n[o];
						i[r] = this[r]
					}
					if (i.hash = t.hash, "" === t.href) return i.href = i.format(), i;
					if (t.slashes && !t.protocol) {
						for (var a = Object.keys(t), l = 0; l < a.length; l++) {
							var h = a[l];
							"protocol" !== h && (i[h] = t[h])
						}
						return g[i.protocol] && i.hostname && !i.pathname && (i.pathname = "/", i.path = i.pathname), i.href = i.format(), i
					}
					if (t.protocol && t.protocol !== i.protocol) {
						if (!g[t.protocol]) {
							for (var u = Object.keys(t), c = 0; c < u.length; c++) {
								var d = u[c];
								i[d] = t[d]
							}
							return i.href = i.format(), i
						}
						if (i.protocol = t.protocol, t.host || m[t.protocol]) i.pathname = t.pathname;
						else {
							for (var p = (t.pathname || "").split("/"); p.length && !(t.host = p.shift()););
							t.host || (t.host = ""), t.hostname || (t.hostname = ""), "" !== p[0] && p.unshift(""), p.length < 2 && p.unshift(""), i.pathname = p.join("/")
						}
						if (i.search = t.search, i.query = t.query, i.host = t.host || "", i.auth = t.auth, i.hostname = t.hostname || t.host, i.port = t.port, i.pathname || i.search) {
							var _ = i.pathname || "",
								f = i.search || "";
							i.path = _ + f
						}
						return i.slashes = i.slashes || t.slashes, i.href = i.format(), i
					}
					var S = i.pathname && "/" === i.pathname.charAt(0),
						y = t.host || t.pathname && "/" === t.pathname.charAt(0),
						v = y || S || i.host && t.pathname,
						T = v,
						E = i.pathname && i.pathname.split("/") || [],
						b = (p = t.pathname && t.pathname.split("/") || [], i.protocol && !g[i.protocol]);
					if (b && (i.hostname = "", i.port = null, i.host && ("" === E[0] ? E[0] = i.host : E.unshift(i.host)), i.host = "", t.protocol && (t.hostname = null, t.port = null, t.host && ("" === p[0] ? p[0] = t.host : p.unshift(t.host)), t.host = null), v = v && ("" === p[0] || "" === E[0])), y) i.host = t.host || "" === t.host ? t.host : i.host, i.hostname = t.hostname || "" === t.hostname ? t.hostname : i.hostname, i.search = t.search, i.query = t.query, E = p;
					else if (p.length) E || (E = []), E.pop(), E = E.concat(p), i.search = t.search, i.query = t.query;
					else if (null != t.search) return b && (i.host = E.shift(), i.hostname = i.host, (L = !!(i.host && i.host.indexOf("@") > 0) && i.host.split("@")) && (i.auth = L.shift(), i.hostname = L.shift(), i.host = i.hostname)), i.search = t.search, i.query = t.query, null === i.pathname && null === i.search || (i.path = (i.pathname ? i.pathname : "") + (i.search ? i.search : "")), i.href = i.format(), i;
					if (!E.length) return i.pathname = null, i.search ? i.path = "/" + i.search : i.path = null, i.href = i.format(), i;
					for (var A = E.slice(-1)[0], P = (i.host || t.host || E.length > 1) && ("." === A || ".." === A) || "" === A, I = 0, w = E.length; w >= 0; w--) "." === (A = E[w]) ? E.splice(w, 1) : ".." === A ? (E.splice(w, 1), I++) : I && (E.splice(w, 1), I--);
					if (!v && !T)
						for (; I--; I) E.unshift("..");
					!v || "" === E[0] || E[0] && "/" === E[0].charAt(0) || E.unshift(""), P && "/" !== E.join("/").substr(-1) && E.push("");
					var L, C = "" === E[0] || E[0] && "/" === E[0].charAt(0);
					return b && (i.hostname = C ? "" : E.length ? E.shift() : "", i.host = i.hostname, (L = !!(i.host && i.host.indexOf("@") > 0) && i.host.split("@")) && (i.auth = L.shift(), i.hostname = L.shift(), i.host = i.hostname)), (v = v || i.host && E.length) && !C && E.unshift(""), E.length > 0 ? i.pathname = E.join("/") : (i.pathname = null, i.path = null), null === i.pathname && null === i.search || (i.path = (i.pathname ? i.pathname : "") + (i.search ? i.search : "")), i.auth = t.auth || i.auth, i.slashes = i.slashes || t.slashes, i.href = i.format(), i
				}, s.prototype.parseHost = function() {
					var t = this.host,
						e = r.exec(t);
					e && (":" !== (e = e[0]) && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t)
				}, e.parse = S, e.resolve = function(t, e) {
					return S(t, !1, !0).resolve(e)
				}, e.resolveObject = function(t, e) {
					return t ? S(t, !1, !0).resolveObject(e) : e
				}, e.format = function(t) {
					return "string" == typeof t && (t = S(t)), t instanceof s ? t.format() : s.prototype.format.call(t)
				}, e.Url = s
			},
			42634: () => {},
			37657: t => {
				"use strict";
				t.exports = {
					rE: "1.3.4"
				}
			},
			71533: t => {
				"use strict";
				t.exports = JSON.parse('{"name":"@nolimitcity/game-communication","version":"0.3.0","description":"Connect to the Nolimit City platform as a javascript game client.","main":"src/communication.js","scripts":{"lint":"eslint src test","posttest":"npm run lint","patch":"npm --no-git-tag-version version patch","push":"git commit -a -m $npm_package_version && git push","postpush":"echo $npm_package_name $npm_package_version","ppp":"npm run patch && npm publish && npm run push","pp":"npm run patch && npm publish"},"keywords":[],"author":"Kristoffer Lundn <kristoffer@nolimitcity.com>","license":"UNLICENSED","dependencies":{"@nolimitcity/core":"^0.2.0"},"repository":{"type":"git","url":"git+https://github.com/nolimitcity/nolimit-game-communication.git"},"bugs":{"url":"https://github.com/nolimitcity/nolimit-game-communication/issues"},"homepage":"https://github.com/nolimitcity/nolimit-game-communication#readme"}')
			},
			2087: t => {
				"use strict";
				t.exports = {
					rE: "1.10.14"
				}
			}
		},
		e = {};

	function i(n) {
		var s = e[n];
		if (void 0 !== s) return s.exports;
		var o = e[n] = {
			id: n,
			loaded: !1,
			exports: {}
		};
		return t[n].call(o.exports, o, o.exports, i), o.loaded = !0, o.exports
	}
	i.n = t => {
		var e = t && t.__esModule ? () => t.default : () => t;
		return i.d(e, {
			a: e
		}), e
	}, i.d = (t, e) => {
		for (var n in e) i.o(e, n) && !i.o(t, n) && Object.defineProperty(t, n, {
			enumerable: !0,
			get: e[n]
		})
	}, i.g = function() {
		if ("object" == typeof globalThis) return globalThis;
		try {
			return this || new Function("return this")()
		} catch (t) {
			if ("object" == typeof window) return window
		}
	}(), i.hmd = t => ((t = Object.create(t)).children || (t.children = []), Object.defineProperty(t, "exports", {
		enumerable: !0,
		set: () => {
			throw new Error("ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: " + t.id)
		}
	}), t), i.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), i.r = t => {
		"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
			value: "Module"
		}), Object.defineProperty(t, "__esModule", {
			value: !0
		})
	}, i.nmd = t => (t.paths = [], t.children || (t.children = []), t), i.nc = void 0, i(89787)
})();
//# sourceMappingURL=game.js.map